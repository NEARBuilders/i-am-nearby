"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-wallet-selector";
exports.ids = ["vendor-chunks/@near-wallet-selector"];
exports.modules = {

/***/ "(ssr)/./node_modules/@near-wallet-selector/modal-ui/styles.css":
/*!****************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/modal-ui/styles.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f7b68a6f96ce\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21vZGFsLXVpL3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pLWFtLW5lYXJieS8uL25vZGVfbW9kdWxlcy9AbmVhci13YWxsZXQtc2VsZWN0b3IvbW9kYWwtdWkvc3R5bGVzLmNzcz85NjIyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZjdiNjhhNmY5NmNlXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/modal-ui/styles.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/core/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@near-wallet-selector/core/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),\n/* harmony export */   allowOnlyLanguage: () => (/* binding */ allowOnlyLanguage),\n/* harmony export */   getActiveAccount: () => (/* binding */ getActiveAccount),\n/* harmony export */   isCurrentBrowserSupported: () => (/* binding */ isCurrentBrowserSupported),\n/* harmony export */   serializeNep413: () => (/* binding */ serializeNep413),\n/* harmony export */   setupWalletSelector: () => (/* binding */ setupWalletSelector),\n/* harmony export */   translate: () => (/* binding */ translate),\n/* harmony export */   verifyFullKeyBelongsToUser: () => (/* binding */ verifyFullKeyBelongsToUser),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Subject_scan_rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Subject,scan!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Subject_scan_rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Subject,scan!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Subject_scan_rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Subject,scan!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/scan.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! js-sha256 */ \"(ssr)/./node_modules/js-sha256/src/sha256.js\");\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nclass Provider {\n    constructor(url){\n        this.provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n            url\n        });\n    }\n    query(params) {\n        return this.provider.query(params);\n    }\n    viewAccessKey({ accountId, publicKey }) {\n        return this.query({\n            request_type: \"view_access_key\",\n            finality: \"final\",\n            account_id: accountId,\n            public_key: publicKey\n        });\n    }\n    block(reference) {\n        return this.provider.block(reference);\n    }\n    sendTransaction(signedTransaction) {\n        return this.provider.sendTransaction(signedTransaction);\n    }\n}\nconst KEY_DELIMITER = \":\";\nclass JsonStorage {\n    constructor(storage, namespace){\n        this.storage = storage;\n        this.namespace = Array.isArray(namespace) ? namespace.join(KEY_DELIMITER) : namespace;\n    }\n    resolveKey(key) {\n        return [\n            this.namespace,\n            key\n        ].join(KEY_DELIMITER);\n    }\n    getItem(key) {\n        return this.storage.getItem(this.resolveKey(key)).then((item)=>{\n            return typeof item === \"string\" ? JSON.parse(item) : null;\n        });\n    }\n    setItem(key, value) {\n        return this.storage.setItem(this.resolveKey(key), JSON.stringify(value));\n    }\n    removeItem(key) {\n        return this.storage.removeItem(this.resolveKey(key));\n    }\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar check = function(it) {\n    return it && it.Math == Math && it;\n};\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$t = // eslint-disable-next-line es-x/no-global-this -- safe\ncheck(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\ncheck(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback\nfunction() {\n    return this;\n}() || Function(\"return this\")();\nvar objectGetOwnPropertyDescriptor = {};\nvar fails$s = function(exec) {\n    try {\n        return !!exec();\n    } catch (error) {\n        return true;\n    }\n};\nvar fails$r = fails$s;\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$r(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty({}, 1, {\n        get: function() {\n            return 7;\n        }\n    })[1] != 7;\n});\nvar fails$q = fails$s;\nvar functionBindNative = !fails$q(function() {\n    // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n    var test = (function() {}).bind();\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$3 = functionBindNative;\nvar call$l = Function.prototype.call;\nvar functionCall = NATIVE_BIND$3 ? call$l.bind(call$l) : function() {\n    return call$l.apply(call$l, arguments);\n};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({\n    1: 2\n}, 1);\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n    var descriptor = getOwnPropertyDescriptor$2(this, V);\n    return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar createPropertyDescriptor$5 = function(bitmap, value) {\n    return {\n        enumerable: !(bitmap & 1),\n        configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        value: value\n    };\n};\nvar NATIVE_BIND$2 = functionBindNative;\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$7 = FunctionPrototype$2.bind;\nvar call$k = FunctionPrototype$2.call;\nvar uncurryThis$p = NATIVE_BIND$2 && bind$7.bind(call$k, call$k);\nvar functionUncurryThis = NATIVE_BIND$2 ? function(fn) {\n    return fn && uncurryThis$p(fn);\n} : function(fn) {\n    return fn && function() {\n        return call$k.apply(fn, arguments);\n    };\n};\nvar uncurryThis$o = functionUncurryThis;\nvar toString$7 = uncurryThis$o({}.toString);\nvar stringSlice$3 = uncurryThis$o(\"\".slice);\nvar classofRaw$1 = function(it) {\n    return stringSlice$3(toString$7(it), 8, -1);\n};\nvar uncurryThis$n = functionUncurryThis;\nvar fails$p = fails$s;\nvar classof$b = classofRaw$1;\nvar $Object$4 = Object;\nvar split = uncurryThis$n(\"\".split);\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$p(function() {\n    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return !$Object$4(\"z\").propertyIsEnumerable(0);\n}) ? function(it) {\n    return classof$b(it) == \"String\" ? split(it, \"\") : $Object$4(it);\n} : $Object$4;\nvar $TypeError$f = TypeError;\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$6 = function(it) {\n    if (it == undefined) throw $TypeError$f(\"Can't call method on \" + it);\n    return it;\n};\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$5 = requireObjectCoercible$6;\nvar toIndexedObject$6 = function(it) {\n    return IndexedObject$3(requireObjectCoercible$5(it));\n};\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function(argument) {\n    return typeof argument == \"function\";\n};\nvar isCallable$m = isCallable$n;\nvar isObject$d = function(it) {\n    return typeof it == \"object\" ? it !== null : isCallable$m(it);\n};\nvar global$s = global$t;\nvar isCallable$l = isCallable$n;\nvar aFunction = function(argument) {\n    return isCallable$l(argument) ? argument : undefined;\n};\nvar getBuiltIn$8 = function(namespace, method) {\n    return arguments.length < 2 ? aFunction(global$s[namespace]) : global$s[namespace] && global$s[namespace][method];\n};\nvar uncurryThis$m = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$m({}.isPrototypeOf);\nvar getBuiltIn$7 = getBuiltIn$8;\nvar engineUserAgent = getBuiltIn$7(\"navigator\", \"userAgent\") || \"\";\nvar global$r = global$t;\nvar userAgent$5 = engineUserAgent;\nvar process$3 = global$r.process;\nvar Deno$1 = global$r.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n    match = v8.split(\".\");\n    // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n    // but their correct versions are not interesting for us\n    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n    match = userAgent$5.match(/Edge\\/(\\d+)/);\n    if (!match || match[1] >= 74) {\n        match = userAgent$5.match(/Chrome\\/(\\d+)/);\n        if (match) version = +match[1];\n    }\n}\nvar engineV8Version = version;\n/* eslint-disable es-x/no-symbol -- required for testing */ var V8_VERSION$1 = engineV8Version;\nvar fails$o = fails$s;\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$o(function() {\n    var symbol = Symbol();\n    // Chrome 38 Symbol has incorrect toString conversion\n    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n/* eslint-disable es-x/no-symbol -- required for testing */ var NATIVE_SYMBOL$1 = nativeSymbol;\nvar useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar $Object$3 = Object;\nvar isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function(it) {\n    return typeof it == \"symbol\";\n} : function(it) {\n    var $Symbol = getBuiltIn$6(\"Symbol\");\n    return isCallable$k($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$3(it));\n};\nvar $String$3 = String;\nvar tryToString$5 = function(argument) {\n    try {\n        return $String$3(argument);\n    } catch (error) {\n        return \"Object\";\n    }\n};\nvar isCallable$j = isCallable$n;\nvar tryToString$4 = tryToString$5;\nvar $TypeError$e = TypeError;\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function(argument) {\n    if (isCallable$j(argument)) return argument;\n    throw $TypeError$e(tryToString$4(argument) + \" is not a function\");\n};\nvar aCallable$8 = aCallable$9;\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function(V, P) {\n    var func = V[P];\n    return func == null ? undefined : aCallable$8(func);\n};\nvar call$j = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$c = isObject$d;\nvar $TypeError$d = TypeError;\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function(input, pref) {\n    var fn, val;\n    if (pref === \"string\" && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n    if (isCallable$i(fn = input.valueOf) && !isObject$c(val = call$j(fn, input))) return val;\n    if (pref !== \"string\" && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n    throw $TypeError$d(\"Can't convert object to primitive value\");\n};\nvar shared$4 = {\n    exports: {}\n};\nvar global$q = global$t;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$7 = Object.defineProperty;\nvar defineGlobalProperty$3 = function(key, value) {\n    try {\n        defineProperty$7(global$q, key, {\n            value: value,\n            configurable: true,\n            writable: true\n        });\n    } catch (error) {\n        global$q[key] = value;\n    }\n    return value;\n};\nvar global$p = global$t;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\nvar SHARED = \"__core-js_shared__\";\nvar store$3 = global$p[SHARED] || defineGlobalProperty$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$4.exports = function(key, value) {\n    return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})(\"versions\", []).push({\n    version: \"3.23.3\",\n    mode: \"global\",\n    copyright: \"\\xa9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n});\nvar requireObjectCoercible$4 = requireObjectCoercible$6;\nvar $Object$2 = Object;\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$7 = function(argument) {\n    return $Object$2(requireObjectCoercible$4(argument));\n};\nvar uncurryThis$l = functionUncurryThis;\nvar toObject$6 = toObject$7;\nvar hasOwnProperty = uncurryThis$l({}.hasOwnProperty);\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n    return hasOwnProperty(toObject$6(it), key);\n};\nvar uncurryThis$k = functionUncurryThis;\nvar id = 0;\nvar postfix = Math.random();\nvar toString$6 = uncurryThis$k(1.0.toString);\nvar uid$3 = function(key) {\n    return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString$6(++id + postfix, 36);\n};\nvar global$o = global$t;\nvar shared$3 = shared$4.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$2 = uid$3;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$3(\"wks\");\nvar Symbol$1 = global$o.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1[\"for\"];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;\nvar wellKnownSymbol$j = function(name) {\n    if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n        var description = \"Symbol.\" + name;\n        if (NATIVE_SYMBOL && hasOwn$b(Symbol$1, name)) {\n            WellKnownSymbolsStore[name] = Symbol$1[name];\n        } else if (USE_SYMBOL_AS_UID && symbolFor) {\n            WellKnownSymbolsStore[name] = symbolFor(description);\n        } else {\n            WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n        }\n    }\n    return WellKnownSymbolsStore[name];\n};\nvar call$i = functionCall;\nvar isObject$b = isObject$d;\nvar isSymbol$2 = isSymbol$3;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$i = wellKnownSymbol$j;\nvar $TypeError$c = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$i(\"toPrimitive\");\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$2 = function(input, pref) {\n    if (!isObject$b(input) || isSymbol$2(input)) return input;\n    var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n    var result;\n    if (exoticToPrim) {\n        if (pref === undefined) pref = \"default\";\n        result = call$i(exoticToPrim, input, pref);\n        if (!isObject$b(result) || isSymbol$2(result)) return result;\n        throw $TypeError$c(\"Can't convert object to primitive value\");\n    }\n    if (pref === undefined) pref = \"number\";\n    return ordinaryToPrimitive(input, pref);\n};\nvar toPrimitive$1 = toPrimitive$2;\nvar isSymbol$1 = isSymbol$3;\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$4 = function(argument) {\n    var key = toPrimitive$1(argument, \"string\");\n    return isSymbol$1(key) ? key : key + \"\";\n};\nvar global$n = global$t;\nvar isObject$a = isObject$d;\nvar document$3 = global$n.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$a(document$3) && isObject$a(document$3.createElement);\nvar documentCreateElement$2 = function(it) {\n    return EXISTS$1 ? document$3.createElement(it) : {};\n};\nvar DESCRIPTORS$d = descriptors;\nvar fails$n = fails$s;\nvar createElement$1 = documentCreateElement$2;\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$d && !fails$n(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(createElement$1(\"div\"), \"a\", {\n        get: function() {\n            return 7;\n        }\n    }).a != 7;\n});\nvar DESCRIPTORS$c = descriptors;\nvar call$h = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$5 = toIndexedObject$6;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$a = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$c ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n    O = toIndexedObject$5(O);\n    P = toPropertyKey$3(P);\n    if (IE8_DOM_DEFINE$1) try {\n        return $getOwnPropertyDescriptor$1(O, P);\n    } catch (error) {}\n    if (hasOwn$a(O, P)) return createPropertyDescriptor$4(!call$h(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\nvar objectDefineProperty = {};\nvar DESCRIPTORS$b = descriptors;\nvar fails$m = fails$s;\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$m(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(function() {}, \"prototype\", {\n        value: 42,\n        writable: false\n    }).prototype != 42;\n});\nvar isObject$9 = isObject$d;\nvar $String$2 = String;\nvar $TypeError$b = TypeError;\n// `Assert: Type(argument) is Object`\nvar anObject$e = function(argument) {\n    if (isObject$9(argument)) return argument;\n    throw $TypeError$b($String$2(argument) + \" is not an object\");\n};\nvar DESCRIPTORS$a = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$d = anObject$e;\nvar toPropertyKey$2 = toPropertyKey$4;\nvar $TypeError$a = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = \"enumerable\";\nvar CONFIGURABLE$1 = \"configurable\";\nvar WRITABLE = \"writable\";\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$a ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n    anObject$d(O);\n    P = toPropertyKey$2(P);\n    anObject$d(Attributes);\n    if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n        var current = $getOwnPropertyDescriptor(O, P);\n        if (current && current[WRITABLE]) {\n            O[P] = Attributes.value;\n            Attributes = {\n                configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                writable: false\n            };\n        }\n    }\n    return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n    anObject$d(O);\n    P = toPropertyKey$2(P);\n    anObject$d(Attributes);\n    if (IE8_DOM_DEFINE) try {\n        return $defineProperty(O, P, Attributes);\n    } catch (error) {}\n    if (\"get\" in Attributes || \"set\" in Attributes) throw $TypeError$a(\"Accessors not supported\");\n    if (\"value\" in Attributes) O[P] = Attributes.value;\n    return O;\n};\nvar DESCRIPTORS$9 = descriptors;\nvar definePropertyModule$6 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$8 = DESCRIPTORS$9 ? function(object, key, value) {\n    return definePropertyModule$6.f(object, key, createPropertyDescriptor$3(1, value));\n} : function(object, key, value) {\n    object[key] = value;\n    return object;\n};\nvar makeBuiltIn$2 = {\n    exports: {}\n};\nvar DESCRIPTORS$8 = descriptors;\nvar hasOwn$9 = hasOwnProperty_1;\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$8 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$9(FunctionPrototype$1, \"name\");\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() {}).name === \"something\";\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$8 || DESCRIPTORS$8 && getDescriptor(FunctionPrototype$1, \"name\").configurable);\nvar functionName = {\n    EXISTS: EXISTS,\n    PROPER: PROPER,\n    CONFIGURABLE: CONFIGURABLE\n};\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$j(Function.toString);\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n    store$1.inspectSource = function(it) {\n        return functionToString(it);\n    };\n}\nvar inspectSource$4 = store$1.inspectSource;\nvar global$m = global$t;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\nvar WeakMap$1 = global$m.WeakMap;\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\nvar shared$2 = shared$4.exports;\nvar uid$1 = uid$3;\nvar keys$1 = shared$2(\"keys\");\nvar sharedKey$3 = function(key) {\n    return keys$1[key] || (keys$1[key] = uid$1(key));\n};\nvar hiddenKeys$4 = {};\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$l = global$t;\nvar uncurryThis$i = functionUncurryThis;\nvar isObject$8 = isObject$d;\nvar createNonEnumerableProperty$7 = createNonEnumerableProperty$8;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\nvar OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\nvar TypeError$3 = global$l.TypeError;\nvar WeakMap = global$l.WeakMap;\nvar set$2, get$1, has;\nvar enforce = function(it) {\n    return has(it) ? get$1(it) : set$2(it, {});\n};\nvar getterFor = function(TYPE) {\n    return function(it) {\n        var state;\n        if (!isObject$8(it) || (state = get$1(it)).type !== TYPE) {\n            throw TypeError$3(\"Incompatible receiver, \" + TYPE + \" required\");\n        }\n        return state;\n    };\n};\nif (NATIVE_WEAK_MAP || shared$1.state) {\n    var store = shared$1.state || (shared$1.state = new WeakMap());\n    var wmget = uncurryThis$i(store.get);\n    var wmhas = uncurryThis$i(store.has);\n    var wmset = uncurryThis$i(store.set);\n    set$2 = function(it, metadata) {\n        if (wmhas(store, it)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        wmset(store, it, metadata);\n        return metadata;\n    };\n    get$1 = function(it) {\n        return wmget(store, it) || {};\n    };\n    has = function(it) {\n        return wmhas(store, it);\n    };\n} else {\n    var STATE = sharedKey$2(\"state\");\n    hiddenKeys$3[STATE] = true;\n    set$2 = function(it, metadata) {\n        if (hasOwn$8(it, STATE)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        createNonEnumerableProperty$7(it, STATE, metadata);\n        return metadata;\n    };\n    get$1 = function(it) {\n        return hasOwn$8(it, STATE) ? it[STATE] : {};\n    };\n    has = function(it) {\n        return hasOwn$8(it, STATE);\n    };\n}\nvar internalState = {\n    set: set$2,\n    get: get$1,\n    has: has,\n    enforce: enforce,\n    getterFor: getterFor\n};\nvar fails$l = fails$s;\nvar isCallable$f = isCallable$n;\nvar hasOwn$7 = hasOwnProperty_1;\nvar DESCRIPTORS$7 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\nvar enforceInternalState$2 = InternalStateModule$5.enforce;\nvar getInternalState$5 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$7 && !fails$l(function() {\n    return defineProperty$6(function() {}, \"length\", {\n        value: 8\n    }).length !== 8;\n});\nvar TEMPLATE = String(String).split(\"String\");\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {\n    if (String(name).slice(0, 7) === \"Symbol(\") {\n        name = \"[\" + String(name).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n    }\n    if (options && options.getter) name = \"get \" + name;\n    if (options && options.setter) name = \"set \" + name;\n    if (!hasOwn$7(value, \"name\") || CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name) {\n        if (DESCRIPTORS$7) defineProperty$6(value, \"name\", {\n            value: name,\n            configurable: true\n        });\n        else value.name = name;\n    }\n    if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, \"arity\") && value.length !== options.arity) {\n        defineProperty$6(value, \"length\", {\n            value: options.arity\n        });\n    }\n    try {\n        if (options && hasOwn$7(options, \"constructor\") && options.constructor) {\n            if (DESCRIPTORS$7) defineProperty$6(value, \"prototype\", {\n                writable: false\n            });\n        // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n        } else if (value.prototype) value.prototype = undefined;\n    } catch (error) {}\n    var state = enforceInternalState$2(value);\n    if (!hasOwn$7(state, \"source\")) {\n        state.source = TEMPLATE.join(typeof name == \"string\" ? name : \"\");\n    }\n    return value;\n};\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n    return isCallable$f(this) && getInternalState$5(this).source || inspectSource$2(this);\n}, \"toString\");\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$5 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\nvar defineBuiltIn$8 = function(O, key, value, options) {\n    if (!options) options = {};\n    var simple = options.enumerable;\n    var name = options.name !== undefined ? options.name : key;\n    if (isCallable$e(value)) makeBuiltIn(value, name, options);\n    if (options.global) {\n        if (simple) O[key] = value;\n        else defineGlobalProperty$1(key, value);\n    } else {\n        try {\n            if (!options.unsafe) delete O[key];\n            else if (O[key]) simple = true;\n        } catch (error) {}\n        if (simple) O[key] = value;\n        else definePropertyModule$5.f(O, key, {\n            value: value,\n            enumerable: false,\n            configurable: !options.nonConfigurable,\n            writable: !options.nonWritable\n        });\n    }\n    return O;\n};\nvar objectGetOwnPropertyNames = {};\nvar ceil = Math.ceil;\nvar floor$3 = Math.floor;\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n    var n = +x;\n    return (n > 0 ? floor$3 : ceil)(n);\n};\nvar trunc = mathTrunc;\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$6 = function(argument) {\n    var number = +argument;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number !== number || number === 0 ? 0 : trunc(number);\n};\nvar toIntegerOrInfinity$5 = toIntegerOrInfinity$6;\nvar max$1 = Math.max;\nvar min$2 = Math.min;\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$4 = function(index, length) {\n    var integer = toIntegerOrInfinity$5(index);\n    return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);\n};\nvar toIntegerOrInfinity$4 = toIntegerOrInfinity$6;\nvar min$1 = Math.min;\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$6 = function(argument) {\n    return argument > 0 ? min$1(toIntegerOrInfinity$4(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\nvar toLength$5 = toLength$6;\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$8 = function(obj) {\n    return toLength$5(obj.length);\n};\nvar toIndexedObject$4 = toIndexedObject$6;\nvar toAbsoluteIndex$3 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$8;\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$4 = function(IS_INCLUDES) {\n    return function($this, el, fromIndex) {\n        var O = toIndexedObject$4($this);\n        var length = lengthOfArrayLike$7(O);\n        var index = toAbsoluteIndex$3(fromIndex, length);\n        var value;\n        // Array#includes uses SameValueZero equality algorithm\n        // eslint-disable-next-line no-self-compare -- NaN check\n        if (IS_INCLUDES && el != el) while(length > index){\n            value = O[index++];\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (value != value) return true;\n        // Array#indexOf ignores holes, Array#includes - not\n        }\n        else for(; length > index; index++){\n            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n        }\n        return !IS_INCLUDES && -1;\n    };\n};\nvar arrayIncludes = {\n    // `Array.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-array.prototype.includes\n    includes: createMethod$4(true),\n    // `Array.prototype.indexOf` method\n    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n    indexOf: createMethod$4(false)\n};\nvar uncurryThis$h = functionUncurryThis;\nvar hasOwn$6 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$6;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar push$2 = uncurryThis$h([].push);\nvar objectKeysInternal = function(object, names) {\n    var O = toIndexedObject$3(object);\n    var i = 0;\n    var result = [];\n    var key;\n    for(key in O)!hasOwn$6(hiddenKeys$2, key) && hasOwn$6(O, key) && push$2(result, key);\n    // Don't enum bug & hidden keys\n    while(names.length > i)if (hasOwn$6(O, key = names[i++])) {\n        ~indexOf$1(result, key) || push$2(result, key);\n    }\n    return result;\n};\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n    \"constructor\",\n    \"hasOwnProperty\",\n    \"isPrototypeOf\",\n    \"propertyIsEnumerable\",\n    \"toLocaleString\",\n    \"toString\",\n    \"valueOf\"\n];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\nvar hiddenKeys$1 = enumBugKeys$2.concat(\"length\", \"prototype\");\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return internalObjectKeys$1(O, hiddenKeys$1);\n};\nvar objectGetOwnPropertySymbols = {};\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$g = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$c = anObject$e;\nvar concat$1 = uncurryThis$g([].concat);\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n    var keys = getOwnPropertyNamesModule.f(anObject$c(it));\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n    return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$4 = objectDefineProperty;\nvar copyConstructorProperties$1 = function(target, source, exceptions) {\n    var keys = ownKeys(source);\n    var defineProperty = definePropertyModule$4.f;\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n            defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n        }\n    }\n};\nvar fails$k = fails$s;\nvar isCallable$d = isCallable$n;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$2 = function(feature, detection) {\n    var value = data[normalize(feature)];\n    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$d(detection) ? fails$k(detection) : !!detection;\n};\nvar normalize = isForced$2.normalize = function(string) {\n    return String(string).replace(replacement, \".\").toLowerCase();\n};\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = \"N\";\nvar POLYFILL = isForced$2.POLYFILL = \"P\";\nvar isForced_1 = isForced$2;\nvar global$k = global$t;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$6 = createNonEnumerableProperty$8;\nvar defineBuiltIn$7 = defineBuiltIn$8;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ var _export = function(options, source) {\n    var TARGET = options.target;\n    var GLOBAL = options.global;\n    var STATIC = options.stat;\n    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n    if (GLOBAL) {\n        target = global$k;\n    } else if (STATIC) {\n        target = global$k[TARGET] || defineGlobalProperty(TARGET, {});\n    } else {\n        target = (global$k[TARGET] || {}).prototype;\n    }\n    if (target) for(key in source){\n        sourceProperty = source[key];\n        if (options.dontCallGetSet) {\n            descriptor = getOwnPropertyDescriptor$1(target, key);\n            targetProperty = descriptor && descriptor.value;\n        } else targetProperty = target[key];\n        FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n        // contained in target\n        if (!FORCED && targetProperty !== undefined) {\n            if (typeof sourceProperty == typeof targetProperty) continue;\n            copyConstructorProperties(sourceProperty, targetProperty);\n        }\n        // add a flag to not completely full polyfills\n        if (options.sham || targetProperty && targetProperty.sham) {\n            createNonEnumerableProperty$6(sourceProperty, \"sham\", true);\n        }\n        defineBuiltIn$7(target, key, sourceProperty, options);\n    }\n};\nvar classof$a = classofRaw$1;\nvar global$j = global$t;\nvar engineIsNode = classof$a(global$j.process) == \"process\";\nvar isCallable$c = isCallable$n;\nvar $String$1 = String;\nvar $TypeError$9 = TypeError;\nvar aPossiblePrototype$1 = function(argument) {\n    if (typeof argument == \"object\" || isCallable$c(argument)) return argument;\n    throw $TypeError$9(\"Can't set \" + $String$1(argument) + \" as a prototype\");\n};\n/* eslint-disable no-proto -- safe */ var uncurryThis$f = functionUncurryThis;\nvar anObject$b = anObject$e;\nvar aPossiblePrototype = aPossiblePrototype$1;\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n    var CORRECT_SETTER = false;\n    var test = {};\n    var setter;\n    try {\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        setter = uncurryThis$f(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set);\n        setter(test, []);\n        CORRECT_SETTER = test instanceof Array;\n    } catch (error) {}\n    return function setPrototypeOf(O, proto) {\n        anObject$b(O);\n        aPossiblePrototype(proto);\n        if (CORRECT_SETTER) setter(O, proto);\n        else O.__proto__ = proto;\n        return O;\n    };\n}() : undefined);\nvar defineProperty$5 = objectDefineProperty.f;\nvar hasOwn$4 = hasOwnProperty_1;\nvar wellKnownSymbol$h = wellKnownSymbol$j;\nvar TO_STRING_TAG$4 = wellKnownSymbol$h(\"toStringTag\");\nvar setToStringTag$4 = function(target, TAG, STATIC) {\n    if (target && !STATIC) target = target.prototype;\n    if (target && !hasOwn$4(target, TO_STRING_TAG$4)) {\n        defineProperty$5(target, TO_STRING_TAG$4, {\n            configurable: true,\n            value: TAG\n        });\n    }\n};\nvar getBuiltIn$4 = getBuiltIn$8;\nvar definePropertyModule$3 = objectDefineProperty;\nvar wellKnownSymbol$g = wellKnownSymbol$j;\nvar DESCRIPTORS$6 = descriptors;\nvar SPECIES$4 = wellKnownSymbol$g(\"species\");\nvar setSpecies$2 = function(CONSTRUCTOR_NAME) {\n    var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);\n    var defineProperty = definePropertyModule$3.f;\n    if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$4]) {\n        defineProperty(Constructor, SPECIES$4, {\n            configurable: true,\n            get: function() {\n                return this;\n            }\n        });\n    }\n};\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar $TypeError$8 = TypeError;\nvar anInstance$3 = function(it, Prototype) {\n    if (isPrototypeOf$3(Prototype, it)) return it;\n    throw $TypeError$8(\"Incorrect invocation\");\n};\nvar wellKnownSymbol$f = wellKnownSymbol$j;\nvar TO_STRING_TAG$3 = wellKnownSymbol$f(\"toStringTag\");\nvar test = {};\ntest[TO_STRING_TAG$3] = \"z\";\nvar toStringTagSupport = String(test) === \"[object z]\";\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$b = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$e = wellKnownSymbol$j;\nvar TO_STRING_TAG$2 = wellKnownSymbol$e(\"toStringTag\");\nvar $Object$1 = Object;\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function() {\n    return arguments;\n}()) == \"Arguments\";\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key) {\n    try {\n        return it[key];\n    } catch (error) {}\n};\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$9 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n    var O, tag, result;\n    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && isCallable$b(O.callee) ? \"Arguments\" : result;\n};\nvar uncurryThis$e = functionUncurryThis;\nvar fails$j = fails$s;\nvar isCallable$a = isCallable$n;\nvar classof$8 = classof$9;\nvar getBuiltIn$3 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\nvar noop = function() {};\nvar empty = [];\nvar construct = getBuiltIn$3(\"Reflect\", \"construct\");\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$e(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\nvar isConstructorModern = function isConstructor(argument) {\n    if (!isCallable$a(argument)) return false;\n    try {\n        construct(noop, empty, argument);\n        return true;\n    } catch (error) {\n        return false;\n    }\n};\nvar isConstructorLegacy = function isConstructor(argument) {\n    if (!isCallable$a(argument)) return false;\n    switch(classof$8(argument)){\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n            return false;\n    }\n    try {\n        // we can't check .prototype since constructors produced by .bind haven't it\n        // `Function#toString` throws on some built-it function in some legacy engines\n        // (for example, `DOMQuad` and similar in FF41-)\n        return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));\n    } catch (error) {\n        return true;\n    }\n};\nisConstructorLegacy.sham = true;\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$j(function() {\n    var called;\n    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {\n        called = true;\n    }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$3 = tryToString$5;\nvar $TypeError$7 = TypeError;\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$2 = function(argument) {\n    if (isConstructor$1(argument)) return argument;\n    throw $TypeError$7(tryToString$3(argument) + \" is not a constructor\");\n};\nvar anObject$a = anObject$e;\nvar aConstructor$1 = aConstructor$2;\nvar wellKnownSymbol$d = wellKnownSymbol$j;\nvar SPECIES$3 = wellKnownSymbol$d(\"species\");\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$3 = function(O, defaultConstructor) {\n    var C = anObject$a(O).constructor;\n    var S;\n    return C === undefined || (S = anObject$a(C)[SPECIES$3]) == undefined ? defaultConstructor : aConstructor$1(S);\n};\nvar NATIVE_BIND$1 = functionBindNative;\nvar FunctionPrototype = Function.prototype;\nvar apply$3 = FunctionPrototype.apply;\nvar call$g = FunctionPrototype.call;\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND$1 ? call$g.bind(apply$3) : function() {\n    return call$g.apply(apply$3, arguments);\n});\nvar uncurryThis$d = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\nvar bind$6 = uncurryThis$d(uncurryThis$d.bind);\n// optional / simple context binding\nvar functionBindContext = function(fn, that) {\n    aCallable$7(fn);\n    return that === undefined ? fn : NATIVE_BIND ? bind$6(fn, that) : function() {\n        return fn.apply(that, arguments);\n    };\n};\nvar getBuiltIn$2 = getBuiltIn$8;\nvar html$2 = getBuiltIn$2(\"document\", \"documentElement\");\nvar uncurryThis$c = functionUncurryThis;\nvar arraySlice$5 = uncurryThis$c([].slice);\nvar $TypeError$6 = TypeError;\nvar validateArgumentsLength$1 = function(passed, required) {\n    if (passed < required) throw $TypeError$6(\"Not enough arguments\");\n    return passed;\n};\nvar userAgent$4 = engineUserAgent;\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4);\nvar global$i = global$t;\nvar apply$2 = functionApply;\nvar bind$5 = functionBindContext;\nvar isCallable$9 = isCallable$n;\nvar hasOwn$3 = hasOwnProperty_1;\nvar fails$i = fails$s;\nvar html$1 = html$2;\nvar arraySlice$4 = arraySlice$5;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$3 = engineIsNode;\nvar set$1 = global$i.setImmediate;\nvar clear = global$i.clearImmediate;\nvar process$2 = global$i.process;\nvar Dispatch = global$i.Dispatch;\nvar Function$1 = global$i.Function;\nvar MessageChannel = global$i.MessageChannel;\nvar String$1 = global$i.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = \"onreadystatechange\";\nvar location, defer, channel, port;\ntry {\n    // Deno throws a ReferenceError on `location` access without `--location` flag\n    location = global$i.location;\n} catch (error) {}\nvar run = function(id) {\n    if (hasOwn$3(queue$1, id)) {\n        var fn = queue$1[id];\n        delete queue$1[id];\n        fn();\n    }\n};\nvar runner = function(id) {\n    return function() {\n        run(id);\n    };\n};\nvar listener = function(event) {\n    run(event.data);\n};\nvar post = function(id) {\n    // old engines have not location.origin\n    global$i.postMessage(String$1(id), location.protocol + \"//\" + location.host);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set$1 || !clear) {\n    set$1 = function setImmediate(handler) {\n        validateArgumentsLength(arguments.length, 1);\n        var fn = isCallable$9(handler) ? handler : Function$1(handler);\n        var args = arraySlice$4(arguments, 1);\n        queue$1[++counter] = function() {\n            apply$2(fn, undefined, args);\n        };\n        defer(counter);\n        return counter;\n    };\n    clear = function clearImmediate(id) {\n        delete queue$1[id];\n    };\n    // Node.js 0.8-\n    if (IS_NODE$3) {\n        defer = function(id) {\n            process$2.nextTick(runner(id));\n        };\n    // Sphere (JS game engine) Dispatch API\n    } else if (Dispatch && Dispatch.now) {\n        defer = function(id) {\n            Dispatch.now(runner(id));\n        };\n    // Browsers with MessageChannel, includes WebWorkers\n    // except iOS - https://github.com/zloirock/core-js/issues/624\n    } else if (MessageChannel && !IS_IOS$1) {\n        channel = new MessageChannel();\n        port = channel.port2;\n        channel.port1.onmessage = listener;\n        defer = bind$5(port.postMessage, port);\n    // Browsers with postMessage, skip WebWorkers\n    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n    } else if (global$i.addEventListener && isCallable$9(global$i.postMessage) && !global$i.importScripts && location && location.protocol !== \"file:\" && !fails$i(post)) {\n        defer = post;\n        global$i.addEventListener(\"message\", listener, false);\n    // IE8-\n    } else if (ONREADYSTATECHANGE in createElement(\"script\")) {\n        defer = function(id) {\n            html$1.appendChild(createElement(\"script\"))[ONREADYSTATECHANGE] = function() {\n                html$1.removeChild(this);\n                run(id);\n            };\n        };\n    // Rest old browsers\n    } else {\n        defer = function(id) {\n            setTimeout(runner(id), 0);\n        };\n    }\n}\nvar task$1 = {\n    set: set$1,\n    clear: clear\n};\nvar userAgent$3 = engineUserAgent;\nvar global$h = global$t;\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$3) && global$h.Pebble !== undefined;\nvar userAgent$2 = engineUserAgent;\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$2);\nvar global$g = global$t;\nvar bind$4 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$2 = engineIsNode;\nvar MutationObserver = global$g.MutationObserver || global$g.WebKitMutationObserver;\nvar document$2 = global$g.document;\nvar process$1 = global$g.process;\nvar Promise$1 = global$g.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$g, \"queueMicrotask\");\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\nvar flush, head, last, notify$1, toggle, node, promise, then;\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n    flush = function() {\n        var parent, fn;\n        if (IS_NODE$2 && (parent = process$1.domain)) parent.exit();\n        while(head){\n            fn = head.fn;\n            head = head.next;\n            try {\n                fn();\n            } catch (error) {\n                if (head) notify$1();\n                else last = undefined;\n                throw error;\n            }\n        }\n        last = undefined;\n        if (parent) parent.enter();\n    };\n    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n    if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n        toggle = true;\n        node = document$2.createTextNode(\"\");\n        new MutationObserver(flush).observe(node, {\n            characterData: true\n        });\n        notify$1 = function() {\n            node.data = toggle = !toggle;\n        };\n    // environments with maybe non-completely correct, but existent Promise\n    } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n        // Promise.resolve without an argument throws an error in LG WebOS 2\n        promise = Promise$1.resolve(undefined);\n        // workaround of WebKit ~ iOS Safari 10.1 bug\n        promise.constructor = Promise$1;\n        then = bind$4(promise.then, promise);\n        notify$1 = function() {\n            then(flush);\n        };\n    // Node.js without promises\n    } else if (IS_NODE$2) {\n        notify$1 = function() {\n            process$1.nextTick(flush);\n        };\n    // for other environments - macrotask based on:\n    // - setImmediate\n    // - MessageChannel\n    // - window.postMessage\n    // - onreadystatechange\n    // - setTimeout\n    } else {\n        // strange IE + webpack dev server bug - use .bind(global)\n        macrotask = bind$4(macrotask, global$g);\n        notify$1 = function() {\n            macrotask(flush);\n        };\n    }\n}\nvar microtask$1 = queueMicrotask || function(fn) {\n    var task = {\n        fn: fn,\n        next: undefined\n    };\n    if (last) last.next = task;\n    if (!head) {\n        head = task;\n        notify$1();\n    }\n    last = task;\n};\nvar global$f = global$t;\nvar hostReportErrors$1 = function(a, b) {\n    var console1 = global$f.console;\n    if (console1 && console1.error) {\n        arguments.length == 1 ? console1.error(a) : console1.error(a, b);\n    }\n};\nvar perform$3 = function(exec) {\n    try {\n        return {\n            error: false,\n            value: exec()\n        };\n    } catch (error) {\n        return {\n            error: true,\n            value: error\n        };\n    }\n};\nvar Queue$1 = function() {\n    this.head = null;\n    this.tail = null;\n};\nQueue$1.prototype = {\n    add: function(item) {\n        var entry = {\n            item: item,\n            next: null\n        };\n        if (this.head) this.tail.next = entry;\n        else this.head = entry;\n        this.tail = entry;\n    },\n    get: function() {\n        var entry = this.head;\n        if (entry) {\n            this.head = entry.next;\n            if (this.tail === entry) this.tail = null;\n            return entry.item;\n        }\n    }\n};\nvar queue = Queue$1;\nvar global$e = global$t;\nvar promiseNativeConstructor = global$e.Promise;\nvar engineIsBrowser =  false && 0;\nvar global$d = global$t;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$8 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$c = wellKnownSymbol$j;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$2 = wellKnownSymbol$c(\"species\");\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$8(global$d.PromiseRejectionEvent);\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced(\"Promise\", function() {\n    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n    // We can't detect it synchronously, so just check versions\n    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n    // We can't use @@species feature detection in V8 since it causes\n    // deoptimization and performance degradation\n    // https://github.com/zloirock/core-js/issues/679\n    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n    // Detect correctness of subclassing with @@species support\n    var promise = new NativePromiseConstructor$3(function(resolve) {\n        resolve(1);\n    });\n    var FakePromise = function(exec) {\n        exec(function() {}, function() {});\n    };\n    var constructor = promise.constructor = {};\n    constructor[SPECIES$2] = FakePromise;\n    SUBCLASSING = promise.then(function() {}) instanceof FakePromise;\n    if (!SUBCLASSING) return true;\n    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\nvar promiseConstructorDetection = {\n    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n    SUBCLASSING: SUBCLASSING\n};\nvar newPromiseCapability$2 = {};\nvar aCallable$6 = aCallable$9;\nvar PromiseCapability = function(C) {\n    var resolve, reject;\n    this.promise = new C(function($$resolve, $$reject) {\n        if (resolve !== undefined || reject !== undefined) throw TypeError(\"Bad Promise constructor\");\n        resolve = $$resolve;\n        reject = $$reject;\n    });\n    this.resolve = aCallable$6(resolve);\n    this.reject = aCallable$6(reject);\n};\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function(C) {\n    return new PromiseCapability(C);\n};\nvar $$e = _export;\nvar IS_NODE$1 = engineIsNode;\nvar global$c = global$t;\nvar call$f = functionCall;\nvar defineBuiltIn$6 = defineBuiltIn$8;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$4;\nvar setSpecies$1 = setSpecies$2;\nvar aCallable$5 = aCallable$9;\nvar isCallable$7 = isCallable$n;\nvar isObject$7 = isObject$d;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor$2 = speciesConstructor$3;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$4 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\nvar PROMISE = \"Promise\";\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$4.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$4.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$2 = global$c.TypeError;\nvar document$1 = global$c.document;\nvar process = global$c.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$c.dispatchEvent);\nvar UNHANDLED_REJECTION = \"unhandledrejection\";\nvar REJECTION_HANDLED = \"rejectionhandled\";\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n// helpers\nvar isThenable = function(it) {\n    var then;\n    return isObject$7(it) && isCallable$7(then = it.then) ? then : false;\n};\nvar callReaction = function(reaction, state) {\n    var value = state.value;\n    var ok = state.state == FULFILLED;\n    var handler = ok ? reaction.ok : reaction.fail;\n    var resolve = reaction.resolve;\n    var reject = reaction.reject;\n    var domain = reaction.domain;\n    var result, then, exited;\n    try {\n        if (handler) {\n            if (!ok) {\n                if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n                state.rejection = HANDLED;\n            }\n            if (handler === true) result = value;\n            else {\n                if (domain) domain.enter();\n                result = handler(value); // can throw\n                if (domain) {\n                    domain.exit();\n                    exited = true;\n                }\n            }\n            if (result === reaction.promise) {\n                reject(TypeError$2(\"Promise-chain cycle\"));\n            } else if (then = isThenable(result)) {\n                call$f(then, result, resolve, reject);\n            } else resolve(result);\n        } else reject(value);\n    } catch (error) {\n        if (domain && !exited) domain.exit();\n        reject(error);\n    }\n};\nvar notify = function(state, isReject) {\n    if (state.notified) return;\n    state.notified = true;\n    microtask(function() {\n        var reactions = state.reactions;\n        var reaction;\n        while(reaction = reactions.get()){\n            callReaction(reaction, state);\n        }\n        state.notified = false;\n        if (isReject && !state.rejection) onUnhandled(state);\n    });\n};\nvar dispatchEvent = function(name, promise, reason) {\n    var event, handler;\n    if (DISPATCH_EVENT) {\n        event = document$1.createEvent(\"Event\");\n        event.promise = promise;\n        event.reason = reason;\n        event.initEvent(name, false, true);\n        global$c.dispatchEvent(event);\n    } else event = {\n        promise: promise,\n        reason: reason\n    };\n    if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$c[\"on\" + name])) handler(event);\n    else if (name === UNHANDLED_REJECTION) hostReportErrors(\"Unhandled promise rejection\", reason);\n};\nvar onUnhandled = function(state) {\n    call$f(task, global$c, function() {\n        var promise = state.facade;\n        var value = state.value;\n        var IS_UNHANDLED = isUnhandled(state);\n        var result;\n        if (IS_UNHANDLED) {\n            result = perform$2(function() {\n                if (IS_NODE$1) {\n                    process.emit(\"unhandledRejection\", value, promise);\n                } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n            });\n            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n            state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;\n            if (result.error) throw result.value;\n        }\n    });\n};\nvar isUnhandled = function(state) {\n    return state.rejection !== HANDLED && !state.parent;\n};\nvar onHandleUnhandled = function(state) {\n    call$f(task, global$c, function() {\n        var promise = state.facade;\n        if (IS_NODE$1) {\n            process.emit(\"rejectionHandled\", promise);\n        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n    });\n};\nvar bind$3 = function(fn, state, unwrap) {\n    return function(value) {\n        fn(state, value, unwrap);\n    };\n};\nvar internalReject = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    state.value = value;\n    state.state = REJECTED;\n    notify(state, true);\n};\nvar internalResolve = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    try {\n        if (state.facade === value) throw TypeError$2(\"Promise can't be resolved itself\");\n        var then = isThenable(value);\n        if (then) {\n            microtask(function() {\n                var wrapper = {\n                    done: false\n                };\n                try {\n                    call$f(then, value, bind$3(internalResolve, wrapper, state), bind$3(internalReject, wrapper, state));\n                } catch (error) {\n                    internalReject(wrapper, error, state);\n                }\n            });\n        } else {\n            state.value = value;\n            state.state = FULFILLED;\n            notify(state, false);\n        }\n    } catch (error) {\n        internalReject({\n            done: false\n        }, error, state);\n    }\n};\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n    // 25.4.3.1 Promise(executor)\n    PromiseConstructor = function Promise1(executor) {\n        anInstance$2(this, PromisePrototype);\n        aCallable$5(executor);\n        call$f(Internal, this);\n        var state = getInternalPromiseState(this);\n        try {\n            executor(bind$3(internalResolve, state), bind$3(internalReject, state));\n        } catch (error) {\n            internalReject(state, error);\n        }\n    };\n    PromisePrototype = PromiseConstructor.prototype;\n    // eslint-disable-next-line no-unused-vars -- required for `.length`\n    Internal = function Promise1(executor) {\n        setInternalState$3(this, {\n            type: PROMISE,\n            done: false,\n            notified: false,\n            parent: false,\n            reactions: new Queue(),\n            rejection: false,\n            state: PENDING,\n            value: undefined\n        });\n    };\n    // `Promise.prototype.then` method\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\n    Internal.prototype = defineBuiltIn$6(PromisePrototype, \"then\", function then(onFulfilled, onRejected) {\n        var state = getInternalPromiseState(this);\n        var reaction = newPromiseCapability$1(speciesConstructor$2(this, PromiseConstructor));\n        state.parent = true;\n        reaction.ok = isCallable$7(onFulfilled) ? onFulfilled : true;\n        reaction.fail = isCallable$7(onRejected) && onRejected;\n        reaction.domain = IS_NODE$1 ? process.domain : undefined;\n        if (state.state == PENDING) state.reactions.add(reaction);\n        else microtask(function() {\n            callReaction(reaction, state);\n        });\n        return reaction.promise;\n    });\n    OwnPromiseCapability = function() {\n        var promise = new Internal();\n        var state = getInternalPromiseState(promise);\n        this.promise = promise;\n        this.resolve = bind$3(internalResolve, state);\n        this.reject = bind$3(internalReject, state);\n    };\n    newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function(C) {\n        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n    };\n    if (isCallable$7(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n        nativeThen = NativePromisePrototype$1.then;\n        if (!NATIVE_PROMISE_SUBCLASSING) {\n            // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n            defineBuiltIn$6(NativePromisePrototype$1, \"then\", function then(onFulfilled, onRejected) {\n                var that = this;\n                return new PromiseConstructor(function(resolve, reject) {\n                    call$f(nativeThen, that, resolve, reject);\n                }).then(onFulfilled, onRejected);\n            // https://github.com/zloirock/core-js/issues/640\n            }, {\n                unsafe: true\n            });\n        }\n        // make `.constructor === Promise` work for native promise-based APIs\n        try {\n            delete NativePromisePrototype$1.constructor;\n        } catch (error) {}\n        // make `instanceof Promise` work for native promise-based APIs\n        if (setPrototypeOf$5) {\n            setPrototypeOf$5(NativePromisePrototype$1, PromisePrototype);\n        }\n    }\n}\n$$e({\n    global: true,\n    constructor: true,\n    wrap: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$4\n}, {\n    Promise: PromiseConstructor\n});\nsetToStringTag$3(PromiseConstructor, PROMISE, false);\nsetSpecies$1(PROMISE);\nvar iterators = {};\nvar wellKnownSymbol$b = wellKnownSymbol$j;\nvar Iterators$4 = iterators;\nvar ITERATOR$5 = wellKnownSymbol$b(\"iterator\");\nvar ArrayPrototype$1 = Array.prototype;\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function(it) {\n    return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);\n};\nvar classof$7 = classof$9;\nvar getMethod$2 = getMethod$4;\nvar Iterators$3 = iterators;\nvar wellKnownSymbol$a = wellKnownSymbol$j;\nvar ITERATOR$4 = wellKnownSymbol$a(\"iterator\");\nvar getIteratorMethod$3 = function(it) {\n    if (it != undefined) return getMethod$2(it, ITERATOR$4) || getMethod$2(it, \"@@iterator\") || Iterators$3[classof$7(it)];\n};\nvar call$e = functionCall;\nvar aCallable$4 = aCallable$9;\nvar anObject$9 = anObject$e;\nvar tryToString$2 = tryToString$5;\nvar getIteratorMethod$2 = getIteratorMethod$3;\nvar $TypeError$5 = TypeError;\nvar getIterator$2 = function(argument, usingIterator) {\n    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;\n    if (aCallable$4(iteratorMethod)) return anObject$9(call$e(iteratorMethod, argument));\n    throw $TypeError$5(tryToString$2(argument) + \" is not iterable\");\n};\nvar call$d = functionCall;\nvar anObject$8 = anObject$e;\nvar getMethod$1 = getMethod$4;\nvar iteratorClose$1 = function(iterator, kind, value) {\n    var innerResult, innerError;\n    anObject$8(iterator);\n    try {\n        innerResult = getMethod$1(iterator, \"return\");\n        if (!innerResult) {\n            if (kind === \"throw\") throw value;\n            return value;\n        }\n        innerResult = call$d(innerResult, iterator);\n    } catch (error) {\n        innerError = true;\n        innerResult = error;\n    }\n    if (kind === \"throw\") throw value;\n    if (innerError) throw innerResult;\n    anObject$8(innerResult);\n    return value;\n};\nvar bind$2 = functionBindContext;\nvar call$c = functionCall;\nvar anObject$7 = anObject$e;\nvar tryToString$1 = tryToString$5;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$8;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar getIterator$1 = getIterator$2;\nvar getIteratorMethod$1 = getIteratorMethod$3;\nvar iteratorClose = iteratorClose$1;\nvar $TypeError$4 = TypeError;\nvar Result = function(stopped, result) {\n    this.stopped = stopped;\n    this.result = result;\n};\nvar ResultPrototype = Result.prototype;\nvar iterate$2 = function(iterable, unboundFunction, options) {\n    var that = options && options.that;\n    var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n    var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n    var INTERRUPTED = !!(options && options.INTERRUPTED);\n    var fn = bind$2(unboundFunction, that);\n    var iterator, iterFn, index, length, result, next, step;\n    var stop = function(condition) {\n        if (iterator) iteratorClose(iterator, \"normal\", condition);\n        return new Result(true, condition);\n    };\n    var callFn = function(value) {\n        if (AS_ENTRIES) {\n            anObject$7(value);\n            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n        }\n        return INTERRUPTED ? fn(value, stop) : fn(value);\n    };\n    if (IS_ITERATOR) {\n        iterator = iterable;\n    } else {\n        iterFn = getIteratorMethod$1(iterable);\n        if (!iterFn) throw $TypeError$4(tryToString$1(iterable) + \" is not iterable\");\n        // optimisation for array iterators\n        if (isArrayIteratorMethod$1(iterFn)) {\n            for(index = 0, length = lengthOfArrayLike$6(iterable); length > index; index++){\n                result = callFn(iterable[index]);\n                if (result && isPrototypeOf$2(ResultPrototype, result)) return result;\n            }\n            return new Result(false);\n        }\n        iterator = getIterator$1(iterable, iterFn);\n    }\n    next = iterator.next;\n    while(!(step = call$c(next, iterator)).done){\n        try {\n            result = callFn(step.value);\n        } catch (error) {\n            iteratorClose(iterator, \"throw\", error);\n        }\n        if (typeof result == \"object\" && result && isPrototypeOf$2(ResultPrototype, result)) return result;\n    }\n    return new Result(false);\n};\nvar wellKnownSymbol$9 = wellKnownSymbol$j;\nvar ITERATOR$3 = wellKnownSymbol$9(\"iterator\");\nvar SAFE_CLOSING = false;\ntry {\n    var called = 0;\n    var iteratorWithReturn = {\n        next: function() {\n            return {\n                done: !!called++\n            };\n        },\n        \"return\": function() {\n            SAFE_CLOSING = true;\n        }\n    };\n    iteratorWithReturn[ITERATOR$3] = function() {\n        return this;\n    };\n    // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n    Array.from(iteratorWithReturn, function() {\n        throw 2;\n    });\n} catch (error) {}\nvar checkCorrectnessOfIteration$2 = function(exec, SKIP_CLOSING) {\n    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n    var ITERATION_SUPPORT = false;\n    try {\n        var object = {};\n        object[ITERATOR$3] = function() {\n            return {\n                next: function() {\n                    return {\n                        done: ITERATION_SUPPORT = true\n                    };\n                }\n            };\n        };\n        exec(object);\n    } catch (error) {}\n    return ITERATION_SUPPORT;\n};\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function(iterable) {\n    NativePromiseConstructor$1.all(iterable).then(undefined, function() {});\n});\nvar $$d = _export;\nvar call$b = functionCall;\nvar aCallable$3 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$d({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION$1\n}, {\n    all: function all(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$2.f(C);\n        var resolve = capability.resolve;\n        var reject = capability.reject;\n        var result = perform$1(function() {\n            var $promiseResolve = aCallable$3(C.resolve);\n            var values = [];\n            var counter = 0;\n            var remaining = 1;\n            iterate$1(iterable, function(promise) {\n                var index = counter++;\n                var alreadyCalled = false;\n                remaining++;\n                call$b($promiseResolve, C, promise).then(function(value) {\n                    if (alreadyCalled) return;\n                    alreadyCalled = true;\n                    values[index] = value;\n                    --remaining || resolve(values);\n                }, reject);\n            });\n            --remaining || resolve(values);\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$c = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$6 = isCallable$n;\nvar defineBuiltIn$5 = defineBuiltIn$8;\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$c({\n    target: \"Promise\",\n    proto: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$2,\n    real: true\n}, {\n    \"catch\": function(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n});\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$6(NativePromiseConstructor)) {\n    var method = getBuiltIn$1(\"Promise\").prototype[\"catch\"];\n    if (NativePromisePrototype[\"catch\"] !== method) {\n        defineBuiltIn$5(NativePromisePrototype, \"catch\", method, {\n            unsafe: true\n        });\n    }\n}\nvar $$b = _export;\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$b({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION\n}, {\n    race: function race(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$1.f(C);\n        var reject = capability.reject;\n        var result = perform(function() {\n            var $promiseResolve = aCallable$2(C.resolve);\n            iterate(iterable, function(promise) {\n                call$a($promiseResolve, C, promise).then(capability.resolve, reject);\n            });\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$a = _export;\nvar call$9 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$a({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$1\n}, {\n    reject: function reject(r) {\n        var capability = newPromiseCapabilityModule.f(this);\n        call$9(capability.reject, undefined, r);\n        return capability.promise;\n    }\n});\nvar anObject$6 = anObject$e;\nvar isObject$6 = isObject$d;\nvar newPromiseCapability = newPromiseCapability$2;\nvar promiseResolve$1 = function(C, x) {\n    anObject$6(C);\n    if (isObject$6(x) && x.constructor === C) return x;\n    var promiseCapability = newPromiseCapability.f(C);\n    var resolve = promiseCapability.resolve;\n    resolve(x);\n    return promiseCapability.promise;\n};\nvar $$9 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\ngetBuiltIn(\"Promise\");\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$9({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR\n}, {\n    resolve: function resolve(x) {\n        return promiseResolve(this, x);\n    }\n});\nclass WebStorageService {\n    getItem(key) {\n        return new Promise((resolve)=>{\n            const value = localStorage.getItem(key);\n            resolve(value);\n        });\n    }\n    setItem(key, value) {\n        return new Promise((resolve)=>{\n            localStorage.setItem(key, value);\n            resolve();\n        });\n    }\n    removeItem(key) {\n        return new Promise((resolve)=>{\n            localStorage.removeItem(key);\n            resolve();\n        });\n    }\n}\nvar objectDefineProperties = {};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n    return internalObjectKeys(O, enumBugKeys$1);\n};\nvar DESCRIPTORS$5 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$5 = anObject$e;\nvar toIndexedObject$2 = toIndexedObject$6;\nvar objectKeys$1 = objectKeys$2;\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$5 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n    anObject$5(O);\n    var props = toIndexedObject$2(Properties);\n    var keys = objectKeys$1(Properties);\n    var length = keys.length;\n    var index = 0;\n    var key;\n    while(length > index)definePropertyModule$2.f(O, key = keys[index++], props[key]);\n    return O;\n};\n/* global ActiveXObject -- old IE, WSH */ var anObject$4 = anObject$e;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\nvar GT = \">\";\nvar LT = \"<\";\nvar PROTOTYPE$1 = \"prototype\";\nvar SCRIPT = \"script\";\nvar IE_PROTO$1 = sharedKey$1(\"IE_PROTO\");\nvar EmptyConstructor = function() {};\nvar scriptTag = function(content) {\n    return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n};\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function(activeXDocument) {\n    activeXDocument.write(scriptTag(\"\"));\n    activeXDocument.close();\n    var temp = activeXDocument.parentWindow.Object;\n    activeXDocument = null; // avoid memory leak\n    return temp;\n};\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function() {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = documentCreateElement$1(\"iframe\");\n    var JS = \"java\" + SCRIPT + \":\";\n    var iframeDocument;\n    iframe.style.display = \"none\";\n    html.appendChild(iframe);\n    // https://github.com/zloirock/core-js/issues/475\n    iframe.src = String(JS);\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(scriptTag(\"document.F=Object\"));\n    iframeDocument.close();\n    return iframeDocument.F;\n};\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function() {\n    try {\n        activeXDocument = new ActiveXObject(\"htmlfile\");\n    } catch (error) {}\n    NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n     : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n    var length = enumBugKeys.length;\n    while(length--)delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];\n    return NullProtoObject();\n};\nhiddenKeys[IE_PROTO$1] = true;\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n    var result;\n    if (O !== null) {\n        EmptyConstructor[PROTOTYPE$1] = anObject$4(O);\n        result = new EmptyConstructor();\n        EmptyConstructor[PROTOTYPE$1] = null;\n        // add \"__proto__\" for Object.getPrototypeOf polyfill\n        result[IE_PROTO$1] = O;\n    } else result = NullProtoObject();\n    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\nvar wellKnownSymbol$8 = wellKnownSymbol$j;\nvar create$3 = objectCreate;\nvar defineProperty$4 = objectDefineProperty.f;\nvar UNSCOPABLES = wellKnownSymbol$8(\"unscopables\");\nvar ArrayPrototype = Array.prototype;\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n    defineProperty$4(ArrayPrototype, UNSCOPABLES, {\n        configurable: true,\n        value: create$3(null)\n    });\n}\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function(key) {\n    ArrayPrototype[UNSCOPABLES][key] = true;\n};\nvar fails$h = fails$s;\nvar correctPrototypeGetter = !fails$h(function() {\n    function F() {}\n    F.prototype.constructor = null;\n    // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n    return Object.getPrototypeOf(new F()) !== F.prototype;\n});\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$n;\nvar toObject$5 = toObject$7;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\nvar IE_PROTO = sharedKey(\"IE_PROTO\");\nvar $Object = Object;\nvar ObjectPrototype$2 = $Object.prototype;\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {\n    var object = toObject$5(O);\n    if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];\n    var constructor = object.constructor;\n    if (isCallable$5(constructor) && object instanceof constructor) {\n        return constructor.prototype;\n    }\n    return object instanceof $Object ? ObjectPrototype$2 : null;\n};\nvar fails$g = fails$s;\nvar isCallable$4 = isCallable$n;\nvar getPrototypeOf$3 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$8;\nvar wellKnownSymbol$7 = wellKnownSymbol$j;\nvar ITERATOR$2 = wellKnownSymbol$7(\"iterator\");\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n/* eslint-disable es-x/no-array-prototype-keys -- safe */ if ([].keys) {\n    arrayIterator = [].keys();\n    // Safari 8 has buggy iterators w/o `next`\n    if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n    else {\n        PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));\n        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n    }\n}\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$g(function() {\n    var test = {};\n    // FF44- legacy iterators case\n    return IteratorPrototype$2[ITERATOR$2].call(test) !== test;\n});\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$4(IteratorPrototype$2[ITERATOR$2])) {\n    defineBuiltIn$4(IteratorPrototype$2, ITERATOR$2, function() {\n        return this;\n    });\n}\nvar iteratorsCore = {\n    IteratorPrototype: IteratorPrototype$2,\n    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$2 = setToStringTag$4;\nvar Iterators$2 = iterators;\nvar returnThis$1 = function() {\n    return this;\n};\nvar createIteratorConstructor$1 = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    IteratorConstructor.prototype = create$2(IteratorPrototype$1, {\n        next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next)\n    });\n    setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n    Iterators$2[TO_STRING_TAG] = returnThis$1;\n    return IteratorConstructor;\n};\nvar $$8 = _export;\nvar call$8 = functionCall;\nvar FunctionName$1 = functionName;\nvar isCallable$3 = isCallable$n;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf$2 = objectGetPrototypeOf;\nvar setPrototypeOf$4 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$4;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$8;\nvar defineBuiltIn$3 = defineBuiltIn$8;\nvar wellKnownSymbol$6 = wellKnownSymbol$j;\nvar Iterators$1 = iterators;\nvar IteratorsCore = iteratorsCore;\nvar PROPER_FUNCTION_NAME$2 = FunctionName$1.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol$6(\"iterator\");\nvar KEYS = \"keys\";\nvar VALUES = \"values\";\nvar ENTRIES = \"entries\";\nvar returnThis = function() {\n    return this;\n};\nvar defineIterator$1 = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n    createIteratorConstructor(IteratorConstructor, NAME, next);\n    var getIterationMethod = function(KIND) {\n        if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n        switch(KIND){\n            case KEYS:\n                return function keys() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case VALUES:\n                return function values() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case ENTRIES:\n                return function entries() {\n                    return new IteratorConstructor(this, KIND);\n                };\n        }\n        return function() {\n            return new IteratorConstructor(this);\n        };\n    };\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    var INCORRECT_VALUES_NAME = false;\n    var IterablePrototype = Iterable.prototype;\n    var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n    var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n    var CurrentIteratorPrototype, methods, KEY;\n    // fix native\n    if (anyNativeIterator) {\n        CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));\n        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n            if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {\n                if (setPrototypeOf$4) {\n                    setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);\n                } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$1])) {\n                    defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$1, returnThis);\n                }\n            }\n            // Set @@toStringTag to native iterators\n            setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n        }\n    }\n    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n    if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n        if (CONFIGURABLE_FUNCTION_NAME$1) {\n            createNonEnumerableProperty$5(IterablePrototype, \"name\", VALUES);\n        } else {\n            INCORRECT_VALUES_NAME = true;\n            defaultIterator = function values() {\n                return call$8(nativeIterator, this);\n            };\n        }\n    }\n    // export additional methods\n    if (DEFAULT) {\n        methods = {\n            values: getIterationMethod(VALUES),\n            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n            entries: getIterationMethod(ENTRIES)\n        };\n        if (FORCED) for(KEY in methods){\n            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n                defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n            }\n        }\n        else $$8({\n            target: NAME,\n            proto: true,\n            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n        }, methods);\n    }\n    // define iterator\n    if (IterablePrototype[ITERATOR$1] !== defaultIterator) {\n        defineBuiltIn$3(IterablePrototype, ITERATOR$1, defaultIterator, {\n            name: DEFAULT\n        });\n    }\n    Iterators$1[NAME] = defaultIterator;\n    return methods;\n};\nvar toIndexedObject$1 = toIndexedObject$6;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators = iterators;\nvar InternalStateModule$3 = internalState;\nvar defineProperty$3 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$4 = descriptors;\nvar ARRAY_ITERATOR = \"Array Iterator\";\nvar setInternalState$2 = InternalStateModule$3.set;\nvar getInternalState$4 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, \"Array\", function(iterated, kind) {\n    setInternalState$2(this, {\n        type: ARRAY_ITERATOR,\n        target: toIndexedObject$1(iterated),\n        index: 0,\n        kind: kind // kind\n    });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function() {\n    var state = getInternalState$4(this);\n    var target = state.target;\n    var kind = state.kind;\n    var index = state.index++;\n    if (!target || index >= target.length) {\n        state.target = undefined;\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    if (kind == \"keys\") return {\n        value: index,\n        done: false\n    };\n    if (kind == \"values\") return {\n        value: target[index],\n        done: false\n    };\n    return {\n        value: [\n            index,\n            target[index]\n        ],\n        done: false\n    };\n}, \"values\");\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators.Arguments = Iterators.Array;\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1(\"keys\");\naddToUnscopables$1(\"values\");\naddToUnscopables$1(\"entries\");\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$4 && values.name !== \"values\") try {\n    defineProperty$3(values, \"name\", {\n        value: \"values\"\n    });\n} catch (error) {}\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n};\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\nvar classList = documentCreateElement(\"span\").classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\nvar global$b = global$t;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$8;\nvar wellKnownSymbol$5 = wellKnownSymbol$j;\nvar ITERATOR = wellKnownSymbol$5(\"iterator\");\nvar TO_STRING_TAG$1 = wellKnownSymbol$5(\"toStringTag\");\nvar ArrayValues = ArrayIteratorMethods.values;\nvar handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {\n    if (CollectionPrototype) {\n        // some Chrome versions have non-configurable methods on DOMTokenList\n        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n            createNonEnumerableProperty$4(CollectionPrototype, ITERATOR, ArrayValues);\n        } catch (error) {\n            CollectionPrototype[ITERATOR] = ArrayValues;\n        }\n        if (!CollectionPrototype[TO_STRING_TAG$1]) {\n            createNonEnumerableProperty$4(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);\n        }\n        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){\n            // some Chrome versions have non-configurable methods on DOMTokenList\n            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n                createNonEnumerableProperty$4(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n            } catch (error) {\n                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n            }\n        }\n    }\n};\nfor(var COLLECTION_NAME in DOMIterables){\n    handlePrototype(global$b[COLLECTION_NAME] && global$b[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\nhandlePrototype(DOMTokenListPrototype, \"DOMTokenList\");\nclass Logger {\n    constructor(namespace){\n        this.namespace = namespace;\n    }\n    emit(method, ...params) {\n        if (!Logger.debug) {\n            return;\n        }\n        if (this.namespace && method !== \"error\") {\n            // eslint-disable-next-line no-console\n            console[method](this.namespace, ...params);\n            return;\n        }\n        // eslint-disable-next-line no-console\n        console[method](...params);\n    }\n    log(...params) {\n        this.emit(\"log\", ...params);\n    }\n    info(...params) {\n        this.emit(\"info\", ...params);\n    }\n    warn(...params) {\n        this.emit(\"warn\", ...params);\n    }\n    error(...params) {\n        this.emit(\"error\", ...params);\n    }\n}\nLogger.debug = false;\nconst logger = new Logger();\nvar $$7 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$f = fails$s;\nvar addToUnscopables = addToUnscopables$2;\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$f(function() {\n    return !Array(1).includes();\n});\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$7({\n    target: \"Array\",\n    proto: true,\n    forced: BROKEN_ON_SPARSE\n}, {\n    includes: function includes(el /* , fromIndex = 0 */ ) {\n        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n    }\n});\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(\"includes\");\nvar isObject$5 = isObject$d;\nvar classof$6 = classofRaw$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$j;\nvar MATCH$1 = wellKnownSymbol$4(\"match\");\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function(it) {\n    var isRegExp;\n    return isObject$5(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$6(it) == \"RegExp\");\n};\nvar isRegExp$1 = isRegexp;\nvar $TypeError$3 = TypeError;\nvar notARegexp = function(it) {\n    if (isRegExp$1(it)) {\n        throw $TypeError$3(\"The method doesn't accept regular expressions\");\n    }\n    return it;\n};\nvar classof$5 = classof$9;\nvar $String = String;\nvar toString$5 = function(argument) {\n    if (classof$5(argument) === \"Symbol\") throw TypeError(\"Cannot convert a Symbol value to a string\");\n    return $String(argument);\n};\nvar wellKnownSymbol$3 = wellKnownSymbol$j;\nvar MATCH = wellKnownSymbol$3(\"match\");\nvar correctIsRegexpLogic = function(METHOD_NAME) {\n    var regexp = /./;\n    try {\n        \"/./\"[METHOD_NAME](regexp);\n    } catch (error1) {\n        try {\n            regexp[MATCH] = false;\n            return \"/./\"[METHOD_NAME](regexp);\n        } catch (error2) {}\n    }\n    return false;\n};\nvar $$6 = _export;\nvar uncurryThis$b = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$3 = requireObjectCoercible$6;\nvar toString$4 = toString$5;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\nvar stringIndexOf = uncurryThis$b(\"\".indexOf);\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$6({\n    target: \"String\",\n    proto: true,\n    forced: !correctIsRegExpLogic(\"includes\")\n}, {\n    includes: function includes(searchString /* , position = 0 */ ) {\n        return !!~stringIndexOf(toString$4(requireObjectCoercible$3(this)), toString$4(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);\n    }\n});\n// a string of all valid unicode whitespaces\nvar whitespaces$2 = \"\t\\n\\v\\f\\r \\xa0    \" + \"          　\\u2028\\u2029\\uFEFF\";\nvar uncurryThis$a = functionUncurryThis;\nvar requireObjectCoercible$2 = requireObjectCoercible$6;\nvar toString$3 = toString$5;\nvar whitespaces$1 = whitespaces$2;\nvar replace$1 = uncurryThis$a(\"\".replace);\nvar whitespace = \"[\" + whitespaces$1 + \"]\";\nvar ltrim = RegExp(\"^\" + whitespace + whitespace + \"*\");\nvar rtrim = RegExp(whitespace + whitespace + \"*$\");\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod$3 = function(TYPE) {\n    return function($this) {\n        var string = toString$3(requireObjectCoercible$2($this));\n        if (TYPE & 1) string = replace$1(string, ltrim, \"\");\n        if (TYPE & 2) string = replace$1(string, rtrim, \"\");\n        return string;\n    };\n};\nvar stringTrim = {\n    // `String.prototype.{ trimLeft, trimStart }` methods\n    // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n    start: createMethod$3(1),\n    // `String.prototype.{ trimRight, trimEnd }` methods\n    // https://tc39.es/ecma262/#sec-string.prototype.trimend\n    end: createMethod$3(2),\n    // `String.prototype.trim` method\n    // https://tc39.es/ecma262/#sec-string.prototype.trim\n    trim: createMethod$3(3)\n};\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar fails$e = fails$s;\nvar whitespaces = whitespaces$2;\nvar non = \"​\\x85᠎\";\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nvar stringTrimForced = function(METHOD_NAME) {\n    return fails$e(function() {\n        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME;\n    });\n};\nvar $$5 = _export;\nvar $trim = stringTrim.trim;\nvar forcedStringTrimMethod = stringTrimForced;\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$$5({\n    target: \"String\",\n    proto: true,\n    forced: forcedStringTrimMethod(\"trim\")\n}, {\n    trim: function trim() {\n        return $trim(this);\n    }\n});\nvar DESCRIPTORS$3 = descriptors;\nvar uncurryThis$9 = functionUncurryThis;\nvar call$7 = functionCall;\nvar fails$d = fails$s;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$4 = toObject$7;\nvar IndexedObject$2 = indexedObject;\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$2 = Object.defineProperty;\nvar concat = uncurryThis$9([].concat);\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$d(function() {\n    // should have correct order of operations (Edge bug)\n    if (DESCRIPTORS$3 && $assign({\n        b: 1\n    }, $assign(defineProperty$2({}, \"a\", {\n        enumerable: true,\n        get: function() {\n            defineProperty$2(this, \"b\", {\n                value: 3,\n                enumerable: false\n            });\n        }\n    }), {\n        b: 2\n    })).b !== 1) return true;\n    // should work with symbols and should have deterministic property order (V8 bug)\n    var A = {};\n    var B = {};\n    // eslint-disable-next-line es-x/no-symbol -- safe\n    var symbol = Symbol();\n    var alphabet = \"abcdefghijklmnopqrst\";\n    A[symbol] = 7;\n    alphabet.split(\"\").forEach(function(chr) {\n        B[chr] = chr;\n    });\n    return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\"\") != alphabet;\n}) ? function assign(target, source) {\n    var T = toObject$4(target);\n    var argumentsLength = arguments.length;\n    var index = 1;\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n    var propertyIsEnumerable = propertyIsEnumerableModule.f;\n    while(argumentsLength > index){\n        var S = IndexedObject$2(arguments[index++]);\n        var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n        var length = keys.length;\n        var j = 0;\n        var key;\n        while(length > j){\n            key = keys[j++];\n            if (!DESCRIPTORS$3 || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];\n        }\n    }\n    return T;\n} : $assign;\nvar $$4 = _export;\nvar assign = objectAssign;\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$4({\n    target: \"Object\",\n    stat: true,\n    arity: 2,\n    forced: Object.assign !== assign\n}, {\n    assign: assign\n});\nclass EventEmitter {\n    constructor(){\n        this.emitter = new events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();\n    }\n    on(eventName, callback) {\n        this.emitter.on(eventName, callback);\n        return {\n            remove: ()=>this.emitter.off(eventName, callback)\n        };\n    }\n    off(eventName, callback) {\n        this.emitter.off(eventName, callback);\n    }\n    emit(eventName, event) {\n        this.emitter.emit(eventName, event);\n    }\n}\nconst PACKAGE_NAME = \"near-wallet-selector\";\nconst RECENTLY_SIGNED_IN_WALLETS = \"recentlySignedInWallets\";\nconst CONTRACT = \"contract\";\nconst PENDING_CONTRACT = \"contract:pending\";\nconst SELECTED_WALLET_ID = `selectedWalletId`;\nconst PENDING_SELECTED_WALLET_ID = `selectedWalletId:pending`;\nclass WalletModules {\n    constructor({ factories, storage, options, store, emitter, provider }){\n        this.factories = factories;\n        this.storage = storage;\n        this.options = options;\n        this.store = store;\n        this.emitter = emitter;\n        this.provider = provider;\n        this.modules = [];\n        this.instances = {};\n    }\n    validateWallet(id) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let accounts = [];\n            const wallet = yield this.getWallet(id);\n            if (wallet) {\n                // Ensure our persistent state aligns with the selected wallet.\n                // For example a wallet is selected, but it returns no accounts (not signed in).\n                accounts = yield wallet.getAccounts().catch((err)=>{\n                    logger.log(`Failed to validate ${wallet.id} during setup`);\n                    logger.error(err);\n                    return [];\n                });\n            }\n            return accounts;\n        });\n    }\n    resolveStorageState() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n            const pendingSelectedWalletId = yield jsonStorage.getItem(PENDING_SELECTED_WALLET_ID);\n            const pendingContract = yield jsonStorage.getItem(PENDING_CONTRACT);\n            if (pendingSelectedWalletId && pendingContract) {\n                const _accounts = yield this.validateWallet(pendingSelectedWalletId);\n                yield jsonStorage.removeItem(PENDING_SELECTED_WALLET_ID);\n                yield jsonStorage.removeItem(PENDING_CONTRACT);\n                if (_accounts.length) {\n                    const { selectedWalletId: _selectedWalletId } = this.store.getState();\n                    const selectedWallet = yield this.getWallet(_selectedWalletId);\n                    if (selectedWallet && pendingSelectedWalletId !== _selectedWalletId) {\n                        yield selectedWallet.signOut().catch((err)=>{\n                            logger.log(\"Failed to sign out existing wallet\");\n                            logger.error(err);\n                        });\n                    }\n                    const recentlySignedInWalletsFromPending = yield this.setWalletAsRecentlySignedIn(pendingSelectedWalletId);\n                    return {\n                        accounts: _accounts,\n                        contract: pendingContract,\n                        selectedWalletId: pendingSelectedWalletId,\n                        recentlySignedInWallets: recentlySignedInWalletsFromPending\n                    };\n                }\n            }\n            const { contract, selectedWalletId } = this.store.getState();\n            const accounts = yield this.validateWallet(selectedWalletId);\n            const recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n            if (!accounts.length) {\n                return {\n                    accounts: [],\n                    contract: null,\n                    selectedWalletId: null,\n                    recentlySignedInWallets: recentlySignedInWallets || []\n                };\n            }\n            return {\n                accounts,\n                contract,\n                selectedWalletId,\n                recentlySignedInWallets: recentlySignedInWallets || []\n            };\n        });\n    }\n    setWalletAsRecentlySignedIn(walletId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n            let recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n            if (!recentlySignedInWallets) {\n                recentlySignedInWallets = [];\n            }\n            if (!recentlySignedInWallets.includes(walletId)) {\n                recentlySignedInWallets.unshift(walletId);\n                recentlySignedInWallets = recentlySignedInWallets.slice(0, 5);\n                yield jsonStorage.setItem(RECENTLY_SIGNED_IN_WALLETS, recentlySignedInWallets);\n            }\n            return recentlySignedInWallets;\n        });\n    }\n    signOutWallet(walletId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const wallet = yield this.getWallet(walletId);\n            yield wallet.signOut().catch((err)=>{\n                logger.log(`Failed to sign out ${wallet.id}`);\n                logger.error(err);\n                // At least clean up state on our side.\n                this.onWalletSignedOut(wallet.id);\n            });\n        });\n    }\n    onWalletSignedIn(walletId, { accounts, contractId, methodNames }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { selectedWalletId } = this.store.getState();\n            const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n            const contract = {\n                contractId,\n                methodNames\n            };\n            if (!accounts.length) {\n                const module = this.getModule(walletId);\n                // We can't guarantee the user will actually sign in with browser wallets.\n                // Best we can do is set in storage and validate on init.\n                if (module.type === \"browser\") {\n                    yield jsonStorage.setItem(PENDING_SELECTED_WALLET_ID, walletId);\n                    yield jsonStorage.setItem(PENDING_CONTRACT, contract);\n                }\n                return;\n            }\n            if (selectedWalletId && selectedWalletId !== walletId) {\n                yield this.signOutWallet(selectedWalletId);\n            }\n            const recentlySignedInWallets = yield this.setWalletAsRecentlySignedIn(walletId);\n            this.store.dispatch({\n                type: \"WALLET_CONNECTED\",\n                payload: {\n                    walletId,\n                    contract,\n                    accounts,\n                    recentlySignedInWallets\n                }\n            });\n            this.emitter.emit(\"signedIn\", {\n                walletId,\n                contractId,\n                methodNames,\n                accounts\n            });\n        });\n    }\n    onWalletSignedOut(walletId) {\n        this.store.dispatch({\n            type: \"WALLET_DISCONNECTED\",\n            payload: {\n                walletId\n            }\n        });\n        this.emitter.emit(\"signedOut\", {\n            walletId\n        });\n    }\n    setupWalletEmitter(module) {\n        const emitter = new EventEmitter();\n        emitter.on(\"signedOut\", ()=>{\n            this.onWalletSignedOut(module.id);\n        });\n        emitter.on(\"signedIn\", (event)=>{\n            this.onWalletSignedIn(module.id, event);\n        });\n        emitter.on(\"accountsChanged\", ({ accounts })=>__awaiter(this, void 0, void 0, function*() {\n                this.emitter.emit(\"accountsChanged\", {\n                    walletId: module.id,\n                    accounts\n                });\n                if (!accounts.length) {\n                    return this.signOutWallet(module.id);\n                }\n                this.store.dispatch({\n                    type: \"ACCOUNTS_CHANGED\",\n                    payload: {\n                        walletId: module.id,\n                        accounts\n                    }\n                });\n            }));\n        emitter.on(\"networkChanged\", ({ networkId })=>{\n            this.emitter.emit(\"networkChanged\", {\n                walletId: module.id,\n                networkId\n            });\n        });\n        emitter.on(\"uriChanged\", ({ uri })=>{\n            this.emitter.emit(\"uriChanged\", {\n                walletId: module.id,\n                uri\n            });\n        });\n        return emitter;\n    }\n    validateSignMessageParams({ message, nonce, recipient }) {\n        if (!message || message.trim() === \"\") {\n            throw new Error(\"Invalid message. It must be a non-empty string.\");\n        }\n        if (!Buffer.isBuffer(nonce) || nonce.length !== 32) {\n            throw new Error(\"Invalid nonce. It must be a Buffer with a length of 32 bytes.\");\n        }\n        if (!recipient || recipient.trim() === \"\") {\n            throw new Error(\"Invalid recipient. It must be a non-empty string.\");\n        }\n    }\n    decorateWallet(wallet) {\n        const _signIn = wallet.signIn;\n        const _signOut = wallet.signOut;\n        const _signMessage = wallet.signMessage;\n        wallet.signIn = (params)=>__awaiter(this, void 0, void 0, function*() {\n                const accounts = yield _signIn(params);\n                const { contractId, methodNames = [] } = params;\n                yield this.onWalletSignedIn(wallet.id, {\n                    accounts,\n                    contractId,\n                    methodNames\n                });\n                return accounts;\n            });\n        wallet.signOut = ()=>__awaiter(this, void 0, void 0, function*() {\n                yield _signOut();\n                this.onWalletSignedOut(wallet.id);\n            });\n        wallet.signMessage = (params)=>__awaiter(this, void 0, void 0, function*() {\n                if (_signMessage === undefined) {\n                    throw Error(`The signMessage method is not supported by ${wallet.metadata.name}`);\n                }\n                this.validateSignMessageParams(params);\n                return yield _signMessage(params);\n            });\n        return wallet;\n    }\n    setupInstance(module) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!module.metadata.available) {\n                const message = module.type === \"injected\" ? \"not installed\" : \"not available\";\n                throw Error(`${module.metadata.name} is ${message}`);\n            }\n            const wallet = Object.assign({\n                id: module.id,\n                type: module.type,\n                metadata: module.metadata\n            }, (yield module.init({\n                id: module.id,\n                type: module.type,\n                metadata: module.metadata,\n                options: this.options,\n                store: this.store.toReadOnly(),\n                provider: this.provider,\n                emitter: this.setupWalletEmitter(module),\n                logger: new Logger(module.id),\n                storage: new JsonStorage(this.storage, [\n                    PACKAGE_NAME,\n                    module.id\n                ])\n            })));\n            return this.decorateWallet(wallet);\n        });\n    }\n    getModule(id) {\n        return this.modules.find((x)=>x.id === id);\n    }\n    getWallet(id) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const module = this.getModule(id);\n            if (!module) {\n                return null;\n            }\n            const { selectedWalletId } = this.store.getState();\n            // If user uninstalled/removed a wallet which was previously signed in with\n            // best we can do is clean up state on our side.\n            if (!module.metadata.available && selectedWalletId) {\n                this.onWalletSignedOut(selectedWalletId);\n                return null;\n            }\n            return yield module.wallet();\n        });\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const modules = [];\n            for(let i = 0; i < this.factories.length; i += 1){\n                const module = yield this.factories[i]({\n                    options: this.options\n                }).catch((err)=>{\n                    logger.log(\"Failed to setup module\");\n                    logger.error(err);\n                    return null;\n                });\n                // Filter out wallets that aren't available.\n                if (!module) {\n                    continue;\n                }\n                // Skip duplicated module.\n                if (modules.some((x)=>x.id === module.id)) {\n                    continue;\n                }\n                modules.push({\n                    id: module.id,\n                    type: module.type,\n                    metadata: module.metadata,\n                    wallet: ()=>__awaiter(this, void 0, void 0, function*() {\n                            let instance = this.instances[module.id];\n                            if (instance) {\n                                return instance;\n                            }\n                            instance = yield this.setupInstance(module);\n                            this.instances[module.id] = instance;\n                            return instance;\n                        })\n                });\n            }\n            this.modules = modules;\n            const { accounts, contract, selectedWalletId, recentlySignedInWallets } = yield this.resolveStorageState();\n            this.store.dispatch({\n                type: \"SETUP_WALLET_MODULES\",\n                payload: {\n                    modules,\n                    accounts,\n                    contract,\n                    selectedWalletId,\n                    recentlySignedInWallets\n                }\n            });\n            for(let i = 0; i < this.modules.length; i++){\n                if (this.modules[i].type !== \"instant-link\") {\n                    continue;\n                }\n                const wallet = yield this.modules[i].wallet();\n                if (!wallet.metadata.runOnStartup) {\n                    continue;\n                }\n                try {\n                    yield wallet.signIn({\n                        contractId: wallet.getContractId()\n                    });\n                } catch (err) {\n                    logger.error(\"Failed to sign in to wallet. \" + err);\n                }\n            }\n        });\n    }\n}\nconst getNetworkPreset = (networkId)=>{\n    switch(networkId){\n        case \"mainnet\":\n            return {\n                networkId,\n                nodeUrl: \"https://rpc.mainnet.near.org\",\n                helperUrl: \"https://helper.mainnet.near.org\",\n                explorerUrl: \"https://nearblocks.io\",\n                indexerUrl: \"https://api.kitwallet.app\"\n            };\n        case \"testnet\":\n            return {\n                networkId,\n                nodeUrl: \"https://rpc.testnet.near.org\",\n                helperUrl: \"https://helper.testnet.near.org\",\n                explorerUrl: \"https://testnet.nearblocks.io\",\n                indexerUrl: \"https://testnet-api.kitwallet.app\"\n            };\n        default:\n            throw Error(`Failed to find config for: '${networkId}'`);\n    }\n};\nconst resolveNetwork = (network)=>{\n    return typeof network === \"string\" ? getNetworkPreset(network) : network;\n};\nconst resolveOptions = (params)=>{\n    const options = {\n        languageCode: params.languageCode || undefined,\n        network: resolveNetwork(params.network),\n        debug: params.debug || false,\n        optimizeWalletOrder: params.optimizeWalletOrder === false ? false : true,\n        randomizeWalletOrder: params.randomizeWalletOrder || false,\n        relayerUrl: params.relayerUrl || undefined\n    };\n    return {\n        options,\n        storage: params.storage || new WebStorageService()\n    };\n};\nconst reducer = (state, action)=>{\n    logger.log(\"Store Action\", action);\n    switch(action.type){\n        case \"SETUP_WALLET_MODULES\":\n            {\n                const { modules, accounts, contract, selectedWalletId, recentlySignedInWallets } = action.payload;\n                const accountStates = accounts.map((account, i)=>{\n                    return Object.assign(Object.assign({}, account), {\n                        active: i === 0\n                    });\n                });\n                return Object.assign(Object.assign({}, state), {\n                    modules,\n                    accounts: accountStates,\n                    contract,\n                    selectedWalletId,\n                    recentlySignedInWallets\n                });\n            }\n        case \"WALLET_CONNECTED\":\n            {\n                const { walletId, contract, accounts, recentlySignedInWallets } = action.payload;\n                if (!accounts.length) {\n                    return state;\n                }\n                const activeAccountIndex = state.accounts.findIndex((account)=>account.active);\n                const accountStates = accounts.map((account, i)=>{\n                    return Object.assign(Object.assign({}, account), {\n                        active: i === (activeAccountIndex > -1 ? activeAccountIndex : 0)\n                    });\n                });\n                return Object.assign(Object.assign({}, state), {\n                    contract,\n                    accounts: accountStates,\n                    selectedWalletId: walletId,\n                    recentlySignedInWallets\n                });\n            }\n        case \"WALLET_DISCONNECTED\":\n            {\n                const { walletId } = action.payload;\n                if (walletId !== state.selectedWalletId) {\n                    return state;\n                }\n                return Object.assign(Object.assign({}, state), {\n                    contract: null,\n                    accounts: [],\n                    selectedWalletId: null\n                });\n            }\n        case \"ACCOUNTS_CHANGED\":\n            {\n                const { walletId, accounts } = action.payload;\n                if (walletId !== state.selectedWalletId) {\n                    return state;\n                }\n                const activeAccount = state.accounts.find((account)=>account.active);\n                const isActiveAccountRemoved = !accounts.some((account)=>account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId));\n                const accountStates = accounts.map((account, i)=>{\n                    return Object.assign(Object.assign({}, account), {\n                        active: isActiveAccountRemoved ? i === 0 : account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId)\n                    });\n                });\n                return Object.assign(Object.assign({}, state), {\n                    accounts: accountStates\n                });\n            }\n        case \"SET_ACTIVE_ACCOUNT\":\n            {\n                const { accountId } = action.payload;\n                const accountStates = state.accounts.map((account)=>{\n                    return Object.assign(Object.assign({}, account), {\n                        active: account.accountId === accountId\n                    });\n                });\n                return Object.assign(Object.assign({}, state), {\n                    accounts: accountStates\n                });\n            }\n        default:\n            return state;\n    }\n};\nconst createStore = (storage)=>__awaiter(void 0, void 0, void 0, function*() {\n        const jsonStorage = new JsonStorage(storage, PACKAGE_NAME);\n        const initialState = {\n            modules: [],\n            accounts: [],\n            contract: yield jsonStorage.getItem(CONTRACT),\n            selectedWalletId: yield jsonStorage.getItem(SELECTED_WALLET_ID),\n            recentlySignedInWallets: (yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS)) || []\n        };\n        const state$ = new _barrel_optimize_names_BehaviorSubject_Subject_scan_rxjs__WEBPACK_IMPORTED_MODULE_4__.BehaviorSubject(initialState);\n        const actions$ = new _barrel_optimize_names_BehaviorSubject_Subject_scan_rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();\n        actions$.pipe((0,_barrel_optimize_names_BehaviorSubject_Subject_scan_rxjs__WEBPACK_IMPORTED_MODULE_6__.scan)(reducer, initialState)).subscribe(state$);\n        const syncStorage = (prevState, state, storageKey, property)=>__awaiter(void 0, void 0, void 0, function*() {\n                if (state[property] === prevState[property]) {\n                    return;\n                }\n                if (state[property]) {\n                    yield jsonStorage.setItem(storageKey, state[property]);\n                    return;\n                }\n                yield jsonStorage.removeItem(storageKey);\n            });\n        let prevState = state$.getValue();\n        state$.subscribe((state)=>{\n            syncStorage(prevState, state, SELECTED_WALLET_ID, \"selectedWalletId\");\n            syncStorage(prevState, state, CONTRACT, \"contract\");\n            syncStorage(prevState, state, RECENTLY_SIGNED_IN_WALLETS, \"recentlySignedInWallets\");\n            prevState = state;\n        });\n        return {\n            observable: state$,\n            getState: ()=>state$.getValue(),\n            dispatch: (action)=>actions$.next(action),\n            toReadOnly: ()=>({\n                    getState: ()=>state$.getValue(),\n                    observable: state$.asObservable()\n                })\n        };\n    });\nlet walletSelectorInstance = null;\nconst createSelector = (options, store, walletModules, emitter)=>{\n    return {\n        options,\n        store: store.toReadOnly(),\n        wallet: (id)=>__awaiter(void 0, void 0, void 0, function*() {\n                const { selectedWalletId } = store.getState();\n                const wallet = yield walletModules.getWallet(id || selectedWalletId);\n                if (!wallet) {\n                    if (id) {\n                        throw new Error(\"Invalid wallet id\");\n                    }\n                    throw new Error(\"No wallet selected\");\n                }\n                return wallet;\n            }),\n        setActiveAccount: (accountId)=>{\n            const { accounts } = store.getState();\n            if (!accounts.some((account)=>account.accountId === accountId)) {\n                throw new Error(\"Invalid account id\");\n            }\n            store.dispatch({\n                type: \"SET_ACTIVE_ACCOUNT\",\n                payload: {\n                    accountId\n                }\n            });\n        },\n        isSignedIn () {\n            const { accounts } = store.getState();\n            return Boolean(accounts.length);\n        },\n        on: (eventName, callback)=>{\n            return emitter.on(eventName, callback);\n        },\n        off: (eventName, callback)=>{\n            emitter.off(eventName, callback);\n        }\n    };\n};\n/**\r\n * Initiates a wallet selector instance\r\n * @param {WalletSelectorParams} params Selector parameters (network, modules...)\r\n * @returns {Promise<WalletSelector>} Returns a WalletSelector object\r\n */ const setupWalletSelector = (params)=>__awaiter(void 0, void 0, void 0, function*() {\n        const { options, storage } = resolveOptions(params);\n        Logger.debug = options.debug;\n        const emitter = new EventEmitter();\n        const store = yield createStore(storage);\n        const walletModules = new WalletModules({\n            factories: params.modules,\n            storage,\n            options,\n            store,\n            emitter,\n            provider: new Provider(options.network.nodeUrl)\n        });\n        yield walletModules.setup();\n        if (params.allowMultipleSelectors) {\n            return createSelector(options, store, walletModules, emitter);\n        }\n        if (!walletSelectorInstance) {\n            walletSelectorInstance = createSelector(options, store, walletModules, emitter);\n        }\n        return walletSelectorInstance;\n    });\nconst wait = (ms)=>{\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n};\nconst poll = (cb, interval, remaining)=>__awaiter(void 0, void 0, void 0, function*() {\n        const result = cb();\n        if (result) {\n            return result;\n        }\n        if (!remaining) {\n            throw new Error(\"Exceeded timeout\");\n        }\n        return wait(interval).then(()=>poll(cb, interval, remaining - 1));\n    });\nconst waitFor = (cb, opts = {})=>__awaiter(void 0, void 0, void 0, function*() {\n        const { timeout = 100, interval = 50 } = opts;\n        return Promise.race([\n            wait(timeout).then(()=>{\n                throw new Error(\"Exceeded timeout\");\n            }),\n            poll(cb, interval, Math.floor(timeout / interval))\n        ]);\n    });\nconst getActiveAccount = (state)=>{\n    return state.accounts.find((account)=>account.active) || null;\n};\nvar aCallable$1 = aCallable$9;\nvar toObject$3 = toObject$7;\nvar IndexedObject$1 = indexedObject;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$8;\nvar $TypeError$2 = TypeError;\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod$2 = function(IS_RIGHT) {\n    return function(that, callbackfn, argumentsLength, memo) {\n        aCallable$1(callbackfn);\n        var O = toObject$3(that);\n        var self1 = IndexedObject$1(O);\n        var length = lengthOfArrayLike$5(O);\n        var index = IS_RIGHT ? length - 1 : 0;\n        var i = IS_RIGHT ? -1 : 1;\n        if (argumentsLength < 2) while(true){\n            if (index in self1) {\n                memo = self1[index];\n                index += i;\n                break;\n            }\n            index += i;\n            if (IS_RIGHT ? index < 0 : length <= index) {\n                throw $TypeError$2(\"Reduce of empty array with no initial value\");\n            }\n        }\n        for(; IS_RIGHT ? index >= 0 : length > index; index += i)if (index in self1) {\n            memo = callbackfn(memo, self1[index], index, O);\n        }\n        return memo;\n    };\n};\nvar arrayReduce = {\n    // `Array.prototype.reduce` method\n    // https://tc39.es/ecma262/#sec-array.prototype.reduce\n    left: createMethod$2(false),\n    // `Array.prototype.reduceRight` method\n    // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n    right: createMethod$2(true)\n};\nvar fails$c = fails$s;\nvar arrayMethodIsStrict$1 = function(METHOD_NAME, argument) {\n    var method = [][METHOD_NAME];\n    return !!method && fails$c(function() {\n        // eslint-disable-next-line no-useless-call -- required for testing\n        method.call(null, argument || function() {\n            return 1;\n        }, 1);\n    });\n};\nvar $$3 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$1;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\nvar STRICT_METHOD = arrayMethodIsStrict(\"reduce\");\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$3({\n    target: \"Array\",\n    proto: true,\n    forced: !STRICT_METHOD || CHROME_BUG\n}, {\n    reduce: function reduce(callbackfn /* , initialValue */ ) {\n        var length = arguments.length;\n        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n    }\n});\nvar anObject$3 = anObject$e;\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function() {\n    var that = anObject$3(this);\n    var result = \"\";\n    if (that.hasIndices) result += \"d\";\n    if (that.global) result += \"g\";\n    if (that.ignoreCase) result += \"i\";\n    if (that.multiline) result += \"m\";\n    if (that.dotAll) result += \"s\";\n    if (that.unicode) result += \"u\";\n    if (that.unicodeSets) result += \"v\";\n    if (that.sticky) result += \"y\";\n    return result;\n};\nvar fails$b = fails$s;\nvar global$a = global$t;\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$a.RegExp;\nvar UNSUPPORTED_Y$2 = fails$b(function() {\n    var re = $RegExp$2(\"a\", \"y\");\n    re.lastIndex = 2;\n    return re.exec(\"abcd\") != null;\n});\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$2 || fails$b(function() {\n    return !$RegExp$2(\"a\", \"y\").sticky;\n});\nvar BROKEN_CARET = UNSUPPORTED_Y$2 || fails$b(function() {\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n    var re = $RegExp$2(\"^r\", \"gy\");\n    re.lastIndex = 2;\n    return re.exec(\"str\") != null;\n});\nvar regexpStickyHelpers = {\n    BROKEN_CARET: BROKEN_CARET,\n    MISSED_STICKY: MISSED_STICKY,\n    UNSUPPORTED_Y: UNSUPPORTED_Y$2\n};\nvar fails$a = fails$s;\nvar global$9 = global$t;\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$9.RegExp;\nvar regexpUnsupportedDotAll = fails$a(function() {\n    var re = $RegExp$1(\".\", \"s\");\n    return !(re.dotAll && re.exec(\"\\n\") && re.flags === \"s\");\n});\nvar fails$9 = fails$s;\nvar global$8 = global$t;\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$8.RegExp;\nvar regexpUnsupportedNcg = fails$9(function() {\n    var re = $RegExp(\"(?<a>b)\", \"g\");\n    return re.exec(\"b\").groups.a !== \"b\" || \"b\".replace(re, \"$<a>c\") !== \"bc\";\n});\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */ /* eslint-disable regexp/no-useless-quantifier -- testing */ var call$6 = functionCall;\nvar uncurryThis$8 = functionUncurryThis;\nvar toString$2 = toString$5;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers$1 = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create$1 = objectCreate;\nvar getInternalState$3 = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\nvar nativeReplace = shared(\"native-string-replace\", String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$8(\"\".charAt);\nvar indexOf = uncurryThis$8(\"\".indexOf);\nvar replace = uncurryThis$8(\"\".replace);\nvar stringSlice$2 = uncurryThis$8(\"\".slice);\nvar UPDATES_LAST_INDEX_WRONG = function() {\n    var re1 = /a/;\n    var re2 = /b*/g;\n    call$6(nativeExec, re1, \"a\");\n    call$6(nativeExec, re2, \"a\");\n    return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n}();\nvar UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec(\"\")[1] !== undefined;\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\nif (PATCH) {\n    patchedExec = function exec(string) {\n        var re = this;\n        var state = getInternalState$3(re);\n        var str = toString$2(string);\n        var raw = state.raw;\n        var result, reCopy, lastIndex, match, i, object, group;\n        if (raw) {\n            raw.lastIndex = re.lastIndex;\n            result = call$6(patchedExec, raw, str);\n            re.lastIndex = raw.lastIndex;\n            return result;\n        }\n        var groups = state.groups;\n        var sticky = UNSUPPORTED_Y$1 && re.sticky;\n        var flags = call$6(regexpFlags, re);\n        var source = re.source;\n        var charsAdded = 0;\n        var strCopy = str;\n        if (sticky) {\n            flags = replace(flags, \"y\", \"\");\n            if (indexOf(flags, \"g\") === -1) {\n                flags += \"g\";\n            }\n            strCopy = stringSlice$2(str, re.lastIndex);\n            // Support anchored sticky behavior.\n            if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== \"\\n\")) {\n                source = \"(?: \" + source + \")\";\n                strCopy = \" \" + strCopy;\n                charsAdded++;\n            }\n            // ^(? + rx + ) is needed, in combination with some str slicing, to\n            // simulate the 'y' flag.\n            reCopy = new RegExp(\"^(?:\" + source + \")\", flags);\n        }\n        if (NPCG_INCLUDED) {\n            reCopy = new RegExp(\"^\" + source + \"$(?!\\\\s)\", flags);\n        }\n        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n        match = call$6(nativeExec, sticky ? reCopy : re, strCopy);\n        if (sticky) {\n            if (match) {\n                match.input = stringSlice$2(match.input, charsAdded);\n                match[0] = stringSlice$2(match[0], charsAdded);\n                match.index = re.lastIndex;\n                re.lastIndex += match[0].length;\n            } else re.lastIndex = 0;\n        } else if (UPDATES_LAST_INDEX_WRONG && match) {\n            re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n        }\n        if (NPCG_INCLUDED && match && match.length > 1) {\n            // Fix browsers whose `exec` methods don't consistently return `undefined`\n            // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n            call$6(nativeReplace, match[0], reCopy, function() {\n                for(i = 1; i < arguments.length - 2; i++){\n                    if (arguments[i] === undefined) match[i] = undefined;\n                }\n            });\n        }\n        if (match && groups) {\n            match.groups = object = create$1(null);\n            for(i = 0; i < groups.length; i++){\n                group = groups[i];\n                object[group[0]] = match[group[1]];\n            }\n        }\n        return match;\n    };\n}\nvar regexpExec$3 = patchedExec;\nvar $$2 = _export;\nvar exec$1 = regexpExec$3;\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$$2({\n    target: \"RegExp\",\n    proto: true,\n    forced: /./.exec !== exec$1\n}, {\n    exec: exec$1\n});\n/* eslint-disable no-useless-escape */ // https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\nconst SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nconst userAgentRules = [\n    [\n        \"aol\",\n        /AOLShield\\/([0-9\\._]+)/\n    ],\n    [\n        \"edge\",\n        /Edge\\/([0-9\\._]+)/\n    ],\n    [\n        \"edge-ios\",\n        /EdgiOS\\/([0-9\\._]+)/\n    ],\n    [\n        \"yandexbrowser\",\n        /YaBrowser\\/([0-9\\._]+)/\n    ],\n    [\n        \"kakaotalk\",\n        /KAKAOTALK\\s([0-9\\.]+)/\n    ],\n    [\n        \"samsung\",\n        /SamsungBrowser\\/([0-9\\.]+)/\n    ],\n    [\n        \"silk\",\n        /\\bSilk\\/([0-9._-]+)\\b/\n    ],\n    [\n        \"miui\",\n        /MiuiBrowser\\/([0-9\\.]+)$/\n    ],\n    [\n        \"beaker\",\n        /BeakerBrowser\\/([0-9\\.]+)/\n    ],\n    [\n        \"edge-chromium\",\n        /EdgA?\\/([0-9\\.]+)/\n    ],\n    [\n        \"chromium-webview\",\n        /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/\n    ],\n    [\n        \"chrome\",\n        /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/\n    ],\n    [\n        \"phantomjs\",\n        /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/\n    ],\n    [\n        \"crios\",\n        /CriOS\\/([0-9\\.]+)(:?\\s|$)/\n    ],\n    [\n        \"firefox\",\n        /Firefox\\/([0-9\\.]+)(?:\\s|$)/\n    ],\n    [\n        \"fxios\",\n        /FxiOS\\/([0-9\\.]+)/\n    ],\n    [\n        \"opera-mini\",\n        /Opera Mini.*Version\\/([0-9\\.]+)/\n    ],\n    [\n        \"opera\",\n        /Opera\\/([0-9\\.]+)(?:\\s|$)/\n    ],\n    [\n        \"opera\",\n        /OPR\\/([0-9\\.]+)(:?\\s|$)/\n    ],\n    [\n        \"pie\",\n        /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/\n    ],\n    [\n        \"pie\",\n        /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/\n    ],\n    [\n        \"netfront\",\n        /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/\n    ],\n    [\n        \"ie\",\n        /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/\n    ],\n    [\n        \"ie\",\n        /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/\n    ],\n    [\n        \"ie\",\n        /MSIE\\s(7\\.0)/\n    ],\n    [\n        \"bb10\",\n        /BB10;\\sTouch.*Version\\/([0-9\\.]+)/\n    ],\n    [\n        \"android\",\n        /Android\\s([0-9\\.]+)/\n    ],\n    [\n        \"ios\",\n        /Version\\/([0-9\\._]+).*Mobile.*Safari.*/\n    ],\n    [\n        \"safari\",\n        /Version\\/([0-9\\._]+).*Safari/\n    ],\n    [\n        \"facebook\",\n        /FB[AS]V\\/([0-9\\.]+)/\n    ],\n    [\n        \"instagram\",\n        /Instagram\\s([0-9\\.]+)/\n    ],\n    [\n        \"ios-webview\",\n        /AppleWebKit\\/([0-9\\.]+).*Mobile/\n    ],\n    [\n        \"ios-webview\",\n        /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/\n    ],\n    [\n        \"curl\",\n        /^curl\\/([0-9\\.]+)$/\n    ],\n    [\n        \"searchbot\",\n        SEARCHBOX_UA_REGEX\n    ]\n];\nconst matchUserAgent = (ua)=>{\n    return ua !== \"\" && userAgentRules.reduce((matched, [browser, regex])=>{\n        if (matched) {\n            return matched;\n        }\n        const uaMatch = regex.exec(ua);\n        return !!uaMatch && [\n            browser,\n            uaMatch\n        ];\n    }, false);\n};\nconst isCurrentBrowserSupported = (supportedBrowser)=>{\n    if (typeof navigator === \"undefined\") {\n        return false;\n    }\n    const matchedRule = matchUserAgent(navigator.userAgent);\n    if (!matchedRule) {\n        return false;\n    }\n    const [name] = matchedRule;\n    if (name === \"searchbot\") {\n        return false;\n    }\n    return !!supportedBrowser.find((item)=>item === name);\n};\n// eslint-disable-next-line es-x/no-typed-arrays -- safe\nvar arrayBufferNative = typeof ArrayBuffer != \"undefined\" && typeof DataView != \"undefined\";\nvar NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;\nvar DESCRIPTORS$2 = descriptors;\nvar global$7 = global$t;\nvar isCallable$2 = isCallable$n;\nvar isObject$4 = isObject$d;\nvar hasOwn$1 = hasOwnProperty_1;\nvar classof$4 = classof$9;\nvar tryToString = tryToString$5;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$8;\nvar defineBuiltIn$2 = defineBuiltIn$8;\nvar defineProperty$1 = objectDefineProperty.f;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar setPrototypeOf$3 = objectSetPrototypeOf;\nvar wellKnownSymbol$2 = wellKnownSymbol$j;\nvar uid = uid$3;\nvar InternalStateModule$2 = internalState;\nvar enforceInternalState$1 = InternalStateModule$2.enforce;\nvar getInternalState$2 = InternalStateModule$2.get;\nvar Int8Array$4 = global$7.Int8Array;\nvar Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;\nvar Uint8ClampedArray$1 = global$7.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;\nvar TypedArray$1 = Int8Array$4 && getPrototypeOf$1(Int8Array$4);\nvar TypedArrayPrototype$1 = Int8ArrayPrototype$1 && getPrototypeOf$1(Int8ArrayPrototype$1);\nvar ObjectPrototype$1 = Object.prototype;\nvar TypeError$1 = global$7.TypeError;\nvar TO_STRING_TAG = wellKnownSymbol$2(\"toStringTag\");\nvar TYPED_ARRAY_TAG$1 = uid(\"TYPED_ARRAY_TAG\");\nvar TYPED_ARRAY_CONSTRUCTOR = \"TypedArrayConstructor\";\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$3 && classof$4(global$7.opera) !== \"Opera\";\nvar TYPED_ARRAY_TAG_REQUIRED = false;\nvar NAME, Constructor, Prototype;\nvar TypedArrayConstructorsList = {\n    Int8Array: 1,\n    Uint8Array: 1,\n    Uint8ClampedArray: 1,\n    Int16Array: 2,\n    Uint16Array: 2,\n    Int32Array: 4,\n    Uint32Array: 4,\n    Float32Array: 4,\n    Float64Array: 8\n};\nvar BigIntArrayConstructorsList = {\n    BigInt64Array: 8,\n    BigUint64Array: 8\n};\nvar isView = function isView(it) {\n    if (!isObject$4(it)) return false;\n    var klass = classof$4(it);\n    return klass === \"DataView\" || hasOwn$1(TypedArrayConstructorsList, klass) || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\nvar getTypedArrayConstructor = function(it) {\n    var proto = getPrototypeOf$1(it);\n    if (!isObject$4(proto)) return;\n    var state = getInternalState$2(proto);\n    return state && hasOwn$1(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n};\nvar isTypedArray$1 = function(it) {\n    if (!isObject$4(it)) return false;\n    var klass = classof$4(it);\n    return hasOwn$1(TypedArrayConstructorsList, klass) || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\nvar aTypedArray$4 = function(it) {\n    if (isTypedArray$1(it)) return it;\n    throw TypeError$1(\"Target is not a typed array\");\n};\nvar aTypedArrayConstructor$2 = function(C) {\n    if (isCallable$2(C) && (!setPrototypeOf$3 || isPrototypeOf$1(TypedArray$1, C))) return C;\n    throw TypeError$1(tryToString(C) + \" is not a typed array constructor\");\n};\nvar exportTypedArrayMethod$4 = function(KEY, property, forced, options) {\n    if (!DESCRIPTORS$2) return;\n    if (forced) for(var ARRAY in TypedArrayConstructorsList){\n        var TypedArrayConstructor = global$7[ARRAY];\n        if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor.prototype, KEY)) try {\n            delete TypedArrayConstructor.prototype[KEY];\n        } catch (error) {\n            // old WebKit bug - some methods are non-configurable\n            try {\n                TypedArrayConstructor.prototype[KEY] = property;\n            } catch (error2) {}\n        }\n    }\n    if (!TypedArrayPrototype$1[KEY] || forced) {\n        defineBuiltIn$2(TypedArrayPrototype$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);\n    }\n};\nvar exportTypedArrayStaticMethod$1 = function(KEY, property, forced) {\n    var ARRAY, TypedArrayConstructor;\n    if (!DESCRIPTORS$2) return;\n    if (setPrototypeOf$3) {\n        if (forced) for(ARRAY in TypedArrayConstructorsList){\n            TypedArrayConstructor = global$7[ARRAY];\n            if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor, KEY)) try {\n                delete TypedArrayConstructor[KEY];\n            } catch (error) {}\n        }\n        if (!TypedArray$1[KEY] || forced) {\n            // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n            try {\n                return defineBuiltIn$2(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);\n            } catch (error) {}\n        } else return;\n    }\n    for(ARRAY in TypedArrayConstructorsList){\n        TypedArrayConstructor = global$7[ARRAY];\n        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n            defineBuiltIn$2(TypedArrayConstructor, KEY, property);\n        }\n    }\n};\nfor(NAME in TypedArrayConstructorsList){\n    Constructor = global$7[NAME];\n    Prototype = Constructor && Constructor.prototype;\n    if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n    else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;\n}\nfor(NAME in BigIntArrayConstructorsList){\n    Constructor = global$7[NAME];\n    Prototype = Constructor && Constructor.prototype;\n    if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n}\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$2(TypedArray$1) || TypedArray$1 === Function.prototype) {\n    // eslint-disable-next-line no-shadow -- safe\n    TypedArray$1 = function TypedArray() {\n        throw TypeError$1(\"Incorrect invocation\");\n    };\n    if (NATIVE_ARRAY_BUFFER_VIEWS$2) for(NAME in TypedArrayConstructorsList){\n        if (global$7[NAME]) setPrototypeOf$3(global$7[NAME], TypedArray$1);\n    }\n}\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {\n    TypedArrayPrototype$1 = TypedArray$1.prototype;\n    if (NATIVE_ARRAY_BUFFER_VIEWS$2) for(NAME in TypedArrayConstructorsList){\n        if (global$7[NAME]) setPrototypeOf$3(global$7[NAME].prototype, TypedArrayPrototype$1);\n    }\n}\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$1(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {\n    setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);\n}\nif (DESCRIPTORS$2 && !hasOwn$1(TypedArrayPrototype$1, TO_STRING_TAG)) {\n    TYPED_ARRAY_TAG_REQUIRED = true;\n    defineProperty$1(TypedArrayPrototype$1, TO_STRING_TAG, {\n        get: function() {\n            return isObject$4(this) ? this[TYPED_ARRAY_TAG$1] : undefined;\n        }\n    });\n    for(NAME in TypedArrayConstructorsList)if (global$7[NAME]) {\n        createNonEnumerableProperty$3(global$7[NAME], TYPED_ARRAY_TAG$1, NAME);\n    }\n}\nvar arrayBufferViewCore = {\n    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,\n    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,\n    aTypedArray: aTypedArray$4,\n    aTypedArrayConstructor: aTypedArrayConstructor$2,\n    exportTypedArrayMethod: exportTypedArrayMethod$4,\n    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$1,\n    getTypedArrayConstructor: getTypedArrayConstructor,\n    isView: isView,\n    isTypedArray: isTypedArray$1,\n    TypedArray: TypedArray$1,\n    TypedArrayPrototype: TypedArrayPrototype$1\n};\n/* eslint-disable no-new -- required for testing */ var global$6 = global$t;\nvar fails$8 = fails$s;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;\nvar NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\nvar ArrayBuffer$3 = global$6.ArrayBuffer;\nvar Int8Array$3 = global$6.Int8Array;\nvar typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$8(function() {\n    Int8Array$3(1);\n}) || !fails$8(function() {\n    new Int8Array$3(-1);\n}) || !checkCorrectnessOfIteration(function(iterable) {\n    new Int8Array$3();\n    new Int8Array$3(null);\n    new Int8Array$3(1.5);\n    new Int8Array$3(iterable);\n}, true) || fails$8(function() {\n    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill\n    return new Int8Array$3(new ArrayBuffer$3(2), 1, undefined).length !== 1;\n});\nvar bind$1 = functionBindContext;\nvar call$5 = functionCall;\nvar aConstructor = aConstructor$2;\nvar toObject$2 = toObject$7;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$8;\nvar getIterator = getIterator$2;\nvar getIteratorMethod = getIteratorMethod$3;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;\nvar typedArrayFrom$2 = function from(source /* , mapfn, thisArg */ ) {\n    var C = aConstructor(this);\n    var O = toObject$2(source);\n    var argumentsLength = arguments.length;\n    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iteratorMethod = getIteratorMethod(O);\n    var i, length, result, step, iterator, next;\n    if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {\n        iterator = getIterator(O, iteratorMethod);\n        next = iterator.next;\n        O = [];\n        while(!(step = call$5(next, iterator)).done){\n            O.push(step.value);\n        }\n    }\n    if (mapping && argumentsLength > 2) {\n        mapfn = bind$1(mapfn, arguments[2]);\n    }\n    length = lengthOfArrayLike$4(O);\n    result = new (aTypedArrayConstructor$1(C))(length);\n    for(i = 0; length > i; i++){\n        result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n};\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;\nvar exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod;\nvar typedArrayFrom$1 = typedArrayFrom$2;\n// `%TypedArray%.from` method\n// https://tc39.es/ecma262/#sec-%typedarray%.from\nexportTypedArrayStaticMethod(\"from\", typedArrayFrom$1, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);\nvar defineBuiltIn$1 = defineBuiltIn$8;\nvar defineBuiltIns$1 = function(target, src, options) {\n    for(var key in src)defineBuiltIn$1(target, key, src[key], options);\n    return target;\n};\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$6;\nvar toLength$4 = toLength$6;\nvar $RangeError$2 = RangeError;\n// `ToIndex` abstract operation\n// https://tc39.es/ecma262/#sec-toindex\nvar toIndex$2 = function(it) {\n    if (it === undefined) return 0;\n    var number = toIntegerOrInfinity$3(it);\n    var length = toLength$4(number);\n    if (number !== length) throw $RangeError$2(\"Wrong length or index\");\n    return length;\n};\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar $Array$2 = Array;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor$2 = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\nvar pack = function(number, mantissaLength, bytes) {\n    var buffer = $Array$2(bytes);\n    var exponentLength = bytes * 8 - mantissaLength - 1;\n    var eMax = (1 << exponentLength) - 1;\n    var eBias = eMax >> 1;\n    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\n    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\n    var index = 0;\n    var exponent, mantissa, c;\n    number = abs(number);\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (number != number || number === Infinity) {\n        // eslint-disable-next-line no-self-compare -- NaN check\n        mantissa = number != number ? 1 : 0;\n        exponent = eMax;\n    } else {\n        exponent = floor$2(log(number) / LN2);\n        c = pow(2, -exponent);\n        if (number * c < 1) {\n            exponent--;\n            c *= 2;\n        }\n        if (exponent + eBias >= 1) {\n            number += rt / c;\n        } else {\n            number += rt * pow(2, 1 - eBias);\n        }\n        if (number * c >= 2) {\n            exponent++;\n            c /= 2;\n        }\n        if (exponent + eBias >= eMax) {\n            mantissa = 0;\n            exponent = eMax;\n        } else if (exponent + eBias >= 1) {\n            mantissa = (number * c - 1) * pow(2, mantissaLength);\n            exponent = exponent + eBias;\n        } else {\n            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\n            exponent = 0;\n        }\n    }\n    while(mantissaLength >= 8){\n        buffer[index++] = mantissa & 255;\n        mantissa /= 256;\n        mantissaLength -= 8;\n    }\n    exponent = exponent << mantissaLength | mantissa;\n    exponentLength += mantissaLength;\n    while(exponentLength > 0){\n        buffer[index++] = exponent & 255;\n        exponent /= 256;\n        exponentLength -= 8;\n    }\n    buffer[--index] |= sign * 128;\n    return buffer;\n};\nvar unpack = function(buffer, mantissaLength) {\n    var bytes = buffer.length;\n    var exponentLength = bytes * 8 - mantissaLength - 1;\n    var eMax = (1 << exponentLength) - 1;\n    var eBias = eMax >> 1;\n    var nBits = exponentLength - 7;\n    var index = bytes - 1;\n    var sign = buffer[index--];\n    var exponent = sign & 127;\n    var mantissa;\n    sign >>= 7;\n    while(nBits > 0){\n        exponent = exponent * 256 + buffer[index--];\n        nBits -= 8;\n    }\n    mantissa = exponent & (1 << -nBits) - 1;\n    exponent >>= -nBits;\n    nBits += mantissaLength;\n    while(nBits > 0){\n        mantissa = mantissa * 256 + buffer[index--];\n        nBits -= 8;\n    }\n    if (exponent === 0) {\n        exponent = 1 - eBias;\n    } else if (exponent === eMax) {\n        return mantissa ? NaN : sign ? -Infinity : Infinity;\n    } else {\n        mantissa = mantissa + pow(2, mantissaLength);\n        exponent = exponent - eBias;\n    }\n    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\n};\nvar ieee754 = {\n    pack: pack,\n    unpack: unpack\n};\nvar toObject$1 = toObject$7;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$8;\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nvar arrayFill$1 = function fill(value /* , start = 0, end = @length */ ) {\n    var O = toObject$1(this);\n    var length = lengthOfArrayLike$3(O);\n    var argumentsLength = arguments.length;\n    var index = toAbsoluteIndex$2(argumentsLength > 1 ? arguments[1] : undefined, length);\n    var end = argumentsLength > 2 ? arguments[2] : undefined;\n    var endPos = end === undefined ? length : toAbsoluteIndex$2(end, length);\n    while(endPos > index)O[index++] = value;\n    return O;\n};\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\nvar createProperty$1 = function(object, key, value) {\n    var propertyKey = toPropertyKey$1(key);\n    if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n    else object[propertyKey] = value;\n};\nvar toAbsoluteIndex$1 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$8;\nvar createProperty = createProperty$1;\nvar $Array$1 = Array;\nvar max = Math.max;\nvar arraySliceSimple = function(O, start, end) {\n    var length = lengthOfArrayLike$2(O);\n    var k = toAbsoluteIndex$1(start, length);\n    var fin = toAbsoluteIndex$1(end === undefined ? length : end, length);\n    var result = $Array$1(max(fin - k, 0));\n    for(var n = 0; k < fin; k++, n++)createProperty(result, n, O[k]);\n    result.length = n;\n    return result;\n};\nvar global$5 = global$t;\nvar uncurryThis$7 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar NATIVE_ARRAY_BUFFER = arrayBufferNative;\nvar FunctionName = functionName;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$8;\nvar defineBuiltIns = defineBuiltIns$1;\nvar fails$7 = fails$s;\nvar anInstance$1 = anInstance$3;\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$6;\nvar toLength$3 = toLength$6;\nvar toIndex$1 = toIndex$2;\nvar IEEE754 = ieee754;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$2 = objectSetPrototypeOf;\nvar getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar defineProperty = objectDefineProperty.f;\nvar arrayFill = arrayFill$1;\nvar arraySlice$3 = arraySliceSimple;\nvar setToStringTag = setToStringTag$4;\nvar InternalStateModule$1 = internalState;\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar getInternalState$1 = InternalStateModule$1.get;\nvar setInternalState$1 = InternalStateModule$1.set;\nvar ARRAY_BUFFER = \"ArrayBuffer\";\nvar DATA_VIEW = \"DataView\";\nvar PROTOTYPE = \"prototype\";\nvar WRONG_LENGTH$1 = \"Wrong length\";\nvar WRONG_INDEX = \"Wrong index\";\nvar NativeArrayBuffer = global$5[ARRAY_BUFFER];\nvar $ArrayBuffer = NativeArrayBuffer;\nvar ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];\nvar $DataView = global$5[DATA_VIEW];\nvar DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE];\nvar ObjectPrototype = Object.prototype;\nvar Array$1 = global$5.Array;\nvar RangeError$3 = global$5.RangeError;\nvar fill = uncurryThis$7(arrayFill);\nvar reverse = uncurryThis$7([].reverse);\nvar packIEEE754 = IEEE754.pack;\nvar unpackIEEE754 = IEEE754.unpack;\nvar packInt8 = function(number) {\n    return [\n        number & 0xFF\n    ];\n};\nvar packInt16 = function(number) {\n    return [\n        number & 0xFF,\n        number >> 8 & 0xFF\n    ];\n};\nvar packInt32 = function(number) {\n    return [\n        number & 0xFF,\n        number >> 8 & 0xFF,\n        number >> 16 & 0xFF,\n        number >> 24 & 0xFF\n    ];\n};\nvar unpackInt32 = function(buffer) {\n    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n};\nvar packFloat32 = function(number) {\n    return packIEEE754(number, 23, 4);\n};\nvar packFloat64 = function(number) {\n    return packIEEE754(number, 52, 8);\n};\nvar addGetter$1 = function(Constructor, key) {\n    defineProperty(Constructor[PROTOTYPE], key, {\n        get: function() {\n            return getInternalState$1(this)[key];\n        }\n    });\n};\nvar get = function(view, count, index, isLittleEndian) {\n    var intIndex = toIndex$1(index);\n    var store = getInternalState$1(view);\n    if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n    var bytes = getInternalState$1(store.buffer).bytes;\n    var start = intIndex + store.byteOffset;\n    var pack = arraySlice$3(bytes, start, start + count);\n    return isLittleEndian ? pack : reverse(pack);\n};\nvar set = function(view, count, index, conversion, value, isLittleEndian) {\n    var intIndex = toIndex$1(index);\n    var store = getInternalState$1(view);\n    if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n    var bytes = getInternalState$1(store.buffer).bytes;\n    var start = intIndex + store.byteOffset;\n    var pack = conversion(+value);\n    for(var i = 0; i < count; i++)bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\n};\nif (!NATIVE_ARRAY_BUFFER) {\n    $ArrayBuffer = function ArrayBuffer1(length) {\n        anInstance$1(this, ArrayBufferPrototype$1);\n        var byteLength = toIndex$1(length);\n        setInternalState$1(this, {\n            bytes: fill(Array$1(byteLength), 0),\n            byteLength: byteLength\n        });\n        if (!DESCRIPTORS$1) this.byteLength = byteLength;\n    };\n    ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];\n    $DataView = function DataView1(buffer, byteOffset, byteLength) {\n        anInstance$1(this, DataViewPrototype$1);\n        anInstance$1(buffer, ArrayBufferPrototype$1);\n        var bufferLength = getInternalState$1(buffer).byteLength;\n        var offset = toIntegerOrInfinity$2(byteOffset);\n        if (offset < 0 || offset > bufferLength) throw RangeError$3(\"Wrong offset\");\n        byteLength = byteLength === undefined ? bufferLength - offset : toLength$3(byteLength);\n        if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);\n        setInternalState$1(this, {\n            buffer: buffer,\n            byteLength: byteLength,\n            byteOffset: offset\n        });\n        if (!DESCRIPTORS$1) {\n            this.buffer = buffer;\n            this.byteLength = byteLength;\n            this.byteOffset = offset;\n        }\n    };\n    DataViewPrototype$1 = $DataView[PROTOTYPE];\n    if (DESCRIPTORS$1) {\n        addGetter$1($ArrayBuffer, \"byteLength\");\n        addGetter$1($DataView, \"buffer\");\n        addGetter$1($DataView, \"byteLength\");\n        addGetter$1($DataView, \"byteOffset\");\n    }\n    defineBuiltIns(DataViewPrototype$1, {\n        getInt8: function getInt8(byteOffset) {\n            return get(this, 1, byteOffset)[0] << 24 >> 24;\n        },\n        getUint8: function getUint8(byteOffset) {\n            return get(this, 1, byteOffset)[0];\n        },\n        getInt16: function getInt16(byteOffset /* , littleEndian */ ) {\n            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n        },\n        getUint16: function getUint16(byteOffset /* , littleEndian */ ) {\n            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n            return bytes[1] << 8 | bytes[0];\n        },\n        getInt32: function getInt32(byteOffset /* , littleEndian */ ) {\n            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\n        },\n        getUint32: function getUint32(byteOffset /* , littleEndian */ ) {\n            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\n        },\n        getFloat32: function getFloat32(byteOffset /* , littleEndian */ ) {\n            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\n        },\n        getFloat64: function getFloat64(byteOffset /* , littleEndian */ ) {\n            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\n        },\n        setInt8: function setInt8(byteOffset, value) {\n            set(this, 1, byteOffset, packInt8, value);\n        },\n        setUint8: function setUint8(byteOffset, value) {\n            set(this, 1, byteOffset, packInt8, value);\n        },\n        setInt16: function setInt16(byteOffset, value /* , littleEndian */ ) {\n            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n        },\n        setUint16: function setUint16(byteOffset, value /* , littleEndian */ ) {\n            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n        },\n        setInt32: function setInt32(byteOffset, value /* , littleEndian */ ) {\n            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n        },\n        setUint32: function setUint32(byteOffset, value /* , littleEndian */ ) {\n            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n        },\n        setFloat32: function setFloat32(byteOffset, value /* , littleEndian */ ) {\n            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\n        },\n        setFloat64: function setFloat64(byteOffset, value /* , littleEndian */ ) {\n            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\n        }\n    });\n} else {\n    var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;\n    /* eslint-disable no-new -- required for testing */ if (!fails$7(function() {\n        NativeArrayBuffer(1);\n    }) || !fails$7(function() {\n        new NativeArrayBuffer(-1);\n    }) || fails$7(function() {\n        new NativeArrayBuffer();\n        new NativeArrayBuffer(1.5);\n        new NativeArrayBuffer(NaN);\n        return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;\n    })) {\n        /* eslint-enable no-new -- required for testing */ $ArrayBuffer = function ArrayBuffer1(length) {\n            anInstance$1(this, ArrayBufferPrototype$1);\n            return new NativeArrayBuffer(toIndex$1(length));\n        };\n        $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;\n        for(var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;){\n            if (!((key = keys[j++]) in $ArrayBuffer)) {\n                createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);\n            }\n        }\n        ArrayBufferPrototype$1.constructor = $ArrayBuffer;\n    } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {\n        createNonEnumerableProperty$2(NativeArrayBuffer, \"name\", ARRAY_BUFFER);\n    }\n    // WebKit bug - the same parent prototype for typed arrays and data view\n    if (setPrototypeOf$2 && getPrototypeOf(DataViewPrototype$1) !== ObjectPrototype) {\n        setPrototypeOf$2(DataViewPrototype$1, ObjectPrototype);\n    }\n    // iOS Safari 7.x bug\n    var testView = new $DataView(new $ArrayBuffer(2));\n    var $setInt8 = uncurryThis$7(DataViewPrototype$1.setInt8);\n    testView.setInt8(0, 2147483648);\n    testView.setInt8(1, 2147483649);\n    if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype$1, {\n        setInt8: function setInt8(byteOffset, value) {\n            $setInt8(this, byteOffset, value << 24 >> 24);\n        },\n        setUint8: function setUint8(byteOffset, value) {\n            $setInt8(this, byteOffset, value << 24 >> 24);\n        }\n    }, {\n        unsafe: true\n    });\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nvar arrayBuffer = {\n    ArrayBuffer: $ArrayBuffer,\n    DataView: $DataView\n};\nvar $$1 = _export;\nvar uncurryThis$6 = functionUncurryThis;\nvar fails$6 = fails$s;\nvar ArrayBufferModule$1 = arrayBuffer;\nvar anObject$2 = anObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$4;\nvar toLength$2 = toLength$6;\nvar speciesConstructor$1 = speciesConstructor$3;\nvar ArrayBuffer$2 = ArrayBufferModule$1.ArrayBuffer;\nvar DataView$2 = ArrayBufferModule$1.DataView;\nvar DataViewPrototype = DataView$2.prototype;\nvar un$ArrayBufferSlice = uncurryThis$6(ArrayBuffer$2.prototype.slice);\nvar getUint8 = uncurryThis$6(DataViewPrototype.getUint8);\nvar setUint8 = uncurryThis$6(DataViewPrototype.setUint8);\nvar INCORRECT_SLICE = fails$6(function() {\n    return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;\n});\n// `ArrayBuffer.prototype.slice` method\n// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice\n$$1({\n    target: \"ArrayBuffer\",\n    proto: true,\n    unsafe: true,\n    forced: INCORRECT_SLICE\n}, {\n    slice: function slice(start, end) {\n        if (un$ArrayBufferSlice && end === undefined) {\n            return un$ArrayBufferSlice(anObject$2(this), start); // FF fix\n        }\n        var length = anObject$2(this).byteLength;\n        var first = toAbsoluteIndex(start, length);\n        var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n        var result = new (speciesConstructor$1(this, ArrayBuffer$2))(toLength$2(fin - first));\n        var viewSource = new DataView$2(this);\n        var viewTarget = new DataView$2(result);\n        var index = 0;\n        while(first < fin){\n            setUint8(viewTarget, index++, getUint8(viewSource, first++));\n        }\n        return result;\n    }\n});\nvar typedArrayConstructor = {\n    exports: {}\n};\nvar isObject$3 = isObject$d;\nvar floor$1 = Math.floor;\n// `IsIntegralNumber` abstract operation\n// https://tc39.es/ecma262/#sec-isintegralnumber\n// eslint-disable-next-line es-x/no-number-isinteger -- safe\nvar isIntegralNumber$1 = Number.isInteger || function isInteger(it) {\n    return !isObject$3(it) && isFinite(it) && floor$1(it) === it;\n};\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$6;\nvar $RangeError$1 = RangeError;\nvar toPositiveInteger$1 = function(it) {\n    var result = toIntegerOrInfinity$1(it);\n    if (result < 0) throw $RangeError$1(\"The argument can't be less than 0\");\n    return result;\n};\nvar toPositiveInteger = toPositiveInteger$1;\nvar $RangeError = RangeError;\nvar toOffset$2 = function(it, BYTES) {\n    var offset = toPositiveInteger(it);\n    if (offset % BYTES) throw $RangeError(\"Wrong offset\");\n    return offset;\n};\nvar classof$3 = classofRaw$1;\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es-x/no-array-isarray -- safe\nvar isArray$1 = Array.isArray || function isArray(argument) {\n    return classof$3(argument) == \"Array\";\n};\nvar isArray = isArray$1;\nvar isConstructor = isConstructor$2;\nvar isObject$2 = isObject$d;\nvar wellKnownSymbol$1 = wellKnownSymbol$j;\nvar SPECIES$1 = wellKnownSymbol$1(\"species\");\nvar $Array = Array;\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function(originalArray) {\n    var C;\n    if (isArray(originalArray)) {\n        C = originalArray.constructor;\n        // cross-realm fallback\n        if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;\n        else if (isObject$2(C)) {\n            C = C[SPECIES$1];\n            if (C === null) C = undefined;\n        }\n    }\n    return C === undefined ? $Array : C;\n};\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$1 = function(originalArray, length) {\n    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\nvar bind = functionBindContext;\nvar uncurryThis$5 = functionUncurryThis;\nvar IndexedObject = indexedObject;\nvar toObject = toObject$7;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$8;\nvar arraySpeciesCreate = arraySpeciesCreate$1;\nvar push$1 = uncurryThis$5([].push);\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod$1 = function(TYPE) {\n    var IS_MAP = TYPE == 1;\n    var IS_FILTER = TYPE == 2;\n    var IS_SOME = TYPE == 3;\n    var IS_EVERY = TYPE == 4;\n    var IS_FIND_INDEX = TYPE == 6;\n    var IS_FILTER_REJECT = TYPE == 7;\n    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n    return function($this, callbackfn, that, specificCreate) {\n        var O = toObject($this);\n        var self1 = IndexedObject(O);\n        var boundFunction = bind(callbackfn, that);\n        var length = lengthOfArrayLike$1(self1);\n        var index = 0;\n        var create = specificCreate || arraySpeciesCreate;\n        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n        var value, result;\n        for(; length > index; index++)if (NO_HOLES || index in self1) {\n            value = self1[index];\n            result = boundFunction(value, index, O);\n            if (TYPE) {\n                if (IS_MAP) target[index] = result; // map\n                else if (result) switch(TYPE){\n                    case 3:\n                        return true; // some\n                    case 5:\n                        return value; // find\n                    case 6:\n                        return index; // findIndex\n                    case 2:\n                        push$1(target, value); // filter\n                }\n                else switch(TYPE){\n                    case 4:\n                        return false; // every\n                    case 7:\n                        push$1(target, value); // filterReject\n                }\n            }\n        }\n        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n    };\n};\nvar arrayIteration = {\n    // `Array.prototype.forEach` method\n    // https://tc39.es/ecma262/#sec-array.prototype.foreach\n    forEach: createMethod$1(0),\n    // `Array.prototype.map` method\n    // https://tc39.es/ecma262/#sec-array.prototype.map\n    map: createMethod$1(1),\n    // `Array.prototype.filter` method\n    // https://tc39.es/ecma262/#sec-array.prototype.filter\n    filter: createMethod$1(2),\n    // `Array.prototype.some` method\n    // https://tc39.es/ecma262/#sec-array.prototype.some\n    some: createMethod$1(3),\n    // `Array.prototype.every` method\n    // https://tc39.es/ecma262/#sec-array.prototype.every\n    every: createMethod$1(4),\n    // `Array.prototype.find` method\n    // https://tc39.es/ecma262/#sec-array.prototype.find\n    find: createMethod$1(5),\n    // `Array.prototype.findIndex` method\n    // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n    findIndex: createMethod$1(6),\n    // `Array.prototype.filterReject` method\n    // https://github.com/tc39/proposal-array-filtering\n    filterReject: createMethod$1(7)\n};\nvar isCallable$1 = isCallable$n;\nvar isObject$1 = isObject$d;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\n// makes subclassing work correct for wrapped built-ins\nvar inheritIfRequired$1 = function($this, dummy, Wrapper) {\n    var NewTarget, NewTargetPrototype;\n    if (// it can work only with native `setPrototypeOf`\n    setPrototypeOf$1 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable$1(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$1(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf$1($this, NewTargetPrototype);\n    return $this;\n};\nvar $ = _export;\nvar global$4 = global$t;\nvar call$4 = functionCall;\nvar DESCRIPTORS = descriptors;\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;\nvar ArrayBufferViewCore$4 = arrayBufferViewCore;\nvar ArrayBufferModule = arrayBuffer;\nvar anInstance = anInstance$3;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$8;\nvar isIntegralNumber = isIntegralNumber$1;\nvar toLength$1 = toLength$6;\nvar toIndex = toIndex$2;\nvar toOffset$1 = toOffset$2;\nvar toPropertyKey = toPropertyKey$4;\nvar hasOwn = hasOwnProperty_1;\nvar classof$2 = classof$9;\nvar isObject = isObject$d;\nvar isSymbol = isSymbol$3;\nvar create = objectCreate;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\nvar typedArrayFrom = typedArrayFrom$2;\nvar forEach = arrayIteration.forEach;\nvar setSpecies = setSpecies$2;\nvar definePropertyModule = objectDefineProperty;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar InternalStateModule = internalState;\nvar inheritIfRequired = inheritIfRequired$1;\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar enforceInternalState = InternalStateModule.enforce;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar round = Math.round;\nvar RangeError$2 = global$4.RangeError;\nvar ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;\nvar ArrayBufferPrototype = ArrayBuffer$1.prototype;\nvar DataView$1 = ArrayBufferModule.DataView;\nvar NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;\nvar TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;\nvar TypedArray = ArrayBufferViewCore$4.TypedArray;\nvar TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;\nvar aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;\nvar isTypedArray = ArrayBufferViewCore$4.isTypedArray;\nvar BYTES_PER_ELEMENT = \"BYTES_PER_ELEMENT\";\nvar WRONG_LENGTH = \"Wrong length\";\nvar fromList = function(C, list) {\n    aTypedArrayConstructor(C);\n    var index = 0;\n    var length = list.length;\n    var result = new C(length);\n    while(length > index)result[index] = list[index++];\n    return result;\n};\nvar addGetter = function(it, key) {\n    nativeDefineProperty(it, key, {\n        get: function() {\n            return getInternalState(this)[key];\n        }\n    });\n};\nvar isArrayBuffer = function(it) {\n    var klass;\n    return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof$2(it)) == \"ArrayBuffer\" || klass == \"SharedArrayBuffer\";\n};\nvar isTypedArrayIndex = function(target, key) {\n    return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;\n};\nvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\n    key = toPropertyKey(key);\n    return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);\n};\nvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\n    key = toPropertyKey(key);\n    if (isTypedArrayIndex(target, key) && isObject(descriptor) && hasOwn(descriptor, \"value\") && !hasOwn(descriptor, \"get\") && !hasOwn(descriptor, \"set\") && !descriptor.configurable && (!hasOwn(descriptor, \"writable\") || descriptor.writable) && (!hasOwn(descriptor, \"enumerable\") || descriptor.enumerable)) {\n        target[key] = descriptor.value;\n        return target;\n    }\n    return nativeDefineProperty(target, key, descriptor);\n};\nif (DESCRIPTORS) {\n    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;\n        definePropertyModule.f = wrappedDefineProperty;\n        addGetter(TypedArrayPrototype, \"buffer\");\n        addGetter(TypedArrayPrototype, \"byteOffset\");\n        addGetter(TypedArrayPrototype, \"byteLength\");\n        addGetter(TypedArrayPrototype, \"length\");\n    }\n    $({\n        target: \"Object\",\n        stat: true,\n        forced: !NATIVE_ARRAY_BUFFER_VIEWS\n    }, {\n        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\n        defineProperty: wrappedDefineProperty\n    });\n    typedArrayConstructor.exports = function(TYPE, wrapper, CLAMPED) {\n        var BYTES = TYPE.match(/\\d+$/)[0] / 8;\n        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? \"Clamped\" : \"\") + \"Array\";\n        var GETTER = \"get\" + TYPE;\n        var SETTER = \"set\" + TYPE;\n        var NativeTypedArrayConstructor = global$4[CONSTRUCTOR_NAME];\n        var TypedArrayConstructor = NativeTypedArrayConstructor;\n        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\n        var exported = {};\n        var getter = function(that, index) {\n            var data = getInternalState(that);\n            return data.view[GETTER](index * BYTES + data.byteOffset, true);\n        };\n        var setter = function(that, index, value) {\n            var data = getInternalState(that);\n            if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\n            data.view[SETTER](index * BYTES + data.byteOffset, value, true);\n        };\n        var addElement = function(that, index) {\n            nativeDefineProperty(that, index, {\n                get: function() {\n                    return getter(this, index);\n                },\n                set: function(value) {\n                    return setter(this, index, value);\n                },\n                enumerable: true\n            });\n        };\n        if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n            TypedArrayConstructor = wrapper(function(that, data, offset, $length) {\n                anInstance(that, TypedArrayConstructorPrototype);\n                var index = 0;\n                var byteOffset = 0;\n                var buffer, byteLength, length;\n                if (!isObject(data)) {\n                    length = toIndex(data);\n                    byteLength = length * BYTES;\n                    buffer = new ArrayBuffer$1(byteLength);\n                } else if (isArrayBuffer(data)) {\n                    buffer = data;\n                    byteOffset = toOffset$1(offset, BYTES);\n                    var $len = data.byteLength;\n                    if ($length === undefined) {\n                        if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);\n                        byteLength = $len - byteOffset;\n                        if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);\n                    } else {\n                        byteLength = toLength$1($length) * BYTES;\n                        if (byteLength + byteOffset > $len) throw RangeError$2(WRONG_LENGTH);\n                    }\n                    length = byteLength / BYTES;\n                } else if (isTypedArray(data)) {\n                    return fromList(TypedArrayConstructor, data);\n                } else {\n                    return call$4(typedArrayFrom, TypedArrayConstructor, data);\n                }\n                setInternalState(that, {\n                    buffer: buffer,\n                    byteOffset: byteOffset,\n                    byteLength: byteLength,\n                    length: length,\n                    view: new DataView$1(buffer)\n                });\n                while(index < length)addElement(that, index++);\n            });\n            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);\n        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {\n            TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {\n                anInstance(dummy, TypedArrayConstructorPrototype);\n                return inheritIfRequired(function() {\n                    if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\n                    if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);\n                    if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\n                    return call$4(typedArrayFrom, TypedArrayConstructor, data);\n                }(), dummy, TypedArrayConstructor);\n            });\n            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n            forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {\n                if (!(key in TypedArrayConstructor)) {\n                    createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\n                }\n            });\n            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\n        }\n        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\n            createNonEnumerableProperty$1(TypedArrayConstructorPrototype, \"constructor\", TypedArrayConstructor);\n        }\n        enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;\n        if (TYPED_ARRAY_TAG) {\n            createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\n        }\n        var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;\n        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\n        $({\n            global: true,\n            constructor: true,\n            forced: FORCED,\n            sham: !NATIVE_ARRAY_BUFFER_VIEWS\n        }, exported);\n        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\n            createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\n        }\n        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\n            createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\n        }\n        setSpecies(CONSTRUCTOR_NAME);\n    };\n} else typedArrayConstructor.exports = function() {};\nvar createTypedArrayConstructor = typedArrayConstructor.exports;\n// `Uint8Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor(\"Uint8\", function(init) {\n    return function Uint8Array1(data, byteOffset, length) {\n        return init(this, data, byteOffset, length);\n    };\n});\nvar toPrimitive = toPrimitive$2;\nvar $TypeError$1 = TypeError;\n// `ToBigInt` abstract operation\n// https://tc39.es/ecma262/#sec-tobigint\nvar toBigInt$1 = function(argument) {\n    var prim = toPrimitive(argument, \"number\");\n    if (typeof prim == \"number\") throw $TypeError$1(\"Can't convert number to bigint\");\n    // eslint-disable-next-line es-x/no-bigint -- safe\n    return BigInt(prim);\n};\nvar ArrayBufferViewCore$3 = arrayBufferViewCore;\nvar $fill = arrayFill$1;\nvar toBigInt = toBigInt$1;\nvar classof$1 = classof$9;\nvar call$3 = functionCall;\nvar uncurryThis$4 = functionUncurryThis;\nvar fails$5 = fails$s;\nvar aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;\nvar exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;\nvar slice = uncurryThis$4(\"\".slice);\n// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18\nvar CONVERSION_BUG = fails$5(function() {\n    var count = 0;\n    // eslint-disable-next-line es-x/no-typed-arrays -- safe\n    new Int8Array(2).fill({\n        valueOf: function() {\n            return count++;\n        }\n    });\n    return count !== 1;\n});\n// `%TypedArray%.prototype.fill` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill\nexportTypedArrayMethod$3(\"fill\", function fill(value /* , start, end */ ) {\n    var length = arguments.length;\n    aTypedArray$3(this);\n    var actualValue = slice(classof$1(this), 0, 3) === \"Big\" ? toBigInt(value) : +value;\n    return call$3($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);\n}, CONVERSION_BUG);\nvar global$3 = global$t;\nvar call$2 = functionCall;\nvar ArrayBufferViewCore$2 = arrayBufferViewCore;\nvar lengthOfArrayLike = lengthOfArrayLike$8;\nvar toOffset = toOffset$2;\nvar toIndexedObject = toObject$7;\nvar fails$4 = fails$s;\nvar RangeError$1 = global$3.RangeError;\nvar Int8Array$2 = global$3.Int8Array;\nvar Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;\nvar $set = Int8ArrayPrototype && Int8ArrayPrototype.set;\nvar aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;\nvar exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;\nvar WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails$4(function() {\n    // eslint-disable-next-line es-x/no-typed-arrays -- required for testing\n    var array = new Uint8ClampedArray(2);\n    call$2($set, array, {\n        length: 1,\n        0: 3\n    }, 1);\n    return array[1] !== 3;\n});\n// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other\nvar TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$2.NATIVE_ARRAY_BUFFER_VIEWS && fails$4(function() {\n    var array = new Int8Array$2(2);\n    array.set(1);\n    array.set(\"2\", 1);\n    return array[0] !== 0 || array[1] !== 2;\n});\n// `%TypedArray%.prototype.set` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set\nexportTypedArrayMethod$2(\"set\", function set(arrayLike /* , offset */ ) {\n    aTypedArray$2(this);\n    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n    var src = toIndexedObject(arrayLike);\n    if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call$2($set, this, src, offset);\n    var length = this.length;\n    var len = lengthOfArrayLike(src);\n    var index = 0;\n    if (len + offset > length) throw RangeError$1(\"Wrong length\");\n    while(index < len)this[offset + index] = src[index++];\n}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);\nvar arraySlice$2 = arraySliceSimple;\nvar floor = Math.floor;\nvar mergeSort = function(array, comparefn) {\n    var length = array.length;\n    var middle = floor(length / 2);\n    return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice$2(array, 0, middle), comparefn), mergeSort(arraySlice$2(array, middle), comparefn), comparefn);\n};\nvar insertionSort = function(array, comparefn) {\n    var length = array.length;\n    var i = 1;\n    var element, j;\n    while(i < length){\n        j = i;\n        element = array[i];\n        while(j && comparefn(array[j - 1], element) > 0){\n            array[j] = array[--j];\n        }\n        if (j !== i++) array[j] = element;\n    }\n    return array;\n};\nvar merge = function(array, left, right, comparefn) {\n    var llength = left.length;\n    var rlength = right.length;\n    var lindex = 0;\n    var rindex = 0;\n    while(lindex < llength || rindex < rlength){\n        array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];\n    }\n    return array;\n};\nvar arraySort = mergeSort;\nvar userAgent$1 = engineUserAgent;\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\nvar engineFfVersion = !!firefox && +firefox[1];\nvar UA = engineUserAgent;\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\nvar userAgent = engineUserAgent;\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\nvar engineWebkitVersion = !!webkit && +webkit[1];\nvar global$2 = global$t;\nvar uncurryThis$3 = functionUncurryThis;\nvar fails$3 = fails$s;\nvar aCallable = aCallable$9;\nvar internalSort = arraySort;\nvar ArrayBufferViewCore$1 = arrayBufferViewCore;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\nvar aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;\nvar exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;\nvar Uint16Array = global$2.Uint16Array;\nvar un$Sort = Uint16Array && uncurryThis$3(Uint16Array.prototype.sort);\n// WebKit\nvar ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails$3(function() {\n    un$Sort(new Uint16Array(2), null);\n}) && fails$3(function() {\n    un$Sort(new Uint16Array(2), {});\n}));\nvar STABLE_SORT = !!un$Sort && !fails$3(function() {\n    // feature detection can be too slow, so check engines versions\n    if (V8) return V8 < 74;\n    if (FF) return FF < 67;\n    if (IE_OR_EDGE) return true;\n    if (WEBKIT) return WEBKIT < 602;\n    var array = new Uint16Array(516);\n    var expected = Array(516);\n    var index, mod;\n    for(index = 0; index < 516; index++){\n        mod = index % 4;\n        array[index] = 515 - index;\n        expected[index] = index - 2 * mod + 3;\n    }\n    un$Sort(array, function(a, b) {\n        return (a / 4 | 0) - (b / 4 | 0);\n    });\n    for(index = 0; index < 516; index++){\n        if (array[index] !== expected[index]) return true;\n    }\n});\nvar getSortCompare = function(comparefn) {\n    return function(x, y) {\n        if (comparefn !== undefined) return +comparefn(x, y) || 0;\n        // eslint-disable-next-line no-self-compare -- NaN check\n        if (y !== y) return -1;\n        // eslint-disable-next-line no-self-compare -- NaN check\n        if (x !== x) return 1;\n        if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;\n        return x > y;\n    };\n};\n// `%TypedArray%.prototype.sort` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort\nexportTypedArrayMethod$1(\"sort\", function sort(comparefn) {\n    if (comparefn !== undefined) aCallable(comparefn);\n    if (STABLE_SORT) return un$Sort(this, comparefn);\n    return internalSort(aTypedArray$1(this), getSortCompare(comparefn));\n}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);\nvar global$1 = global$t;\nvar apply$1 = functionApply;\nvar ArrayBufferViewCore = arrayBufferViewCore;\nvar fails$2 = fails$s;\nvar arraySlice$1 = arraySlice$5;\nvar Int8Array$1 = global$1.Int8Array;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $toLocaleString = [].toLocaleString;\n// iOS Safari 6.x fails here\nvar TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$2(function() {\n    $toLocaleString.call(new Int8Array$1(1));\n});\nvar FORCED = fails$2(function() {\n    return [\n        1,\n        2\n    ].toLocaleString() != new Int8Array$1([\n        1,\n        2\n    ]).toLocaleString();\n}) || !fails$2(function() {\n    Int8Array$1.prototype.toLocaleString.call([\n        1,\n        2\n    ]);\n});\n// `%TypedArray%.prototype.toLocaleString` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring\nexportTypedArrayMethod(\"toLocaleString\", function toLocaleString() {\n    return apply$1($toLocaleString, TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray(this)) : aTypedArray(this), arraySlice$1(arguments));\n}, FORCED);\nclass Payload {\n    constructor(data){\n        // The tag's value is a hardcoded value as per\n        // defined in the NEP [NEP413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)\n        this.tag = 2147484061;\n        this.message = data.message;\n        this.nonce = data.nonce;\n        this.recipient = data.recipient;\n        if (data.callbackUrl) {\n            this.callbackUrl = data.callbackUrl;\n        }\n    }\n}\nconst payloadSchema = new Map([\n    [\n        Payload,\n        {\n            kind: \"struct\",\n            fields: [\n                [\n                    \"tag\",\n                    \"u32\"\n                ],\n                [\n                    \"message\",\n                    \"string\"\n                ],\n                [\n                    \"nonce\",\n                    [\n                        32\n                    ]\n                ],\n                [\n                    \"recipient\",\n                    \"string\"\n                ],\n                [\n                    \"callbackUrl\",\n                    {\n                        kind: \"option\",\n                        type: \"string\"\n                    }\n                ]\n            ]\n        }\n    ]\n]);\nconst serializeNep413 = (signMessageParams)=>{\n    const payload = new Payload(Object.assign({}, signMessageParams));\n    return Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload));\n};\nconst verifySignature = ({ publicKey, signature, message, nonce, recipient, callbackUrl })=>{\n    // Reconstruct the payload that was **actually signed**\n    const payload = new Payload({\n        message,\n        nonce,\n        recipient,\n        callbackUrl\n    });\n    // Serialize payload based on payloadSchema\n    const borshPayload = (0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload);\n    // Hash the payload as in the NEP0413 referenced example\n    // https://github.com/near/NEPs/blob/master/neps/nep-0413.md#references\n    // https://github.com/gagdiez/near-login/blob/main/authenticate/wallet-authenticate.js#L21\n    const hashedPayload = Uint8Array.from(js_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.array(borshPayload));\n    // Convert real signature to buffer base64\n    const realSignature = Buffer.from(signature, \"base64\");\n    const pk = near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.PublicKey.from(publicKey);\n    // Verify the signature\n    return pk.verify(hashedPayload, realSignature);\n};\nconst fetchAllUserKeys = ({ accountId, network, publicKey })=>__awaiter(void 0, void 0, void 0, function*() {\n        const provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n            url: network.nodeUrl\n        });\n        const key = yield provider.query({\n            request_type: \"view_access_key\",\n            account_id: accountId,\n            finality: \"final\",\n            public_key: publicKey\n        });\n        return key;\n    });\nconst verifyFullKeyBelongsToUser = ({ publicKey, accountId, network })=>__awaiter(void 0, void 0, void 0, function*() {\n        const { permission } = yield fetchAllUserKeys({\n            accountId,\n            network,\n            publicKey\n        });\n        return permission === \"FullAccess\";\n    });\n// TODO: Remove from `core-js@4` since it's moved to entry points\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$8;\nvar regexpExec$2 = regexpExec$3;\nvar fails$1 = fails$s;\nvar wellKnownSymbol = wellKnownSymbol$j;\nvar createNonEnumerableProperty = createNonEnumerableProperty$8;\nvar SPECIES = wellKnownSymbol(\"species\");\nvar RegExpPrototype = RegExp.prototype;\nvar fixRegexpWellKnownSymbolLogic = function(KEY, exec, FORCED, SHAM) {\n    var SYMBOL = wellKnownSymbol(KEY);\n    var DELEGATES_TO_SYMBOL = !fails$1(function() {\n        // String methods call symbol-named RegEp methods\n        var O = {};\n        O[SYMBOL] = function() {\n            return 7;\n        };\n        return \"\"[KEY](O) != 7;\n    });\n    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function() {\n        // Symbol-named RegExp methods call .exec\n        var execCalled = false;\n        var re = /a/;\n        if (KEY === \"split\") {\n            // We can't use real regex here since it causes deoptimization\n            // and serious performance degradation in V8\n            // https://github.com/zloirock/core-js/issues/306\n            re = {};\n            // RegExp[@@split] doesn't call the regex's exec method, but first creates\n            // a new one. We need to return the patched regex when creating the new one.\n            re.constructor = {};\n            re.constructor[SPECIES] = function() {\n                return re;\n            };\n            re.flags = \"\";\n            re[SYMBOL] = /./[SYMBOL];\n        }\n        re.exec = function() {\n            execCalled = true;\n            return null;\n        };\n        re[SYMBOL](\"\");\n        return !execCalled;\n    });\n    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {\n        var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n        var methods = exec(SYMBOL, \"\"[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {\n            var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n            var $exec = regexp.exec;\n            if ($exec === regexpExec$2 || $exec === RegExpPrototype.exec) {\n                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n                    // The native String method already delegates to @@method (this\n                    // polyfilled function), leasing to infinite recursion.\n                    // We avoid it by directly calling the native @@method method.\n                    return {\n                        done: true,\n                        value: uncurriedNativeRegExpMethod(regexp, str, arg2)\n                    };\n                }\n                return {\n                    done: true,\n                    value: uncurriedNativeMethod(str, regexp, arg2)\n                };\n            }\n            return {\n                done: false\n            };\n        });\n        defineBuiltIn(String.prototype, KEY, methods[0]);\n        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n    }\n    if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], \"sham\", true);\n};\nvar uncurryThis$1 = functionUncurryThis;\nvar toIntegerOrInfinity = toIntegerOrInfinity$6;\nvar toString$1 = toString$5;\nvar requireObjectCoercible$1 = requireObjectCoercible$6;\nvar charAt$1 = uncurryThis$1(\"\".charAt);\nvar charCodeAt = uncurryThis$1(\"\".charCodeAt);\nvar stringSlice$1 = uncurryThis$1(\"\".slice);\nvar createMethod = function(CONVERT_TO_STRING) {\n    return function($this, pos) {\n        var S = toString$1(requireObjectCoercible$1($this));\n        var position = toIntegerOrInfinity(pos);\n        var size = S.length;\n        var first, second;\n        if (position < 0 || position >= size) return CONVERT_TO_STRING ? \"\" : undefined;\n        first = charCodeAt(S, position);\n        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$1(S, position) : first : CONVERT_TO_STRING ? stringSlice$1(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n    };\n};\nvar stringMultibyte = {\n    // `String.prototype.codePointAt` method\n    // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n    codeAt: createMethod(false),\n    // `String.prototype.at` method\n    // https://github.com/mathiasbynens/String.prototype.at\n    charAt: createMethod(true)\n};\nvar charAt = stringMultibyte.charAt;\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function(S, index, unicode) {\n    return index + (unicode ? charAt(S, index).length : 1);\n};\nvar call$1 = functionCall;\nvar anObject$1 = anObject$e;\nvar isCallable = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec$1 = regexpExec$3;\nvar $TypeError = TypeError;\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function(R, S) {\n    var exec = R.exec;\n    if (isCallable(exec)) {\n        var result = call$1(exec, R, S);\n        if (result !== null) anObject$1(result);\n        return result;\n    }\n    if (classof(R) === \"RegExp\") return call$1(regexpExec$1, R, S);\n    throw $TypeError(\"RegExp#exec called on incompatible receiver\");\n};\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar isRegExp = isRegexp;\nvar anObject = anObject$e;\nvar requireObjectCoercible = requireObjectCoercible$6;\nvar speciesConstructor = speciesConstructor$3;\nvar advanceStringIndex = advanceStringIndex$1;\nvar toLength = toLength$6;\nvar toString = toString$5;\nvar getMethod = getMethod$4;\nvar arraySlice = arraySliceSimple;\nvar callRegExpExec = regexpExecAbstract;\nvar regexpExec = regexpExec$3;\nvar stickyHelpers = regexpStickyHelpers;\nvar fails = fails$s;\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar MAX_UINT32 = 0xFFFFFFFF;\nvar min = Math.min;\nvar $push = [].push;\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis($push);\nvar stringSlice = uncurryThis(\"\".slice);\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    var re = /(?:)/;\n    var originalExec = re.exec;\n    re.exec = function() {\n        return originalExec.apply(this, arguments);\n    };\n    var result = \"ab\".split(re);\n    return result.length !== 2 || result[0] !== \"a\" || result[1] !== \"b\";\n});\n// @@split logic\nfixRegExpWellKnownSymbolLogic(\"split\", function(SPLIT, nativeSplit, maybeCallNative) {\n    var internalSplit;\n    if (\"abbc\".split(/(b)*/)[1] == \"c\" || // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    \"test\".split(/(?:)/, -1).length != 4 || \"ab\".split(/(?:ab)*/).length != 2 || \".\".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing\n    \".\".split(/()()/).length > 1 || \"\".split(/.?/).length) {\n        // based on es5-shim implementation, need to rework it\n        internalSplit = function(separator, limit) {\n            var string = toString(requireObjectCoercible(this));\n            var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n            if (lim === 0) return [];\n            if (separator === undefined) return [\n                string\n            ];\n            // If `separator` is not a regex, use native split\n            if (!isRegExp(separator)) {\n                return call(nativeSplit, string, separator, lim);\n            }\n            var output = [];\n            var flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.unicode ? \"u\" : \"\") + (separator.sticky ? \"y\" : \"\");\n            var lastLastIndex = 0;\n            // Make `global` and avoid `lastIndex` issues by working with a copy\n            var separatorCopy = new RegExp(separator.source, flags + \"g\");\n            var match, lastIndex, lastLength;\n            while(match = call(regexpExec, separatorCopy, string)){\n                lastIndex = separatorCopy.lastIndex;\n                if (lastIndex > lastLastIndex) {\n                    push(output, stringSlice(string, lastLastIndex, match.index));\n                    if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));\n                    lastLength = match[0].length;\n                    lastLastIndex = lastIndex;\n                    if (output.length >= lim) break;\n                }\n                if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n            }\n            if (lastLastIndex === string.length) {\n                if (lastLength || !exec(separatorCopy, \"\")) push(output, \"\");\n            } else push(output, stringSlice(string, lastLastIndex));\n            return output.length > lim ? arraySlice(output, 0, lim) : output;\n        };\n    // Chakra, V8\n    } else if (\"0\".split(undefined, 0).length) {\n        internalSplit = function(separator, limit) {\n            return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);\n        };\n    } else internalSplit = nativeSplit;\n    return [\n        // `String.prototype.split` method\n        // https://tc39.es/ecma262/#sec-string.prototype.split\n        function split(separator, limit) {\n            var O = requireObjectCoercible(this);\n            var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);\n            return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);\n        },\n        // `RegExp.prototype[@@split]` method\n        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n        //\n        // NOTE: This cannot be properly polyfilled in engines that don't support\n        // the 'y' flag.\n        function(string, limit) {\n            var rx = anObject(this);\n            var S = toString(string);\n            var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);\n            if (res.done) return res.value;\n            var C = speciesConstructor(rx, RegExp);\n            var unicodeMatching = rx.unicode;\n            var flags = (rx.ignoreCase ? \"i\" : \"\") + (rx.multiline ? \"m\" : \"\") + (rx.unicode ? \"u\" : \"\") + (UNSUPPORTED_Y ? \"g\" : \"y\");\n            // ^(? + rx + ) is needed, in combination with some S slicing, to\n            // simulate the 'y' flag.\n            var splitter = new C(UNSUPPORTED_Y ? \"^(?:\" + rx.source + \")\" : rx, flags);\n            var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n            if (lim === 0) return [];\n            if (S.length === 0) return callRegExpExec(splitter, S) === null ? [\n                S\n            ] : [];\n            var p = 0;\n            var q = 0;\n            var A = [];\n            while(q < S.length){\n                splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;\n                var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);\n                var e;\n                if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {\n                    q = advanceStringIndex(S, q, unicodeMatching);\n                } else {\n                    push(A, stringSlice(S, p, q));\n                    if (A.length === lim) return A;\n                    for(var i = 1; i <= z.length - 1; i++){\n                        push(A, z[i]);\n                        if (A.length === lim) return A;\n                    }\n                    q = p = e;\n                }\n            }\n            push(A, stringSlice(S, p));\n            return A;\n        }\n    ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\nvar modal$b = {\n    wallet: {\n        connectYourWallet: \"Connect Your Wallet\",\n        whatIsAWallet: \"What is a Wallet?\",\n        secureAndManage: \"Secure & Manage Your Digital Assets\",\n        safelyStore: \"Safely store and transfer your crypto and NFTs.\",\n        logInToAny: \"Log In to Any NEAR App\",\n        noNeedToCreate: \"No need to create new accounts or credentials. Connect your wallet and you are good to go!\",\n        getAWallet: \"Get a Wallet\",\n        useAWallet: \"Use a wallet to secure and manage your NEAR assets, and to log in to any NEAR app without the need for usernames and passwords.\",\n        connectionFailed: \"Connection Failed\",\n        connectionSuccessful: \"Connection Successful\",\n        connected: \"Connected\",\n        connectingTo: \"Connecting to\",\n        connectingMessage: {\n            injected: \"Confirm the connection in the extension window\",\n            browser: \"Confirm the connection in the wallet after redirect\",\n            hardware: \"Confirm the connection in the ledger device\",\n            bridge: \"Confirm the connection in the wallet\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Connect with Ledger\",\n        makeSureYourLedger: \"Make sure your Ledger is connected securely, and that the NEAR app is open on your device\",\n        \"continue\": \"Continue\",\n        specifyHDPath: \"Specify HD Path\",\n        enterYourPreferredHDPath: \"Enter your preferred HD path, then scan for any active accounts.\",\n        scan: \"Scan\",\n        retry: \"Retry\",\n        ledgerIsNotAvailable: \"Ledger is not available\",\n        accessDeniedToUseLedgerDevice: \"Access denied to use Ledger device\",\n        noAccountsFound: \"No Accounts Found\",\n        selectYourAccounts: \"Select Your Accounts\",\n        connecting1Account: \"Connecting 1 Account\",\n        cantFindAnyAccount: \"Can't find any account associated with this Ledger. Please create a new NEAR account on\",\n        orConnectAnAnotherLedger: \"or connect an another Ledger.\",\n        connecting: \"Connecting\",\n        ofAccounts: \"of Accounts\",\n        failedToAutomatically: \"Failed to automatically find account id. Provide it manually:\",\n        overviewTheListOfAuthorized: \"Overview the list of authorized account(s), complete sign in by clicking the button below.\",\n        finish: \"Finish\"\n    },\n    install: {\n        youllNeedToInstall: \"You'll need to install\",\n        toContinueAfterInstalling: \"to continue. After installing\",\n        refreshThePage: \"refresh the page.\",\n        open: \"Open\"\n    },\n    qr: {\n        copiedToClipboard: \"Copied to clipboard\",\n        failedToCopy: \"Failed to copy to clipboard\",\n        scanWithYourMobile: \"Scan with Your Mobile Device\",\n        copyToClipboard: \" Copy to clipboard\",\n        preferTheOfficial: \"Prefer the official dialogue of\",\n        open: \"Open\"\n    },\n    walletTypes: {\n        hardware: \"Hardware Wallet\",\n        browser: \"Browser Wallet\",\n        injected: \"Wallet Extension\",\n        bridge: \"Bridge Wallet\",\n        mobile: \"Mobile Wallet\",\n        \"instant-link\": \"Instant Wallet\"\n    },\n    exportAccounts: {\n        chooseAWallet: \"Choose a Wallet\",\n        transferYourAccounts: \"Transfer Your Accounts\",\n        selectAWallet: \"Select a wallet that fits your needs and supports your connected accounts.\",\n        selectYourAccounts: \"Select Your Accounts\",\n        afterDecide: \"After you decide on a wallet, you can select which accounts you want to transfer.\",\n        disclaimer: \"You won’t be able to transfer accounts that have never been funded or used on NEAR.\",\n        warning: \"does not support account export at this time. Please select another wallet.\",\n        walletTypes: {\n            hardware: \"Hardware Wallet\",\n            browser: \"Browser Wallet\",\n            injected: \"Wallet Extension\",\n            bridge: \"Bridge Wallet\",\n            mobile: \"Mobile Wallet\"\n        },\n        selectAccounts: {\n            title: \"Select Accounts to Transfer\",\n            button: \"Continue\",\n            deselectAll: \"Deselect All\",\n            selectAll: \"Select All\",\n            unavailable: \"Transfer Unavailable\",\n            error: \"Account does not exist\",\n            warningLedger: \"Ledger support required\",\n            noBalance: \"Account not funded\"\n        },\n        getPassphrase: {\n            title: \"Copy Temporary Password\",\n            desc: \"You’ll need to enter this password when you begin exporting your accounts to a different wallet.\",\n            button: \"Continue\",\n            transferButton: \"Transfer Accounts\",\n            label: \"Click to Copy\",\n            checkLabel: \"I copied or wrote down the password\"\n        },\n        complete: {\n            title: \"Complete the Transfer\",\n            descOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n            descTwo: \"Once import part of process is completed from selected wallet, press button to complete the transfer process.\",\n            startOverButton: \"Start Over\",\n            button: \"Complete\"\n        }\n    }\n};\nvar component$1 = {\n    clickToCopy: {\n        label: \"Copied\",\n        tooltip: \"Click to copy\"\n    }\n};\nvar en = {\n    modal: modal$b,\n    component: component$1\n};\nvar modal$a = {\n    wallet: {\n        connectYourWallet: \"Conecta Tu Billetera\",\n        whatIsAWallet: \"\\xbfQue es una Billetera?\",\n        secureAndManage: \"Resguarda y Administrar Tus Activos Digitales\",\n        safelyStore: \"Almacena de forma segura y transfiere tus cryptos y NFT's\",\n        logInToAny: \"Inicie sesi\\xf3n en Cualquier Aplicacion NEAR\",\n        noNeedToCreate: \"No es necesario crear nuevas cuentas o credenciales, \\xa1Conecta tu billetera y listo!\",\n        getAWallet: \"Obten una Billetera\",\n        useAWallet: \"Usa tu Billetera para resguardar y administrar tus activos en NEAR, e Iniciar sesi\\xf3n en cualquier aplicacion NEAR sin la necesidad de nombres de usuarios y contrase\\xf1as\",\n        connectionFailed: \"Conexi\\xf3n Fallida\",\n        connectionSuccessful: \"Conexi\\xf3n Existosa\",\n        connected: \"Conectado\",\n        connectingTo: \"Conectando a \",\n        connectingMessage: {\n            injected: \"Confirme la conexi\\xf3n en la ventana de extensi\\xf3n\",\n            browser: \"Confirme la conexi\\xf3n en la billetera despu\\xe9s de la redirecci\\xf3n\",\n            hardware: \"Confirme la conexi\\xf3n en el dispositivo de libro mayor\",\n            bridge: \"Confirmar la conexi\\xf3n en la billetera\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Conectar con Ledger\",\n        makeSureYourLedger: \"Aseg\\xfarese de que su ledger est\\xe1 conectada de forma segura y que la aplicacion NEAR est\\xe9 abierta en su dispositivo\",\n        \"continue\": \"Continuar\",\n        specifyHDPath: \"Especifique la ruta HD\",\n        enterYourPreferredHDPath: \"Ingrese su ruta HD prerida,y luego busque cualquier cuenta activa.\",\n        scan: \"Escanear\",\n        retry: \"Reintentar\",\n        ledgerIsNotAvailable: \"El Ledger no est\\xe1 disponible\",\n        accessDeniedToUseLedgerDevice: \"Acceso denegado para usar el dispositivo ledger\",\n        noAccountsFound: \"No se encontraron cuentas\",\n        selectYourAccounts: \"Selecciona tus cuentas\",\n        connecting1Account: \"Conectando a 1 cuenta\",\n        cantFindAnyAccount: \"No se pudo encontrar ninguna cuenta asociada con este ledger,Por favor crea una nueva cuenta en NEAR\",\n        orConnectAnAnotherLedger: \"o conecta otro ledger\",\n        connecting: \"Conectando\",\n        ofAccounts: \"de Cuentas\",\n        failedToAutomatically: \"No se pudo encontrar automaticamente el id de la cuenta,Ingresalo manualmente:\",\n        overviewTheListOfAuthorized: \"Revise la lista de las cuentas autorizadas,Complete el inicio de sesi\\xf3n haciedo click a countinuacion.\",\n        finish: \"Finalizar\"\n    },\n    install: {\n        youllNeedToInstall: \"Tendr\\xe1s que instalar\",\n        toContinueAfterInstalling: \"Para continuar, Despues de instalar\",\n        refreshThePage: \"Recarga la pagina\",\n        open: \"Abrir\"\n    },\n    qr: {\n        copiedToClipboard: \"Copiado al Portapapeles\",\n        failedToCopy: \"Fall\\xf3 la copia al Portapapeles\",\n        scanWithYourMobile: \"Busca con tu dispositivo movil\",\n        copyToClipboard: \" Copiar al Portapapeles\",\n        preferTheOfficial: \"\\xbfPrefires el di\\xe1logo oficial de\",\n        open: \"Abrir\"\n    },\n    walletTypes: {\n        hardware: \"Hardware Wallet\",\n        browser: \"Browser Wallet\",\n        injected: \"Wallet Extension\",\n        bridge: \"Bridge Wallet\",\n        mobile: \"Mobile Wallet\",\n        \"instant-link\": \"Instant Wallet\"\n    }\n};\nvar es = {\n    modal: modal$a\n};\nvar modal$9 = {\n    wallet: {\n        connectYourWallet: \"连接你的钱包\",\n        whatIsAWallet: \"什么是钱包？\",\n        secureAndManage: \"保护和管理你的数字资产\",\n        safelyStore: \"安全存储和转移你的加密货币和NFT\",\n        logInToAny: \"登录任何 NEAR 应用\",\n        noNeedToCreate: \"不需要创建新账户或密码。连接你的钱包，即可开始使用！\",\n        getAWallet: \"获取新账户\",\n        useAWallet: \"使用钱包来保护和管理你的 NEAR 资产，无需用户名和密码即可登录任何 NEAR 应用\",\n        connectionFailed: \"连接失败\",\n        connectionSuccessful: \"连接成功\",\n        connected: \"已连接\",\n        connectingTo: \"正在连接\"\n    },\n    ledger: {\n        connectWithLedger: \"连接 Ledger\",\n        makeSureYourLedger: \"确保你的 Ledger 已经安全连接，并且 NEAR 应用已经在你设备上打开\",\n        \"continue\": \"继续\",\n        specifyHDPath: \"指定 HD 路径\",\n        enterYourPreferredHDPath: \"输入你偏好的 HD 路径，然后为任意活跃账户扫码\",\n        scan: \"扫码\",\n        retry: \"重试\",\n        ledgerIsNotAvailable: \"Ledger 不可用\",\n        accessDeniedToUseLedgerDevice: \"访问 Ledger 设备被拒绝\",\n        noAccountsFound: \"没有找到账户\",\n        selectYourAccounts: \"选择你的账户\",\n        connecting1Account: \"正在连接1个账户\",\n        cantFindAnyAccount: \"没有找到任何与这个 Ledger 相关联的账户。请创建新账户于\",\n        \"orConnectAnAnotherLedger.\": \"或连接另一个 Ledger\",\n        connecting: \"正在连接\",\n        ofAccounts: \"个账户\",\n        failedToAutomatically: \"无法自动找到账户ID，请主动提供：\",\n        overviewTheListOfAuthorized: \"请查看已授权的账户列表，点击以下按钮完成登录\",\n        finish: \"完成\"\n    },\n    install: {\n        youllNeedToInstall: \"你将需要安装\",\n        toContinueAfterInstalling: \"以继续。安装完\",\n        refreshThePage: \"请刷新页面\",\n        open: \"打开\"\n    },\n    qr: {\n        copiedToClipboard: \"复制到了剪贴板\",\n        failedToCopy: \"复制到剪贴板失败\",\n        scanWithYourMobile: \"用你的移动设备扫码\",\n        copyToClipboard: \" 复制到剪贴板\",\n        preferTheOfficial: \"希望使用官方对话框于\",\n        open: \"打开\"\n    },\n    walletTypes: {\n        hardware: \"Hardware Wallet\",\n        browser: \"Browser Wallet\",\n        injected: \"Wallet Extension\",\n        bridge: \"Bridge Wallet\",\n        mobile: \"Mobile Wallet\",\n        \"instant-link\": \"Instant Wallet\"\n    }\n};\nvar zh = {\n    modal: modal$9\n};\nvar modal$8 = {\n    wallet: {\n        connectYourWallet: \"Свържете вашия Портфейл\",\n        whatIsAWallet: \"Какво е Портфейл?\",\n        secureAndManage: \"Защитете и управлявайте дигиталните си активи\",\n        safelyStore: \"Съхранявайте и прехвърляйте безопасно вашите крипто и NFT.\",\n        logInToAny: \"Използвайте всяко приложение на NEAR\",\n        noNeedToCreate: \"Няма нужда да създавате нови профили. Свържете портфейла си и сте готови!\",\n        getAWallet: \"Създайте Портфейл\",\n        useAWallet: \"Използвайте портфейла, за да защитите и управлявате активите си на NEAR както и да използвате всяко приложение на NEAR без нужда от потребителски имена и пароли.\",\n        connectionFailed: \"Свързването неуспешно\",\n        connectionSuccessful: \"Свързването успешно\",\n        connected: \"Свързан\",\n        connectingTo: \"Свързване към\",\n        connectingMessage: {\n            injected: \"Потвърдете свързването в прозореца на разширението\",\n            browser: \"Потвърдете свързването в портфейла след пренасочването\",\n            hardware: \"Потвърдете свързването в хардуерния портфейл\",\n            bridge: \"Потвърдете връзката в портфейла\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Свържете се с Ledger\",\n        makeSureYourLedger: \"Уверете се, че вашият Ledger е свързан и че приложението NEAR е отворено нa него.\",\n        \"continue\": \"Продължете\",\n        specifyHDPath: \"Посочете HD път\",\n        enterYourPreferredHDPath: \"Въведете предпочитания HD път, след което сканирайте за активни акаунти.\",\n        scan: \"Сканирайте\",\n        retry: \"Опитайте отново\",\n        ledgerIsNotAvailable: \"Ledger устройството не е достъпно\",\n        accessDeniedToUseLedgerDevice: \"Достъпът за използване на Ledger е отказан\",\n        noAccountsFound: \"Няма намерени профили\",\n        selectYourAccounts: \"Изберете вашите профили\",\n        connecting1Account: \"Свързване на 1 профил\",\n        cantFindAnyAccount: \"Няма намерени профили, съврзани с този Ledger. Моля, създайте нов NEAR профил на\",\n        orConnectAnAnotherLedger: \"или свържете друг Ledger.\",\n        connecting: \"Свързване\",\n        ofAccounts: \"от профили\",\n        failedToAutomatically: \"Автоматичното намиране на профила не бе успешно. Въведете го ръчно:\",\n        overviewTheListOfAuthorized: \"Прегледайте списъка с упълномощени профили, завършете влизането, като щракнете върху бутона по-долу..\",\n        finish: \"Завършете\"\n    },\n    install: {\n        youllNeedToInstall: \"Ще трябва да инсталирате\",\n        toContinueAfterInstalling: \"за да продължите. След инсталиране\",\n        refreshThePage: \"презаредете страницата.\",\n        open: \"Отворете\"\n    },\n    qr: {\n        copiedToClipboard: \"Копирано в клипборда\",\n        failedToCopy: \"Неуспешно копиране в клипборда\",\n        scanWithYourMobile: \" Сканирайте с мобилното си устройство\",\n        copyToClipboard: \" Копирайте в клипборда\",\n        preferTheOfficial: \"Предпочитан език за кореспонденция\",\n        open: \"Отворете\"\n    },\n    walletTypes: {\n        hardware: \"Hardware Wallet\",\n        browser: \"Browser Wallet\",\n        injected: \"Wallet Extension\",\n        bridge: \"Bridge Wallet\",\n        mobile: \"Mobile Wallet\",\n        \"instant-link\": \"Instant Wallet\"\n    }\n};\nvar bg = {\n    modal: modal$8\n};\nvar modal$7 = {\n    wallet: {\n        connectYourWallet: \"지갑 연결하기\",\n        whatIsAWallet: \"지갑은 무슨 역할을 하나요?\",\n        secureAndManage: \"당신의 디지털 자산을 보호하고 관리합니다.\",\n        safelyStore: \"암호화폐와 NFT를 안전하게 저장하고 전송할 수 있습니다.\",\n        logInToAny: \"NEAR App에 로그인합니다.\",\n        noNeedToCreate: \"새로운 계정이나 비밀번호를 만들 필요 없이 지갑을 연결한 후 바로 사용할 수 있습니다.\",\n        getAWallet: \"지갑 가져오기\",\n        useAWallet: \"지갑을 사용하여 NEAR 자산을 보호\\xb7관리하고, 아이디와 비밀번호 없이 NEAR 앱에 로그인할 수 있습니다.\",\n        connectionFailed: \"연결 실패\",\n        connectionSuccessful: \"연결 성공\",\n        connected: \"Connected\",\n        connectingTo: \"연결 중: \",\n        connectingMessage: {\n            injected: \"익스텐션 창에서 연결을 확인하세요\",\n            browser: \"리다이렉트 된 지갑에서 연결을 확인하세요\",\n            hardware: \"Ledger 기기에서 연결을 확인하세요\",\n            bridge: \"지갑에서 연결 확인\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Ledger 연결하기\",\n        makeSureYourLedger: \"Ledger가 안전하게 연결되어 있고, NEAR 앱이 열려 있는 지 확인하세요\",\n        \"continue\": \"계속하기\",\n        specifyHDPath: \"HD Path 지정하기\",\n        enterYourPreferredHDPath: \"원하는 HD Path를 선택하고, 활성화된 계정이 있는 지 검색하세요\",\n        scan: \"검색\",\n        retry: \"다시 시도\",\n        ledgerIsNotAvailable: \"Ledger를 사용할 수 없습니다\",\n        accessDeniedToUseLedgerDevice: \"Ledger 기기 접근 권한이 거부되었습니다\",\n        noAccountsFound: \"계정을 찾을 수 없습니다\",\n        selectYourAccounts: \"계정 선택하기\",\n        connecting1Account: \"하나의 계정에 연결\",\n        cantFindAnyAccount: \"Ledger와 연결된 계정을 찾을 수 없습니다. 새로운 계정을 생성하거나 \",\n        orConnectAnAnotherLedger: \"다른 Ledger를 연결하세요\",\n        connecting: \"계정 연결하기: \",\n        ofAccounts: \"개 계정을 찾았습니다\",\n        failedToAutomatically: \"계정 ID를 찾지 못했습니다. 수동으로 입력해주세요.\",\n        overviewTheListOfAuthorized: \"인증된 계정 목록을 확인한 후 아래 버튼을 클릭하여 로그인을 완료하세요\",\n        finish: \"완료\"\n    },\n    walletTypes: {\n        hardware: \"하드웨어 지갑\",\n        browser: \"브라우저 지갑\",\n        injected: \"지갑 확장\",\n        bridge: \"브리지 지갑\",\n        mobile: \"모바일 지갑\",\n        \"instant-link\": \"인스턴트 지갑\"\n    },\n    install: {\n        youllNeedToInstall: \"다음 확장 프로그램을 설치해주세요:\",\n        toContinueAfterInstalling: \". 설치 완료 후 페이지 새로 고침이 필요합니다. \",\n        refreshThePage: \"새로 고침\",\n        open: \"Open\"\n    },\n    qr: {\n        copiedToClipboard: \"클립보드에 복사 완료\",\n        failedToCopy: \"클립보드에 복사 실패\",\n        scanWithYourMobile: \"모바일 장치를 사용하여 스캔해주세요\",\n        copyToClipboard: \" 클립보드에 복사하기\",\n        preferTheOfficial: \"다음 프로그램에서 제공하는 공식 프로세스를 선호하십니까: \",\n        open: \"Open\"\n    }\n};\nvar ko = {\n    modal: modal$7\n};\nvar modal$6 = {\n    wallet: {\n        connectYourWallet: \"Kết nối v\\xed của bạn\",\n        whatIsAWallet: \"V\\xed l\\xe0 g\\xec?\",\n        secureAndManage: \"Bảo mật & Quản l\\xfd t\\xe0i sản số của bạn\",\n        safelyStore: \"Lưu trữ v\\xe0 chuyển tiền điện tử v\\xe0 NFT của bạn một c\\xe1ch an to\\xe0n.\",\n        logInToAny: \"Đăng nhập v\\xe0o bất kỳ ứng dụng tr\\xean NEAR\",\n        noNeedToCreate: \"Kh\\xf4ng cần tạo t\\xe0i khoản hoặc th\\xf4ng tin đăng nhập mới. Kết nối v\\xed của bạn v\\xe0 bắt đầu!\",\n        getAWallet: \"Tạo V\\xed\",\n        useAWallet: \"Sử dụng v\\xed để bảo mật v\\xe0 quản l\\xfd t\\xe0i sản tr\\xean NEAR của bạn v\\xe0 đăng nhập v\\xe0o bất kỳ ứng dụng NEAR n\\xe0o, kh\\xf4ng cần t\\xean người d\\xf9ng v\\xe0 mật khẩu.\",\n        connectionFailed: \"Kết nối thất bại\",\n        connectionSuccessful: \"Kết nối th\\xe0nh c\\xf4ng\",\n        connected: \"Đ\\xe3 kết nối\",\n        connectingTo: \"Đang kết nối tới\",\n        connectingMessage: {\n            injected: \"X\\xe1c nhận kết nối trong cửa sổ tiện \\xedch mở rộng\",\n            browser: \"X\\xe1c nhận kết nối trong v\\xed sau khi được chuyển hướng\",\n            hardware: \"X\\xe1c nhận kết nối với v\\xed lạnh\",\n            bridge: \"X\\xe1c nhận kết nối trong v\\xed\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Kết nối v\\xed Ledger\",\n        makeSureYourLedger: \"Đảm bảo Ledger của bạn được kết nối an to\\xe0n v\\xe0 ứng dụng NEAR đang mở sẵn tr\\xean thiết bị\",\n        \"continue\": \"Tiếp tục\",\n        specifyHDPath: \"Chỉ định HD Path\",\n        enterYourPreferredHDPath: \"Nhập HD Path của bạn, sau đ\\xf3 qu\\xe9t t\\xecm c\\xe1c t\\xe0i khoản hoạt động\",\n        scan: \"Qu\\xe9t\",\n        retry: \"Thử lại\",\n        ledgerIsNotAvailable: \"Ledger kh\\xf4ng khả dụng\",\n        accessDeniedToUseLedgerDevice: \"Truy cập Ledger bị từ chối\",\n        noAccountsFound: \"Kh\\xf4ng t\\xecm thấy t\\xe0i khoản\",\n        selectYourAccounts: \"Chọn t\\xe0i khoản của bạn\",\n        connecting1Account: \"Đang kết nối 1 t\\xe0i khoản\",\n        cantFindAnyAccount: \"Kh\\xf4ng thể t\\xecm thấy bất kỳ t\\xe0i khoản n\\xe0o được li\\xean kết với Ledger n\\xe0y. Vui l\\xf2ng tạo một t\\xe0i khoản NEAR mới\",\n        orConnectAnAnotherLedger: \"hoặc kết nối với v\\xed Ledger kh\\xe1c.\",\n        connecting: \"Đang kết nối\",\n        ofAccounts: \"của t\\xe0i khoản\",\n        failedToAutomatically: \"Kh\\xf4ng thể tự động t\\xecm id t\\xe0i khoản. Nhập thủ c\\xf4ng:\",\n        overviewTheListOfAuthorized: \"Tổng quan danh s\\xe1ch c\\xe1c t\\xe0i khoản được ủy quyền, ho\\xe0n tất đăng nhập bằng c\\xe1ch bấm v\\xe0o n\\xfat b\\xean dưới.\",\n        finish: \"Ho\\xe0n th\\xe0nh\"\n    },\n    install: {\n        youllNeedToInstall: \"Bạn sẽ cần c\\xe0i đặt\",\n        toContinueAfterInstalling: \"để bắt đầu. Sau khi c\\xe0i đặt xong\",\n        refreshThePage: \"Tải lại trang.\",\n        open: \"Mở\"\n    },\n    qr: {\n        copiedToClipboard: \"Đ\\xe3 sao ch\\xe9p v\\xe0o bảng ghi tạm\",\n        failedToCopy: \"Sao ch\\xe9p v\\xe0o bảng ghi tạm thất bại\",\n        scanWithYourMobile: \"Qu\\xe9t với điện thoại của bạn\",\n        copyToClipboard: \" Sao ch\\xe9p v\\xe0o bảng ghi tạm\",\n        preferTheOfficial: \"Dialogue ch\\xednh thức của\",\n        open: \"Mở\"\n    },\n    walletTypes: {\n        hardware: \"V\\xed lạnh\",\n        browser: \"V\\xed tr\\xecnh duyệt\",\n        injected: \"V\\xed tiện \\xedch mở rộng\",\n        bridge: \"V\\xed Cầu\",\n        mobile: \"V\\xed Mobile\",\n        \"instant-link\": \"V\\xed tức th\\xec\"\n    },\n    exportAccounts: {\n        chooseAWallet: \"Chọn v\\xed\",\n        transferYourAccounts: \"Chuyển t\\xe0i khoản\",\n        selectAWallet: \"Chọn v\\xed ph\\xf9 hợp với nhu cầu của bạn, v\\xed được chọn cần hỗ trợ c\\xe1c t\\xe0i khoản đang sử dụng.\",\n        selectYourAccounts: \"Chọn t\\xe0i khoản\",\n        afterDecide: \"Sau khi chọn được t\\xe0i khoản bạn c\\xf3 chuyển.\",\n        disclaimer: \"Bạn kh\\xf4ng thể chuyển t\\xe0i khoản nếu t\\xe0i khoản đ\\xf3 chưa được nhận tiền hoặc chưa ph\\xe1t sinh giao dịch tr\\xean NEAR.\",\n        warning: \"kh\\xf4ng hỗ trợ xuất t\\xe0i khoản. Vui l\\xf2ng chọn v\\xed kh\\xe1c.\",\n        walletTypes: {\n            hardware: \"V\\xed lạnh\",\n            browser: \"V\\xed tr\\xecnh duyệt\",\n            injected: \"V\\xed tiện \\xedch mở rộng\",\n            bridge: \"V\\xed Cầu\",\n            mobile: \"V\\xed Mobile\"\n        },\n        selectAccounts: {\n            title: \"Chọn t\\xe0i khoản để chuyển\",\n            button: \"Lấy cụm mật khẩu\",\n            deselectAll: \"Bỏ chọn tất cả\",\n            selectAll: \"Chọn tất cả\",\n            unavailable: \"Chuyển kh\\xf4ng khả dụng\",\n            error: \"T\\xe0i khoản kh\\xf4ng tồn tại\",\n            warningLedger: \"Y\\xeau cầu hỗ trợ Ledger\",\n            noBalance: \"T\\xe0i khoản trống\"\n        },\n        getPassphrase: {\n            title: \"Sao ch\\xe9p mật khẩu tạm thời\",\n            desc: \"Bạn sẽ cần nhập mật khẩu khi bắt đầu xuất c\\xe1c khoản tới v\\xed kh\\xe1c.\",\n            button: \"Tiếp tục\",\n            label: \"Bấm để sao ch\\xe9p\",\n            checkLabel: \"T\\xf4i đ\\xe3 ch\\xe9p hoặc ghi lại mật khẩu\"\n        },\n        complete: {\n            title: \"Ho\\xe0n th\\xe0nh chuyển\",\n            descOne: \"Bạn sẽ được chuyển hướng tới t\\xe0i khoản đ\\xe3 chọn để ho\\xe0n tất qu\\xe1 tr\\xecnh.\",\n            descTwo: \"Sau khi nhập, nhấn n\\xfat để ho\\xe0n tất quy tr\\xecnh chuyển.\",\n            button: \"Ho\\xe0n th\\xe0nh\"\n        }\n    }\n};\nvar component = {\n    clickToCopy: {\n        label: \"Đ\\xe3 sao ch\\xe9p\",\n        tooltip: \"Bấm để sao ch\\xe9p\"\n    }\n};\nvar vi = {\n    modal: modal$6,\n    component: component\n};\nvar modal$5 = {\n    wallet: {\n        connectYourWallet: \"अपना वॉलेट (Wallet) कनेक्ट करें।\",\n        whatIsAWallet: \"वॉलेट क्या है?\",\n        secureAndManage: \"सुरक्षित और प्रबंधित करें।\",\n        safelyStore: \"अपनी क्रिप्टोकरेंसी और एनएफटी को सुरक्षित रूप से स्टोर और ट्रांसफर करें।\",\n        logInToAny: \"NEAR पर किसी भी ऐप में साइन इन करें।\",\n        noNeedToCreate: \"नए खाते या लॉगिन बनाने की आवश्यकता नहीं है। अपना वॉलेट(NEAR Wallet)कनेक्ट करें और आरंभ करें।\",\n        getAWallet: \"एक वॉलेट बनाएँ।\",\n        useAWallet: \"अपनी NEAR संपत्तियों को सुरक्षित और प्रबंधित करने के लिए वॉलेट का उपयोग करें और किसी भी NEAR ऐप (app) में लॉग इन करें, किसी उपयोगकर्ता (user) नाम और पासवर्ड की आवश्यकता नहीं है।\",\n        connectionFailed: \"कनेक्शन विफल|\",\n        connectionSuccessful: \"कनेक्शन सफल|\",\n        connected: \"वॉलेट जुड़ गया|\",\n        connectingTo: \"वॉलेट जुड़ रहा हे|\",\n        connectingMessage: {\n            injected: \"एक्सटेंशन विंडो में कनेक्शन की पुष्टि करें|\",\n            browser: \"रीडायरेक्ट होने के बाद वॉलेट में कनेक्शन की पुष्टि करें|\",\n            hardware: \"कोल्ड वॉलेट के साथ कनेक्शन की पुष्टि करें|\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"लेजर(Ledger)वॉलेट कनेक्ट करें|\",\n        makeSureYourLedger: \"सुनिश्चित करें कि आपका लेजर सुरक्षित रूप से जुड़ा हुआ है और NEAR ऐप आपके डिवाइस (Device)पर पहले से ही खुला है|\",\n        \"continue\": \"जारी रखे|\",\n        specifyHDPath: \"हार्ड डिस्क(Hard Disk)पथ(Path)निर्धारित करे|\",\n        enterYourPreferredHDPath: \"अपना एचडी पथ दर्ज करें, फिर सक्रिय खातों के लिए स्कैन करें|\",\n        scan: \"स्कैन करे|\",\n        retry: \"दोबारा प्रयास करे|\",\n        ledgerIsNotAvailable: \"लेजर उपलब्ध नहीं है|\",\n        accessDeniedToUseLedgerDevice: \"लेजर डिवाइस का उपयोग करने के लिए प्रवेश निषेध|\",\n        noAccountsFound: \"खाता नहीं मिला|\",\n        selectYourAccounts: \"अपने खाते चुनें|\",\n        connecting1Account: \"एक खाता कनेक्ट हो रहा है|\",\n        cantFindAnyAccount: \"इस लेजर से जुड़ा कोई खाता नहीं मिला। कृपया एक नया NEAR खाता बनाएँ|\",\n        orConnectAnAnotherLedger: \"अथवा दूसरे लेजर वॉलेट से कनेक्ट करें।\",\n        connecting: \"जुड़ रहा हे|\",\n        ofAccounts: \"खाता अब जुड़ा नहीं हे|\",\n        failedToAutomatically: \"खाता आईडी स्वचालित रूप से खोजने में असमर्थ। मैन्युअल (Manuall) रूप से कोशिश करें|\",\n        overviewTheListOfAuthorized: \"अवलोकन अधिकृत की सूची, नीचे दिए गए बटन पर क्लिक करके लॉगिन पूरा करें।\",\n        finish: \"समाप्त|\"\n    },\n    install: {\n        youllNeedToInstall: \"आपको इंस्टॉल करना होगा|\",\n        toContinueAfterInstalling: \"इंस्टॉल करने के बाद जारी रखे|\",\n        refreshThePage: \"पुन: लोड करें।\",\n        open: \"खोले|\"\n    },\n    qr: {\n        copiedToClipboard: \"क्लिपबोर्ड(Clipboard)पर कॉपी किया गया|\",\n        failedToCopy: \"क्लिपबोर्ड पर कॉपी करना विफल रहा|\",\n        scanWithYourMobile: \"अपने फोन (Mobile)से स्कैन करें|\",\n        copyToClipboard: \" क्लिपबोर्ड पर कॉपी करें|\",\n        preferTheOfficial: \"आधिकारिक संवाद को प्राथमिकता दें|\",\n        open: \"खोले|\"\n    },\n    walletTypes: {\n        hardware: \"Hardware Wallet\",\n        browser: \"Browser Wallet\",\n        injected: \"Wallet Extension\",\n        bridge: \"Bridge Wallet\",\n        mobile: \"Mobile Wallet\",\n        \"instant-link\": \"Instant Wallet\"\n    }\n};\nvar hi = {\n    modal: modal$5\n};\nvar modal$4 = {\n    wallet: {\n        connectYourWallet: \"صل محفظتك\",\n        whatIsAWallet: \"ما هي المحفظة؟\",\n        secureAndManage: \"تأمين وإدارة الممتلكات الرقمية الخاصة بك\",\n        safelyStore: \"قم بتخزين و ارسال عملاتك و أصولك الرقمية بأمان\",\n        logInToAny: \"سجل الدخول إلى أي تطبيق يستخدم نير\",\n        noNeedToCreate: \".لا داعي لإنشاء حساب جديد. فقط قم بتوصيل محفظتك وانطلق\",\n        getAWallet: \"احصل على محفظة\",\n        useAWallet: \"استخدم محفظة لتأمين وإدارة أصول نير الخاصة بك، وادخل لأي تطبيق يستخدم نير دون الحاجة إلى اسم المستخدم وكلمةالمرور\",\n        connectionFailed: \"اتصال فاشل\",\n        connectionSuccessful: \"اتصال ناجح\",\n        connected: \"متصل\",\n        connectingTo: \"جاري الاتصال ب\",\n        connectingMessage: {\n            injected: \"وافق على الاتصال في نافذة الإضافة\",\n            browser: \"وافق على الاتصال في المحفظة بعد إعادة توجيه\",\n            hardware: \"وافق على الاتصال في جهاز ليدجر\",\n            bridge: \"وافق على الاتصال في المحفظة\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"اتصل مع ليدجر\",\n        makeSureYourLedger: \"تأكد أن ليدجر متصل بأمان, و أن تطبيق نير مفتوح في جهازك\",\n        \"continue\": \"تابع\",\n        specifyHDPath: \"حدد مسار الحساب\",\n        enterYourPreferredHDPath: \"أدخل مسار الحساب المفضل، ثم ابحث عن كل الحسابات النشطة\",\n        scan: \"مسح\",\n        retry: \"أعد المحاولة\",\n        ledgerIsNotAvailable: \"ليدجر غير متوفر\",\n        accessDeniedToUseLedgerDevice: \"تم رفض الاتصال بليدجر\",\n        noAccountsFound: \"لم يتم العثور على أي حسابات\",\n        selectYourAccounts: \"حدد حساباتك\",\n        connecting1Account: \"جاري الاتصال بحساب واحد\",\n        cantFindAnyAccount: \"لا يمكن العثور على أي حساب مرتبط بهذا ليدجر الرجاء إنشاء حساب نير جديد على\",\n        orConnectAnAnotherLedger: \"او اربط جهاز ليدجر آخر\",\n        connecting: \"جاري الاتصال\",\n        ofAccounts: \"من الحسابات\",\n        failedToAutomatically: \"فشل في الاتصال بالحساب تلقائيا. يرجى الاتصال بالحساب يدويا\",\n        overviewTheListOfAuthorized: \"لائحة الحسابات المصرح بها, أكمل تسجيل الدخول بالنقر على الزر أدناه\",\n        finish: \"إنهاء\"\n    },\n    install: {\n        youllNeedToInstall: \"ستحتاج لتثبيت\",\n        toContinueAfterInstalling: \"للاستكمال. بعد التثبيت\",\n        refreshThePage: \"قم بتحديث الصفحة\",\n        open: \"افتح\"\n    },\n    qr: {\n        copiedToClipboard: \"تم النسخ\",\n        failedToCopy: \"فشل النسخ\",\n        scanWithYourMobile: \"امسح بجهازك المحمول\",\n        copyToClipboard: \"نسخ\",\n        preferTheOfficial: \"تفضل الحوار الرسمي ل\",\n        open: \"فتح\"\n    },\n    walletTypes: {\n        hardware: \"Hardware Wallet\",\n        browser: \"Browser Wallet\",\n        injected: \"Wallet Extension\",\n        bridge: \"Bridge Wallet\",\n        mobile: \"Mobile Wallet\",\n        \"instant-link\": \"Instant Wallet\"\n    }\n};\nvar ar = {\n    modal: modal$4\n};\nvar modal$3 = {\n    wallet: {\n        connectYourWallet: \"Spojite crypto novčanik!\",\n        whatIsAWallet: \"Što je to crypto novčanik?\",\n        secureAndManage: \"Osigurajte i upravljajte svojom digitalnom imovinom.\",\n        safelyStore: \"Sigurno pohranite i prebacite svoj crypto i NFT-eve.\",\n        logInToAny: \" Prijavite se u bilo koju NEAR aplikaciju\",\n        noNeedToCreate: \"Nema potrebe za stvaranjem novih naloga ili korisničkih podataka. Spojite svoj crypto novčanik i spremni ste!\",\n        getAWallet: \"Otvorite crypto novčanik\",\n        useAWallet: \"Koristite crypto novčanik da biste osigurali i upravljali svojom NEAR imovinom, te se prijavite u bilo koju NEAR aplikaciju bez korisničkog imena i lozinke.\",\n        connectionFailed: \"Neuspješno povezivanje.\",\n        connectionSuccessful: \"Uspješno povezivanje.\",\n        connected: \"Povezano.\",\n        connectingTo: \"Povezivanje u tijeku\",\n        connectingMessage: {\n            injected: \"Potvrdite vezu u eksternom prozoru\",\n            browser: \"Nakon redirekcije, potvrdite vezu u novčaniku\",\n            hardware: \"Potvrdite vezu sa novčanikom\",\n            bridge: \"Potvrdite vezu u novčaniku\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Povežite se hardverskim novčanikom\",\n        makeSureYourLedger: \"Osigurajte sigurnu vezu s hardverskim novčanikom, te da je NEAR aplikacija otvorena na vašem uređaju\",\n        \"continue\": \"Nastavite\",\n        specifyHDPath: \"Specificirajte HD putanju\",\n        enterYourPreferredHDPath: \"Upišite preferiranu HD putanju, zatim skenirajte aktivne naloge\",\n        scan: \"Skenirajte\",\n        retry: \"Pokušajte ponovno\",\n        ledgerIsNotAvailable: \"Hardverski novčanik nije dostupan.\",\n        accessDeniedToUseLedgerDevice: \"Odbijen pristup za korištenjem hardverskog novčanika\",\n        noAccountsFound: \"Nalozi nisu pronađeni\",\n        selectYourAccounts: \"Odaberite svoje naloge\",\n        connecting1Account: \"Povezivanje 1 naloga\",\n        cantFindAnyAccount: \"Nije moguće pronaći niti jedan nalog povezan s ovim hardverskim novčanikom. Molimo vas, kreirajte novi NEAR nalog\",\n        orConnectAnAnotherLedger: \"Ili povežite drugi hardverski novčanik.\",\n        connecting: \"Povezivanje\",\n        ofAccounts: \"naloga\",\n        failedToAutomatically: \"Neuspješno automatsko pronalaženje ID naloga. Unesite ručno:\",\n        overviewTheListOfAuthorized: \"Pregledajte popis odobrenih naloga, završite prijavu pritiskom na niže prikazani gumb.\",\n        finish: \"Završite\"\n    },\n    install: {\n        youllNeedToInstall: \" Potrebno je instalirati modal\",\n        toContinueAfterInstalling: \"za nastavak. Nakon instalacije\",\n        refreshThePage: \"osvježite stranicu.\",\n        open: \"Otvorite QR modal\"\n    },\n    qr: {\n        copiedToClipboard: \"Kopirano u međuspremnik\",\n        failedToCopy: \"Neupsješno kopiranje u međuspremnik\",\n        scanWithYourMobile: \"Skenirajte svojim mobilnim uređajem\",\n        copyToClipboard: \" Kopirajte u međuspremnik\",\n        preferTheOfficial: \"Odaberite službeni dijalog\",\n        open: \"Otvorite\"\n    },\n    walletTypes: {\n        hardware: \"Hardware Wallet\",\n        browser: \"Browser Wallet\",\n        injected: \"Wallet Extension\",\n        bridge: \"Bridge Wallet\",\n        mobile: \"Mobile Wallet\",\n        \"instant-link\": \"Instant Wallet\"\n    },\n    exportAccounts: {\n        chooseAWallet: \"Odaberi Wallet\",\n        transferYourAccounts: \"Prenesi svoje naloge\",\n        selectAWallet: \"Odaberite wallet koji odgovara vašim potrebama i podržava vaše povezane naloge.\",\n        selectYourAccounts: \"Odaberi svoje naloge\",\n        afterDecide: \"Nakon što odlučite koji wallet koristite, možete odabrati koje račune želite prebaciti.\",\n        disclaimer: \"Nećete moći prebaciti naloge koji nisu nikada bili korišteni na NEAR-u.\",\n        warning: \"ne podržava izvoz naloga u ovom trenutku. Molimo odaberite drugi wallet.\",\n        walletTypes: {\n            hardware: \"Hardware Wallet\",\n            browser: \"Browser Wallet\",\n            injected: \"Wallet Extension\",\n            bridge: \"Bridge Wallet\",\n            mobile: \"Mobile Wallet\"\n        },\n        selectAccounts: {\n            title: \"Odaberi naloge za prijenos\",\n            button: \"Generiraj lozinku\",\n            deselectAll: \"Makni odabir sa svih\",\n            selectAll: \"Odaberi sve\",\n            unavailable: \"Prijenos nije dostupan\",\n            error: \"Nalog ne postoji\",\n            warningLedger: \"Potrebna ledger podrška\",\n            noBalance: \"Nalog nema sredstava\"\n        },\n        getPassphrase: {\n            title: \"Kopiraj privremenu lozinku\",\n            desc: \"Bit će potrebno unijeti ovu lozinku na početku izvoza naloga na drugi wallet.\",\n            button: \"Nastavi\",\n            label: \"Klikni za kopiju\",\n            checkLabel: \"Kopirao sam ili zapisao lozinku\"\n        },\n        complete: {\n            title: \"Završi prijenos\",\n            descOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n            descTwo: \"Kada je unos s odabranog walleta završen, pritisnite gumb da biste završili prijenos.\",\n            button: \"Završi\"\n        }\n    }\n};\nvar hr = {\n    modal: modal$3\n};\nvar modal$2 = {\n    wallet: {\n        connectYourWallet: \"Поврзете го вашиот новчаник!\",\n        whatIsAWallet: \"Што е новчаник?\",\n        secureAndManage: \"Заштитете ги и управувајте со вашите дигитални средства.\",\n        safelyStore: \"Безбедно складирајте и извршувајте трансакции со вашите крипто и NFT.\",\n        logInToAny: \"Најавете се на која било NEAR апликација\",\n        noNeedToCreate: \"Нема потреба да креирате нови сметки или ингеренции. Поврзете го вашиот паричник и сте подготвени!\",\n        getAWallet: \"Направете новчаник\",\n        useAWallet: \"Користете паричник за да ги заштитите и управувате вашите NEAR средства и да се најавите на која било NEAR апликација без потреба од кориснички имиња и лозинки.\",\n        connectionFailed: \"Поврзувањето не беше успешно.\",\n        connectionSuccessful: \"Успешно поврзување.\",\n        connected: \"Поврзано.\",\n        connectingTo: \"Поврзување со\",\n        connectingMessage: {\n            injected: \"Потврдете го поврзувањето во екстерниот прозорец\",\n            browser: \"По преусмерувањето, потврдете го поврзувањето од новчаниокт\",\n            hardware: \"Потврдете го поврзувањето со ладен новчаник\",\n            bridge: \"Потврдете ја врската во новчаникот\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Поврзете се со Леџер\",\n        makeSureYourLedger: \"Осигурајте се дека вашиот Леџер е поврзан безбедно, и дека NEAR апликацијата е отворена на вашиот уред\",\n        \"continue\": \"Продолжете\",\n        specifyHDPath: \"Наведете ХД локација\",\n        enterYourPreferredHDPath: \"Внесете ја вашата преферирана ХД локација, а потоа скенирајте да ги најдете активните сметки.\",\n        scan: \"Скенирајте\",\n        retry: \"Обидете се повторно\",\n        ledgerIsNotAvailable: \"Леџерот не е достапен.\",\n        accessDeniedToUseLedgerDevice: \"Пристапот за користење на Леџер уред е одбиен\",\n        noAccountsFound: \"Нема најдени сметки\",\n        selectYourAccounts: \"Изберете ги вашите сметки\",\n        connecting1Account: \"Поврзување на една сметка\",\n        cantFindAnyAccount: \"Не се најдени сметки поврзани со овој Леџер. Ве молиме креирајте нова NEAR сметка \",\n        orConnectAnAnotherLedger: \"или поврзете друг Леџер.\",\n        connecting: \"Поврзување\",\n        ofAccounts: \"на сметки\",\n        failedToAutomatically: \"Неуспешно автоматско барање на ИД на сметката. Внесете го рачно:\",\n        overviewTheListOfAuthorized: \"Преглед на листата на овластени сметки, завршете се најавата со кликнување на копчето подолу.\",\n        finish: \"Завршете\"\n    },\n    install: {\n        youllNeedToInstall: \"Треба да инсталирате\",\n        toContinueAfterInstalling: \"за да продолжите. По инсталирањето\",\n        refreshThePage: \"Освежете ја страната.\",\n        open: \"Отворете\"\n    },\n    qr: {\n        copiedToClipboard: \"Копирано на клипбордот\",\n        failedToCopy: \"Неуспешно копирање на клипборд\",\n        scanWithYourMobile: \"Скенирајте со вашиот телефонски уред\",\n        copyToClipboard: \"Копирајте на клипборд\",\n        preferTheOfficial: \"Преферирајте официјален диалог на\",\n        open: \"Отворете\"\n    },\n    walletTypes: {\n        hardware: \"Хардверски новчаник\",\n        browser: \"Новчаник на интернет прелистувач\",\n        injected: \"Екстензија за новчаник\",\n        bridge: \"Bridge новчаник\",\n        mobile: \"Мобилен новчаник\",\n        \"instant-link\": \"Инстант паричник\"\n    },\n    exportAccounts: {\n        chooseAWallet: \"Одберете паричник\",\n        transferYourAccounts: \"Префрлете ги вашите кориснички сметки\",\n        selectAWallet: \"Изберетен новчаник кој ги задоволува вашите баранња и ги поддржува вашите поврзани кориснички сметки.\",\n        selectYourAccounts: \"Изберете ги вашите кориснички сметки\",\n        afterDecide: \"Одкако ќе изберете новчаник, можете да изберете кои кориснички сметки сакате да ги префрлите.\",\n        disclaimer: \"Не можете да прфрлате кориснички сметки кои никогаш не биле надополнати или користени на NEAR.\",\n        warning: \"не поддржува извезување на кориснички сметки во овој момент. Ве молиме изберете друг новчаник.\",\n        walletTypes: {\n            hardware: \"Хардверски новчаник\",\n            browser: \"Новчаник на интернет прелистувач\",\n            injected: \"Екстензија за новчаник\",\n            bridge: \"Bridge новчаник\",\n            mobile: \"Мобилен новчаник\"\n        },\n        selectAccounts: {\n            title: \"Изберете ги корисничките сметки за да ги префрлите.\",\n            button: \"Добијте лозинка\",\n            deselectAll: \"Отселектирајте се\",\n            selectAll: \"Изберете се\",\n            unavailable: \"Трансферот е недостапен\",\n            error: \"Корисничката сметка не постои\",\n            warningLedger: \"Потребна е поддршка од Леџер\",\n            noBalance: \"Сметката не е финансирана\"\n        },\n        getPassphrase: {\n            title: \"Копирајте ја привремената лозинка\",\n            desc: \"Ќе треба да ја внесете оваа лозинка кога ќе започнете да ги извезувате вашите сметки на друг новчаник.\",\n            button: \"Продолжете\",\n            label: \"Кликнете за да копирате\",\n            checkLabel: \"Ја копирав или запишав лозинката\"\n        },\n        complete: {\n            title: \"Завршете го преносот\",\n            descOne: \"Сега ќе бидете пренасочени на избраниот новчаник за завршување на преносот.\",\n            descTwo: \"Откако ќе заврши увозот од избраниот новчаник, притиснете го копчето за да го завршите преносот.\",\n            button: \"Завршете\"\n        }\n    }\n};\nvar mk = {\n    modal: modal$2\n};\nvar modal$1 = {\n    wallet: {\n        connectYourWallet: \"Povežite svojo denarnico!\",\n        whatIsAWallet: \"Kaj je denarnica?\",\n        secureAndManage: \"Zavarujte in upravljajte svoja digitalna sredstva.\",\n        safelyStore: \"Varno shranjujte in prenašajte svoje kriptovalute in NFTje.\",\n        logInToAny: \"Prijavite se v katero koli aplikacijo na NEAR\",\n        noNeedToCreate: \"Ni vam treba ustvarjati novih računov. Povežite svojo denarnico in začnite!\",\n        getAWallet: \"Ustvarite denarnico\",\n        useAWallet: \"Uporabite denarnico, da bi zavarovali in upravljali s svoja NEAR digitalna sredstva, in se prijavite v katero koli aplikacijo ekosistema NEAR\",\n        connectionFailed: \"Povezava ni bila uspešna.\",\n        connectionSuccessful: \"Povezava je bila uspešna.\",\n        connected: \"Vaša denarnica je povezana.\",\n        connectingTo: \"Povezovanje z\",\n        connectingMessage: {\n            injected: \"Potrdite povezavo v oknu razširitve\",\n            browser: \"Po preusmeritvi potrdite povezavo v denarnici\",\n            hardware: \"Potrdite povezavo s hladno denarnico\",\n            bridge: \"Potrdite povezavo v denarnici\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Povežite se z Ledger\",\n        makeSureYourLedger: \"Prepričajte se, da je vaš Ledger varno povezan in da je aplikacija NEAR odprta v vaši napravi\",\n        \"continue\": \"Nadaljuj\",\n        specifyHDPath: \"Določite HD pot\",\n        enterYourPreferredHDPath: \"Vnesite želeno HD pot, nato poiščite vse aktivne račune.\",\n        scan: \"Skenirajte\",\n        retry: \"Poskusite znova\",\n        ledgerIsNotAvailable: \"Ledger ni na voljo\",\n        accessDeniedToUseLedgerDevice: \"Dostop za uporabo naprave Ledger zavrnjen\",\n        noAccountsFound: \"Ni najdenih računov\",\n        selectYourAccounts: \"Izberite Vaši računi\",\n        connecting1Account: \"Povezovanje enega računa\",\n        cantFindAnyAccount: \"Ni mogoče najti nobenega računa, povezanega s tem Ledgerjem. Ustvarite nov NEAR račun \",\n        orConnectAnAnotherLedger: \"ali povežite drug Ledger..\",\n        connecting: \"Povezovanje\",\n        ofAccounts: \"računov\",\n        failedToAutomatically: \"ID-ja računa ni bilo mogoče samodejno najti. Zagotovite ga ročno:\",\n        overviewTheListOfAuthorized: \"Oglejte si seznam pooblaščenih računov, dokončajte prijavo s klikom na spodnji gumb.\",\n        finish: \"Končajte\"\n    },\n    install: {\n        youllNeedToInstall: \"Morali ga boste namestiti\",\n        toContinueAfterInstalling: \"nadaljevati. Po namestitvi\",\n        refreshThePage: \"Osvežite stran.\",\n        open: \"Odprite\"\n    },\n    qr: {\n        copiedToClipboard: \"Kopirano v podložni mapi\",\n        failedToCopy: \"Kopiranje v podložni mapi ni uspelo\",\n        scanWithYourMobile: \"Skenirajte s svojo mobilno napravo\",\n        copyToClipboard: \" Kopirajte v podložni mapi\",\n        preferTheOfficial: \"Preferirajte uradno pogovorno okno\",\n        open: \"Odprite\"\n    },\n    walletTypes: {\n        hardware: \"Hladna denarnica\",\n        browser: \"Denarnica brskalnika\",\n        injected: \"Razširitev za denarnico\",\n        bridge: \"Bridge denarnica\",\n        mobile: \"Mobilna denarnica\",\n        \"instant-link\": \"Takojšnja denarnica\"\n    },\n    exportAccounts: {\n        chooseAWallet: \"Izberite denarnico\",\n        transferYourAccounts: \"Prenesite svoje račune\",\n        selectAWallet: \"Izberite denarnico, ki ustreza vašim potrebam in podpira vaše povezane račune.\",\n        selectYourAccounts: \"Izberite vaši računi\",\n        afterDecide: \"Ko se odločite za denarnico, lahko izberete, katere račune želite prenesti.\",\n        disclaimer: \"Ne boste mogli prenesti Računov, ki nikoli niso bili financirani ali uporabljeni na NEAR.\",\n        warning: \"trenutno ne podpira izvoza računa. Izberite drugo denarnico\",\n        walletTypes: {\n            hardware: \"Hladna denarnica\",\n            browser: \"Denarnica brskalnika\",\n            injected: \"Razširitev za denarnico\",\n            bridge: \"Bridge denarnica\",\n            mobile: \"Mobilna denarnica\"\n        },\n        selectAccounts: {\n            title: \"Izberite računi za prenos.\",\n            button: \"Pridobite geslo\",\n            deselectAll: \"Prekliči izbiro vseh\",\n            selectAll: \"Izberi vse\",\n            unavailable: \"Prenos ni na voljo\",\n            error: \"Račun ne obstaja\",\n            warningLedger: \"Potrebna je podpora za Ledger\",\n            noBalance: \"Račun ni financiran\"\n        },\n        getPassphrase: {\n            title: \"Kopiraj začasno geslo\",\n            desc: \"To geslo boste morali vnesti, ko boste začeli izvažati svoje račune v drugo denarnico.\",\n            button: \"Nadaljujte\",\n            label: \"Kliknite za kopiranje\",\n            checkLabel: \"Geslo sem kopiral ali zapisal\"\n        },\n        complete: {\n            title: \"Dokončajte prenos\",\n            descOne: \"Zdaj boste preusmerjeni v denarnico, ki ste jo izbrali za dokončanje prenosa.\",\n            descTwo: \"Ko je uvozni del postopka končan iz izbrane denarnice, pritisnite gumb za dokončanje postopka prenosa.\",\n            button: \"Končajte\"\n        }\n    }\n};\nvar sl = {\n    modal: modal$1\n};\nvar modal = {\n    wallet: {\n        connectYourWallet: \"Повежите свој новчаник!\",\n        whatIsAWallet: \"Шта је новчаник?\",\n        secureAndManage: \"Обезбедите и управљајте својом дигиталном имовином.\",\n        safelyStore: \"Безбедно чувајте и преносите своје криптовалуте и NFT.\",\n        logInToAny: \"Пријавите се на било коју апликацију NEAR\",\n        noNeedToCreate: \"Нема потребе да креирате нове налоге или акредитиве. Повежите новчаник и спремни стe!\",\n        getAWallet: \"Набавите новчаник\",\n        useAWallet: \"Користите новчаник да обезбедите и управљате својим NEAR средствима и да се пријавите у било коју апликацију NEAR без потребе за корисничким именима и лозинкама.\",\n        connectionFailed: \"Веза није успостављена.\",\n        connectionSuccessful: \"Веза је успела.\",\n        connected: \"Повезан.\",\n        connectingTo: \"Повезивање на\",\n        connectingMessage: {\n            injected: \"Потврдите везу у спољном прозору\",\n            browser: \"Након преусмеравања, потврдите везу у новчанику\",\n            hardware: \"Потврдите везу са хладним новчаником\",\n            bridge: \"Потврдите везу са новчаником\"\n        }\n    },\n    ledger: {\n        connectWithLedger: \"Повежите се са Ledger\",\n        makeSureYourLedger: \"Уверите се да је ваш Ledger безбедно повезан и да је апликација NEAR отворена на вашем уређају\",\n        \"continue\": \"Настави\",\n        specifyHDPath: \"Наведите ХД путању\",\n        enterYourPreferredHDPath: \"Унесите жељену жељену ХД путању, а затим скенирајте све активне налоге.\",\n        scan: \"Скенирајте\",\n        retry: \"Покушај поново\",\n        ledgerIsNotAvailable: \"Ledger није доступан.\",\n        accessDeniedToUseLedgerDevice: \"Приступ је одбијен за коришћење Ledger уређаја\",\n        noAccountsFound: \"Наlози нису пронађени\",\n        selectYourAccounts: \"Изаберите Ваш наlог\",\n        connecting1Account: \"Повезати 1 наlог\",\n        cantFindAnyAccount: \"Није могуће пронаћи ниједан наlог повезан са овим Ledger-ом. Направите нови NEAR наlог\",\n        orConnectAnAnotherLedger: \"или повежите други Ledger.\",\n        connecting: \"Повезивање\",\n        ofAccounts: \"наlога\",\n        failedToAutomatically: \"Аутоматско проналажење ID-a наlога није успело. Наведите га ручно:\",\n        overviewTheListOfAuthorized: \"Прегледајте листу овлашћених рачуна, завршите пријаву кликом на дугме испод.\",\n        finish: \"Заврши\"\n    },\n    install: {\n        youllNeedToInstall: \"Мораћете да инсталирате\",\n        toContinueAfterInstalling: \"за наставак. Након инсталирања\",\n        refreshThePage: \"поново учитати страницу.\",\n        open: \"Отвори\"\n    },\n    qr: {\n        copiedToClipboard: \"Копирано у међуспремник\",\n        failedToCopy: \"Копирање у међуспремник није успело\",\n        scanWithYourMobile: \"Скенирајте помоћу мобилног уређаја\",\n        copyToClipboard: \" Копирај у међуспремник\",\n        preferTheOfficial: \"Преферирате званични дијалог од\",\n        open: \"Отвори\"\n    },\n    walletTypes: {\n        hardware: \"Хардверски новчаник\",\n        browser: \"Новчаник претраживача,\",\n        injected: \"Додатак за новчаник,\",\n        bridge: \"Bridge новчаник\",\n        mobile: \"Мобилни новчаник\",\n        \"instant-link\": \"Инстант новчаник\"\n    },\n    exportAccounts: {\n        chooseAWallet: \"Изаберите новчаник\",\n        transferYourAccounts: \"Пренесите своје налоге\",\n        selectAWallet: \"Изаберите новчаник који одговара вашим потребама и који подржава ваше повезане налоге.\",\n        selectYourAccounts: \"Изаберите ваше налоге\",\n        afterDecide: \"Након што се одлучите за новчаник, можете изабрати које налоге желите да пренесете.\",\n        disclaimer: \"Нећете моћи да пренесете налоге који никада нису били финансирани или коришћени на  NEAR.\",\n        warning: \"тренутно не подржава извоз налога. Изаберите други новчаник.\",\n        walletTypes: {\n            hardware: \"Хардверски новчаник\",\n            browser: \"Новчаник претраживача,\",\n            injected: \"Додатак за новчаник,\",\n            bridge: \"Bridge новчаник\",\n            mobile: \"Мобилни новчаник\"\n        },\n        selectAccounts: {\n            title: \"Изаберите налоге за пренос.\",\n            button: \"Добијте приступну фразу\",\n            deselectAll: \"Поништите избор\",\n            selectAll: \"Изаберите све\",\n            unavailable: \"Трансфер није доступан\",\n            error: \"Налог не постоји\",\n            warningLedger: \"Потребна подршка за Ledger\",\n            noBalance: \"Налог није финансиран\"\n        },\n        getPassphrase: {\n            title: \"Копирај привремену лозинку\",\n            desc: \"Мораћете да унесете ову лозинку када почнете да извозите своје налоге у други новчаник.\",\n            button: \"Наставите\",\n            label: \"Кликните да бисте копирали\",\n            checkLabel: \"Копирао сам или записао лозинку\"\n        },\n        complete: {\n            title: \"Довршите трансфер\",\n            descOne: \"Сада ћете бити преусмерени на новчаник који сте изабрали да завршите трансфер.\",\n            descTwo: \"Када се део процеса увоза заврши из изабраног новчаника, притисните дугме да завршите процес преноса.\",\n            button: \"Завршите\"\n        }\n    }\n};\nvar sr = {\n    modal: modal\n};\nconst getLanguage = (languageCode)=>{\n    switch(languageCode){\n        case \"en\":\n            return en;\n        case \"es\":\n            return es;\n        case \"zh\":\n            return zh;\n        case \"bg\":\n            return bg;\n        case \"ko\":\n            return ko;\n        case \"vi\":\n            return vi;\n        case \"hi\":\n            return hi;\n        case \"ar\":\n            return ar;\n        case \"hr\":\n            return hr;\n        case \"mk\":\n            return mk;\n        case \"sl\":\n            return sl;\n        case \"sr\":\n            return sr;\n        default:\n            return en;\n    }\n};\nlet chosenLang;\nconst allowOnlyLanguage = (langCode)=>{\n    chosenLang = langCode;\n};\n// (i.e en-CA returns just en)\nconst shortenLanguageCode = (lang)=>{\n    return lang.indexOf(\"-\") !== -1 ? lang.split(\"-\")[0] : lang.split(\"_\")[0];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst findObjectPropByStringPath = (obj, prop)=>{\n    if (!obj) {\n        return \"\";\n    }\n    const _index = prop.indexOf(\".\");\n    if (_index > -1) {\n        const currentProp = prop.substring(0, _index);\n        const nextProp = prop.substring(_index + 1);\n        return findObjectPropByStringPath(obj[currentProp], nextProp);\n    }\n    return obj[prop];\n};\nconst translate = (path)=>{\n    let browserLang = window.navigator.languages ? window.navigator.languages[0] : null;\n    browserLang = browserLang || window.navigator.language;\n    const languageCode = shortenLanguageCode(chosenLang || browserLang);\n    const selectedLanguage = getLanguage(languageCode);\n    const text = findObjectPropByStringPath(selectedLanguage, path);\n    return text && typeof text === \"string\" ? text : path;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2NvcmUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDUTtBQUNTO0FBQ0Y7QUFDcEI7QUFDQztBQUVuQzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsU0FBU1UsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsT0FBT08sb0JBQW9CLGFBQWFBLGtCQUFrQixTQUFVQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsT0FBTztJQUMxRixJQUFJVCxJQUFJLElBQUlVLE1B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bkIsU0FBUyxHQUFHdjRELE9BQU9reEMsU0FBUyxDQUFDcW5CLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDL0VELGNBQWNBLGVBQWV0NEQsT0FBT2t4QyxTQUFTLENBQUNzbkIsUUFBUTtJQUN0RCxNQUFNOXZCLGVBQWVrdkIsb0JBQW9CSCxjQUFjYTtJQUN2RCxNQUFNRyxtQkFBbUJqQixZQUFZOXVCO0lBQ3JDLE1BQU1nd0IsT0FBT1osMkJBQTJCVyxrQkFBa0JKO0lBQzFELE9BQU9LLFFBQVEsT0FBT0EsU0FBUyxXQUFXQSxPQUFPTDtBQUNuRDtBQUUrTCIsInNvdXJjZXMiOlsid2VicGFjazovL2ktYW0tbmVhcmJ5Ly4vbm9kZV9tb2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci9jb3JlL2luZGV4LmpzP2RkMGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbmVhckFQSSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyB1dGlscywgcHJvdmlkZXJzIH0gZnJvbSAnbmVhci1hcGktanMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlciQxIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgU3ViamVjdCwgc2NhbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2VyaWFsaXplIH0gZnJvbSAnYm9yc2gnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnanMtc2hhMjU2JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuY2xhc3MgUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IG5lYXJBUEkucHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcih7XG4gICAgICB1cmxcbiAgICB9KTtcbiAgfVxuICBxdWVyeShwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5xdWVyeShwYXJhbXMpO1xuICB9XG4gIHZpZXdBY2Nlc3NLZXkoe1xuICAgIGFjY291bnRJZCxcbiAgICBwdWJsaWNLZXlcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJ2aWV3X2FjY2Vzc19rZXlcIixcbiAgICAgIGZpbmFsaXR5OiBcImZpbmFsXCIsXG4gICAgICBhY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXlcbiAgICB9KTtcbiAgfVxuICBibG9jayhyZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5ibG9jayhyZWZlcmVuY2UpO1xuICB9XG4gIHNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gIH1cbn1cblxuY29uc3QgS0VZX0RFTElNSVRFUiA9IFwiOlwiO1xuY2xhc3MgSnNvblN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBuYW1lc3BhY2UpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMubmFtZXNwYWNlID0gQXJyYXkuaXNBcnJheShuYW1lc3BhY2UpID8gbmFtZXNwYWNlLmpvaW4oS0VZX0RFTElNSVRFUikgOiBuYW1lc3BhY2U7XG4gIH1cbiAgcmVzb2x2ZUtleShrZXkpIHtcbiAgICByZXR1cm4gW3RoaXMubmFtZXNwYWNlLCBrZXldLmpvaW4oS0VZX0RFTElNSVRFUik7XG4gIH1cbiAgZ2V0SXRlbShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5yZXNvbHZlS2V5KGtleSkpLnRoZW4oaXRlbSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGl0ZW0pIDogbnVsbDtcbiAgICB9KTtcbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5yZXNvbHZlS2V5KGtleSksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cbiAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5yZXNvbHZlS2V5KGtleSkpO1xuICB9XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsJHQgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHt9O1xuXG52YXIgZmFpbHMkcyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkciA9IGZhaWxzJHM7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkcihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cbnZhciBmYWlscyRxID0gZmFpbHMkcztcblxudmFyIGZ1bmN0aW9uQmluZE5hdGl2ZSA9ICFmYWlscyRxKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQzID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgY2FsbCRsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQzID8gY2FsbCRsLmJpbmQoY2FsbCRsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkbC5hcHBseShjYWxsJGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxub2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNSA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgTkFUSVZFX0JJTkQkMiA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCQ3ID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kO1xudmFyIGNhbGwkayA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRwID0gTkFUSVZFX0JJTkQkMiAmJiBiaW5kJDcuYmluZChjYWxsJGssIGNhbGwkayk7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMiA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkcChmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkay5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRvID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIHRvU3RyaW5nJDcgPSB1bmN1cnJ5VGhpcyRvKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSQzID0gdW5jdXJyeVRoaXMkbygnJy5zbGljZSk7XG5cbnZhciBjbGFzc29mUmF3JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlJDModG9TdHJpbmckNyhpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRuID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRwID0gZmFpbHMkcztcbnZhciBjbGFzc29mJGIgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDQgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyRuKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkcChmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQ0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiRiKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDQoaXQpO1xufSA6ICRPYmplY3QkNDtcblxudmFyICRUeXBlRXJyb3IkZiA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ2ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkZihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMyA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ1ID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ2O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDUoaXQpKTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDYWxsYWJsZSRtID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgaXNPYmplY3QkZCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJG0oaXQpO1xufTtcblxudmFyIGdsb2JhbCRzID0gZ2xvYmFsJHQ7XG52YXIgaXNDYWxsYWJsZSRsID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGwoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ4ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkc1tuYW1lc3BhY2VdKSA6IGdsb2JhbCRzW25hbWVzcGFjZV0gJiYgZ2xvYmFsJHNbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIHVuY3VycnlUaGlzJG0gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJG0oe30uaXNQcm90b3R5cGVPZik7XG5cbnZhciBnZXRCdWlsdEluJDcgPSBnZXRCdWlsdEluJDg7XG5cbnZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluJDcoJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxudmFyIGdsb2JhbCRyID0gZ2xvYmFsJHQ7XG52YXIgdXNlckFnZW50JDUgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBwcm9jZXNzJDMgPSBnbG9iYWwkci5wcm9jZXNzO1xudmFyIERlbm8kMSA9IGdsb2JhbCRyLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzJDMgJiYgcHJvY2VzcyQzLnZlcnNpb25zIHx8IERlbm8kMSAmJiBEZW5vJDEudmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50JDUpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQkNS5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQkNS5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgVjhfVkVSU0lPTiQxID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIGZhaWxzJG8gPSBmYWlscyRzO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgbmF0aXZlU3ltYm9sID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyRvKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OJDEgJiYgVjhfVkVSU0lPTiQxIDwgNDE7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcblxudmFyIHVzZVN5bWJvbEFzVWlkID0gTkFUSVZFX1NZTUJPTCQxXG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkayA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc1Byb3RvdHlwZU9mJDQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyICRPYmplY3QkMyA9IE9iamVjdDtcblxudmFyIGlzU3ltYm9sJDMgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ2KCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaygkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJDQoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMyhpdCkpO1xufTtcblxudmFyICRTdHJpbmckMyA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQzKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJGogPSBpc0NhbGxhYmxlJG47XG52YXIgdHJ5VG9TdHJpbmckNCA9IHRyeVRvU3RyaW5nJDU7XG5cbnZhciAkVHlwZUVycm9yJGUgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDkgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkaihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciRlKHRyeVRvU3RyaW5nJDQoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSQ4ID0gYUNhbGxhYmxlJDk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkNCA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ4KGZ1bmMpO1xufTtcblxudmFyIGNhbGwkaiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGkgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkYyA9IGlzT2JqZWN0JGQ7XG5cbnZhciAkVHlwZUVycm9yJGQgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkYyh2YWwgPSBjYWxsJGooZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkYyh2YWwgPSBjYWxsJGooZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JGModmFsID0gY2FsbCRqKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJGQoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgc2hhcmVkJDQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ2xvYmFsJHEgPSBnbG9iYWwkdDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQ3ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNyhnbG9iYWwkcSwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWwkcVtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdsb2JhbCRwID0gZ2xvYmFsJHQ7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMiA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJHBbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyKFNIQVJFRCwge30pO1xuXG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG52YXIgc3RvcmUkMiA9IHNoYXJlZFN0b3JlO1xuXG4oc2hhcmVkJDQuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjMuMycsXG4gIG1vZGU6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMy4zL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0ID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ2O1xuXG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMihyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQoYXJndW1lbnQpKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRsID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b09iamVjdCQ2ID0gdG9PYmplY3QkNztcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkbCh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkNihpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkayA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmckNiA9IHVuY3VycnlUaGlzJGsoMS4wLnRvU3RyaW5nKTtcblxudmFyIHVpZCQzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDYoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG5cbnZhciBnbG9iYWwkbyA9IGdsb2JhbCR0O1xudmFyIHNoYXJlZCQzID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciBoYXNPd24kYiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDIgPSB1aWQkMztcbnZhciBOQVRJVkVfU1lNQk9MID0gbmF0aXZlU3ltYm9sO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQkMygnd2tzJyk7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkby5TeW1ib2w7XG52YXIgc3ltYm9sRm9yID0gU3ltYm9sJDEgJiYgU3ltYm9sJDFbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sJDEgOiBTeW1ib2wkMSAmJiBTeW1ib2wkMS53aXRob3V0U2V0dGVyIHx8IHVpZCQyO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGogPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biRiKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gJ1N5bWJvbC4nICsgbmFtZTtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXNPd24kYihTeW1ib2wkMSwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQgJiYgc3ltYm9sRm9yKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxudmFyIGNhbGwkaSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCRiID0gaXNPYmplY3QkZDtcbnZhciBpc1N5bWJvbCQyID0gaXNTeW1ib2wkMztcbnZhciBnZXRNZXRob2QkMyA9IGdldE1ldGhvZCQ0O1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBvcmRpbmFyeVRvUHJpbWl0aXZlJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGkgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyICRUeXBlRXJyb3IkYyA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2wkaSgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbnZhciB0b1ByaW1pdGl2ZSQyID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QkYihpbnB1dCkgfHwgaXNTeW1ib2wkMihpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZCQzKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsJGkoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdCRiKHJlc3VsdCkgfHwgaXNTeW1ib2wkMihyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93ICRUeXBlRXJyb3IkYyhcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cbnZhciB0b1ByaW1pdGl2ZSQxID0gdG9QcmltaXRpdmUkMjtcbnZhciBpc1N5bWJvbCQxID0gaXNTeW1ib2wkMztcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG52YXIgdG9Qcm9wZXJ0eUtleSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZSQxKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbCQxKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBnbG9iYWwkbiA9IGdsb2JhbCR0O1xudmFyIGlzT2JqZWN0JGEgPSBpc09iamVjdCRkO1xuXG52YXIgZG9jdW1lbnQkMyA9IGdsb2JhbCRuLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTJDEgPSBpc09iamVjdCRhKGRvY3VtZW50JDMpICYmIGlzT2JqZWN0JGEoZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KTtcblxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMkMSA/IGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBERVNDUklQVE9SUyRkID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkbiA9IGZhaWxzJHM7XG52YXIgY3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyRkICYmICFmYWlscyRuKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCQxKCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkYyA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkaCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciB0b0luZGV4ZWRPYmplY3QkNSA9IHRvSW5kZXhlZE9iamVjdCQ2O1xudmFyIHRvUHJvcGVydHlLZXkkMyA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBoYXNPd24kYSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJGMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDUoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDMoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biRhKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQoIWNhbGwkaChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJG0gPSBmYWlscyRzO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJGIgJiYgZmFpbHMkbShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgaXNPYmplY3QkOSA9IGlzT2JqZWN0JGQ7XG5cbnZhciAkU3RyaW5nJDIgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciRiID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG52YXIgYW5PYmplY3QkZSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QkOShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciRiKCRTdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyRhID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGFuT2JqZWN0JGQgPSBhbk9iamVjdCRlO1xudmFyIHRvUHJvcGVydHlLZXkkMiA9IHRvUHJvcGVydHlLZXkkNDtcblxudmFyICRUeXBlRXJyb3IkYSA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJGEgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRkKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBhbk9iamVjdCRkKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRkKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBhbk9iamVjdCRkKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yJGEoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBERVNDUklQVE9SUyQ5ID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkOCA9IERFU0NSSVBUT1JTJDkgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ2LmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIG1ha2VCdWlsdEluJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkOCA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biQ5ID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkOCAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJDkoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkOCB8fCAoREVTQ1JJUFRPUlMkOCAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRqID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJG47XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJGooRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkaChzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkNCA9IHN0b3JlJDEuaW5zcGVjdFNvdXJjZTtcblxudmFyIGdsb2JhbCRtID0gZ2xvYmFsJHQ7XG52YXIgaXNDYWxsYWJsZSRnID0gaXNDYWxsYWJsZSRuO1xudmFyIGluc3BlY3RTb3VyY2UkMyA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCRtLldlYWtNYXA7XG5cbnZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZSRnKFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UkMyhXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQyID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciB1aWQkMSA9IHVpZCQzO1xuXG52YXIga2V5cyQxID0gc2hhcmVkJDIoJ2tleXMnKTtcblxudmFyIHNoYXJlZEtleSQzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5cyQxW2tleV0gfHwgKGtleXMkMVtrZXldID0gdWlkJDEoa2V5KSk7XG59O1xuXG52YXIgaGlkZGVuS2V5cyQ0ID0ge307XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSBuYXRpdmVXZWFrTWFwO1xudmFyIGdsb2JhbCRsID0gZ2xvYmFsJHQ7XG52YXIgdW5jdXJyeVRoaXMkaSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNPYmplY3QkOCA9IGlzT2JqZWN0JGQ7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDcgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBoYXNPd24kOCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgc2hhcmVkJDEgPSBzaGFyZWRTdG9yZTtcbnZhciBzaGFyZWRLZXkkMiA9IHNoYXJlZEtleSQzO1xudmFyIGhpZGRlbktleXMkMyA9IGhpZGRlbktleXMkNDtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IkMyA9IGdsb2JhbCRsLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsJGwuV2Vha01hcDtcbnZhciBzZXQkMiwgZ2V0JDEsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQkMShpdCkgOiBzZXQkMihpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdCQ4KGl0KSB8fCAoc3RhdGUgPSBnZXQkMShpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvciQzKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQkMS5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQkMS5zdGF0ZSB8fCAoc2hhcmVkJDEuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMkaShzdG9yZS5nZXQpO1xuICB2YXIgd21oYXMgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLmhhcyk7XG4gIHZhciB3bXNldCA9IHVuY3VycnlUaGlzJGkoc3RvcmUuc2V0KTtcbiAgc2V0JDIgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkMyhPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQyKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDIgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ4KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMyhPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDcoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kOChpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24kOChpdCwgU1RBVEUpO1xuICB9O1xufVxuXG52YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgc2V0OiBzZXQkMixcbiAgZ2V0OiBnZXQkMSxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgZmFpbHMkbCA9IGZhaWxzJHM7XG52YXIgaXNDYWxsYWJsZSRmID0gaXNDYWxsYWJsZSRuO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMiA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSQyID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNSA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQ1ID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQ3ICYmICFmYWlscyRsKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDYoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4kMSA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoU3RyaW5nKG5hbWUpLnNsaWNlKDAsIDcpID09PSAnU3ltYm9sKCcpIHtcbiAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duJDcodmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDIgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkNykgZGVmaW5lUHJvcGVydHkkNih2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093biQ3KG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5JDYodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDcob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTJDcpIGRlZmluZVByb3BlcnR5JDYodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQyKHZhbHVlKTtcbiAgaWYgKCFoYXNPd24kNyhzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4kMShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkZih0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlJDUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UkMih0aGlzKTtcbn0sICd0b1N0cmluZycpO1xuXG52YXIgaXNDYWxsYWJsZSRlID0gaXNDYWxsYWJsZSRuO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBtYWtlQnVpbHRJbiA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cztcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIGRlZmluZUJ1aWx0SW4kOCA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSRlKHZhbHVlKSkgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5JDEoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG4gICAgICBlbHNlIGlmIChPW2tleV0pIHNpbXBsZSA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lUHJvcGVydHlNb2R1bGUkNS5mKE8sIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6ICFvcHRpb25zLm5vbkNvbmZpZ3VyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgIH0pO1xuICB9IHJldHVybiBPO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSB7fTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IkMyA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG52YXIgbWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciQzIDogY2VpbCkobik7XG59O1xuXG52YXIgdHJ1bmMgPSBtYXRoVHJ1bmM7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ1ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xuXG52YXIgbWF4JDEgPSBNYXRoLm1heDtcbnZhciBtaW4kMiA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkNShpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heCQxKGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDIoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDQgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG5cbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxudmFyIHRvTGVuZ3RoJDYgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbiQxKHRvSW50ZWdlck9ySW5maW5pdHkkNChhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIHRvTGVuZ3RoJDUgPSB0b0xlbmd0aCQ2O1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDggPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aCQ1KG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ0ID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDMgPSB0b0Fic29sdXRlSW5kZXgkNDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ3ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkNCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkNCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDcoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDMoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbnZhciBhcnJheUluY2x1ZGVzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCQ0KHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZCQ0KGZhbHNlKVxufTtcblxudmFyIHVuY3VycnlUaGlzJGggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhhc093biQ2ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB0b0luZGV4ZWRPYmplY3QkMyA9IHRvSW5kZXhlZE9iamVjdCQ2O1xudmFyIGluZGV4T2YkMSA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDQ7XG5cbnZhciBwdXNoJDIgPSB1bmN1cnJ5VGhpcyRoKFtdLnB1c2gpO1xuXG52YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMyhvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093biQ2KGhpZGRlbktleXMkMiwga2V5KSAmJiBoYXNPd24kNihPLCBrZXkpICYmIHB1c2gkMihyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24kNihPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mJDEocmVzdWx0LCBrZXkpIHx8IHB1c2gkMihyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGVudW1CdWdLZXlzJDMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7XG5cbnZhciBoaWRkZW5LZXlzJDEgPSBlbnVtQnVnS2V5cyQyLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBoaWRkZW5LZXlzJDEpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIGdldEJ1aWx0SW4kNSA9IGdldEJ1aWx0SW4kODtcbnZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCRjID0gYW5PYmplY3QkZTtcblxudmFyIGNvbmNhdCQxID0gdW5jdXJyeVRoaXMkZyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgb3duS2V5cyQxID0gZ2V0QnVpbHRJbiQ1KCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0JGMoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMShrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaGFzT3duJDUgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0LmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093biQ1KHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duJDUoZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWlscyRrID0gZmFpbHMkcztcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJG47XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCQyID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlJGQoZGV0ZWN0aW9uKSA/IGZhaWxzJGsoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMi5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkJDIuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkJDIuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQkMi5QT0xZRklMTCA9ICdQJztcblxudmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQyO1xuXG52YXIgZ2xvYmFsJGsgPSBnbG9iYWwkdDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbiQ3ID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxO1xudmFyIGlzRm9yY2VkJDEgPSBpc0ZvcmNlZF8xO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGs7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGtbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsJGtbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZCQxKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNihzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbiQ3KHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBjbGFzc29mJGEgPSBjbGFzc29mUmF3JDE7XG52YXIgZ2xvYmFsJGogPSBnbG9iYWwkdDtcblxudmFyIGVuZ2luZUlzTm9kZSA9IGNsYXNzb2YkYShnbG9iYWwkai5wcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbnZhciBpc0NhbGxhYmxlJGMgPSBpc0NhbGxhYmxlJG47XG5cbnZhciAkU3RyaW5nJDEgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQ5ID0gVHlwZUVycm9yO1xuXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlJGMoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkOShcIkNhbid0IHNldCBcIiArICRTdHJpbmckMShhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG5cbnZhciB1bmN1cnJ5VGhpcyRmID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhbk9iamVjdCRiID0gYW5PYmplY3QkZTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBhUG9zc2libGVQcm90b3R5cGUkMTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMkZihPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QkYihPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkNSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHdlbGxLbm93blN5bWJvbCRoID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBUT19TVFJJTkdfVEFHJDQgPSB3ZWxsS25vd25TeW1ib2wkaCgndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDQgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093biQ0KHRhcmdldCwgVE9fU1RSSU5HX1RBRyQ0KSkge1xuICAgIGRlZmluZVByb3BlcnR5JDUodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDQsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcblxudmFyIFNQRUNJRVMkNCA9IHdlbGxLbm93blN5bWJvbCRnKCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzJDIgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluJDQoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDMuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMkNiAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFUyQ0XSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTJDQsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcblxudmFyICRUeXBlRXJyb3IkOCA9IFR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMyA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDMoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ4KCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkZigndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBRyQzXSA9ICd6JztcblxudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkYiA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRlID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2wkZSgndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0JDEgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiQ5ID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QkMShpdCksIFRPX1NUUklOR19UQUckMikpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZSRiKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxudmFyIHVuY3VycnlUaGlzJGUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGogPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mJDggPSBjbGFzc29mJDk7XG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluJDMoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMkMiA9IHVuY3VycnlUaGlzJGUoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJGEoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJGEoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiQ4KGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyQyKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlJDEoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG52YXIgaXNDb25zdHJ1Y3RvciQyID0gIWNvbnN0cnVjdCB8fCBmYWlscyRqKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXG4gICAgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcblxudmFyIGlzQ29uc3RydWN0b3IkMSA9IGlzQ29uc3RydWN0b3IkMjtcbnZhciB0cnlUb1N0cmluZyQzID0gdHJ5VG9TdHJpbmckNTtcblxudmFyICRUeXBlRXJyb3IkNyA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ29uc3RydWN0b3IkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3RvciQxKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDcodHJ5VG9TdHJpbmckMyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgYW5PYmplY3QkYSA9IGFuT2JqZWN0JGU7XG52YXIgYUNvbnN0cnVjdG9yJDEgPSBhQ29uc3RydWN0b3IkMjtcbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgU1BFQ0lFUyQzID0gd2VsbEtub3duU3ltYm9sJGQoJ3NwZWNpZXMnKTtcblxuLy8gYFNwZWNpZXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNwZWNpZXNjb25zdHJ1Y3RvclxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciQzID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0JGEoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QkYShDKVtTUEVDSUVTJDNdKSA9PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29uc3RydWN0b3IgOiBhQ29uc3RydWN0b3IkMShTKTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQxID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkkMyA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwkZyA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXJlZmxlY3QgLS0gc2FmZVxudmFyIGZ1bmN0aW9uQXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCQxID8gY2FsbCRnLmJpbmQoYXBwbHkkMykgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJGcuYXBwbHkoYXBwbHkkMywgYXJndW1lbnRzKTtcbn0pO1xuXG52YXIgdW5jdXJyeVRoaXMkZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDcgPSBhQ2FsbGFibGUkOTtcbnZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIGJpbmQkNiA9IHVuY3VycnlUaGlzJGQodW5jdXJyeVRoaXMkZC5iaW5kKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgZnVuY3Rpb25CaW5kQ29udGV4dCA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuICBhQ2FsbGFibGUkNyhmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IE5BVElWRV9CSU5EID8gYmluZCQ2KGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQyID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgaHRtbCQyID0gZ2V0QnVpbHRJbiQyKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxudmFyIHVuY3VycnlUaGlzJGMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgYXJyYXlTbGljZSQ1ID0gdW5jdXJyeVRoaXMkYyhbXS5zbGljZSk7XG5cbnZhciAkVHlwZUVycm9yJDYgPSBUeXBlRXJyb3I7XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyAkVHlwZUVycm9yJDYoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG52YXIgdXNlckFnZW50JDQgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0lvcyA9IC8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCQ0KTtcblxudmFyIGdsb2JhbCRpID0gZ2xvYmFsJHQ7XG52YXIgYXBwbHkkMiA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgYmluZCQ1ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBpc0NhbGxhYmxlJDkgPSBpc0NhbGxhYmxlJG47XG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGZhaWxzJGkgPSBmYWlscyRzO1xudmFyIGh0bWwkMSA9IGh0bWwkMjtcbnZhciBhcnJheVNsaWNlJDQgPSBhcnJheVNsaWNlJDU7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcbnZhciBJU19JT1MkMSA9IGVuZ2luZUlzSW9zO1xudmFyIElTX05PREUkMyA9IGVuZ2luZUlzTm9kZTtcblxudmFyIHNldCQxID0gZ2xvYmFsJGkuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyID0gZ2xvYmFsJGkuY2xlYXJJbW1lZGlhdGU7XG52YXIgcHJvY2VzcyQyID0gZ2xvYmFsJGkucHJvY2VzcztcbnZhciBEaXNwYXRjaCA9IGdsb2JhbCRpLkRpc3BhdGNoO1xudmFyIEZ1bmN0aW9uJDEgPSBnbG9iYWwkaS5GdW5jdGlvbjtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbCRpLk1lc3NhZ2VDaGFubmVsO1xudmFyIFN0cmluZyQxID0gZ2xvYmFsJGkuU3RyaW5nO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlJDEgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBsb2NhdGlvbiwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnRyeSB7XG4gIC8vIERlbm8gdGhyb3dzIGEgUmVmZXJlbmNlRXJyb3Igb24gYGxvY2F0aW9uYCBhY2Nlc3Mgd2l0aG91dCBgLS1sb2NhdGlvbmAgZmxhZ1xuICBsb2NhdGlvbiA9IGdsb2JhbCRpLmxvY2F0aW9uO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgcnVuID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmIChoYXNPd24kMyhxdWV1ZSQxLCBpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZSQxW2lkXTtcbiAgICBkZWxldGUgcXVldWUkMVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIHJ1bm5lciA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJ1bihpZCk7XG4gIH07XG59O1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuKGV2ZW50LmRhdGEpO1xufTtcblxudmFyIHBvc3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgLy8gb2xkIGVuZ2luZXMgaGF2ZSBub3QgbG9jYXRpb24ub3JpZ2luXG4gIGdsb2JhbCRpLnBvc3RNZXNzYWdlKFN0cmluZyQxKGlkKSwgbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCk7XG59O1xuXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldCQxIHx8ICFjbGVhcikge1xuICBzZXQkMSA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShoYW5kbGVyKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQ5KGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlJDQoYXJndW1lbnRzLCAxKTtcbiAgICBxdWV1ZSQxWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseSQyKGZuLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWUkMVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoSVNfTk9ERSQzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MkMi5uZXh0VGljayhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgLy8gZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82MjRcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCAmJiAhSVNfSU9TJDEpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQkNShwb3J0LnBvc3RNZXNzYWdlLCBwb3J0KTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoXG4gICAgZ2xvYmFsJGkuYWRkRXZlbnRMaXN0ZW5lciAmJlxuICAgIGlzQ2FsbGFibGUkOShnbG9iYWwkaS5wb3N0TWVzc2FnZSkgJiZcbiAgICAhZ2xvYmFsJGkuaW1wb3J0U2NyaXB0cyAmJlxuICAgIGxvY2F0aW9uICYmIGxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgIWZhaWxzJGkocG9zdClcbiAgKSB7XG4gICAgZGVmZXIgPSBwb3N0O1xuICAgIGdsb2JhbCRpLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwkMS5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbCQxLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4oaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KHJ1bm5lcihpZCksIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIHRhc2skMSA9IHtcbiAgc2V0OiBzZXQkMSxcbiAgY2xlYXI6IGNsZWFyXG59O1xuXG52YXIgdXNlckFnZW50JDMgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkdDtcblxudmFyIGVuZ2luZUlzSW9zUGViYmxlID0gL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCQzKSAmJiBnbG9iYWwkaC5QZWJibGUgIT09IHVuZGVmaW5lZDtcblxudmFyIHVzZXJBZ2VudCQyID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNXZWJvc1dlYmtpdCA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50JDIpO1xuXG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkdDtcbnZhciBiaW5kJDQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIG1hY3JvdGFzayA9IHRhc2skMS5zZXQ7XG52YXIgSVNfSU9TID0gZW5naW5lSXNJb3M7XG52YXIgSVNfSU9TX1BFQkJMRSA9IGVuZ2luZUlzSW9zUGViYmxlO1xudmFyIElTX1dFQk9TX1dFQktJVCA9IGVuZ2luZUlzV2Vib3NXZWJraXQ7XG52YXIgSVNfTk9ERSQyID0gZW5naW5lSXNOb2RlO1xuXG52YXIgTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbCRnLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsJGcuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBkb2N1bWVudCQyID0gZ2xvYmFsJGcuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyQxID0gZ2xvYmFsJGcucHJvY2VzcztcbnZhciBQcm9taXNlJDEgPSBnbG9iYWwkZy5Qcm9taXNlO1xuLy8gTm9kZS5qcyAxMSBzaG93cyBFeHBlcmltZW50YWxXYXJuaW5nIG9uIGdldHRpbmcgYHF1ZXVlTWljcm90YXNrYFxudmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwkZywgJ3F1ZXVlTWljcm90YXNrJyk7XG52YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSQxLCB0b2dnbGUsIG5vZGUsIHByb21pc2UsIHRoZW47XG5cbi8vIG1vZGVybiBlbmdpbmVzIGhhdmUgcXVldWVNaWNyb3Rhc2sgbWV0aG9kXG5pZiAoIXF1ZXVlTWljcm90YXNrKSB7XG4gIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChJU19OT0RFJDIgJiYgKHBhcmVudCA9IHByb2Nlc3MkMS5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkkMSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIC8vIGFsc28gZXhjZXB0IFdlYk9TIFdlYmtpdCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODk4XG4gIGlmICghSVNfSU9TICYmICFJU19OT0RFJDIgJiYgIUlTX1dFQk9TX1dFQktJVCAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGRvY3VtZW50JDIpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudCQyLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoIUlTX0lPU19QRUJCTEUgJiYgUHJvbWlzZSQxICYmIFByb21pc2UkMS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAvLyB3b3JrYXJvdW5kIG9mIFdlYktpdCB+IGlPUyBTYWZhcmkgMTAuMSBidWdcbiAgICBwcm9taXNlLmNvbnN0cnVjdG9yID0gUHJvbWlzZSQxO1xuICAgIHRoZW4gPSBiaW5kJDQocHJvbWlzZS50aGVuLCBwcm9taXNlKTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIE5vZGUuanMgd2l0aG91dCBwcm9taXNlc1xuICB9IGVsc2UgaWYgKElTX05PREUkMikge1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdlXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5iaW5kKGdsb2JhbClcbiAgICBtYWNyb3Rhc2sgPSBiaW5kJDQobWFjcm90YXNrLCBnbG9iYWwkZyk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYWNyb3Rhc2soZmx1c2gpO1xuICAgIH07XG4gIH1cbn1cblxudmFyIG1pY3JvdGFzayQxID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYgKCFoZWFkKSB7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5JDEoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG5cbnZhciBnbG9iYWwkZiA9IGdsb2JhbCR0O1xuXG52YXIgaG9zdFJlcG9ydEVycm9ycyQxID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGNvbnNvbGUgPSBnbG9iYWwkZi5jb25zb2xlO1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG5cbnZhciBwZXJmb3JtJDMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcblxudmFyIFF1ZXVlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG59O1xuXG5RdWV1ZSQxLnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBlbnRyeSA9IHsgaXRlbTogaXRlbSwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV4dDtcbiAgICAgIGlmICh0aGlzLnRhaWwgPT09IGVudHJ5KSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgcmV0dXJuIGVudHJ5Lml0ZW07XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVldWUgPSBRdWV1ZSQxO1xuXG52YXIgZ2xvYmFsJGUgPSBnbG9iYWwkdDtcblxudmFyIHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbCRlLlByb21pc2U7XG5cbnZhciBlbmdpbmVJc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHR5cGVvZiBEZW5vICE9ICdvYmplY3QnO1xuXG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkdDtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJG47XG52YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJU19CUk9XU0VSID0gZW5naW5lSXNCcm93c2VyO1xudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG5cbk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzLnByb3RvdHlwZTtcbnZhciBTUEVDSUVTJDIgPSB3ZWxsS25vd25TeW1ib2wkYygnc3BlY2llcycpO1xudmFyIFNVQkNMQVNTSU5HID0gZmFsc2U7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEgPSBpc0NhbGxhYmxlJDgoZ2xvYmFsJGQuUHJvbWlzZVJlamVjdGlvbkV2ZW50KTtcblxudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUgPSBpc0ZvcmNlZCgnUHJvbWlzZScsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFID0gaW5zcGVjdFNvdXJjZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIHZhciBHTE9CQUxfQ09SRV9KU19QUk9NSVNFID0gUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgIT09IFN0cmluZyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIC8vIFY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gIC8vIFdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gIGlmICghR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBWOF9WRVJTSU9OID09PSA2NikgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSkpIHJldHVybiBmYWxzZTtcbiAgLy8gRGV0ZWN0IGNvcnJlY3RuZXNzIG9mIHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgdmFyIHByb21pc2UgPSBuZXcgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSgxKTsgfSk7XG4gIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIH07XG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTtcbiAgY29uc3RydWN0b3JbU1BFQ0lFUyQyXSA9IEZha2VQcm9taXNlO1xuICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIGlmICghU1VCQ0xBU1NJTkcpIHJldHVybiB0cnVlO1xuICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMTtcbn0pO1xuXG52YXIgcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0ge1xuICBDT05TVFJVQ1RPUjogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSxcbiAgUkVKRUNUSU9OX0VWRU5UOiBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMiA9IHt9O1xuXG52YXIgYUNhbGxhYmxlJDYgPSBhQ2FsbGFibGUkOTtcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFDYWxsYWJsZSQ2KHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZSQ2KHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubmV3UHJvbWlzZUNhcGFiaWxpdHkkMi5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbnZhciAkJGUgPSBfZXhwb3J0O1xudmFyIElTX05PREUkMSA9IGVuZ2luZUlzTm9kZTtcbnZhciBnbG9iYWwkYyA9IGdsb2JhbCR0O1xudmFyIGNhbGwkZiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBkZWZpbmVCdWlsdEluJDYgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgc2V0UHJvdG90eXBlT2YkNSA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBzZXRUb1N0cmluZ1RhZyQ0O1xudmFyIHNldFNwZWNpZXMkMSA9IHNldFNwZWNpZXMkMjtcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ5O1xudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCQ3ID0gaXNPYmplY3QkZDtcbnZhciBhbkluc3RhbmNlJDIgPSBhbkluc3RhbmNlJDM7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDIgPSBzcGVjaWVzQ29uc3RydWN0b3IkMztcbnZhciB0YXNrID0gdGFzayQxLnNldDtcbnZhciBtaWNyb3Rhc2sgPSBtaWNyb3Rhc2skMTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gaG9zdFJlcG9ydEVycm9ycyQxO1xudmFyIHBlcmZvcm0kMiA9IHBlcmZvcm0kMztcbnZhciBRdWV1ZSA9IHF1ZXVlO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNCA9IGludGVybmFsU3RhdGU7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xuXG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0ID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5SRUpFQ1RJT05fRVZFTlQ7XG52YXIgTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uU1VCQ0xBU1NJTkc7XG52YXIgZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuZ2V0dGVyRm9yKFBST01JU0UpO1xudmFyIHNldEludGVybmFsU3RhdGUkMyA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5zZXQ7XG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIucHJvdG90eXBlO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvciA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyO1xudmFyIFByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDE7XG52YXIgVHlwZUVycm9yJDIgPSBnbG9iYWwkYy5UeXBlRXJyb3I7XG52YXIgZG9jdW1lbnQkMSA9IGdsb2JhbCRjLmRvY3VtZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwkYy5wcm9jZXNzO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzLmY7XG52YXIgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMTtcblxudmFyIERJU1BBVENIX0VWRU5UID0gISEoZG9jdW1lbnQkMSAmJiBkb2N1bWVudCQxLmNyZWF0ZUV2ZW50ICYmIGdsb2JhbCRjLmRpc3BhdGNoRXZlbnQpO1xudmFyIFVOSEFORExFRF9SRUpFQ1RJT04gPSAndW5oYW5kbGVkcmVqZWN0aW9uJztcbnZhciBSRUpFQ1RJT05fSEFORExFRCA9ICdyZWplY3Rpb25oYW5kbGVkJztcbnZhciBQRU5ESU5HID0gMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcbnZhciBIQU5ETEVEID0gMTtcbnZhciBVTkhBTkRMRUQgPSAyO1xuXG52YXIgSW50ZXJuYWwsIE93blByb21pc2VDYXBhYmlsaXR5LCBQcm9taXNlV3JhcHBlciwgbmF0aXZlVGhlbjtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdCQ3KGl0KSAmJiBpc0NhbGxhYmxlJDcodGhlbiA9IGl0LnRoZW4pID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIGNhbGxSZWFjdGlvbiA9IGZ1bmN0aW9uIChyZWFjdGlvbiwgc3RhdGUpIHtcbiAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gIHZhciBvayA9IHN0YXRlLnN0YXRlID09IEZVTEZJTExFRDtcbiAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gIHRyeSB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGlmICghb2spIHtcbiAgICAgICAgaWYgKHN0YXRlLnJlamVjdGlvbiA9PT0gVU5IQU5ETEVEKSBvbkhhbmRsZVVuaGFuZGxlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLnJlamVjdGlvbiA9IEhBTkRMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBjYW4gdGhyb3dcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICByZWplY3QoVHlwZUVycm9yJDIoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgY2FsbCRmKHRoZW4sIHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgIHJlamVjdChlcnJvcik7XG4gIH1cbn07XG5cbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoc3RhdGUsIGlzUmVqZWN0KSB7XG4gIGlmIChzdGF0ZS5ub3RpZmllZCkgcmV0dXJuO1xuICBzdGF0ZS5ub3RpZmllZCA9IHRydWU7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlYWN0aW9ucyA9IHN0YXRlLnJlYWN0aW9ucztcbiAgICB2YXIgcmVhY3Rpb247XG4gICAgd2hpbGUgKHJlYWN0aW9uID0gcmVhY3Rpb25zLmdldCgpKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUubm90aWZpZWQgPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXN0YXRlLnJlamVjdGlvbikgb25VbmhhbmRsZWQoc3RhdGUpO1xuICB9KTtcbn07XG5cbnZhciBkaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIHByb21pc2UsIHJlYXNvbikge1xuICB2YXIgZXZlbnQsIGhhbmRsZXI7XG4gIGlmIChESVNQQVRDSF9FVkVOVCkge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQkMS5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBldmVudC5yZWFzb24gPSByZWFzb247XG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgICBnbG9iYWwkYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIGV2ZW50ID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHJlYXNvbiB9O1xuICBpZiAoIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCAmJiAoaGFuZGxlciA9IGdsb2JhbCRjWydvbicgKyBuYW1lXSkpIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkZih0YXNrLCBnbG9iYWwkYywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBJU19VTkhBTkRMRUQgPSBpc1VuaGFuZGxlZChzdGF0ZSk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoSVNfVU5IQU5ETEVEKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtJDIoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoSVNfTk9ERSQxKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUkMSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkZih0YXNrLCBnbG9iYWwkYywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFJDEpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gIH0pO1xufTtcblxudmFyIGJpbmQkMyA9IGZ1bmN0aW9uIChmbiwgc3RhdGUsIHVud3JhcCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZm4oc3RhdGUsIHZhbHVlLCB1bndyYXApO1xuICB9O1xufTtcblxudmFyIGludGVybmFsUmVqZWN0ID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgc3RhdGUuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgbm90aWZ5KHN0YXRlLCB0cnVlKTtcbn07XG5cbnZhciBpbnRlcm5hbFJlc29sdmUgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICB0cnkge1xuICAgIGlmIChzdGF0ZS5mYWNhZGUgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IkMihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIHZhciB0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSk7XG4gICAgaWYgKHRoZW4pIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbGwkZih0aGVuLCB2YWx1ZSxcbiAgICAgICAgICAgIGJpbmQkMyhpbnRlcm5hbFJlc29sdmUsIHdyYXBwZXIsIHN0YXRlKSxcbiAgICAgICAgICAgIGJpbmQkMyhpbnRlcm5hbFJlamVjdCwgd3JhcHBlciwgc3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbnRlcm5hbFJlamVjdCh3cmFwcGVyLCBlcnJvciwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHN0YXRlLnN0YXRlID0gRlVMRklMTEVEO1xuICAgICAgbm90aWZ5KHN0YXRlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGludGVybmFsUmVqZWN0KHsgZG9uZTogZmFsc2UgfSwgZXJyb3IsIHN0YXRlKTtcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmIChGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0KSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFByb21pc2VDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlJDIodGhpcywgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgYUNhbGxhYmxlJDUoZXhlY3V0b3IpO1xuICAgIGNhbGwkZihJbnRlcm5hbCwgdGhpcyk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGJpbmQkMyhpbnRlcm5hbFJlc29sdmUsIHN0YXRlKSwgYmluZCQzKGludGVybmFsUmVqZWN0LCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdChzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBQcm9taXNlUHJvdG90eXBlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBzZXRJbnRlcm5hbFN0YXRlJDModGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogbmV3IFF1ZXVlKCksXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYFByb21pc2UucHJvdG90eXBlLnRoZW5gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgSW50ZXJuYWwucHJvdG90eXBlID0gZGVmaW5lQnVpbHRJbiQ2KFByb21pc2VQcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEoc3BlY2llc0NvbnN0cnVjdG9yJDIodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yKSk7XG4gICAgc3RhdGUucGFyZW50ID0gdHJ1ZTtcbiAgICByZWFjdGlvbi5vayA9IGlzQ2FsbGFibGUkNyhvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgcmVhY3Rpb24uZmFpbCA9IGlzQ2FsbGFibGUkNyhvblJlamVjdGVkKSAmJiBvblJlamVjdGVkO1xuICAgIHJlYWN0aW9uLmRvbWFpbiA9IElTX05PREUkMSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgIGlmIChzdGF0ZS5zdGF0ZSA9PSBQRU5ESU5HKSBzdGF0ZS5yZWFjdGlvbnMuYWRkKHJlYWN0aW9uKTtcbiAgICBlbHNlIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgfSk7XG5cbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZShwcm9taXNlKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGJpbmQkMyhpbnRlcm5hbFJlc29sdmUsIHN0YXRlKTtcbiAgICB0aGlzLnJlamVjdCA9IGJpbmQkMyhpbnRlcm5hbFJlamVjdCwgc3RhdGUpO1xuICB9O1xuXG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoaXNDYWxsYWJsZSQ3KE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyKSAmJiBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBuYXRpdmVUaGVuID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLnRoZW47XG5cbiAgICBpZiAoIU5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HKSB7XG4gICAgICAvLyBtYWtlIGBQcm9taXNlI3RoZW5gIHJldHVybiBhIHBvbHlmaWxsZWQgYFByb21pc2VgIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgICBkZWZpbmVCdWlsdEluJDYoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgY2FsbCRmKG5hdGl2ZVRoZW4sIHRoYXQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY0MFxuICAgICAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBgLmNvbnN0cnVjdG9yID09PSBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEuY29uc3RydWN0b3I7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4gICAgLy8gbWFrZSBgaW5zdGFuY2VvZiBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgaWYgKHNldFByb3RvdHlwZU9mJDUpIHtcbiAgICAgIHNldFByb3RvdHlwZU9mJDUoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuJCRlKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0IH0sIHtcbiAgUHJvbWlzZTogUHJvbWlzZUNvbnN0cnVjdG9yXG59KTtcblxuc2V0VG9TdHJpbmdUYWckMyhQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlKTtcbnNldFNwZWNpZXMkMShQUk9NSVNFKTtcblxudmFyIGl0ZXJhdG9ycyA9IHt9O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBJdGVyYXRvcnMkNCA9IGl0ZXJhdG9ycztcblxudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSQxID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycyQ0LkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZSQxW0lURVJBVE9SJDVdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiQ3ID0gY2xhc3NvZiQ5O1xudmFyIGdldE1ldGhvZCQyID0gZ2V0TWV0aG9kJDQ7XG52YXIgSXRlcmF0b3JzJDMgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJGEgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIElURVJBVE9SJDQgPSB3ZWxsS25vd25TeW1ib2wkYSgnaXRlcmF0b3InKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGdldE1ldGhvZCQyKGl0LCBJVEVSQVRPUiQ0KVxuICAgIHx8IGdldE1ldGhvZCQyKGl0LCAnQEBpdGVyYXRvcicpXG4gICAgfHwgSXRlcmF0b3JzJDNbY2xhc3NvZiQ3KGl0KV07XG59O1xuXG52YXIgY2FsbCRlID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQ0ID0gYUNhbGxhYmxlJDk7XG52YXIgYW5PYmplY3QkOSA9IGFuT2JqZWN0JGU7XG52YXIgdHJ5VG9TdHJpbmckMiA9IHRyeVRvU3RyaW5nJDU7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IGdldEl0ZXJhdG9yTWV0aG9kJDM7XG5cbnZhciAkVHlwZUVycm9yJDUgPSBUeXBlRXJyb3I7XG5cbnZhciBnZXRJdGVyYXRvciQyID0gZnVuY3Rpb24gKGFyZ3VtZW50LCB1c2luZ0l0ZXJhdG9yKSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QkMihhcmd1bWVudCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAoYUNhbGxhYmxlJDQoaXRlcmF0b3JNZXRob2QpKSByZXR1cm4gYW5PYmplY3QkOShjYWxsJGUoaXRlcmF0b3JNZXRob2QsIGFyZ3VtZW50KSk7XG4gIHRocm93ICRUeXBlRXJyb3IkNSh0cnlUb1N0cmluZyQyKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG59O1xuXG52YXIgY2FsbCRkID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDggPSBhbk9iamVjdCRlO1xudmFyIGdldE1ldGhvZCQxID0gZ2V0TWV0aG9kJDQ7XG5cbnZhciBpdGVyYXRvckNsb3NlJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgYW5PYmplY3QkOChpdGVyYXRvcik7XG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QkMShpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsJGQoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xuICB9XG4gIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICBhbk9iamVjdCQ4KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGJpbmQkMiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgY2FsbCRjID0gZnVuY3Rpb25DYWxsO1xudmFyIGFuT2JqZWN0JDcgPSBhbk9iamVjdCRlO1xudmFyIHRyeVRvU3RyaW5nJDEgPSB0cnlUb1N0cmluZyQ1O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNiA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG52YXIgaXNQcm90b3R5cGVPZiQyID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBnZXRJdGVyYXRvciQxID0gZ2V0SXRlcmF0b3IkMjtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQxID0gZ2V0SXRlcmF0b3JNZXRob2QkMztcbnZhciBpdGVyYXRvckNsb3NlID0gaXRlcmF0b3JDbG9zZSQxO1xuXG52YXIgJFR5cGVFcnJvciQ0ID0gVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG52YXIgaXRlcmF0ZSQyID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQkMih1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ25vcm1hbCcsIGNvbmRpdGlvbik7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgfTtcblxuICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgIGFuT2JqZWN0JDcodmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZCQxKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgJFR5cGVFcnJvciQ0KHRyeVRvU3RyaW5nJDEoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QkMShpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNihpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YkMihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvciQxKGl0ZXJhYmxlLCBpdGVyRm4pO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsJGMobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQyKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDkgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2wkOSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1IkM10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMiA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SJDNdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG5cbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMSA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQyO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG5cbnZhciBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbiA9IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMS5hbGwoaXRlcmFibGUpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciAkJGQgPSBfZXhwb3J0O1xudmFyIGNhbGwkYiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ5O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0kMSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFsbFxuJCRkKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSB9LCB7XG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMi5mKEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUkMyhDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlJDEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIGNhbGwkYigkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJGMgPSBfZXhwb3J0O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJDYgPSBpc0NhbGxhYmxlJG47XG52YXIgZGVmaW5lQnVpbHRJbiQ1ID0gZGVmaW5lQnVpbHRJbiQ4O1xuXG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4vLyBgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5jYXRjaFxuJCRjKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIsIHJlYWw6IHRydWUgfSwge1xuICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgfVxufSk7XG5cbi8vIG1ha2VzIHN1cmUgdGhhdCBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzIGBQcm9taXNlI2NhdGNoYCBwcm9wZXJseSB3b3JrcyB3aXRoIHBhdGNoZWQgYFByb21pc2UjdGhlbmBcbmlmIChpc0NhbGxhYmxlJDYoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKSkge1xuICB2YXIgbWV0aG9kID0gZ2V0QnVpbHRJbiQxKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQ1KE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICdjYXRjaCcsIG1ldGhvZCwgeyB1bnNhZmU6IHRydWUgfSk7XG4gIH1cbn1cblxudmFyICQkYiA9IF9leHBvcnQ7XG52YXIgY2FsbCRhID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQyID0gYUNhbGxhYmxlJDk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgcGVyZm9ybSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OID0gcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb247XG5cbi8vIGBQcm9taXNlLnJhY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJhY2VcbiQkYih7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEuZihDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZSQyKEMucmVzb2x2ZSk7XG4gICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBjYWxsJGEoJHByb21pc2VSZXNvbHZlLCBDLCBwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgJCRhID0gX2V4cG9ydDtcbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG5cbi8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmVqZWN0XG4kJGEoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQxIH0sIHtcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZih0aGlzKTtcbiAgICBjYWxsJDkoY2FwYWJpbGl0eS5yZWplY3QsIHVuZGVmaW5lZCwgcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciBhbk9iamVjdCQ2ID0gYW5PYmplY3QkZTtcbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkZDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBwcm9taXNlUmVzb2x2ZSQxID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QkNihDKTtcbiAgaWYgKGlzT2JqZWN0JDYoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG52YXIgJCQ5ID0gX2V4cG9ydDtcbnZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiQ4O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIHByb21pc2VSZXNvbHZlID0gcHJvbWlzZVJlc29sdmUkMTtcblxuZ2V0QnVpbHRJbignUHJvbWlzZScpO1xuXG4vLyBgUHJvbWlzZS5yZXNvbHZlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZXNvbHZlXG4kJDkoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZSh0aGlzLCB4KTtcbiAgfVxufSk7XG5cbmNsYXNzIFdlYlN0b3JhZ2VTZXJ2aWNlIHtcbiAgZ2V0SXRlbShrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSB7fTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbnZhciBvYmplY3RLZXlzJDIgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyQxKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ1ID0gZGVzY3JpcHRvcnM7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgYW5PYmplY3QkNSA9IGFuT2JqZWN0JGU7XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciBvYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzJDI7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5vYmplY3REZWZpbmVQcm9wZXJ0aWVzLmYgPSBERVNDUklQVE9SUyQ1ICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JDUoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdCQyKFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMkMShQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDIuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xuXG52YXIgYW5PYmplY3QkNCA9IGFuT2JqZWN0JGU7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnRpZXM7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQzO1xudmFyIGhpZGRlbktleXMgPSBoaWRkZW5LZXlzJDQ7XG52YXIgaHRtbCA9IGh0bWwkMjtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUkMSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG4gICAgICA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEUkMV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE8kMV0gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSA9IGFuT2JqZWN0JDQoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UTyQxXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgY3JlYXRlJDMgPSBvYmplY3RDcmVhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkkNCA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCQ4KCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5JDQoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUkMyhudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIGFkZFRvVW5zY29wYWJsZXMkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxudmFyIGZhaWxzJGggPSBmYWlscyRzO1xuXG52YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyRoKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQ2FsbGFibGUkNSA9IGlzQ2FsbGFibGUkbjtcbnZhciB0b09iamVjdCQ1ID0gdG9PYmplY3QkNztcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkMztcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBjb3JyZWN0UHJvdG90eXBlR2V0dGVyO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUkMiA9ICRPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gJE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdCQ1KE8pO1xuICBpZiAoaGFzT3duJDIob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlJDUoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgJE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSQyIDogbnVsbDtcbn07XG5cbnZhciBmYWlscyRnID0gZmFpbHMkcztcbnZhciBpc0NhbGxhYmxlJDQgPSBpc0NhbGxhYmxlJG47XG52YXIgZ2V0UHJvdG90eXBlT2YkMyA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIGRlZmluZUJ1aWx0SW4kNCA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciB3ZWxsS25vd25TeW1ib2wkNyA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCQ3KCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGZhbHNlO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMiwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDMoZ2V0UHJvdG90eXBlT2YkMyhhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG52YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9IEl0ZXJhdG9yUHJvdG90eXBlJDIgPT0gdW5kZWZpbmVkIHx8IGZhaWxzJGcoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkMl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IHt9O1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoIWlzQ2FsbGFibGUkNChJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDJdKSkge1xuICBkZWZpbmVCdWlsdEluJDQoSXRlcmF0b3JQcm90b3R5cGUkMiwgSVRFUkFUT1IkMiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbn1cblxudmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSQyLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDFcbn07XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSQxID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUkMiA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHNldFRvU3RyaW5nVGFnJDIgPSBzZXRUb1N0cmluZ1RhZyQ0O1xudmFyIEl0ZXJhdG9ycyQyID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlJDIoSXRlcmF0b3JQcm90b3R5cGUkMSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnJDIoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UpO1xuICBJdGVyYXRvcnMkMltUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgJCQ4ID0gX2V4cG9ydDtcbnZhciBjYWxsJDggPSBmdW5jdGlvbkNhbGw7XG52YXIgRnVuY3Rpb25OYW1lJDEgPSBmdW5jdGlvbk5hbWU7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRuO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDE7XG52YXIgZ2V0UHJvdG90eXBlT2YkMiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mJDQgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckNDtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGRlZmluZUJ1aWx0SW4kMyA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIEl0ZXJhdG9ycyQxID0gaXRlcmF0b3JzO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSBpdGVyYXRvcnNDb3JlO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUkMiA9IEZ1bmN0aW9uTmFtZSQxLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxID0gRnVuY3Rpb25OYW1lJDEuQ09ORklHVVJBQkxFO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2wkNignaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGRlZmluZUl0ZXJhdG9yJDEgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkMV1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQyKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoZ2V0UHJvdG90eXBlT2YkMihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YkNCkge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mJDQoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUkMyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkMV0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbiQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkMSwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnJDEoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSQyICYmIERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIGlmIChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNShJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbCQ4KG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbiQzKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQkOCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDFdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDEsIGRlZmF1bHRJdGVyYXRvciwgeyBuYW1lOiBERUZBVUxUIH0pO1xuICB9XG4gIEl0ZXJhdG9ycyQxW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIHJldHVybiBtZXRob2RzO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyQxID0gYWRkVG9VbnNjb3BhYmxlcyQyO1xudmFyIEl0ZXJhdG9ycyA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDMgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IkMTtcbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDQgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXG4vLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXG52YXIgZXNfYXJyYXlfaXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUkMih0aGlzLCB7XG4gICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXG4gICAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QkMShpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkNCh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMkMSgna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcyQxKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMkMSgnZW50cmllcycpO1xuXG4vLyBWOCB+IENocm9tZSA0NS0gYnVnXG5pZiAoREVTQ1JJUFRPUlMkNCAmJiB2YWx1ZXMubmFtZSAhPT0gJ3ZhbHVlcycpIHRyeSB7XG4gIGRlZmluZVByb3BlcnR5JDModmFsdWVzLCAnbmFtZScsIHsgdmFsdWU6ICd2YWx1ZXMnIH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbnZhciBkb21JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG4vLyBpbiBvbGQgV2ViS2l0IHZlcnNpb25zLCBgZWxlbWVudC5jbGFzc0xpc3RgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBnbG9iYWwgYERPTVRva2VuTGlzdGBcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxudmFyIGNsYXNzTGlzdCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc3BhbicpLmNsYXNzTGlzdDtcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxudmFyIGRvbVRva2VuTGlzdFByb3RvdHlwZSA9IERPTVRva2VuTGlzdFByb3RvdHlwZSQxID09PSBPYmplY3QucHJvdG90eXBlID8gdW5kZWZpbmVkIDogRE9NVG9rZW5MaXN0UHJvdG90eXBlJDE7XG5cbnZhciBnbG9iYWwkYiA9IGdsb2JhbCR0O1xudmFyIERPTUl0ZXJhYmxlcyA9IGRvbUl0ZXJhYmxlcztcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUgPSBkb21Ub2tlbkxpc3RQcm90b3R5cGU7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSBlc19hcnJheV9pdGVyYXRvcjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCQ1KCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCQ1KCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG52YXIgaGFuZGxlUHJvdG90eXBlID0gZnVuY3Rpb24gKENvbGxlY3Rpb25Qcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSkge1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBRyQxXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRyQxLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsJGJbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWwkYltDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKTtcbn1cblxuaGFuZGxlUHJvdG90eXBlKERPTVRva2VuTGlzdFByb3RvdHlwZSwgJ0RPTVRva2VuTGlzdCcpO1xuXG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lc3BhY2UpIHtcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgfVxuICBlbWl0KG1ldGhvZCwgLi4ucGFyYW1zKSB7XG4gICAgaWYgKCFMb2dnZXIuZGVidWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmFtZXNwYWNlICYmIG1ldGhvZCAhPT0gXCJlcnJvclwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZVttZXRob2RdKHRoaXMubmFtZXNwYWNlLCAuLi5wYXJhbXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGVbbWV0aG9kXSguLi5wYXJhbXMpO1xuICB9XG4gIGxvZyguLi5wYXJhbXMpIHtcbiAgICB0aGlzLmVtaXQoXCJsb2dcIiwgLi4ucGFyYW1zKTtcbiAgfVxuICBpbmZvKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcImluZm9cIiwgLi4ucGFyYW1zKTtcbiAgfVxuICB3YXJuKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcIndhcm5cIiwgLi4ucGFyYW1zKTtcbiAgfVxuICBlcnJvciguLi5wYXJhbXMpIHtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCAuLi5wYXJhbXMpO1xuICB9XG59XG5Mb2dnZXIuZGVidWcgPSBmYWxzZTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxudmFyICQkNyA9IF9leHBvcnQ7XG52YXIgJGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcy5pbmNsdWRlcztcbnZhciBmYWlscyRmID0gZmFpbHMkcztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gYWRkVG9VbnNjb3BhYmxlcyQyO1xuXG4vLyBGRjk5KyBidWdcbnZhciBCUk9LRU5fT05fU1BBUlNFID0gZmFpbHMkZihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhQXJyYXkoMSkuaW5jbHVkZXMoKTtcbn0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kJDcoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJST0tFTl9PTl9TUEFSU0UgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnaW5jbHVkZXMnKTtcblxudmFyIGlzT2JqZWN0JDUgPSBpc09iamVjdCRkO1xudmFyIGNsYXNzb2YkNiA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgTUFUQ0gkMSA9IHdlbGxLbm93blN5bWJvbCQ0KCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxudmFyIGlzUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0JDUoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSCQxXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mJDYoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cbnZhciBpc1JlZ0V4cCQxID0gaXNSZWdleHA7XG5cbnZhciAkVHlwZUVycm9yJDMgPSBUeXBlRXJyb3I7XG5cbnZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cCQxKGl0KSkge1xuICAgIHRocm93ICRUeXBlRXJyb3IkMyhcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG52YXIgY2xhc3NvZiQ1ID0gY2xhc3NvZiQ5O1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nJDUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YkNShhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nKGFyZ3VtZW50KTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkMyA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2wkMygnbWF0Y2gnKTtcblxudmFyIGNvcnJlY3RJc1JlZ2V4cExvZ2ljID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgJCQ2ID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBub3RBUmVnRXhwID0gbm90QVJlZ2V4cDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG52YXIgdG9TdHJpbmckNCA9IHRvU3RyaW5nJDU7XG52YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSBjb3JyZWN0SXNSZWdleHBMb2dpYztcblxudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcyRiKCcnLmluZGV4T2YpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQkNih7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZihcbiAgICAgIHRvU3RyaW5nJDQocmVxdWlyZU9iamVjdENvZXJjaWJsZSQzKHRoaXMpKSxcbiAgICAgIHRvU3RyaW5nJDQobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpKSxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxufSk7XG5cbi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG52YXIgd2hpdGVzcGFjZXMkMiA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMicgK1xuICAnXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG52YXIgdW5jdXJyeVRoaXMkYSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ2O1xudmFyIHRvU3RyaW5nJDMgPSB0b1N0cmluZyQ1O1xudmFyIHdoaXRlc3BhY2VzJDEgPSB3aGl0ZXNwYWNlcyQyO1xuXG52YXIgcmVwbGFjZSQxID0gdW5jdXJyeVRoaXMkYSgnJy5yZXBsYWNlKTtcbnZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMkMSArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQzID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMigkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gcmVwbGFjZSQxKHN0cmluZywgbHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHJlcGxhY2UkMShzdHJpbmcsIHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdUcmltID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QkMygxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCQzKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kJDMoMylcbn07XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQxID0gZnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBmYWlscyRlID0gZmFpbHMkcztcbnZhciB3aGl0ZXNwYWNlcyA9IHdoaXRlc3BhY2VzJDI7XG5cbnZhciBub24gPSAnXFx1MjAwQlxcdTAwODVcXHUxODBFJztcblxuLy8gY2hlY2sgdGhhdCBhIG1ldGhvZCB3b3JrcyB3aXRoIHRoZSBjb3JyZWN0IGxpc3Rcbi8vIG9mIHdoaXRlc3BhY2VzIGFuZCBoYXMgYSBjb3JyZWN0IG5hbWVcbnZhciBzdHJpbmdUcmltRm9yY2VkID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHJldHVybiBmYWlscyRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF3aGl0ZXNwYWNlc1tNRVRIT0RfTkFNRV0oKVxuICAgICAgfHwgbm9uW01FVEhPRF9OQU1FXSgpICE9PSBub25cbiAgICAgIHx8IChQUk9QRVJfRlVOQ1RJT05fTkFNRSQxICYmIHdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXS5uYW1lICE9PSBNRVRIT0RfTkFNRSk7XG4gIH0pO1xufTtcblxudmFyICQkNSA9IF9leHBvcnQ7XG52YXIgJHRyaW0gPSBzdHJpbmdUcmltLnRyaW07XG52YXIgZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCA9IHN0cmluZ1RyaW1Gb3JjZWQ7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiQkNSh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ1RyaW1NZXRob2QoJ3RyaW0nKSB9LCB7XG4gIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMpO1xuICB9XG59KTtcblxudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgZmFpbHMkZCA9IGZhaWxzJHM7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciB0b09iamVjdCQ0ID0gdG9PYmplY3QkNztcbnZhciBJbmRleGVkT2JqZWN0JDIgPSBpbmRleGVkT2JqZWN0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5JDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMkOShbXS5jb25jYXQpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbnZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyRkKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKERFU0NSSVBUT1JTJDMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSQyKHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkMih0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdmFyIFQgPSB0b09iamVjdCQ0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdCQyKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQob2JqZWN0S2V5cyhTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJDMgfHwgY2FsbCQ3KHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbnZhciAkJDQgPSBfZXhwb3J0O1xudmFyIGFzc2lnbiA9IG9iamVjdEFzc2lnbjtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kJDQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIkMSgpO1xuICB9XG4gIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogKCkgPT4gdGhpcy5lbWl0dGVyLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKVxuICAgIH07XG4gIH1cbiAgb2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICB9XG4gIGVtaXQoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9XG59XG5cbmNvbnN0IFBBQ0tBR0VfTkFNRSA9IFwibmVhci13YWxsZXQtc2VsZWN0b3JcIjtcbmNvbnN0IFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTID0gXCJyZWNlbnRseVNpZ25lZEluV2FsbGV0c1wiO1xuY29uc3QgQ09OVFJBQ1QgPSBcImNvbnRyYWN0XCI7XG5jb25zdCBQRU5ESU5HX0NPTlRSQUNUID0gXCJjb250cmFjdDpwZW5kaW5nXCI7XG5jb25zdCBTRUxFQ1RFRF9XQUxMRVRfSUQgPSBgc2VsZWN0ZWRXYWxsZXRJZGA7XG5jb25zdCBQRU5ESU5HX1NFTEVDVEVEX1dBTExFVF9JRCA9IGBzZWxlY3RlZFdhbGxldElkOnBlbmRpbmdgO1xuXG5jbGFzcyBXYWxsZXRNb2R1bGVzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGZhY3RvcmllcyxcbiAgICBzdG9yYWdlLFxuICAgIG9wdGlvbnMsXG4gICAgc3RvcmUsXG4gICAgZW1pdHRlcixcbiAgICBwcm92aWRlclxuICB9KSB7XG4gICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLm1vZHVsZXMgPSBbXTtcbiAgICB0aGlzLmluc3RhbmNlcyA9IHt9O1xuICB9XG4gIHZhbGlkYXRlV2FsbGV0KGlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBhY2NvdW50cyA9IFtdO1xuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgdGhpcy5nZXRXYWxsZXQoaWQpO1xuICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICAvLyBFbnN1cmUgb3VyIHBlcnNpc3RlbnQgc3RhdGUgYWxpZ25zIHdpdGggdGhlIHNlbGVjdGVkIHdhbGxldC5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUgYSB3YWxsZXQgaXMgc2VsZWN0ZWQsIGJ1dCBpdCByZXR1cm5zIG5vIGFjY291bnRzIChub3Qgc2lnbmVkIGluKS5cbiAgICAgICAgYWNjb3VudHMgPSB5aWVsZCB3YWxsZXQuZ2V0QWNjb3VudHMoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byB2YWxpZGF0ZSAke3dhbGxldC5pZH0gZHVyaW5nIHNldHVwYCk7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9KTtcbiAgfVxuICByZXNvbHZlU3RvcmFnZVN0YXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBqc29uU3RvcmFnZSA9IG5ldyBKc29uU3RvcmFnZSh0aGlzLnN0b3JhZ2UsIFBBQ0tBR0VfTkFNRSk7XG4gICAgICBjb25zdCBwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCA9IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUEVORElOR19TRUxFQ1RFRF9XQUxMRVRfSUQpO1xuICAgICAgY29uc3QgcGVuZGluZ0NvbnRyYWN0ID0geWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShQRU5ESU5HX0NPTlRSQUNUKTtcbiAgICAgIGlmIChwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCAmJiBwZW5kaW5nQ29udHJhY3QpIHtcbiAgICAgICAgY29uc3QgX2FjY291bnRzID0geWllbGQgdGhpcy52YWxpZGF0ZVdhbGxldChwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEVORElOR19TRUxFQ1RFRF9XQUxMRVRfSUQpO1xuICAgICAgICB5aWVsZCBqc29uU3RvcmFnZS5yZW1vdmVJdGVtKFBFTkRJTkdfQ09OVFJBQ1QpO1xuICAgICAgICBpZiAoX2FjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IF9zZWxlY3RlZFdhbGxldElkXG4gICAgICAgICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZFdhbGxldCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0KF9zZWxlY3RlZFdhbGxldElkKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRXYWxsZXQgJiYgcGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQgIT09IF9zZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICAgICAgICB5aWVsZCBzZWxlY3RlZFdhbGxldC5zaWduT3V0KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBzaWduIG91dCBleGlzdGluZyB3YWxsZXRcIik7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzRnJvbVBlbmRpbmcgPSB5aWVsZCB0aGlzLnNldFdhbGxldEFzUmVjZW50bHlTaWduZWRJbihwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnRzOiBfYWNjb3VudHMsXG4gICAgICAgICAgICBjb250cmFjdDogcGVuZGluZ0NvbnRyYWN0LFxuICAgICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogcGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0czogcmVjZW50bHlTaWduZWRJbldhbGxldHNGcm9tUGVuZGluZ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udHJhY3QsXG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIHRoaXMudmFsaWRhdGVXYWxsZXQoc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICBjb25zdCByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMpO1xuICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY2NvdW50czogW10sXG4gICAgICAgICAgY29udHJhY3Q6IG51bGwsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogbnVsbCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0czogcmVjZW50bHlTaWduZWRJbldhbGxldHMgfHwgW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBjb250cmFjdCxcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHM6IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzIHx8IFtdXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHNldFdhbGxldEFzUmVjZW50bHlTaWduZWRJbih3YWxsZXRJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBqc29uU3RvcmFnZSA9IG5ldyBKc29uU3RvcmFnZSh0aGlzLnN0b3JhZ2UsIFBBQ0tBR0VfTkFNRSk7XG4gICAgICBsZXQgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTKTtcbiAgICAgIGlmICghcmVjZW50bHlTaWduZWRJbldhbGxldHMpIHtcbiAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjZW50bHlTaWduZWRJbldhbGxldHMuaW5jbHVkZXMod2FsbGV0SWQpKSB7XG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLnVuc2hpZnQod2FsbGV0SWQpO1xuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLnNsaWNlKDAsIDUpO1xuICAgICAgICB5aWVsZCBqc29uU3RvcmFnZS5zZXRJdGVtKFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTLCByZWNlbnRseVNpZ25lZEluV2FsbGV0cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjZW50bHlTaWduZWRJbldhbGxldHM7XG4gICAgfSk7XG4gIH1cbiAgc2lnbk91dFdhbGxldCh3YWxsZXRJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCB0aGlzLmdldFdhbGxldCh3YWxsZXRJZCk7XG4gICAgICB5aWVsZCB3YWxsZXQuc2lnbk91dCgpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBzaWduIG91dCAke3dhbGxldC5pZH1gKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgIC8vIEF0IGxlYXN0IGNsZWFuIHVwIHN0YXRlIG9uIG91ciBzaWRlLlxuICAgICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkT3V0KHdhbGxldC5pZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbldhbGxldFNpZ25lZEluKHdhbGxldElkLCB7XG4gICAgYWNjb3VudHMsXG4gICAgY29udHJhY3RJZCxcbiAgICBtZXRob2ROYW1lc1xuICB9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGpzb25TdG9yYWdlID0gbmV3IEpzb25TdG9yYWdlKHRoaXMuc3RvcmFnZSwgUEFDS0FHRV9OQU1FKTtcbiAgICAgIGNvbnN0IGNvbnRyYWN0ID0ge1xuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lc1xuICAgICAgfTtcbiAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMuZ2V0TW9kdWxlKHdhbGxldElkKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgZ3VhcmFudGVlIHRoZSB1c2VyIHdpbGwgYWN0dWFsbHkgc2lnbiBpbiB3aXRoIGJyb3dzZXIgd2FsbGV0cy5cbiAgICAgICAgLy8gQmVzdCB3ZSBjYW4gZG8gaXMgc2V0IGluIHN0b3JhZ2UgYW5kIHZhbGlkYXRlIG9uIGluaXQuXG4gICAgICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJicm93c2VyXCIpIHtcbiAgICAgICAgICB5aWVsZCBqc29uU3RvcmFnZS5zZXRJdGVtKFBFTkRJTkdfU0VMRUNURURfV0FMTEVUX0lELCB3YWxsZXRJZCk7XG4gICAgICAgICAgeWllbGQganNvblN0b3JhZ2Uuc2V0SXRlbShQRU5ESU5HX0NPTlRSQUNULCBjb250cmFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkV2FsbGV0SWQgJiYgc2VsZWN0ZWRXYWxsZXRJZCAhPT0gd2FsbGV0SWQpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zaWduT3V0V2FsbGV0KHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSB5aWVsZCB0aGlzLnNldFdhbGxldEFzUmVjZW50bHlTaWduZWRJbih3YWxsZXRJZCk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJXQUxMRVRfQ09OTkVDVEVEXCIsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2lnbmVkSW5cIiwge1xuICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgbWV0aG9kTmFtZXMsXG4gICAgICAgIGFjY291bnRzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbldhbGxldFNpZ25lZE91dCh3YWxsZXRJZCkge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJXQUxMRVRfRElTQ09OTkVDVEVEXCIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIHdhbGxldElkXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJzaWduZWRPdXRcIiwge1xuICAgICAgd2FsbGV0SWRcbiAgICB9KTtcbiAgfVxuICBzZXR1cFdhbGxldEVtaXR0ZXIobW9kdWxlKSB7XG4gICAgY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICBlbWl0dGVyLm9uKFwic2lnbmVkT3V0XCIsICgpID0+IHtcbiAgICAgIHRoaXMub25XYWxsZXRTaWduZWRPdXQobW9kdWxlLmlkKTtcbiAgICB9KTtcbiAgICBlbWl0dGVyLm9uKFwic2lnbmVkSW5cIiwgZXZlbnQgPT4ge1xuICAgICAgdGhpcy5vbldhbGxldFNpZ25lZEluKG1vZHVsZS5pZCwgZXZlbnQpO1xuICAgIH0pO1xuICAgIGVtaXR0ZXIub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKHtcbiAgICAgIGFjY291bnRzXG4gICAgfSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogbW9kdWxlLmlkLFxuICAgICAgICBhY2NvdW50c1xuICAgICAgfSk7XG4gICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduT3V0V2FsbGV0KG1vZHVsZS5pZCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJBQ0NPVU5UU19DSEFOR0VEXCIsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICB3YWxsZXRJZDogbW9kdWxlLmlkLFxuICAgICAgICAgIGFjY291bnRzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgICBlbWl0dGVyLm9uKFwibmV0d29ya0NoYW5nZWRcIiwgKHtcbiAgICAgIG5ldHdvcmtJZFxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwibmV0d29ya0NoYW5nZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogbW9kdWxlLmlkLFxuICAgICAgICBuZXR3b3JrSWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVtaXR0ZXIub24oXCJ1cmlDaGFuZ2VkXCIsICh7XG4gICAgICB1cmlcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInVyaUNoYW5nZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogbW9kdWxlLmlkLFxuICAgICAgICB1cmlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBlbWl0dGVyO1xuICB9XG4gIHZhbGlkYXRlU2lnbk1lc3NhZ2VQYXJhbXMoe1xuICAgIG1lc3NhZ2UsXG4gICAgbm9uY2UsXG4gICAgcmVjaXBpZW50XG4gIH0pIHtcbiAgICBpZiAoIW1lc3NhZ2UgfHwgbWVzc2FnZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWVzc2FnZS4gSXQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCIpO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihub25jZSkgfHwgbm9uY2UubGVuZ3RoICE9PSAzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub25jZS4gSXQgbXVzdCBiZSBhIEJ1ZmZlciB3aXRoIGEgbGVuZ3RoIG9mIDMyIGJ5dGVzLlwiKTtcbiAgICB9XG4gICAgaWYgKCFyZWNpcGllbnQgfHwgcmVjaXBpZW50LnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWNpcGllbnQuIEl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiKTtcbiAgICB9XG4gIH1cbiAgZGVjb3JhdGVXYWxsZXQod2FsbGV0KSB7XG4gICAgY29uc3QgX3NpZ25JbiA9IHdhbGxldC5zaWduSW47XG4gICAgY29uc3QgX3NpZ25PdXQgPSB3YWxsZXQuc2lnbk91dDtcbiAgICBjb25zdCBfc2lnbk1lc3NhZ2UgPSB3YWxsZXQuc2lnbk1lc3NhZ2U7XG4gICAgd2FsbGV0LnNpZ25JbiA9IHBhcmFtcyA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIF9zaWduSW4ocGFyYW1zKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBbXVxuICAgICAgfSA9IHBhcmFtcztcbiAgICAgIHlpZWxkIHRoaXMub25XYWxsZXRTaWduZWRJbih3YWxsZXQuaWQsIHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9KTtcbiAgICB3YWxsZXQuc2lnbk91dCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zaWduT3V0KCk7XG4gICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkT3V0KHdhbGxldC5pZCk7XG4gICAgfSk7XG4gICAgd2FsbGV0LnNpZ25NZXNzYWdlID0gcGFyYW1zID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChfc2lnbk1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgVGhlIHNpZ25NZXNzYWdlIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5ICR7d2FsbGV0Lm1ldGFkYXRhLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICB0aGlzLnZhbGlkYXRlU2lnbk1lc3NhZ2VQYXJhbXMocGFyYW1zKTtcbiAgICAgIHJldHVybiB5aWVsZCBfc2lnbk1lc3NhZ2UocGFyYW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gd2FsbGV0O1xuICB9XG4gIHNldHVwSW5zdGFuY2UobW9kdWxlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghbW9kdWxlLm1ldGFkYXRhLmF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbW9kdWxlLnR5cGUgPT09IFwiaW5qZWN0ZWRcIiA/IFwibm90IGluc3RhbGxlZFwiIDogXCJub3QgYXZhaWxhYmxlXCI7XG4gICAgICAgIHRocm93IEVycm9yKGAke21vZHVsZS5tZXRhZGF0YS5uYW1lfSBpcyAke21lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxsZXQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgaWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgdHlwZTogbW9kdWxlLnR5cGUsXG4gICAgICAgIG1ldGFkYXRhOiBtb2R1bGUubWV0YWRhdGFcbiAgICAgIH0sIHlpZWxkIG1vZHVsZS5pbml0KHtcbiAgICAgICAgaWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgdHlwZTogbW9kdWxlLnR5cGUsXG4gICAgICAgIG1ldGFkYXRhOiBtb2R1bGUubWV0YWRhdGEsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmUudG9SZWFkT25seSgpLFxuICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgICAgZW1pdHRlcjogdGhpcy5zZXR1cFdhbGxldEVtaXR0ZXIobW9kdWxlKSxcbiAgICAgICAgbG9nZ2VyOiBuZXcgTG9nZ2VyKG1vZHVsZS5pZCksXG4gICAgICAgIHN0b3JhZ2U6IG5ldyBKc29uU3RvcmFnZSh0aGlzLnN0b3JhZ2UsIFtQQUNLQUdFX05BTUUsIG1vZHVsZS5pZF0pXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvcmF0ZVdhbGxldCh3YWxsZXQpO1xuICAgIH0pO1xuICB9XG4gIGdldE1vZHVsZShpZCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZXMuZmluZCh4ID0+IHguaWQgPT09IGlkKTtcbiAgfVxuICBnZXRXYWxsZXQoaWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5nZXRNb2R1bGUoaWQpO1xuICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAvLyBJZiB1c2VyIHVuaW5zdGFsbGVkL3JlbW92ZWQgYSB3YWxsZXQgd2hpY2ggd2FzIHByZXZpb3VzbHkgc2lnbmVkIGluIHdpdGhcbiAgICAgIC8vIGJlc3Qgd2UgY2FuIGRvIGlzIGNsZWFuIHVwIHN0YXRlIG9uIG91ciBzaWRlLlxuICAgICAgaWYgKCFtb2R1bGUubWV0YWRhdGEuYXZhaWxhYmxlICYmIHNlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgdGhpcy5vbldhbGxldFNpZ25lZE91dChzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4geWllbGQgbW9kdWxlLndhbGxldCgpO1xuICAgIH0pO1xuICB9XG4gIHNldHVwKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBtb2R1bGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjdG9yaWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHlpZWxkIHRoaXMuZmFjdG9yaWVzW2ldKHtcbiAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBsb2dnZXIubG9nKFwiRmFpbGVkIHRvIHNldHVwIG1vZHVsZVwiKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgd2FsbGV0cyB0aGF0IGFyZW4ndCBhdmFpbGFibGUuXG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBkdXBsaWNhdGVkIG1vZHVsZS5cbiAgICAgICAgaWYgKG1vZHVsZXMuc29tZSh4ID0+IHguaWQgPT09IG1vZHVsZS5pZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGVzLnB1c2goe1xuICAgICAgICAgIGlkOiBtb2R1bGUuaWQsXG4gICAgICAgICAgdHlwZTogbW9kdWxlLnR5cGUsXG4gICAgICAgICAgbWV0YWRhdGE6IG1vZHVsZS5tZXRhZGF0YSxcbiAgICAgICAgICB3YWxsZXQ6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzW21vZHVsZS5pZF07XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2UgPSB5aWVsZCB0aGlzLnNldHVwSW5zdGFuY2UobW9kdWxlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzW21vZHVsZS5pZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kdWxlcyA9IG1vZHVsZXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBjb250cmFjdCxcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgIH0gPSB5aWVsZCB0aGlzLnJlc29sdmVTdG9yYWdlU3RhdGUoKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIlNFVFVQX1dBTExFVF9NT0RVTEVTXCIsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5tb2R1bGVzW2ldLnR5cGUgIT09IFwiaW5zdGFudC1saW5rXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCB0aGlzLm1vZHVsZXNbaV0ud2FsbGV0KCk7XG4gICAgICAgIGlmICghd2FsbGV0Lm1ldGFkYXRhLnJ1bk9uU3RhcnR1cCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgd2FsbGV0LnNpZ25Jbih7XG4gICAgICAgICAgICBjb250cmFjdElkOiB3YWxsZXQuZ2V0Q29udHJhY3RJZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBzaWduIGluIHRvIHdhbGxldC4gXCIgKyBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZ2V0TmV0d29ya1ByZXNldCA9IG5ldHdvcmtJZCA9PiB7XG4gIHN3aXRjaCAobmV0d29ya0lkKSB7XG4gICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5ldHdvcmtJZCxcbiAgICAgICAgbm9kZVVybDogXCJodHRwczovL3JwYy5tYWlubmV0Lm5lYXIub3JnXCIsXG4gICAgICAgIGhlbHBlclVybDogXCJodHRwczovL2hlbHBlci5tYWlubmV0Lm5lYXIub3JnXCIsXG4gICAgICAgIGV4cGxvcmVyVXJsOiBcImh0dHBzOi8vbmVhcmJsb2Nrcy5pb1wiLFxuICAgICAgICBpbmRleGVyVXJsOiBcImh0dHBzOi8vYXBpLmtpdHdhbGxldC5hcHBcIlxuICAgICAgfTtcbiAgICBjYXNlIFwidGVzdG5ldFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV0d29ya0lkLFxuICAgICAgICBub2RlVXJsOiBcImh0dHBzOi8vcnBjLnRlc3RuZXQubmVhci5vcmdcIixcbiAgICAgICAgaGVscGVyVXJsOiBcImh0dHBzOi8vaGVscGVyLnRlc3RuZXQubmVhci5vcmdcIixcbiAgICAgICAgZXhwbG9yZXJVcmw6IFwiaHR0cHM6Ly90ZXN0bmV0Lm5lYXJibG9ja3MuaW9cIixcbiAgICAgICAgaW5kZXhlclVybDogXCJodHRwczovL3Rlc3RuZXQtYXBpLmtpdHdhbGxldC5hcHBcIlxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGNvbmZpZyBmb3I6ICcke25ldHdvcmtJZH0nYCk7XG4gIH1cbn07XG5jb25zdCByZXNvbHZlTmV0d29yayA9IG5ldHdvcmsgPT4ge1xuICByZXR1cm4gdHlwZW9mIG5ldHdvcmsgPT09IFwic3RyaW5nXCIgPyBnZXROZXR3b3JrUHJlc2V0KG5ldHdvcmspIDogbmV0d29yaztcbn07XG5jb25zdCByZXNvbHZlT3B0aW9ucyA9IHBhcmFtcyA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbGFuZ3VhZ2VDb2RlOiBwYXJhbXMubGFuZ3VhZ2VDb2RlIHx8IHVuZGVmaW5lZCxcbiAgICBuZXR3b3JrOiByZXNvbHZlTmV0d29yayhwYXJhbXMubmV0d29yayksXG4gICAgZGVidWc6IHBhcmFtcy5kZWJ1ZyB8fCBmYWxzZSxcbiAgICBvcHRpbWl6ZVdhbGxldE9yZGVyOiBwYXJhbXMub3B0aW1pemVXYWxsZXRPcmRlciA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUsXG4gICAgcmFuZG9taXplV2FsbGV0T3JkZXI6IHBhcmFtcy5yYW5kb21pemVXYWxsZXRPcmRlciB8fCBmYWxzZSxcbiAgICByZWxheWVyVXJsOiBwYXJhbXMucmVsYXllclVybCB8fCB1bmRlZmluZWRcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIHN0b3JhZ2U6IHBhcmFtcy5zdG9yYWdlIHx8IG5ldyBXZWJTdG9yYWdlU2VydmljZSgpXG4gIH07XG59O1xuXG5jb25zdCByZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgbG9nZ2VyLmxvZyhcIlN0b3JlIEFjdGlvblwiLCBhY3Rpb24pO1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcIlNFVFVQX1dBTExFVF9NT0RVTEVTXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBhY2NvdW50U3RhdGVzID0gYWNjb3VudHMubWFwKChhY2NvdW50LCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogaSA9PT0gMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICBhY2NvdW50czogYWNjb3VudFN0YXRlcyxcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGNhc2UgXCJXQUxMRVRfQ09OTkVDVEVEXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGl2ZUFjY291bnRJbmRleCA9IHN0YXRlLmFjY291bnRzLmZpbmRJbmRleChhY2NvdW50ID0+IGFjY291bnQuYWN0aXZlKTtcbiAgICAgICAgY29uc3QgYWNjb3VudFN0YXRlcyA9IGFjY291bnRzLm1hcCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7XG4gICAgICAgICAgICBhY3RpdmU6IGkgPT09IChhY3RpdmVBY2NvdW50SW5kZXggPiAtMSA/IGFjdGl2ZUFjY291bnRJbmRleCA6IDApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICBhY2NvdW50czogYWNjb3VudFN0YXRlcyxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiB3YWxsZXRJZCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlIFwiV0FMTEVUX0RJU0NPTk5FQ1RFRFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2FsbGV0SWRcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBpZiAod2FsbGV0SWQgIT09IHN0YXRlLnNlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgICAgICAgY29udHJhY3Q6IG51bGwsXG4gICAgICAgICAgYWNjb3VudHM6IFtdLFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgY2FzZSBcIkFDQ09VTlRTX0NIQU5HRURcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdhbGxldElkLFxuICAgICAgICAgIGFjY291bnRzXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgaWYgKHdhbGxldElkICE9PSBzdGF0ZS5zZWxlY3RlZFdhbGxldElkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGl2ZUFjY291bnQgPSBzdGF0ZS5hY2NvdW50cy5maW5kKGFjY291bnQgPT4gYWNjb3VudC5hY3RpdmUpO1xuICAgICAgICBjb25zdCBpc0FjdGl2ZUFjY291bnRSZW1vdmVkID0gIWFjY291bnRzLnNvbWUoYWNjb3VudCA9PiBhY2NvdW50LmFjY291bnRJZCA9PT0gKGFjdGl2ZUFjY291bnQgPT09IG51bGwgfHwgYWN0aXZlQWNjb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlQWNjb3VudC5hY2NvdW50SWQpKTtcbiAgICAgICAgY29uc3QgYWNjb3VudFN0YXRlcyA9IGFjY291bnRzLm1hcCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7XG4gICAgICAgICAgICBhY3RpdmU6IGlzQWN0aXZlQWNjb3VudFJlbW92ZWQgPyBpID09PSAwIDogYWNjb3VudC5hY2NvdW50SWQgPT09IChhY3RpdmVBY2NvdW50ID09PSBudWxsIHx8IGFjdGl2ZUFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUFjY291bnQuYWNjb3VudElkKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7XG4gICAgICAgICAgYWNjb3VudHM6IGFjY291bnRTdGF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgY2FzZSBcIlNFVF9BQ1RJVkVfQUNDT1VOVFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYWNjb3VudElkXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgY29uc3QgYWNjb3VudFN0YXRlcyA9IHN0YXRlLmFjY291bnRzLm1hcChhY2NvdW50ID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgYWN0aXZlOiBhY2NvdW50LmFjY291bnRJZCA9PT0gYWNjb3VudElkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBhY2NvdW50czogYWNjb3VudFN0YXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSBzdG9yYWdlID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBqc29uU3RvcmFnZSA9IG5ldyBKc29uU3RvcmFnZShzdG9yYWdlLCBQQUNLQUdFX05BTUUpO1xuICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgbW9kdWxlczogW10sXG4gICAgYWNjb3VudHM6IFtdLFxuICAgIGNvbnRyYWN0OiB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKENPTlRSQUNUKSxcbiAgICBzZWxlY3RlZFdhbGxldElkOiB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFNFTEVDVEVEX1dBTExFVF9JRCksXG4gICAgcmVjZW50bHlTaWduZWRJbldhbGxldHM6ICh5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTKSkgfHwgW11cbiAgfTtcbiAgY29uc3Qgc3RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdChpbml0aWFsU3RhdGUpO1xuICBjb25zdCBhY3Rpb25zJCA9IG5ldyBTdWJqZWN0KCk7XG4gIGFjdGlvbnMkLnBpcGUoc2NhbihyZWR1Y2VyLCBpbml0aWFsU3RhdGUpKS5zdWJzY3JpYmUoc3RhdGUkKTtcbiAgY29uc3Qgc3luY1N0b3JhZ2UgPSAocHJldlN0YXRlLCBzdGF0ZSwgc3RvcmFnZUtleSwgcHJvcGVydHkpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGlmIChzdGF0ZVtwcm9wZXJ0eV0gPT09IHByZXZTdGF0ZVtwcm9wZXJ0eV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YXRlW3Byb3BlcnR5XSkge1xuICAgICAgeWllbGQganNvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBzdGF0ZVtwcm9wZXJ0eV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB5aWVsZCBqc29uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICB9KTtcbiAgbGV0IHByZXZTdGF0ZSA9IHN0YXRlJC5nZXRWYWx1ZSgpO1xuICBzdGF0ZSQuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICBzeW5jU3RvcmFnZShwcmV2U3RhdGUsIHN0YXRlLCBTRUxFQ1RFRF9XQUxMRVRfSUQsIFwic2VsZWN0ZWRXYWxsZXRJZFwiKTtcbiAgICBzeW5jU3RvcmFnZShwcmV2U3RhdGUsIHN0YXRlLCBDT05UUkFDVCwgXCJjb250cmFjdFwiKTtcbiAgICBzeW5jU3RvcmFnZShwcmV2U3RhdGUsIHN0YXRlLCBSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUywgXCJyZWNlbnRseVNpZ25lZEluV2FsbGV0c1wiKTtcbiAgICBwcmV2U3RhdGUgPSBzdGF0ZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb2JzZXJ2YWJsZTogc3RhdGUkLFxuICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSQuZ2V0VmFsdWUoKSxcbiAgICBkaXNwYXRjaDogYWN0aW9uID0+IGFjdGlvbnMkLm5leHQoYWN0aW9uKSxcbiAgICB0b1JlYWRPbmx5OiAoKSA9PiAoe1xuICAgICAgZ2V0U3RhdGU6ICgpID0+IHN0YXRlJC5nZXRWYWx1ZSgpLFxuICAgICAgb2JzZXJ2YWJsZTogc3RhdGUkLmFzT2JzZXJ2YWJsZSgpXG4gICAgfSlcbiAgfTtcbn0pO1xuXG5sZXQgd2FsbGV0U2VsZWN0b3JJbnN0YW5jZSA9IG51bGw7XG5jb25zdCBjcmVhdGVTZWxlY3RvciA9IChvcHRpb25zLCBzdG9yZSwgd2FsbGV0TW9kdWxlcywgZW1pdHRlcikgPT4ge1xuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgc3RvcmU6IHN0b3JlLnRvUmVhZE9ubHkoKSxcbiAgICB3YWxsZXQ6IGlkID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHdhbGxldE1vZHVsZXMuZ2V0V2FsbGV0KGlkIHx8IHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3YWxsZXQgaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gd2FsbGV0IHNlbGVjdGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9KSxcbiAgICBzZXRBY3RpdmVBY2NvdW50OiBhY2NvdW50SWQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoIWFjY291bnRzLnNvbWUoYWNjb3VudCA9PiBhY2NvdW50LmFjY291bnRJZCA9PT0gYWNjb3VudElkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFjY291bnQgaWRcIik7XG4gICAgICB9XG4gICAgICBzdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiU0VUX0FDVElWRV9BQ0NPVU5UXCIsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBhY2NvdW50SWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpc1NpZ25lZEluKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gQm9vbGVhbihhY2NvdW50cy5sZW5ndGgpO1xuICAgIH0sXG4gICAgb246IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICByZXR1cm4gZW1pdHRlci5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZjogKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcbn07XG4vKipcclxuICogSW5pdGlhdGVzIGEgd2FsbGV0IHNlbGVjdG9yIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7V2FsbGV0U2VsZWN0b3JQYXJhbXN9IHBhcmFtcyBTZWxlY3RvciBwYXJhbWV0ZXJzIChuZXR3b3JrLCBtb2R1bGVzLi4uKVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxXYWxsZXRTZWxlY3Rvcj59IFJldHVybnMgYSBXYWxsZXRTZWxlY3RvciBvYmplY3RcclxuICovXG5jb25zdCBzZXR1cFdhbGxldFNlbGVjdG9yID0gcGFyYW1zID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgb3B0aW9ucyxcbiAgICBzdG9yYWdlXG4gIH0gPSByZXNvbHZlT3B0aW9ucyhwYXJhbXMpO1xuICBMb2dnZXIuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBjb25zdCBzdG9yZSA9IHlpZWxkIGNyZWF0ZVN0b3JlKHN0b3JhZ2UpO1xuICBjb25zdCB3YWxsZXRNb2R1bGVzID0gbmV3IFdhbGxldE1vZHVsZXMoe1xuICAgIGZhY3RvcmllczogcGFyYW1zLm1vZHVsZXMsXG4gICAgc3RvcmFnZSxcbiAgICBvcHRpb25zLFxuICAgIHN0b3JlLFxuICAgIGVtaXR0ZXIsXG4gICAgcHJvdmlkZXI6IG5ldyBQcm92aWRlcihvcHRpb25zLm5ldHdvcmsubm9kZVVybClcbiAgfSk7XG4gIHlpZWxkIHdhbGxldE1vZHVsZXMuc2V0dXAoKTtcbiAgaWYgKHBhcmFtcy5hbGxvd011bHRpcGxlU2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yKG9wdGlvbnMsIHN0b3JlLCB3YWxsZXRNb2R1bGVzLCBlbWl0dGVyKTtcbiAgfVxuICBpZiAoIXdhbGxldFNlbGVjdG9ySW5zdGFuY2UpIHtcbiAgICB3YWxsZXRTZWxlY3Rvckluc3RhbmNlID0gY3JlYXRlU2VsZWN0b3Iob3B0aW9ucywgc3RvcmUsIHdhbGxldE1vZHVsZXMsIGVtaXR0ZXIpO1xuICB9XG4gIHJldHVybiB3YWxsZXRTZWxlY3Rvckluc3RhbmNlO1xufSk7XG5cbmNvbnN0IHdhaXQgPSBtcyA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn07XG5jb25zdCBwb2xsID0gKGNiLCBpbnRlcnZhbCwgcmVtYWluaW5nKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3QgcmVzdWx0ID0gY2IoKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFyZW1haW5pbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGNlZWRlZCB0aW1lb3V0XCIpO1xuICB9XG4gIHJldHVybiB3YWl0KGludGVydmFsKS50aGVuKCgpID0+IHBvbGwoY2IsIGludGVydmFsLCByZW1haW5pbmcgLSAxKSk7XG59KTtcbmNvbnN0IHdhaXRGb3IgPSAoY2IsIG9wdHMgPSB7fSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHtcbiAgICB0aW1lb3V0ID0gMTAwLFxuICAgIGludGVydmFsID0gNTBcbiAgfSA9IG9wdHM7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3dhaXQodGltZW91dCkudGhlbigoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhjZWVkZWQgdGltZW91dFwiKTtcbiAgfSksIHBvbGwoY2IsIGludGVydmFsLCBNYXRoLmZsb29yKHRpbWVvdXQgLyBpbnRlcnZhbCkpXSk7XG59KTtcblxuY29uc3QgZ2V0QWN0aXZlQWNjb3VudCA9IHN0YXRlID0+IHtcbiAgcmV0dXJuIHN0YXRlLmFjY291bnRzLmZpbmQoYWNjb3VudCA9PiBhY2NvdW50LmFjdGl2ZSkgfHwgbnVsbDtcbn07XG5cbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ5O1xudmFyIHRvT2JqZWN0JDMgPSB0b09iamVjdCQ3O1xudmFyIEluZGV4ZWRPYmplY3QkMSA9IGluZGV4ZWRPYmplY3Q7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNSA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG5cbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMiA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFDYWxsYWJsZSQxKGNhbGxiYWNrZm4pO1xuICAgIHZhciBPID0gdG9PYmplY3QkMyh0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QkMShPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNShPKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyAkVHlwZUVycm9yJDIoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbnZhciBhcnJheVJlZHVjZSA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kJDIoZmFsc2UpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlcmlnaHRcbiAgcmlnaHQ6IGNyZWF0ZU1ldGhvZCQyKHRydWUpXG59O1xuXG52YXIgZmFpbHMkYyA9IGZhaWxzJHM7XG5cbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDEgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyRjKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcblxudmFyICQkMyA9IF9leHBvcnQ7XG52YXIgJHJlZHVjZSA9IGFycmF5UmVkdWNlLmxlZnQ7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBJU19OT0RFID0gZW5naW5lSXNOb2RlO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3JlZHVjZScpO1xuLy8gQ2hyb21lIDgwLTgyIGhhcyBhIGNyaXRpY2FsIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA0OTk4MlxudmFyIENIUk9NRV9CVUcgPSAhSVNfTk9ERSAmJiBDSFJPTUVfVkVSU0lPTiA+IDc5ICYmIENIUk9NRV9WRVJTSU9OIDwgODM7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuJCQzKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCB8fCBDSFJPTUVfQlVHIH0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGxlbmd0aCwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JGU7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciByZWdleHBGbGFncyQxID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0JDModGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuaGFzSW5kaWNlcykgcmVzdWx0ICs9ICdkJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQudW5pY29kZVNldHMpIHJlc3VsdCArPSAndic7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBmYWlscyRiID0gZmFpbHMkcztcbnZhciBnbG9iYWwkYSA9IGdsb2JhbCR0O1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJ2EnLCAneScpIC0+IC9hL3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAkMiA9IGdsb2JhbCRhLlJlZ0V4cDtcblxudmFyIFVOU1VQUE9SVEVEX1kkMiA9IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwJDIoJ2EnLCAneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnYWJjZCcpICE9IG51bGw7XG59KTtcblxuLy8gVUMgQnJvd3NlciBidWdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMDA4XG52YXIgTUlTU0VEX1NUSUNLWSA9IFVOU1VQUE9SVEVEX1kkMiB8fCBmYWlscyRiKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEkUmVnRXhwJDIoJ2EnLCAneScpLnN0aWNreTtcbn0pO1xuXG52YXIgQlJPS0VOX0NBUkVUID0gVU5TVVBQT1JURURfWSQyIHx8IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NzM2ODdcbiAgdmFyIHJlID0gJFJlZ0V4cCQyKCdecicsICdneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnc3RyJykgIT0gbnVsbDtcbn0pO1xuXG52YXIgcmVnZXhwU3RpY2t5SGVscGVycyA9IHtcbiAgQlJPS0VOX0NBUkVUOiBCUk9LRU5fQ0FSRVQsXG4gIE1JU1NFRF9TVElDS1k6IE1JU1NFRF9TVElDS1ksXG4gIFVOU1VQUE9SVEVEX1k6IFVOU1VQUE9SVEVEX1kkMlxufTtcblxudmFyIGZhaWxzJGEgPSBmYWlscyRzO1xudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJHQ7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnLicsICdzJykgLT4gLy4vcyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCQxID0gZ2xvYmFsJDkuUmVnRXhwO1xuXG52YXIgcmVnZXhwVW5zdXBwb3J0ZWREb3RBbGwgPSBmYWlscyRhKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCQxKCcuJywgJ3MnKTtcbiAgcmV0dXJuICEocmUuZG90QWxsICYmIHJlLmV4ZWMoJ1xcbicpICYmIHJlLmZsYWdzID09PSAncycpO1xufSk7XG5cbnZhciBmYWlscyQ5ID0gZmFpbHMkcztcbnZhciBnbG9iYWwkOCA9IGdsb2JhbCR0O1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJyg/PGE+YiknLCAnZycpIC0+IC8oPzxhPmIpL2cgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAgPSBnbG9iYWwkOC5SZWdFeHA7XG5cbnZhciByZWdleHBVbnN1cHBvcnRlZE5jZyA9IGZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwKCcoPzxhPmIpJywgJ2cnKTtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2InKS5ncm91cHMuYSAhPT0gJ2InIHx8XG4gICAgJ2InLnJlcGxhY2UocmUsICckPGE+YycpICE9PSAnYmMnO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby1lbXB0eS1jYXB0dXJpbmctZ3JvdXAsIHJlZ2V4cC9uby1lbXB0eS1ncm91cCwgcmVnZXhwL25vLWxhenktZW5kcyAtLSB0ZXN0aW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tdXNlbGVzcy1xdWFudGlmaWVyIC0tIHRlc3RpbmcgKi9cbnZhciBjYWxsJDYgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9TdHJpbmckMiA9IHRvU3RyaW5nJDU7XG52YXIgcmVnZXhwRmxhZ3MgPSByZWdleHBGbGFncyQxO1xudmFyIHN0aWNreUhlbHBlcnMkMSA9IHJlZ2V4cFN0aWNreUhlbHBlcnM7XG52YXIgc2hhcmVkID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciBjcmVhdGUkMSA9IG9iamVjdENyZWF0ZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDMgPSBpbnRlcm5hbFN0YXRlLmdldDtcbnZhciBVTlNVUFBPUlRFRF9ET1RfQUxMID0gcmVnZXhwVW5zdXBwb3J0ZWREb3RBbGw7XG52YXIgVU5TVVBQT1JURURfTkNHID0gcmVnZXhwVW5zdXBwb3J0ZWROY2c7XG5cbnZhciBuYXRpdmVSZXBsYWNlID0gc2hhcmVkKCduYXRpdmUtc3RyaW5nLXJlcGxhY2UnLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG52YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xudmFyIGNoYXJBdCQyID0gdW5jdXJyeVRoaXMkOCgnJy5jaGFyQXQpO1xudmFyIGluZGV4T2YgPSB1bmN1cnJ5VGhpcyQ4KCcnLmluZGV4T2YpO1xudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcyQ4KCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlJDIgPSB1bmN1cnJ5VGhpcyQ4KCcnLnNsaWNlKTtcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgY2FsbCQ2KG5hdGl2ZUV4ZWMsIHJlMSwgJ2EnKTtcbiAgY2FsbCQ2KG5hdGl2ZUV4ZWMsIHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZJDEgPSBzdGlja3lIZWxwZXJzJDEuQlJPS0VOX0NBUkVUO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRCB8fCBVTlNVUFBPUlRFRF9ZJDEgfHwgVU5TVVBQT1JURURfRE9UX0FMTCB8fCBVTlNVUFBPUlRFRF9OQ0c7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyaW5nKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDMocmUpO1xuICAgIHZhciBzdHIgPSB0b1N0cmluZyQyKHN0cmluZyk7XG4gICAgdmFyIHJhdyA9IHN0YXRlLnJhdztcbiAgICB2YXIgcmVzdWx0LCByZUNvcHksIGxhc3RJbmRleCwgbWF0Y2gsIGksIG9iamVjdCwgZ3JvdXA7XG5cbiAgICBpZiAocmF3KSB7XG4gICAgICByYXcubGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgcmVzdWx0ID0gY2FsbCQ2KHBhdGNoZWRFeGVjLCByYXcsIHN0cik7XG4gICAgICByZS5sYXN0SW5kZXggPSByYXcubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBzID0gc3RhdGUuZ3JvdXBzO1xuICAgIHZhciBzdGlja3kgPSBVTlNVUFBPUlRFRF9ZJDEgJiYgcmUuc3RpY2t5O1xuICAgIHZhciBmbGFncyA9IGNhbGwkNihyZWdleHBGbGFncywgcmUpO1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2U7XG4gICAgdmFyIGNoYXJzQWRkZWQgPSAwO1xuICAgIHZhciBzdHJDb3B5ID0gc3RyO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgZmxhZ3MgPSByZXBsYWNlKGZsYWdzLCAneScsICcnKTtcbiAgICAgIGlmIChpbmRleE9mKGZsYWdzLCAnZycpID09PSAtMSkge1xuICAgICAgICBmbGFncyArPSAnZyc7XG4gICAgICB9XG5cbiAgICAgIHN0ckNvcHkgPSBzdHJpbmdTbGljZSQyKHN0ciwgcmUubGFzdEluZGV4KTtcbiAgICAgIC8vIFN1cHBvcnQgYW5jaG9yZWQgc3RpY2t5IGJlaGF2aW9yLlxuICAgICAgaWYgKHJlLmxhc3RJbmRleCA+IDAgJiYgKCFyZS5tdWx0aWxpbmUgfHwgcmUubXVsdGlsaW5lICYmIGNoYXJBdCQyKHN0ciwgcmUubGFzdEluZGV4IC0gMSkgIT09ICdcXG4nKSkge1xuICAgICAgICBzb3VyY2UgPSAnKD86ICcgKyBzb3VyY2UgKyAnKSc7XG4gICAgICAgIHN0ckNvcHkgPSAnICcgKyBzdHJDb3B5O1xuICAgICAgICBjaGFyc0FkZGVkKys7XG4gICAgICB9XG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgc3RyIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeKD86JyArIHNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgIH1cblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgIH1cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG5cbiAgICBtYXRjaCA9IGNhbGwkNihuYXRpdmVFeGVjLCBzdGlja3kgPyByZUNvcHkgOiByZSwgc3RyQ29weSk7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbWF0Y2guaW5wdXQgPSBzdHJpbmdTbGljZSQyKG1hdGNoLmlucHV0LCBjaGFyc0FkZGVkKTtcbiAgICAgICAgbWF0Y2hbMF0gPSBzdHJpbmdTbGljZSQyKG1hdGNoWzBdLCBjaGFyc0FkZGVkKTtcbiAgICAgICAgbWF0Y2guaW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHJlLmxhc3RJbmRleCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9IGVsc2UgcmUubGFzdEluZGV4ID0gMDtcbiAgICB9IGVsc2UgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyAmJiBtYXRjaCkge1xuICAgICAgcmUubGFzdEluZGV4ID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIGNhbGwkNihuYXRpdmVSZXBsYWNlLCBtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoICYmIGdyb3Vwcykge1xuICAgICAgbWF0Y2guZ3JvdXBzID0gb2JqZWN0ID0gY3JlYXRlJDEobnVsbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBvYmplY3RbZ3JvdXBbMF1dID0gbWF0Y2hbZ3JvdXBbMV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxudmFyIHJlZ2V4cEV4ZWMkMyA9IHBhdGNoZWRFeGVjO1xuXG52YXIgJCQyID0gX2V4cG9ydDtcbnZhciBleGVjJDEgPSByZWdleHBFeGVjJDM7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmV4ZWNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLmV4ZWNcbiQkMih7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSBleGVjJDEgfSwge1xuICBleGVjOiBleGVjJDFcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhbW9uT2VobG1hbi9kZXRlY3QtYnJvd3Nlci9ibG9iL21hc3Rlci9zcmMvaW5kZXgudHNcbmNvbnN0IFNFQVJDSEJPWF9VQV9SRUdFWCA9IC9hbGV4YXxib3R8Y3Jhd2woZXJ8aW5nKXxmYWNlYm9va2V4dGVybmFsaGl0fGZlZWRidXJuZXJ8Z29vZ2xlIHdlYiBwcmV2aWV3fG5hZ2lvc3xwb3N0cmFua3xwaW5nZG9tfHNsdXJwfHNwaWRlcnx5YWhvbyF8eWFuZGV4LztcbmNvbnN0IHVzZXJBZ2VudFJ1bGVzID0gW1tcImFvbFwiLCAvQU9MU2hpZWxkXFwvKFswLTlcXC5fXSspL10sIFtcImVkZ2VcIiwgL0VkZ2VcXC8oWzAtOVxcLl9dKykvXSwgW1wiZWRnZS1pb3NcIiwgL0VkZ2lPU1xcLyhbMC05XFwuX10rKS9dLCBbXCJ5YW5kZXhicm93c2VyXCIsIC9ZYUJyb3dzZXJcXC8oWzAtOVxcLl9dKykvXSwgW1wia2FrYW90YWxrXCIsIC9LQUtBT1RBTEtcXHMoWzAtOVxcLl0rKS9dLCBbXCJzYW1zdW5nXCIsIC9TYW1zdW5nQnJvd3NlclxcLyhbMC05XFwuXSspL10sIFtcInNpbGtcIiwgL1xcYlNpbGtcXC8oWzAtOS5fLV0rKVxcYi9dLCBbXCJtaXVpXCIsIC9NaXVpQnJvd3NlclxcLyhbMC05XFwuXSspJC9dLCBbXCJiZWFrZXJcIiwgL0JlYWtlckJyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLCBbXCJlZGdlLWNocm9taXVtXCIsIC9FZGdBP1xcLyhbMC05XFwuXSspL10sIFtcImNocm9taXVtLXdlYnZpZXdcIiwgLyg/IUNocm9tLipPUFIpd3ZcXCkuKkNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wiY2hyb21lXCIsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSwgW1wicGhhbnRvbWpzXCIsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLCBbXCJjcmlvc1wiLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLCBbXCJmaXJlZm94XCIsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSwgW1wiZnhpb3NcIiwgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSwgW1wib3BlcmEtbWluaVwiLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sIFtcIm9wZXJhXCIsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sIFtcIm9wZXJhXCIsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLCBbXCJwaWVcIiwgL15NaWNyb3NvZnQgUG9ja2V0IEludGVybmV0IEV4cGxvcmVyXFwvKFxcZCtcXC5cXGQrKSQvXSwgW1wicGllXCIsIC9eTW96aWxsYVxcL1xcZFxcLlxcZCtcXHNcXChjb21wYXRpYmxlO1xccyg/Ok1TUD9JRXxNU0ludGVybmV0IEV4cGxvcmVyKSAoXFxkK1xcLlxcZCspOy4qV2luZG93cyBDRS4qXFwpJC9dLCBbXCJuZXRmcm9udFwiLCAvXk1vemlsbGFcXC9cXGRcXC5cXGQrLipOZXRGcm9udFxcLyhcXGQuXFxkKS9dLCBbXCJpZVwiLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLCBbXCJpZVwiLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSwgW1wiaWVcIiwgL01TSUVcXHMoN1xcLjApL10sIFtcImJiMTBcIiwgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLCBbXCJhbmRyb2lkXCIsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSwgW1wiaW9zXCIsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sIFtcInNhZmFyaVwiLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sIFtcImZhY2Vib29rXCIsIC9GQltBU11WXFwvKFswLTlcXC5dKykvXSwgW1wiaW5zdGFncmFtXCIsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLCBbXCJpb3Mtd2Vidmlld1wiLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sIFtcImlvcy13ZWJ2aWV3XCIsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSwgW1wiY3VybFwiLCAvXmN1cmxcXC8oWzAtOVxcLl0rKSQvXSwgW1wic2VhcmNoYm90XCIsIFNFQVJDSEJPWF9VQV9SRUdFWF1dO1xuY29uc3QgbWF0Y2hVc2VyQWdlbnQgPSB1YSA9PiB7XG4gIHJldHVybiB1YSAhPT0gXCJcIiAmJiB1c2VyQWdlbnRSdWxlcy5yZWR1Y2UoKG1hdGNoZWQsIFticm93c2VyLCByZWdleF0pID0+IHtcbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHVhTWF0Y2ggPSByZWdleC5leGVjKHVhKTtcbiAgICByZXR1cm4gISF1YU1hdGNoICYmIFticm93c2VyLCB1YU1hdGNoXTtcbiAgfSwgZmFsc2UpO1xufTtcbmNvbnN0IGlzQ3VycmVudEJyb3dzZXJTdXBwb3J0ZWQgPSBzdXBwb3J0ZWRCcm93c2VyID0+IHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbWF0Y2hlZFJ1bGUgPSBtYXRjaFVzZXJBZ2VudChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgaWYgKCFtYXRjaGVkUnVsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbbmFtZV0gPSBtYXRjaGVkUnVsZTtcbiAgaWYgKG5hbWUgPT09IFwic2VhcmNoYm90XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICEhc3VwcG9ydGVkQnJvd3Nlci5maW5kKGl0ZW0gPT4gaXRlbSA9PT0gbmFtZSk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby10eXBlZC1hcnJheXMgLS0gc2FmZVxudmFyIGFycmF5QnVmZmVyTmF0aXZlID0gdHlwZW9mIEFycmF5QnVmZmVyICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEYXRhVmlldyAhPSAndW5kZWZpbmVkJztcblxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIkMSA9IGFycmF5QnVmZmVyTmF0aXZlO1xudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbnZhciBnbG9iYWwkNyA9IGdsb2JhbCR0O1xudmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCQ0ID0gaXNPYmplY3QkZDtcbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZiQ5O1xudmFyIHRyeVRvU3RyaW5nID0gdHJ5VG9TdHJpbmckNTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGRlZmluZUJ1aWx0SW4kMiA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBpc1Byb3RvdHlwZU9mJDEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldFByb3RvdHlwZU9mJDEgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQzID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgd2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciB1aWQgPSB1aWQkMztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDIgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5nZXQ7XG52YXIgSW50OEFycmF5JDQgPSBnbG9iYWwkNy5JbnQ4QXJyYXk7XG52YXIgSW50OEFycmF5UHJvdG90eXBlJDEgPSBJbnQ4QXJyYXkkNCAmJiBJbnQ4QXJyYXkkNC5wcm90b3R5cGU7XG52YXIgVWludDhDbGFtcGVkQXJyYXkkMSA9IGdsb2JhbCQ3LlVpbnQ4Q2xhbXBlZEFycmF5O1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlID0gVWludDhDbGFtcGVkQXJyYXkkMSAmJiBVaW50OENsYW1wZWRBcnJheSQxLnByb3RvdHlwZTtcbnZhciBUeXBlZEFycmF5JDEgPSBJbnQ4QXJyYXkkNCAmJiBnZXRQcm90b3R5cGVPZiQxKEludDhBcnJheSQ0KTtcbnZhciBUeXBlZEFycmF5UHJvdG90eXBlJDEgPSBJbnQ4QXJyYXlQcm90b3R5cGUkMSAmJiBnZXRQcm90b3R5cGVPZiQxKEludDhBcnJheVByb3RvdHlwZSQxKTtcbnZhciBPYmplY3RQcm90b3R5cGUkMSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkNy5UeXBlRXJyb3I7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDIoJ3RvU3RyaW5nVGFnJyk7XG52YXIgVFlQRURfQVJSQVlfVEFHJDEgPSB1aWQoJ1RZUEVEX0FSUkFZX1RBRycpO1xudmFyIFRZUEVEX0FSUkFZX0NPTlNUUlVDVE9SID0gJ1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcic7XG4vLyBGaXhpbmcgbmF0aXZlIHR5cGVkIGFycmF5cyBpbiBPcGVyYSBQcmVzdG8gY3Jhc2hlcyB0aGUgYnJvd3Nlciwgc2VlICM1OTVcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgPSBOQVRJVkVfQVJSQVlfQlVGRkVSJDEgJiYgISFzZXRQcm90b3R5cGVPZiQzICYmIGNsYXNzb2YkNChnbG9iYWwkNy5vcGVyYSkgIT09ICdPcGVyYSc7XG52YXIgVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gZmFsc2U7XG52YXIgTkFNRSwgQ29uc3RydWN0b3IsIFByb3RvdHlwZTtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0ID0ge1xuICBJbnQ4QXJyYXk6IDEsXG4gIFVpbnQ4QXJyYXk6IDEsXG4gIFVpbnQ4Q2xhbXBlZEFycmF5OiAxLFxuICBJbnQxNkFycmF5OiAyLFxuICBVaW50MTZBcnJheTogMixcbiAgSW50MzJBcnJheTogNCxcbiAgVWludDMyQXJyYXk6IDQsXG4gIEZsb2F0MzJBcnJheTogNCxcbiAgRmxvYXQ2NEFycmF5OiA4XG59O1xuXG52YXIgQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0ID0ge1xuICBCaWdJbnQ2NEFycmF5OiA4LFxuICBCaWdVaW50NjRBcnJheTogOFxufTtcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICBpZiAoIWlzT2JqZWN0JDQoaXQpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrbGFzcyA9IGNsYXNzb2YkNChpdCk7XG4gIHJldHVybiBrbGFzcyA9PT0gJ0RhdGFWaWV3J1xuICAgIHx8IGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcylcbiAgICB8fCBoYXNPd24kMShCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG5cbnZhciBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YkMShpdCk7XG4gIGlmICghaXNPYmplY3QkNChwcm90bykpIHJldHVybjtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQyKHByb3RvKTtcbiAgcmV0dXJuIChzdGF0ZSAmJiBoYXNPd24kMShzdGF0ZSwgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IpKSA/IHN0YXRlW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA6IGdldFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcihwcm90byk7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdCQ0KGl0KSkgcmV0dXJuIGZhbHNlO1xuICB2YXIga2xhc3MgPSBjbGFzc29mJDQoaXQpO1xuICByZXR1cm4gaGFzT3duJDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKVxuICAgIHx8IGhhc093biQxKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGFUeXBlZEFycmF5JDQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzVHlwZWRBcnJheSQxKGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBUeXBlRXJyb3IkMSgnVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5Jyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQyID0gZnVuY3Rpb24gKEMpIHtcbiAgaWYgKGlzQ2FsbGFibGUkMihDKSAmJiAoIXNldFByb3RvdHlwZU9mJDMgfHwgaXNQcm90b3R5cGVPZiQxKFR5cGVkQXJyYXkkMSwgQykpKSByZXR1cm4gQztcbiAgdGhyb3cgVHlwZUVycm9yJDEodHJ5VG9TdHJpbmcoQykgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQ0ID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCwgb3B0aW9ucykge1xuICBpZiAoIURFU0NSSVBUT1JTJDIpIHJldHVybjtcbiAgaWYgKGZvcmNlZCkgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsJDdbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzT3duJDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSwgS0VZKSkgdHJ5IHtcbiAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlW0tFWV07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIG9sZCBXZWJLaXQgYnVnIC0gc29tZSBtZXRob2RzIGFyZSBub24tY29uZmlndXJhYmxlXG4gICAgICB0cnkge1xuICAgICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlW0tFWV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfVxuICB9XG4gIGlmICghVHlwZWRBcnJheVByb3RvdHlwZSQxW0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQyKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eVxuICAgICAgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgJiYgSW50OEFycmF5UHJvdG90eXBlJDFbS0VZXSB8fCBwcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDEgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG4gIHZhciBBUlJBWSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICBpZiAoIURFU0NSSVBUT1JTJDIpIHJldHVybjtcbiAgaWYgKHNldFByb3RvdHlwZU9mJDMpIHtcbiAgICBpZiAoZm9yY2VkKSBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkN1tBUlJBWV07XG4gICAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093biQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZKSkgdHJ5IHtcbiAgICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIH1cbiAgICBpZiAoIVR5cGVkQXJyYXkkMVtLRVldIHx8IGZvcmNlZCkge1xuICAgICAgLy8gVjggfiBDaHJvbWUgNDktNTAgYCVUeXBlZEFycmF5JWAgbWV0aG9kcyBhcmUgbm9uLXdyaXRhYmxlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVCdWlsdEluJDIoVHlwZWRBcnJheSQxLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5IDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyICYmIFR5cGVkQXJyYXkkMVtLRVldIHx8IHByb3BlcnR5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG4gIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkN1tBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldIHx8IGZvcmNlZCkpIHtcbiAgICAgIGRlZmluZUJ1aWx0SW4kMihUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfVxufTtcblxuZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIENvbnN0cnVjdG9yID0gZ2xvYmFsJDdbTkFNRV07XG4gIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yICYmIENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaWYgKFByb3RvdHlwZSkgZW5mb3JjZUludGVybmFsU3RhdGUkMShQcm90b3R5cGUpW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA9IENvbnN0cnVjdG9yO1xuICBlbHNlIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiA9IGZhbHNlO1xufVxuXG5mb3IgKE5BTUUgaW4gQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIENvbnN0cnVjdG9yID0gZ2xvYmFsJDdbTkFNRV07XG4gIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yICYmIENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaWYgKFByb3RvdHlwZSkgZW5mb3JjZUludGVybmFsU3RhdGUkMShQcm90b3R5cGUpW1RZUEVEX0FSUkFZX0NPTlNUUlVDVE9SXSA9IENvbnN0cnVjdG9yO1xufVxuXG4vLyBXZWJLaXQgYnVnIC0gdHlwZWQgYXJyYXlzIGNvbnN0cnVjdG9ycyBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZVxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgfHwgIWlzQ2FsbGFibGUkMihUeXBlZEFycmF5JDEpIHx8IFR5cGVkQXJyYXkkMSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3cgLS0gc2FmZVxuICBUeXBlZEFycmF5JDEgPSBmdW5jdGlvbiBUeXBlZEFycmF5KCkge1xuICAgIHRocm93IFR5cGVFcnJvciQxKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9O1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsJDdbTkFNRV0pIHNldFByb3RvdHlwZU9mJDMoZ2xvYmFsJDdbTkFNRV0sIFR5cGVkQXJyYXkkMSk7XG4gIH1cbn1cblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgfHwgIVR5cGVkQXJyYXlQcm90b3R5cGUkMSB8fCBUeXBlZEFycmF5UHJvdG90eXBlJDEgPT09IE9iamVjdFByb3RvdHlwZSQxKSB7XG4gIFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9IFR5cGVkQXJyYXkkMS5wcm90b3R5cGU7XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIGlmIChnbG9iYWwkN1tOQU1FXSkgc2V0UHJvdG90eXBlT2YkMyhnbG9iYWwkN1tOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUkMSk7XG4gIH1cbn1cblxuLy8gV2ViS2l0IGJ1ZyAtIG9uZSBtb3JlIG9iamVjdCBpbiBVaW50OENsYW1wZWRBcnJheSBwcm90b3R5cGUgY2hhaW5cbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgJiYgZ2V0UHJvdG90eXBlT2YkMShVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUkMSkge1xuICBzZXRQcm90b3R5cGVPZiQzKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlJDEpO1xufVxuXG5pZiAoREVTQ1JJUFRPUlMkMiAmJiAhaGFzT3duJDEoVHlwZWRBcnJheVByb3RvdHlwZSQxLCBUT19TVFJJTkdfVEFHKSkge1xuICBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgPSB0cnVlO1xuICBkZWZpbmVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgVE9fU1RSSU5HX1RBRywgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QkNCh0aGlzKSA/IHRoaXNbVFlQRURfQVJSQVlfVEFHJDFdIDogdW5kZWZpbmVkO1xuICB9IH0pO1xuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWwkN1tOQU1FXSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzKGdsb2JhbCQ3W05BTUVdLCBUWVBFRF9BUlJBWV9UQUckMSwgTkFNRSk7XG4gIH1cbn1cblxudmFyIGFycmF5QnVmZmVyVmlld0NvcmUgPSB7XG4gIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMixcbiAgVFlQRURfQVJSQVlfVEFHOiBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgJiYgVFlQRURfQVJSQVlfVEFHJDEsXG4gIGFUeXBlZEFycmF5OiBhVHlwZWRBcnJheSQ0LFxuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yOiBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDIsXG4gIGV4cG9ydFR5cGVkQXJyYXlNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkNCxcbiAgZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZDogZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCQxLFxuICBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3I6IGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiAgaXNWaWV3OiBpc1ZpZXcsXG4gIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5JDEsXG4gIFR5cGVkQXJyYXk6IFR5cGVkQXJyYXkkMSxcbiAgVHlwZWRBcnJheVByb3RvdHlwZTogVHlwZWRBcnJheVByb3RvdHlwZSQxXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIGdsb2JhbCQ2ID0gZ2xvYmFsJHQ7XG52YXIgZmFpbHMkOCA9IGZhaWxzJHM7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDI7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQxID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xuXG52YXIgQXJyYXlCdWZmZXIkMyA9IGdsb2JhbCQ2LkFycmF5QnVmZmVyO1xudmFyIEludDhBcnJheSQzID0gZ2xvYmFsJDYuSW50OEFycmF5O1xuXG52YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yc1JlcXVpcmVXcmFwcGVycyA9ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDEgfHwgIWZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICBJbnQ4QXJyYXkkMygxKTtcbn0pIHx8ICFmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgbmV3IEludDhBcnJheSQzKC0xKTtcbn0pIHx8ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIG5ldyBJbnQ4QXJyYXkkMygpO1xuICBuZXcgSW50OEFycmF5JDMobnVsbCk7XG4gIG5ldyBJbnQ4QXJyYXkkMygxLjUpO1xuICBuZXcgSW50OEFycmF5JDMoaXRlcmFibGUpO1xufSwgdHJ1ZSkgfHwgZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIC8vIFNhZmFyaSAoMTErKSBidWcgLSBhIHJlYXNvbiB3aHkgZXZlbiBTYWZhcmkgMTMgc2hvdWxkIGxvYWQgYSB0eXBlZCBhcnJheSBwb2x5ZmlsbFxuICByZXR1cm4gbmV3IEludDhBcnJheSQzKG5ldyBBcnJheUJ1ZmZlciQzKDIpLCAxLCB1bmRlZmluZWQpLmxlbmd0aCAhPT0gMTtcbn0pO1xuXG52YXIgYmluZCQxID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDI7XG52YXIgdG9PYmplY3QkMiA9IHRvT2JqZWN0JDc7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNCA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG52YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQyO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkMztcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbnZhciB0eXBlZEFycmF5RnJvbSQyID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICB2YXIgQyA9IGFDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgdmFyIE8gPSB0b09iamVjdCQyKHNvdXJjZSk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgaSwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0O1xuICBpZiAoaXRlcmF0b3JNZXRob2QgJiYgIWlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpIHtcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKE8sIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgICBPID0gW107XG4gICAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkNShuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICAgIE8ucHVzaChzdGVwLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hcHBpbmcgJiYgYXJndW1lbnRzTGVuZ3RoID4gMikge1xuICAgIG1hcGZuID0gYmluZCQxKG1hcGZuLCBhcmd1bWVudHNbMl0pO1xuICB9XG4gIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDQoTyk7XG4gIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQxKEMpKShsZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyQxID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yc1JlcXVpcmVXcmFwcGVycztcbnZhciBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kO1xudmFyIHR5cGVkQXJyYXlGcm9tJDEgPSB0eXBlZEFycmF5RnJvbSQyO1xuXG4vLyBgJVR5cGVkQXJyYXklLmZyb21gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUuZnJvbVxuZXhwb3J0VHlwZWRBcnJheVN0YXRpY01ldGhvZCgnZnJvbScsIHR5cGVkQXJyYXlGcm9tJDEsIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMkMSk7XG5cbnZhciBkZWZpbmVCdWlsdEluJDEgPSBkZWZpbmVCdWlsdEluJDg7XG5cbnZhciBkZWZpbmVCdWlsdElucyQxID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIGRlZmluZUJ1aWx0SW4kMSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMyA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcbnZhciB0b0xlbmd0aCQ0ID0gdG9MZW5ndGgkNjtcblxudmFyICRSYW5nZUVycm9yJDIgPSBSYW5nZUVycm9yO1xuXG4vLyBgVG9JbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0luZGV4JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQzKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoJDQobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyAkUmFuZ2VFcnJvciQyKCdXcm9uZyBsZW5ndGggb3IgaW5kZXgnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgJEFycmF5JDIgPSBBcnJheTtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciQyID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxudmFyIHBhY2sgPSBmdW5jdGlvbiAobnVtYmVyLCBtYW50aXNzYUxlbmd0aCwgYnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9ICRBcnJheSQyKGJ5dGVzKTtcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGV4cG9uZW50TGVuZ3RoKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbWFudGlzc2FMZW5ndGggPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBzaWduID0gbnVtYmVyIDwgMCB8fCBudW1iZXIgPT09IDAgJiYgMSAvIG51bWJlciA8IDAgPyAxIDogMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGV4cG9uZW50LCBtYW50aXNzYSwgYztcbiAgbnVtYmVyID0gYWJzKG51bWJlcik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIGlmIChudW1iZXIgIT0gbnVtYmVyIHx8IG51bWJlciA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIG1hbnRpc3NhID0gbnVtYmVyICE9IG51bWJlciA/IDEgOiAwO1xuICAgIGV4cG9uZW50ID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBleHBvbmVudCA9IGZsb29yJDIobG9nKG51bWJlcikgLyBMTjIpO1xuICAgIGMgPSBwb3coMiwgLWV4cG9uZW50KTtcbiAgICBpZiAobnVtYmVyICogYyA8IDEpIHtcbiAgICAgIGV4cG9uZW50LS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG51bWJlciArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlciArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyICogYyA+PSAyKSB7XG4gICAgICBleHBvbmVudCsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtYW50aXNzYSA9IDA7XG4gICAgICBleHBvbmVudCA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChleHBvbmVudCArIGVCaWFzID49IDEpIHtcbiAgICAgIG1hbnRpc3NhID0gKG51bWJlciAqIGMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hbnRpc3NhID0gbnVtYmVyICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgICAgZXhwb25lbnQgPSAwO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobWFudGlzc2FMZW5ndGggPj0gOCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IG1hbnRpc3NhICYgMjU1O1xuICAgIG1hbnRpc3NhIC89IDI1NjtcbiAgICBtYW50aXNzYUxlbmd0aCAtPSA4O1xuICB9XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgPDwgbWFudGlzc2FMZW5ndGggfCBtYW50aXNzYTtcbiAgZXhwb25lbnRMZW5ndGggKz0gbWFudGlzc2FMZW5ndGg7XG4gIHdoaWxlIChleHBvbmVudExlbmd0aCA+IDApIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBleHBvbmVudCAmIDI1NTtcbiAgICBleHBvbmVudCAvPSAyNTY7XG4gICAgZXhwb25lbnRMZW5ndGggLT0gODtcbiAgfVxuICBidWZmZXJbLS1pbmRleF0gfD0gc2lnbiAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbnZhciB1bnBhY2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYW50aXNzYUxlbmd0aCkge1xuICB2YXIgYnl0ZXMgPSBidWZmZXIubGVuZ3RoO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBleHBvbmVudExlbmd0aCAtIDc7XG4gIHZhciBpbmRleCA9IGJ5dGVzIC0gMTtcbiAgdmFyIHNpZ24gPSBidWZmZXJbaW5kZXgtLV07XG4gIHZhciBleHBvbmVudCA9IHNpZ24gJiAxMjc7XG4gIHZhciBtYW50aXNzYTtcbiAgc2lnbiA+Pj0gNztcbiAgd2hpbGUgKG5CaXRzID4gMCkge1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKiAyNTYgKyBidWZmZXJbaW5kZXgtLV07XG4gICAgbkJpdHMgLT0gODtcbiAgfVxuICBtYW50aXNzYSA9IGV4cG9uZW50ICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGV4cG9uZW50ID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1hbnRpc3NhTGVuZ3RoO1xuICB3aGlsZSAobkJpdHMgPiAwKSB7XG4gICAgbWFudGlzc2EgPSBtYW50aXNzYSAqIDI1NiArIGJ1ZmZlcltpbmRleC0tXTtcbiAgICBuQml0cyAtPSA4O1xuICB9XG4gIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgIGV4cG9uZW50ID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGV4cG9uZW50ID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG1hbnRpc3NhID8gTmFOIDogc2lnbiA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKyBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSBlQmlhcztcbiAgfSByZXR1cm4gKHNpZ24gPyAtMSA6IDEpICogbWFudGlzc2EgKiBwb3coMiwgZXhwb25lbnQgLSBtYW50aXNzYUxlbmd0aCk7XG59O1xuXG52YXIgaWVlZTc1NCA9IHtcbiAgcGFjazogcGFjayxcbiAgdW5wYWNrOiB1bnBhY2tcbn07XG5cbnZhciB0b09iamVjdCQxID0gdG9PYmplY3QkNztcbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxudmFyIGFycmF5RmlsbCQxID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0JDEodGhpcyk7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQzKE8pO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDIoYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleCQyKGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkMShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSB0b0Fic29sdXRlSW5kZXgkNDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQyID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IGNyZWF0ZVByb3BlcnR5JDE7XG5cbnZhciAkQXJyYXkkMSA9IEFycmF5O1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG52YXIgYXJyYXlTbGljZVNpbXBsZSA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQyKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleCQxKHN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4JDEoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSAkQXJyYXkkMShtYXgoZmluIC0gaywgMCkpO1xuICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJHQ7XG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSBhcnJheUJ1ZmZlck5hdGl2ZTtcbnZhciBGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBkZWZpbmVCdWlsdElucyA9IGRlZmluZUJ1aWx0SW5zJDE7XG52YXIgZmFpbHMkNyA9IGZhaWxzJHM7XG52YXIgYW5JbnN0YW5jZSQxID0gYW5JbnN0YW5jZSQzO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcbnZhciB0b0xlbmd0aCQzID0gdG9MZW5ndGgkNjtcbnZhciB0b0luZGV4JDEgPSB0b0luZGV4JDI7XG52YXIgSUVFRTc1NCA9IGllZWU3NTQ7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQyID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBhcnJheUZpbGwgPSBhcnJheUZpbGwkMTtcbnZhciBhcnJheVNsaWNlJDMgPSBhcnJheVNsaWNlU2ltcGxlO1xudmFyIHNldFRvU3RyaW5nVGFnID0gc2V0VG9TdHJpbmdUYWckNDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5zZXQ7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCQxID0gJ1dyb25nIGxlbmd0aCc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXgnO1xudmFyIE5hdGl2ZUFycmF5QnVmZmVyID0gZ2xvYmFsJDVbQVJSQVlfQlVGRkVSXTtcbnZhciAkQXJyYXlCdWZmZXIgPSBOYXRpdmVBcnJheUJ1ZmZlcjtcbnZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSQxID0gJEFycmF5QnVmZmVyICYmICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdO1xudmFyICREYXRhVmlldyA9IGdsb2JhbCQ1W0RBVEFfVklFV107XG52YXIgRGF0YVZpZXdQcm90b3R5cGUkMSA9ICREYXRhVmlldyAmJiAkRGF0YVZpZXdbUFJPVE9UWVBFXTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEFycmF5JDEgPSBnbG9iYWwkNS5BcnJheTtcbnZhciBSYW5nZUVycm9yJDMgPSBnbG9iYWwkNS5SYW5nZUVycm9yO1xudmFyIGZpbGwgPSB1bmN1cnJ5VGhpcyQ3KGFycmF5RmlsbCk7XG52YXIgcmV2ZXJzZSA9IHVuY3VycnlUaGlzJDcoW10ucmV2ZXJzZSk7XG5cbnZhciBwYWNrSUVFRTc1NCA9IElFRUU3NTQucGFjaztcbnZhciB1bnBhY2tJRUVFNzU0ID0gSUVFRTc1NC51bnBhY2s7XG5cbnZhciBwYWNrSW50OCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MTYgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGLCBudW1iZXIgPj4gMTYgJiAweEZGLCBudW1iZXIgPj4gMjQgJiAweEZGXTtcbn07XG5cbnZhciB1bnBhY2tJbnQzMiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlclszXSA8PCAyNCB8IGJ1ZmZlclsyXSA8PCAxNiB8IGJ1ZmZlclsxXSA8PCA4IHwgYnVmZmVyWzBdO1xufTtcblxudmFyIHBhY2tGbG9hdDMyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCAyMywgNCk7XG59O1xuXG52YXIgcGFja0Zsb2F0NjQgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChudW1iZXIsIDUyLCA4KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIkMSA9IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwga2V5KSB7XG4gIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEludGVybmFsU3RhdGUkMSh0aGlzKVtrZXldOyB9IH0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgkMShpbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUkMSh2aWV3KTtcbiAgaWYgKGludEluZGV4ICsgY291bnQgPiBzdG9yZS5ieXRlTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDMoV1JPTkdfSU5ERVgpO1xuICB2YXIgYnl0ZXMgPSBnZXRJbnRlcm5hbFN0YXRlJDEoc3RvcmUuYnVmZmVyKS5ieXRlcztcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyBzdG9yZS5ieXRlT2Zmc2V0O1xuICB2YXIgcGFjayA9IGFycmF5U2xpY2UkMyhieXRlcywgc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcmV2ZXJzZShwYWNrKTtcbn07XG5cbnZhciBzZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleCQxKGluZGV4KTtcbiAgdmFyIHN0b3JlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMyhXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUkMShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIGJ5dGVzW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGNvdW50IC0gaSAtIDFdO1xufTtcblxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UkMSh0aGlzLCBBcnJheUJ1ZmZlclByb3RvdHlwZSQxKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgkMShsZW5ndGgpO1xuICAgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgICBieXRlczogZmlsbChBcnJheSQxKGJ5dGVMZW5ndGgpLCAwKSxcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGhcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTJDEpIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgQXJyYXlCdWZmZXJQcm90b3R5cGUkMSA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdO1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UkMSh0aGlzLCBEYXRhVmlld1Byb3RvdHlwZSQxKTtcbiAgICBhbkluc3RhbmNlJDEoYnVmZmVyLCBBcnJheUJ1ZmZlclByb3RvdHlwZSQxKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKGJ1ZmZlcikuYnl0ZUxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQzKCdXcm9uZyBvZmZzZXQnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgkMyhieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQzKFdST05HX0xFTkdUSCQxKTtcbiAgICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoLFxuICAgICAgYnl0ZU9mZnNldDogb2Zmc2V0XG4gICAgfSk7XG4gICAgaWYgKCFERVNDUklQVE9SUyQxKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgICB0aGlzLmJ5dGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICB9O1xuXG4gIERhdGFWaWV3UHJvdG90eXBlJDEgPSAkRGF0YVZpZXdbUFJPVE9UWVBFXTtcblxuICBpZiAoREVTQ1JJUFRPUlMkMSkge1xuICAgIGFkZEdldHRlciQxKCRBcnJheUJ1ZmZlciwgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIkMSgkRGF0YVZpZXcsICdidWZmZXInKTtcbiAgICBhZGRHZXR0ZXIkMSgkRGF0YVZpZXcsICdieXRlTGVuZ3RoJyk7XG4gICAgYWRkR2V0dGVyJDEoJERhdGFWaWV3LCAnYnl0ZU9mZnNldCcpO1xuICB9XG5cbiAgZGVmaW5lQnVpbHRJbnMoRGF0YVZpZXdQcm90b3R5cGUkMSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDIzKTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSwgNTIpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJbnQ4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJbnQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQ2NCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgdmFyIElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSA9IFBST1BFUl9GVU5DVElPTl9OQU1FICYmIE5hdGl2ZUFycmF5QnVmZmVyLm5hbWUgIT09IEFSUkFZX0JVRkZFUjtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG4gIGlmICghZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gICAgTmF0aXZlQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoLTEpO1xuICB9KSB8fCBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoKTtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoMS41KTtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoTmFOKTtcbiAgICByZXR1cm4gSU5DT1JSRUNUX0FSUkFZX0JVRkZFUl9OQU1FICYmICFDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRTtcbiAgfSkpIHtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UkMSh0aGlzLCBBcnJheUJ1ZmZlclByb3RvdHlwZSQxKTtcbiAgICAgIHJldHVybiBuZXcgTmF0aXZlQXJyYXlCdWZmZXIodG9JbmRleCQxKGxlbmd0aCkpO1xuICAgIH07XG5cbiAgICAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEFycmF5QnVmZmVyUHJvdG90eXBlJDE7XG5cbiAgICBmb3IgKHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyQxKE5hdGl2ZUFycmF5QnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMigkQXJyYXlCdWZmZXIsIGtleSwgTmF0aXZlQXJyYXlCdWZmZXJba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQXJyYXlCdWZmZXJQcm90b3R5cGUkMS5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfSBlbHNlIGlmIChJTkNPUlJFQ1RfQVJSQVlfQlVGRkVSX05BTUUgJiYgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMihOYXRpdmVBcnJheUJ1ZmZlciwgJ25hbWUnLCBBUlJBWV9CVUZGRVIpO1xuICB9XG5cbiAgLy8gV2ViS2l0IGJ1ZyAtIHRoZSBzYW1lIHBhcmVudCBwcm90b3R5cGUgZm9yIHR5cGVkIGFycmF5cyBhbmQgZGF0YSB2aWV3XG4gIGlmIChzZXRQcm90b3R5cGVPZiQyICYmIGdldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlJDEpICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICBzZXRQcm90b3R5cGVPZiQyKERhdGFWaWV3UHJvdG90eXBlJDEsIE9iamVjdFByb3RvdHlwZSk7XG4gIH1cblxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHRlc3RWaWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgdmFyICRzZXRJbnQ4ID0gdW5jdXJyeVRoaXMkNyhEYXRhVmlld1Byb3RvdHlwZSQxLnNldEludDgpO1xuICB0ZXN0Vmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB0ZXN0Vmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodGVzdFZpZXcuZ2V0SW50OCgwKSB8fCAhdGVzdFZpZXcuZ2V0SW50OCgxKSkgZGVmaW5lQnVpbHRJbnMoRGF0YVZpZXdQcm90b3R5cGUkMSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4KHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDgodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG59XG5cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcblxudmFyIGFycmF5QnVmZmVyID0ge1xuICBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyLFxuICBEYXRhVmlldzogJERhdGFWaWV3XG59O1xuXG52YXIgJCQxID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQ2ID0gZmFpbHMkcztcbnZhciBBcnJheUJ1ZmZlck1vZHVsZSQxID0gYXJyYXlCdWZmZXI7XG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGU7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDQ7XG52YXIgdG9MZW5ndGgkMiA9IHRvTGVuZ3RoJDY7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDEgPSBzcGVjaWVzQ29uc3RydWN0b3IkMztcblxudmFyIEFycmF5QnVmZmVyJDIgPSBBcnJheUJ1ZmZlck1vZHVsZSQxLkFycmF5QnVmZmVyO1xudmFyIERhdGFWaWV3JDIgPSBBcnJheUJ1ZmZlck1vZHVsZSQxLkRhdGFWaWV3O1xudmFyIERhdGFWaWV3UHJvdG90eXBlID0gRGF0YVZpZXckMi5wcm90b3R5cGU7XG52YXIgdW4kQXJyYXlCdWZmZXJTbGljZSA9IHVuY3VycnlUaGlzJDYoQXJyYXlCdWZmZXIkMi5wcm90b3R5cGUuc2xpY2UpO1xudmFyIGdldFVpbnQ4ID0gdW5jdXJyeVRoaXMkNihEYXRhVmlld1Byb3RvdHlwZS5nZXRVaW50OCk7XG52YXIgc2V0VWludDggPSB1bmN1cnJ5VGhpcyQ2KERhdGFWaWV3UHJvdG90eXBlLnNldFVpbnQ4KTtcblxudmFyIElOQ09SUkVDVF9TTElDRSA9IGZhaWxzJDYoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyBBcnJheUJ1ZmZlciQyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pO1xuXG4vLyBgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlidWZmZXIucHJvdG90eXBlLnNsaWNlXG4kJDEoeyB0YXJnZXQ6ICdBcnJheUJ1ZmZlcicsIHByb3RvOiB0cnVlLCB1bnNhZmU6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX1NMSUNFIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodW4kQXJyYXlCdWZmZXJTbGljZSAmJiBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuJEFycmF5QnVmZmVyU2xpY2UoYW5PYmplY3QkMih0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFuT2JqZWN0JDIodGhpcykuYnl0ZUxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IkMSh0aGlzLCBBcnJheUJ1ZmZlciQyKSkodG9MZW5ndGgkMihmaW4gLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3U291cmNlID0gbmV3IERhdGFWaWV3JDIodGhpcyk7XG4gICAgdmFyIHZpZXdUYXJnZXQgPSBuZXcgRGF0YVZpZXckMihyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICBzZXRVaW50OCh2aWV3VGFyZ2V0LCBpbmRleCsrLCBnZXRVaW50OCh2aWV3U291cmNlLCBmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBpc09iamVjdCQzID0gaXNPYmplY3QkZDtcblxudmFyIGZsb29yJDEgPSBNYXRoLmZsb29yO1xuXG4vLyBgSXNJbnRlZ3JhbE51bWJlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzaW50ZWdyYWxudW1iZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW51bWJlci1pc2ludGVnZXIgLS0gc2FmZVxudmFyIGlzSW50ZWdyYWxOdW1iZXIkMSA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QkMyhpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yJDEoaXQpID09PSBpdDtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG5cbnZhciAkUmFuZ2VFcnJvciQxID0gUmFuZ2VFcnJvcjtcblxudmFyIHRvUG9zaXRpdmVJbnRlZ2VyJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShpdCk7XG4gIGlmIChyZXN1bHQgPCAwKSB0aHJvdyAkUmFuZ2VFcnJvciQxKFwiVGhlIGFyZ3VtZW50IGNhbid0IGJlIGxlc3MgdGhhbiAwXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHRvUG9zaXRpdmVJbnRlZ2VyID0gdG9Qb3NpdGl2ZUludGVnZXIkMTtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxudmFyIHRvT2Zmc2V0JDIgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gIHZhciBvZmZzZXQgPSB0b1Bvc2l0aXZlSW50ZWdlcihpdCk7XG4gIGlmIChvZmZzZXQgJSBCWVRFUykgdGhyb3cgJFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCcpO1xuICByZXR1cm4gb2Zmc2V0O1xufTtcblxudmFyIGNsYXNzb2YkMyA9IGNsYXNzb2ZSYXckMTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkMyhhcmd1bWVudCkgPT0gJ0FycmF5Jztcbn07XG5cbnZhciBpc0FycmF5ID0gaXNBcnJheSQxO1xudmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDI7XG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JGQ7XG52YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQxKCdzcGVjaWVzJyk7XG52YXIgJEFycmF5ID0gQXJyYXk7XG5cbi8vIGEgcGFydCBvZiBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5KSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKGlzQ29uc3RydWN0b3IoQykgJiYgKEMgPT09ICRBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgZWxzZSBpZiAoaXNPYmplY3QkMihDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFUyQxXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gJEFycmF5IDogQztcbn07XG5cbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDE7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMSA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xudmFyIHRvT2JqZWN0ID0gdG9PYmplY3QkNztcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQxID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBhcnJheVNwZWNpZXNDcmVhdGUkMTtcblxudmFyIHB1c2gkMSA9IHVuY3VycnlUaGlzJDUoW10ucHVzaCk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMSA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT0gNztcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0KTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMShzZWxmKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcHVzaCQxKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICAgICAgY2FzZSA3OiBwdXNoJDEodGFyZ2V0LCB2YWx1ZSk7ICAgICAgLy8gZmlsdGVyUmVqZWN0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgfTtcbn07XG5cbnZhciBhcnJheUl0ZXJhdGlvbiA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QkMSgwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QkMSgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QkMSgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QkMSgzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QkMSg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QkMSg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QkMSg2KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJSZWplY3RgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1maWx0ZXJpbmdcbiAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QkMSg3KVxufTtcblxudmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCQxID0gaXNPYmplY3QkZDtcbnZhciBzZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG5cbi8vIG1ha2VzIHN1YmNsYXNzaW5nIHdvcmsgY29ycmVjdCBmb3Igd3JhcHBlZCBidWlsdC1pbnNcbnZhciBpbmhlcml0SWZSZXF1aXJlZCQxID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xuICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gIGlmIChcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcbiAgICBzZXRQcm90b3R5cGVPZiQxICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIGlzQ2FsbGFibGUkMShOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdCQxKE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuICApIHNldFByb3RvdHlwZU9mJDEoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG5cbnZhciAkID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkNCA9IGdsb2JhbCR0O1xudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xudmFyIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMgPSB0eXBlZEFycmF5Q29uc3RydWN0b3JzUmVxdWlyZVdyYXBwZXJzO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUkNCA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgQXJyYXlCdWZmZXJNb2R1bGUgPSBhcnJheUJ1ZmZlcjtcbnZhciBhbkluc3RhbmNlID0gYW5JbnN0YW5jZSQzO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgaXNJbnRlZ3JhbE51bWJlciA9IGlzSW50ZWdyYWxOdW1iZXIkMTtcbnZhciB0b0xlbmd0aCQxID0gdG9MZW5ndGgkNjtcbnZhciB0b0luZGV4ID0gdG9JbmRleCQyO1xudmFyIHRvT2Zmc2V0JDEgPSB0b09mZnNldCQyO1xudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBjbGFzc29mJDIgPSBjbGFzc29mJDk7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCRkO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMztcbnZhciBjcmVhdGUgPSBvYmplY3RDcmVhdGU7XG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xudmFyIHR5cGVkQXJyYXlGcm9tID0gdHlwZWRBcnJheUZyb20kMjtcbnZhciBmb3JFYWNoID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcbnZhciBzZXRTcGVjaWVzID0gc2V0U3BlY2llcyQyO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gaW5oZXJpdElmUmVxdWlyZWQkMTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBSYW5nZUVycm9yJDIgPSBnbG9iYWwkNC5SYW5nZUVycm9yO1xudmFyIEFycmF5QnVmZmVyJDEgPSBBcnJheUJ1ZmZlck1vZHVsZS5BcnJheUJ1ZmZlcjtcbnZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9IEFycmF5QnVmZmVyJDEucHJvdG90eXBlO1xudmFyIERhdGFWaWV3JDEgPSBBcnJheUJ1ZmZlck1vZHVsZS5EYXRhVmlldztcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0Lk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG52YXIgVFlQRURfQVJSQVlfVEFHID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LlRZUEVEX0FSUkFZX1RBRztcbnZhciBUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LlR5cGVkQXJyYXk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5UeXBlZEFycmF5UHJvdG90eXBlO1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBpc1R5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuaXNUeXBlZEFycmF5O1xudmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoJztcblxudmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihDKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpW2tleV07XG4gIH0gfSk7XG59O1xuXG52YXIgaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIga2xhc3M7XG4gIHJldHVybiBpc1Byb3RvdHlwZU9mKEFycmF5QnVmZmVyUHJvdG90eXBlLCBpdCkgfHwgKGtsYXNzID0gY2xhc3NvZiQyKGl0KSkgPT0gJ0FycmF5QnVmZmVyJyB8fCBrbGFzcyA9PSAnU2hhcmVkQXJyYXlCdWZmZXInO1xufTtcblxudmFyIGlzVHlwZWRBcnJheUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gIHJldHVybiBpc1R5cGVkQXJyYXkodGFyZ2V0KVxuICAgICYmICFpc1N5bWJvbChrZXkpXG4gICAgJiYga2V5IGluIHRhcmdldFxuICAgICYmIGlzSW50ZWdyYWxOdW1iZXIoK2tleSlcbiAgICAmJiBrZXkgPj0gMDtcbn07XG5cbnZhciB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgcmV0dXJuIGlzVHlwZWRBcnJheUluZGV4KHRhcmdldCwga2V5KVxuICAgID8gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDIsIHRhcmdldFtrZXldKVxuICAgIDogbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbn07XG5cbnZhciB3cmFwcGVkRGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSlcbiAgICAmJiBpc09iamVjdChkZXNjcmlwdG9yKVxuICAgICYmIGhhc093bihkZXNjcmlwdG9yLCAndmFsdWUnKVxuICAgICYmICFoYXNPd24oZGVzY3JpcHRvciwgJ2dldCcpXG4gICAgJiYgIWhhc093bihkZXNjcmlwdG9yLCAnc2V0JylcbiAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICYmICFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZVxuICAgICYmICghaGFzT3duKGRlc2NyaXB0b3IsICd3cml0YWJsZScpIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUpXG4gICAgJiYgKCFoYXNPd24oZGVzY3JpcHRvciwgJ2VudW1lcmFibGUnKSB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUpXG4gICkge1xuICAgIHRhcmdldFtrZXldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG59O1xuXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGRlZmluZVByb3BlcnR5TW9kdWxlLmYgPSB3cmFwcGVkRGVmaW5lUHJvcGVydHk7XG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdidWZmZXInKTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVPZmZzZXQnKTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2xlbmd0aCcpO1xuICB9XG5cbiAgJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfSwge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICBkZWZpbmVQcm9wZXJ0eTogd3JhcHBlZERlZmluZVByb3BlcnR5XG4gIH0pO1xuXG4gIHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsIHdyYXBwZXIsIENMQU1QRUQpIHtcbiAgICB2YXIgQllURVMgPSBUWVBFLm1hdGNoKC9cXGQrJC8pWzBdIC8gODtcbiAgICB2YXIgQ09OU1RSVUNUT1JfTkFNRSA9IFRZUEUgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgVFlQRTtcbiAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBUWVBFO1xuICAgIHZhciBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkNFtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgZXhwb3J0ZWQgPSB7fTtcblxuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHJldHVybiBkYXRhLnZpZXdbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5ieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IHJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhGRiA/IDB4RkYgOiB2YWx1ZSAmIDB4RkY7XG4gICAgICBkYXRhLnZpZXdbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5ieXRlT2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsIG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyJDEoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgYnl0ZU9mZnNldCA9IHRvT2Zmc2V0JDEob2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvciQyKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IkMihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgkMSgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBieXRlT2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvciQyKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2FsbCQ0KHR5cGVkQXJyYXlGcm9tLCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgICAgIGJ5dGVPZmZzZXQ6IGJ5dGVPZmZzZXQsXG4gICAgICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICB2aWV3OiBuZXcgRGF0YVZpZXckMShidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShUeXBlZEFycmF5UHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBkYXRhLCB0eXBlZEFycmF5T2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBpbmhlcml0SWZSZXF1aXJlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IodG9JbmRleChkYXRhKSk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkpIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCQxKHR5cGVkQXJyYXlPZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogdHlwZWRBcnJheU9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCQxKHR5cGVkQXJyYXlPZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEpO1xuICAgICAgICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICAgIHJldHVybiBjYWxsJDQodHlwZWRBcnJheUZyb20sIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH0oKSwgZHVtbXksIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuICAgICAgZm9yRWFjaChnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShUeXBlZEFycmF5Q29uc3RydWN0b3IsIGtleSwgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZS5jb25zdHJ1Y3RvciAhPT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgZW5mb3JjZUludGVybmFsU3RhdGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKS5UeXBlZEFycmF5Q29uc3RydWN0b3IgPSBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbiAgICBpZiAoVFlQRURfQVJSQVlfVEFHKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIFRZUEVEX0FSUkFZX1RBRywgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgfVxuXG4gICAgdmFyIEZPUkNFRCA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAhPSBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbiAgICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgICQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfSwgZXhwb3J0ZWQpO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuICB9O1xufSBlbHNlIHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gdHlwZWRBcnJheUNvbnN0cnVjdG9yLmV4cG9ydHM7XG5cbi8vIGBVaW50OEFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbmNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcignVWludDgnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDI7XG5cbnZhciAkVHlwZUVycm9yJDEgPSBUeXBlRXJyb3I7XG5cbi8vIGBUb0JpZ0ludGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvYmlnaW50XG52YXIgdG9CaWdJbnQkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgcHJpbSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnbnVtYmVyJyk7XG4gIGlmICh0eXBlb2YgcHJpbSA9PSAnbnVtYmVyJykgdGhyb3cgJFR5cGVFcnJvciQxKFwiQ2FuJ3QgY29udmVydCBudW1iZXIgdG8gYmlnaW50XCIpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1iaWdpbnQgLS0gc2FmZVxuICByZXR1cm4gQmlnSW50KHByaW0pO1xufTtcblxudmFyIEFycmF5QnVmZmVyVmlld0NvcmUkMyA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgJGZpbGwgPSBhcnJheUZpbGwkMTtcbnZhciB0b0JpZ0ludCA9IHRvQmlnSW50JDE7XG52YXIgY2xhc3NvZiQxID0gY2xhc3NvZiQ5O1xudmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQ1ID0gZmFpbHMkcztcblxudmFyIGFUeXBlZEFycmF5JDMgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDMuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQzID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQzLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG52YXIgc2xpY2UgPSB1bmN1cnJ5VGhpcyQ0KCcnLnNsaWNlKTtcblxuLy8gVjggfiBDaHJvbWUgPCA1OSwgU2FmYXJpIDwgMTQuMSwgRkYgPCA1NSwgRWRnZSA8PTE4XG52YXIgQ09OVkVSU0lPTl9CVUcgPSBmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tdHlwZWQtYXJyYXlzIC0tIHNhZmVcbiAgbmV3IEludDhBcnJheSgyKS5maWxsKHsgdmFsdWVPZjogZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnQrKzsgfSB9KTtcbiAgcmV0dXJuIGNvdW50ICE9PSAxO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbGxcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMygnZmlsbCcsIGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICBhVHlwZWRBcnJheSQzKHRoaXMpO1xuICB2YXIgYWN0dWFsVmFsdWUgPSBzbGljZShjbGFzc29mJDEodGhpcyksIDAsIDMpID09PSAnQmlnJyA/IHRvQmlnSW50KHZhbHVlKSA6ICt2YWx1ZTtcbiAgcmV0dXJuIGNhbGwkMygkZmlsbCwgdGhpcywgYWN0dWFsVmFsdWUsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xufSwgQ09OVkVSU0lPTl9CVUcpO1xuXG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkdDtcbnZhciBjYWxsJDIgPSBmdW5jdGlvbkNhbGw7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSQyID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG52YXIgdG9PZmZzZXQgPSB0b09mZnNldCQyO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvT2JqZWN0JDc7XG52YXIgZmFpbHMkNCA9IGZhaWxzJHM7XG5cbnZhciBSYW5nZUVycm9yJDEgPSBnbG9iYWwkMy5SYW5nZUVycm9yO1xudmFyIEludDhBcnJheSQyID0gZ2xvYmFsJDMuSW50OEFycmF5O1xudmFyIEludDhBcnJheVByb3RvdHlwZSA9IEludDhBcnJheSQyICYmIEludDhBcnJheSQyLnByb3RvdHlwZTtcbnZhciAkc2V0ID0gSW50OEFycmF5UHJvdG90eXBlICYmIEludDhBcnJheVByb3RvdHlwZS5zZXQ7XG52YXIgYVR5cGVkQXJyYXkkMiA9IEFycmF5QnVmZmVyVmlld0NvcmUkMi5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDIgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDIuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcblxudmFyIFdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUyA9ICFmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tdHlwZWQtYXJyYXlzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciBhcnJheSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSgyKTtcbiAgY2FsbCQyKCRzZXQsIGFycmF5LCB7IGxlbmd0aDogMSwgMDogMyB9LCAxKTtcbiAgcmV0dXJuIGFycmF5WzFdICE9PSAzO1xufSk7XG5cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTExMjk0IGFuZCBvdGhlclxudmFyIFRPX09CSkVDVF9CVUcgPSBXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFRVJJQ19PTl9UWVBFRF9BUlJBWVMgJiYgQXJyYXlCdWZmZXJWaWV3Q29yZSQyLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IG5ldyBJbnQ4QXJyYXkkMigyKTtcbiAgYXJyYXkuc2V0KDEpO1xuICBhcnJheS5zZXQoJzInLCAxKTtcbiAgcmV0dXJuIGFycmF5WzBdICE9PSAwIHx8IGFycmF5WzFdICE9PSAyO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNldGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc2V0XG5leHBvcnRUeXBlZEFycmF5TWV0aG9kJDIoJ3NldCcsIGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcbiAgYVR5cGVkQXJyYXkkMih0aGlzKTtcbiAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAxKTtcbiAgdmFyIHNyYyA9IHRvSW5kZXhlZE9iamVjdChhcnJheUxpa2UpO1xuICBpZiAoV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTKSByZXR1cm4gY2FsbCQyKCRzZXQsIHRoaXMsIHNyYywgb2Zmc2V0KTtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB2YXIgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2Uoc3JjKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQxKCdXcm9uZyBsZW5ndGgnKTtcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbn0sICFXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFRVJJQ19PTl9UWVBFRF9BUlJBWVMgfHwgVE9fT0JKRUNUX0JVRyk7XG5cbnZhciBhcnJheVNsaWNlJDIgPSBhcnJheVNsaWNlU2ltcGxlO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG52YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IGZsb29yKGxlbmd0aCAvIDIpO1xuICByZXR1cm4gbGVuZ3RoIDwgOCA/IGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmVmbikgOiBtZXJnZShcbiAgICBhcnJheSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZSQyKGFycmF5LCAwLCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIG1lcmdlU29ydChhcnJheVNsaWNlJDIoYXJyYXksIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgY29tcGFyZWZuXG4gICk7XG59O1xuXG52YXIgaW5zZXJ0aW9uU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBpID0gMTtcbiAgdmFyIGVsZW1lbnQsIGo7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBqID0gaTtcbiAgICBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal07XG4gICAgfVxuICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAoYXJyYXksIGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgdmFyIHJsZW5ndGggPSByaWdodC5sZW5ndGg7XG4gIHZhciBsaW5kZXggPSAwO1xuICB2YXIgcmluZGV4ID0gMDtcblxuICB3aGlsZSAobGluZGV4IDwgbGxlbmd0aCB8fCByaW5kZXggPCBybGVuZ3RoKSB7XG4gICAgYXJyYXlbbGluZGV4ICsgcmluZGV4XSA9IChsaW5kZXggPCBsbGVuZ3RoICYmIHJpbmRleCA8IHJsZW5ndGgpXG4gICAgICA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXVxuICAgICAgOiBsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK107XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5U29ydCA9IG1lcmdlU29ydDtcblxudmFyIHVzZXJBZ2VudCQxID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudCQxLm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xuXG52YXIgZW5naW5lRmZWZXJzaW9uID0gISFmaXJlZm94ICYmICtmaXJlZm94WzFdO1xuXG52YXIgVUEgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0llT3JFZGdlID0gL01TSUV8VHJpZGVudC8udGVzdChVQSk7XG5cbnZhciB1c2VyQWdlbnQgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciB3ZWJraXQgPSB1c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLyk7XG5cbnZhciBlbmdpbmVXZWJraXRWZXJzaW9uID0gISF3ZWJraXQgJiYgK3dlYmtpdFsxXTtcblxudmFyIGdsb2JhbCQyID0gZ2xvYmFsJHQ7XG52YXIgdW5jdXJyeVRoaXMkMyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkMyA9IGZhaWxzJHM7XG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDk7XG52YXIgaW50ZXJuYWxTb3J0ID0gYXJyYXlTb3J0O1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUkMSA9IGFycmF5QnVmZmVyVmlld0NvcmU7XG52YXIgRkYgPSBlbmdpbmVGZlZlcnNpb247XG52YXIgSUVfT1JfRURHRSA9IGVuZ2luZUlzSWVPckVkZ2U7XG52YXIgVjggPSBlbmdpbmVWOFZlcnNpb247XG52YXIgV0VCS0lUID0gZW5naW5lV2Via2l0VmVyc2lvbjtcblxudmFyIGFUeXBlZEFycmF5JDEgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQxID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQxLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG52YXIgVWludDE2QXJyYXkgPSBnbG9iYWwkMi5VaW50MTZBcnJheTtcbnZhciB1biRTb3J0ID0gVWludDE2QXJyYXkgJiYgdW5jdXJyeVRoaXMkMyhVaW50MTZBcnJheS5wcm90b3R5cGUuc29ydCk7XG5cbi8vIFdlYktpdFxudmFyIEFDQ0VQVF9JTkNPUlJFQ1RfQVJHVU1FTlRTID0gISF1biRTb3J0ICYmICEoZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHVuJFNvcnQobmV3IFVpbnQxNkFycmF5KDIpLCBudWxsKTtcbn0pICYmIGZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICB1biRTb3J0KG5ldyBVaW50MTZBcnJheSgyKSwge30pO1xufSkpO1xuXG52YXIgU1RBQkxFX1NPUlQgPSAhIXVuJFNvcnQgJiYgIWZhaWxzJDMoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3NDtcbiAgaWYgKEZGKSByZXR1cm4gRkYgPCA2NztcbiAgaWYgKElFX09SX0VER0UpIHJldHVybiB0cnVlO1xuICBpZiAoV0VCS0lUKSByZXR1cm4gV0VCS0lUIDwgNjAyO1xuXG4gIHZhciBhcnJheSA9IG5ldyBVaW50MTZBcnJheSg1MTYpO1xuICB2YXIgZXhwZWN0ZWQgPSBBcnJheSg1MTYpO1xuICB2YXIgaW5kZXgsIG1vZDtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA1MTY7IGluZGV4KyspIHtcbiAgICBtb2QgPSBpbmRleCAlIDQ7XG4gICAgYXJyYXlbaW5kZXhdID0gNTE1IC0gaW5kZXg7XG4gICAgZXhwZWN0ZWRbaW5kZXhdID0gaW5kZXggLSAyICogbW9kICsgMztcbiAgfVxuXG4gIHVuJFNvcnQoYXJyYXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChhIC8gNCB8IDApIC0gKGIgLyA0IHwgMCk7XG4gIH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDUxNjsgaW5kZXgrKykge1xuICAgIGlmIChhcnJheVtpbmRleF0gIT09IGV4cGVjdGVkW2luZGV4XSkgcmV0dXJuIHRydWU7XG4gIH1cbn0pO1xuXG52YXIgZ2V0U29ydENvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZWZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmICh5ICE9PSB5KSByZXR1cm4gLTE7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoeCAhPT0geCkgcmV0dXJuIDE7XG4gICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCkgcmV0dXJuIDEgLyB4ID4gMCAmJiAxIC8geSA8IDAgPyAxIDogLTE7XG4gICAgcmV0dXJuIHggPiB5O1xuICB9O1xufTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc29ydFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQxKCdzb3J0JywgZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSBhQ2FsbGFibGUoY29tcGFyZWZuKTtcbiAgaWYgKFNUQUJMRV9TT1JUKSByZXR1cm4gdW4kU29ydCh0aGlzLCBjb21wYXJlZm4pO1xuXG4gIHJldHVybiBpbnRlcm5hbFNvcnQoYVR5cGVkQXJyYXkkMSh0aGlzKSwgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG59LCAhU1RBQkxFX1NPUlQgfHwgQUNDRVBUX0lOQ09SUkVDVF9BUkdVTUVOVFMpO1xuXG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkdDtcbnZhciBhcHBseSQxID0gZnVuY3Rpb25BcHBseTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciBmYWlscyQyID0gZmFpbHMkcztcbnZhciBhcnJheVNsaWNlJDEgPSBhcnJheVNsaWNlJDU7XG5cbnZhciBJbnQ4QXJyYXkkMSA9IGdsb2JhbCQxLkludDhBcnJheTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciAkdG9Mb2NhbGVTdHJpbmcgPSBbXS50b0xvY2FsZVN0cmluZztcblxuLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxudmFyIFRPX0xPQ0FMRV9TVFJJTkdfQlVHID0gISFJbnQ4QXJyYXkkMSAmJiBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgJHRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IEludDhBcnJheSQxKDEpKTtcbn0pO1xuXG52YXIgRk9SQ0VEID0gZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgSW50OEFycmF5JDEoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xufSkgfHwgIWZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICBJbnQ4QXJyYXkkMS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xufSk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS50b2xvY2FsZXN0cmluZ1xuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgndG9Mb2NhbGVTdHJpbmcnLCBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgcmV0dXJuIGFwcGx5JDEoXG4gICAgJHRvTG9jYWxlU3RyaW5nLFxuICAgIFRPX0xPQ0FMRV9TVFJJTkdfQlVHID8gYXJyYXlTbGljZSQxKGFUeXBlZEFycmF5KHRoaXMpKSA6IGFUeXBlZEFycmF5KHRoaXMpLFxuICAgIGFycmF5U2xpY2UkMShhcmd1bWVudHMpXG4gICk7XG59LCBGT1JDRUQpO1xuXG5jbGFzcyBQYXlsb2FkIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIC8vIFRoZSB0YWcncyB2YWx1ZSBpcyBhIGhhcmRjb2RlZCB2YWx1ZSBhcyBwZXJcbiAgICAvLyBkZWZpbmVkIGluIHRoZSBORVAgW05FUDQxM10oaHR0cHM6Ly9naXRodWIuY29tL25lYXIvTkVQcy9ibG9iL21hc3Rlci9uZXBzL25lcC0wNDEzLm1kKVxuICAgIHRoaXMudGFnID0gMjE0NzQ4NDA2MTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBkYXRhLm1lc3NhZ2U7XG4gICAgdGhpcy5ub25jZSA9IGRhdGEubm9uY2U7XG4gICAgdGhpcy5yZWNpcGllbnQgPSBkYXRhLnJlY2lwaWVudDtcbiAgICBpZiAoZGF0YS5jYWxsYmFja1VybCkge1xuICAgICAgdGhpcy5jYWxsYmFja1VybCA9IGRhdGEuY2FsbGJhY2tVcmw7XG4gICAgfVxuICB9XG59XG5jb25zdCBwYXlsb2FkU2NoZW1hID0gbmV3IE1hcChbW1BheWxvYWQsIHtcbiAga2luZDogXCJzdHJ1Y3RcIixcbiAgZmllbGRzOiBbW1widGFnXCIsIFwidTMyXCJdLCBbXCJtZXNzYWdlXCIsIFwic3RyaW5nXCJdLCBbXCJub25jZVwiLCBbMzJdXSwgW1wicmVjaXBpZW50XCIsIFwic3RyaW5nXCJdLCBbXCJjYWxsYmFja1VybFwiLCB7XG4gICAga2luZDogXCJvcHRpb25cIixcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH1dXVxufV1dKTtcbmNvbnN0IHNlcmlhbGl6ZU5lcDQxMyA9IHNpZ25NZXNzYWdlUGFyYW1zID0+IHtcbiAgY29uc3QgcGF5bG9hZCA9IG5ldyBQYXlsb2FkKE9iamVjdC5hc3NpZ24oe30sIHNpZ25NZXNzYWdlUGFyYW1zKSk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZXJpYWxpemUocGF5bG9hZFNjaGVtYSwgcGF5bG9hZCkpO1xufTtcblxuY29uc3QgdmVyaWZ5U2lnbmF0dXJlID0gKHtcbiAgcHVibGljS2V5LFxuICBzaWduYXR1cmUsXG4gIG1lc3NhZ2UsXG4gIG5vbmNlLFxuICByZWNpcGllbnQsXG4gIGNhbGxiYWNrVXJsXG59KSA9PiB7XG4gIC8vIFJlY29uc3RydWN0IHRoZSBwYXlsb2FkIHRoYXQgd2FzICoqYWN0dWFsbHkgc2lnbmVkKipcbiAgY29uc3QgcGF5bG9hZCA9IG5ldyBQYXlsb2FkKHtcbiAgICBtZXNzYWdlLFxuICAgIG5vbmNlLFxuICAgIHJlY2lwaWVudCxcbiAgICBjYWxsYmFja1VybFxuICB9KTtcbiAgLy8gU2VyaWFsaXplIHBheWxvYWQgYmFzZWQgb24gcGF5bG9hZFNjaGVtYVxuICBjb25zdCBib3JzaFBheWxvYWQgPSBzZXJpYWxpemUocGF5bG9hZFNjaGVtYSwgcGF5bG9hZCk7XG4gIC8vIEhhc2ggdGhlIHBheWxvYWQgYXMgaW4gdGhlIE5FUDA0MTMgcmVmZXJlbmNlZCBleGFtcGxlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL05FUHMvYmxvYi9tYXN0ZXIvbmVwcy9uZXAtMDQxMy5tZCNyZWZlcmVuY2VzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWdkaWV6L25lYXItbG9naW4vYmxvYi9tYWluL2F1dGhlbnRpY2F0ZS93YWxsZXQtYXV0aGVudGljYXRlLmpzI0wyMVxuICBjb25zdCBoYXNoZWRQYXlsb2FkID0gVWludDhBcnJheS5mcm9tKHNoYTI1Ni5hcnJheShib3JzaFBheWxvYWQpKTtcbiAgLy8gQ29udmVydCByZWFsIHNpZ25hdHVyZSB0byBidWZmZXIgYmFzZTY0XG4gIGNvbnN0IHJlYWxTaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUsIFwiYmFzZTY0XCIpO1xuICBjb25zdCBwayA9IHV0aWxzLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSk7XG4gIC8vIFZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gIHJldHVybiBway52ZXJpZnkoaGFzaGVkUGF5bG9hZCwgcmVhbFNpZ25hdHVyZSk7XG59O1xuY29uc3QgZmV0Y2hBbGxVc2VyS2V5cyA9ICh7XG4gIGFjY291bnRJZCxcbiAgbmV0d29yayxcbiAgcHVibGljS2V5XG59KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcih7XG4gICAgdXJsOiBuZXR3b3JrLm5vZGVVcmxcbiAgfSk7XG4gIGNvbnN0IGtleSA9IHlpZWxkIHByb3ZpZGVyLnF1ZXJ5KHtcbiAgICByZXF1ZXN0X3R5cGU6IFwidmlld19hY2Nlc3Nfa2V5XCIsXG4gICAgYWNjb3VudF9pZDogYWNjb3VudElkLFxuICAgIGZpbmFsaXR5OiBcImZpbmFsXCIsXG4gICAgcHVibGljX2tleTogcHVibGljS2V5XG4gIH0pO1xuICByZXR1cm4ga2V5O1xufSk7XG5jb25zdCB2ZXJpZnlGdWxsS2V5QmVsb25nc1RvVXNlciA9ICh7XG4gIHB1YmxpY0tleSxcbiAgYWNjb3VudElkLFxuICBuZXR3b3JrXG59KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3Qge1xuICAgIHBlcm1pc3Npb25cbiAgfSA9IHlpZWxkIGZldGNoQWxsVXNlcktleXMoe1xuICAgIGFjY291bnRJZCxcbiAgICBuZXR3b3JrLFxuICAgIHB1YmxpY0tleVxuICB9KTtcbiAgcmV0dXJuIHBlcm1pc3Npb24gPT09IFwiRnVsbEFjY2Vzc1wiO1xufSk7XG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgbW92ZWQgdG8gZW50cnkgcG9pbnRzXG5cbnZhciB1bmN1cnJ5VGhpcyQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBkZWZpbmVCdWlsdEluID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHJlZ2V4cEV4ZWMkMiA9IHJlZ2V4cEV4ZWMkMztcbnZhciBmYWlscyQxID0gZmFpbHMkcztcbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBGT1JDRUQsIFNIQU0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbChLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcblxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFdlIGNhbid0IHVzZSByZWFsIHJlZ2V4IGhlcmUgc2luY2UgaXQgY2F1c2VzIGRlb3B0aW1pemF0aW9uXG4gICAgICAvLyBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBpbiBWOFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMwNlxuICAgICAgcmUgPSB7fTtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICAgIHJlLmZsYWdzID0gJyc7XG4gICAgICByZVtTWU1CT0xdID0gLy4vW1NZTUJPTF07XG4gICAgfVxuXG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KTtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICBGT1JDRURcbiAgKSB7XG4gICAgdmFyIHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZCA9IHVuY3VycnlUaGlzJDIoLy4vW1NZTUJPTF0pO1xuICAgIHZhciBtZXRob2RzID0gZXhlYyhTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIChuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgdmFyIHVuY3VycmllZE5hdGl2ZU1ldGhvZCA9IHVuY3VycnlUaGlzJDIobmF0aXZlTWV0aG9kKTtcbiAgICAgIHZhciAkZXhlYyA9IHJlZ2V4cC5leGVjO1xuICAgICAgaWYgKCRleGVjID09PSByZWdleHBFeGVjJDIgfHwgJGV4ZWMgPT09IFJlZ0V4cFByb3RvdHlwZS5leGVjKSB7XG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmN1cnJpZWROYXRpdmVSZWdFeHBNZXRob2QocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuY3VycmllZE5hdGl2ZU1ldGhvZChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgfSk7XG5cbiAgICBkZWZpbmVCdWlsdEluKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgbWV0aG9kc1swXSk7XG4gICAgZGVmaW5lQnVpbHRJbihSZWdFeHBQcm90b3R5cGUsIFNZTUJPTCwgbWV0aG9kc1sxXSk7XG4gIH1cblxuICBpZiAoU0hBTSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFJlZ0V4cFByb3RvdHlwZVtTWU1CT0xdLCAnc2hhbScsIHRydWUpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG52YXIgdG9TdHJpbmckMSA9IHRvU3RyaW5nJDU7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ2O1xuXG52YXIgY2hhckF0JDEgPSB1bmN1cnJ5VGhpcyQxKCcnLmNoYXJBdCk7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzJDEoJycuY2hhckNvZGVBdCk7XG52YXIgc3RyaW5nU2xpY2UkMSA9IHVuY3VycnlUaGlzJDEoJycuc2xpY2UpO1xuXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmckMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5KHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuICAgICAgfHwgKHNlY29uZCA9IGNoYXJDb2RlQXQoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IGNoYXJBdCQxKFMsIHBvc2l0aW9uKVxuICAgICAgICAgIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gc3RyaW5nU2xpY2UkMShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKVxuICAgICAgICAgIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdNdWx0aWJ5dGUgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuXG52YXIgY2hhckF0ID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxudmFyIGFkdmFuY2VTdHJpbmdJbmRleCQxID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG5cbnZhciBjYWxsJDEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JGU7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mID0gY2xhc3NvZlJhdyQxO1xudmFyIHJlZ2V4cEV4ZWMkMSA9IHJlZ2V4cEV4ZWMkMztcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xudmFyIHJlZ2V4cEV4ZWNBYnN0cmFjdCA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAoaXNDYWxsYWJsZShleGVjKSkge1xuICAgIHZhciByZXN1bHQgPSBjYWxsJDEoZXhlYywgUiwgUyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgYW5PYmplY3QkMShyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgPT09ICdSZWdFeHAnKSByZXR1cm4gY2FsbCQxKHJlZ2V4cEV4ZWMkMSwgUiwgUyk7XG4gIHRocm93ICRUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbn07XG5cbnZhciBhcHBseSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYztcbnZhciBpc1JlZ0V4cCA9IGlzUmVnZXhwO1xudmFyIGFuT2JqZWN0ID0gYW5PYmplY3QkZTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ2O1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHNwZWNpZXNDb25zdHJ1Y3RvciQzO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleCQxO1xudmFyIHRvTGVuZ3RoID0gdG9MZW5ndGgkNjtcbnZhciB0b1N0cmluZyA9IHRvU3RyaW5nJDU7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDQ7XG52YXIgYXJyYXlTbGljZSA9IGFycmF5U2xpY2VTaW1wbGU7XG52YXIgY2FsbFJlZ0V4cEV4ZWMgPSByZWdleHBFeGVjQWJzdHJhY3Q7XG52YXIgcmVnZXhwRXhlYyA9IHJlZ2V4cEV4ZWMkMztcbnZhciBzdGlja3lIZWxwZXJzID0gcmVnZXhwU3RpY2t5SGVscGVycztcbnZhciBmYWlscyA9IGZhaWxzJHM7XG5cbnZhciBVTlNVUFBPUlRFRF9ZID0gc3RpY2t5SGVscGVycy5VTlNVUFBPUlRFRF9ZO1xudmFyIE1BWF9VSU5UMzIgPSAweEZGRkZGRkZGO1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyICRwdXNoID0gW10ucHVzaDtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoLy4vLmV4ZWMpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcygkcHVzaCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbi8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuLy8gV2VleCBKUyBoYXMgZnJvemVuIGJ1aWx0LWluIHByb3RvdHlwZXMsIHNvIHVzZSB0cnkgLyBjYXRjaCB3cmFwcGVyXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1lbXB0eS1ncm91cCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICB2YXIgcmUgPSAvKD86KS87XG4gIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggIT09IDIgfHwgcmVzdWx0WzBdICE9PSAnYScgfHwgcmVzdWx0WzFdICE9PSAnYic7XG59KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3NwbGl0JywgZnVuY3Rpb24gKFNQTElULCBuYXRpdmVTcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBpbnRlcm5hbFNwbGl0O1xuICBpZiAoXG4gICAgJ2FiYmMnLnNwbGl0KC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1lbXB0eS1ncm91cCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT0gNCB8fFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT0gNCB8fFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxIHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoXG4gICkge1xuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHJldHVybiBbc3RyaW5nXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwobmF0aXZlU3BsaXQsIHN0cmluZywgc2VwYXJhdG9yLCBsaW0pO1xuICAgICAgfVxuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICB3aGlsZSAobWF0Y2ggPSBjYWxsKHJlZ2V4cEV4ZWMsIHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weS5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgcHVzaChvdXRwdXQsIHN0cmluZ1NsaWNlKHN0cmluZywgbGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIGFwcGx5KCRwdXNoLCBvdXRwdXQsIGFycmF5U2xpY2UobWF0Y2gsIDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhZXhlYyhzZXBhcmF0b3JDb3B5LCAnJykpIHB1c2gob3V0cHV0LCAnJyk7XG4gICAgICB9IGVsc2UgcHVzaChvdXRwdXQsIHN0cmluZ1NsaWNlKHN0cmluZywgbGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW0gPyBhcnJheVNsaWNlKG91dHB1dCwgMCwgbGltKSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHVuZGVmaW5lZCwgMCkubGVuZ3RoKSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IGNhbGwobmF0aXZlU3BsaXQsIHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH0gZWxzZSBpbnRlcm5hbFNwbGl0ID0gbmF0aXZlU3BsaXQ7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGdldE1ldGhvZChzZXBhcmF0b3IsIFNQTElUKTtcbiAgICAgIHJldHVybiBzcGxpdHRlclxuICAgICAgICA/IGNhbGwoc3BsaXR0ZXIsIHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogY2FsbChpbnRlcm5hbFNwbGl0LCB0b1N0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcbiAgICAvL1xuICAgIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgICAvLyB0aGUgJ3knIGZsYWcuXG4gICAgZnVuY3Rpb24gKHN0cmluZywgbGltaXQpIHtcbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIFMgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShpbnRlcm5hbFNwbGl0LCByeCwgUywgbGltaXQsIGludGVybmFsU3BsaXQgIT09IG5hdGl2ZVNwbGl0KTtcblxuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3RvcihyeCwgUmVnRXhwKTtcblxuICAgICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XG4gICAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChVTlNVUFBPUlRFRF9ZID8gJ2cnIDogJ3knKTtcblxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBDKFVOU1VQUE9SVEVEX1kgPyAnXig/OicgKyByeC5zb3VyY2UgKyAnKScgOiByeCwgZmxhZ3MpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoUy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIHZhciBxID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0dGVyLmxhc3RJbmRleCA9IFVOU1VQUE9SVEVEX1kgPyAwIDogcTtcbiAgICAgICAgdmFyIHogPSBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgVU5TVVBQT1JURURfWSA/IHN0cmluZ1NsaWNlKFMsIHEpIDogUyk7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeiA9PT0gbnVsbCB8fFxuICAgICAgICAgIChlID0gbWluKHRvTGVuZ3RoKHNwbGl0dGVyLmxhc3RJbmRleCArIChVTlNVUFBPUlRFRF9ZID8gcSA6IDApKSwgUy5sZW5ndGgpKSA9PT0gcFxuICAgICAgICApIHtcbiAgICAgICAgICBxID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHEsIHVuaWNvZGVNYXRjaGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaChBLCBzdHJpbmdTbGljZShTLCBwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBwdXNoKEEsIHpbaV0pO1xuICAgICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxID0gcCA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHB1c2goQSwgc3RyaW5nU2xpY2UoUywgcCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSwgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQywgVU5TVVBQT1JURURfWSk7XG5cbnZhciBtb2RhbCRiID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCJDb25uZWN0IFlvdXIgV2FsbGV0XCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCJXaGF0IGlzIGEgV2FsbGV0P1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJTZWN1cmUgJiBNYW5hZ2UgWW91ciBEaWdpdGFsIEFzc2V0c1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcIlNhZmVseSBzdG9yZSBhbmQgdHJhbnNmZXIgeW91ciBjcnlwdG8gYW5kIE5GVHMuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCJMb2cgSW4gdG8gQW55IE5FQVIgQXBwXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTm8gbmVlZCB0byBjcmVhdGUgbmV3IGFjY291bnRzIG9yIGNyZWRlbnRpYWxzLiBDb25uZWN0IHlvdXIgd2FsbGV0IGFuZCB5b3UgYXJlIGdvb2QgdG8gZ28hXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJHZXQgYSBXYWxsZXRcIixcblx0XHR1c2VBV2FsbGV0OiBcIlVzZSBhIHdhbGxldCB0byBzZWN1cmUgYW5kIG1hbmFnZSB5b3VyIE5FQVIgYXNzZXRzLCBhbmQgdG8gbG9nIGluIHRvIGFueSBORUFSIGFwcCB3aXRob3V0IHRoZSBuZWVkIGZvciB1c2VybmFtZXMgYW5kIHBhc3N3b3Jkcy5cIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIkNvbm5lY3Rpb24gRmFpbGVkXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiQ29ubmVjdGlvbiBTdWNjZXNzZnVsXCIsXG5cdFx0Y29ubmVjdGVkOiBcIkNvbm5lY3RlZFwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCJDb25uZWN0aW5nIHRvXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIkNvbmZpcm0gdGhlIGNvbm5lY3Rpb24gaW4gdGhlIGV4dGVuc2lvbiB3aW5kb3dcIixcblx0XHRcdGJyb3dzZXI6IFwiQ29uZmlybSB0aGUgY29ubmVjdGlvbiBpbiB0aGUgd2FsbGV0IGFmdGVyIHJlZGlyZWN0XCIsXG5cdFx0XHRoYXJkd2FyZTogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSBsZWRnZXIgZGV2aWNlXCIsXG5cdFx0XHRicmlkZ2U6IFwiQ29uZmlybSB0aGUgY29ubmVjdGlvbiBpbiB0aGUgd2FsbGV0XCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIkNvbm5lY3Qgd2l0aCBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwiTWFrZSBzdXJlIHlvdXIgTGVkZ2VyIGlzIGNvbm5lY3RlZCBzZWN1cmVseSwgYW5kIHRoYXQgdGhlIE5FQVIgYXBwIGlzIG9wZW4gb24geW91ciBkZXZpY2VcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiQ29udGludWVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIlNwZWNpZnkgSEQgUGF0aFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCJFbnRlciB5b3VyIHByZWZlcnJlZCBIRCBwYXRoLCB0aGVuIHNjYW4gZm9yIGFueSBhY3RpdmUgYWNjb3VudHMuXCIsXG5cdFx0c2NhbjogXCJTY2FuXCIsXG5cdFx0cmV0cnk6IFwiUmV0cnlcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIgaXMgbm90IGF2YWlsYWJsZVwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIkFjY2VzcyBkZW5pZWQgdG8gdXNlIExlZGdlciBkZXZpY2VcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwiTm8gQWNjb3VudHMgRm91bmRcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiU2VsZWN0IFlvdXIgQWNjb3VudHNcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwiQ29ubmVjdGluZyAxIEFjY291bnRcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiQ2FuJ3QgZmluZCBhbnkgYWNjb3VudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBMZWRnZXIuIFBsZWFzZSBjcmVhdGUgYSBuZXcgTkVBUiBhY2NvdW50IG9uXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcIm9yIGNvbm5lY3QgYW4gYW5vdGhlciBMZWRnZXIuXCIsXG5cdFx0Y29ubmVjdGluZzogXCJDb25uZWN0aW5nXCIsXG5cdFx0b2ZBY2NvdW50czogXCJvZiBBY2NvdW50c1wiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJGYWlsZWQgdG8gYXV0b21hdGljYWxseSBmaW5kIGFjY291bnQgaWQuIFByb3ZpZGUgaXQgbWFudWFsbHk6XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIk92ZXJ2aWV3IHRoZSBsaXN0IG9mIGF1dGhvcml6ZWQgYWNjb3VudChzKSwgY29tcGxldGUgc2lnbiBpbiBieSBjbGlja2luZyB0aGUgYnV0dG9uIGJlbG93LlwiLFxuXHRcdGZpbmlzaDogXCJGaW5pc2hcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIllvdSdsbCBuZWVkIHRvIGluc3RhbGxcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcInRvIGNvbnRpbnVlLiBBZnRlciBpbnN0YWxsaW5nXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwicmVmcmVzaCB0aGUgcGFnZS5cIixcblx0XHRvcGVuOiBcIk9wZW5cIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIkNvcGllZCB0byBjbGlwYm9hcmRcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiRmFpbGVkIHRvIGNvcHkgdG8gY2xpcGJvYXJkXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIlNjYW4gd2l0aCBZb3VyIE1vYmlsZSBEZXZpY2VcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIENvcHkgdG8gY2xpcGJvYXJkXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiUHJlZmVyIHRoZSBvZmZpY2lhbCBkaWFsb2d1ZSBvZlwiLFxuXHRcdG9wZW46IFwiT3BlblwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCJDaG9vc2UgYSBXYWxsZXRcIixcblx0XHR0cmFuc2ZlcllvdXJBY2NvdW50czogXCJUcmFuc2ZlciBZb3VyIEFjY291bnRzXCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCJTZWxlY3QgYSB3YWxsZXQgdGhhdCBmaXRzIHlvdXIgbmVlZHMgYW5kIHN1cHBvcnRzIHlvdXIgY29ubmVjdGVkIGFjY291bnRzLlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJTZWxlY3QgWW91ciBBY2NvdW50c1wiLFxuXHRcdGFmdGVyRGVjaWRlOiBcIkFmdGVyIHlvdSBkZWNpZGUgb24gYSB3YWxsZXQsIHlvdSBjYW4gc2VsZWN0IHdoaWNoIGFjY291bnRzIHlvdSB3YW50IHRvIHRyYW5zZmVyLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiWW91IHdvbuKAmXQgYmUgYWJsZSB0byB0cmFuc2ZlciBhY2NvdW50cyB0aGF0IGhhdmUgbmV2ZXIgYmVlbiBmdW5kZWQgb3IgdXNlZCBvbiBORUFSLlwiLFxuXHRcdHdhcm5pbmc6IFwiZG9lcyBub3Qgc3VwcG9ydCBhY2NvdW50IGV4cG9ydCBhdCB0aGlzIHRpbWUuIFBsZWFzZSBzZWxlY3QgYW5vdGhlciB3YWxsZXQuXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCJTZWxlY3QgQWNjb3VudHMgdG8gVHJhbnNmZXJcIixcblx0XHRcdGJ1dHRvbjogXCJDb250aW51ZVwiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwiRGVzZWxlY3QgQWxsXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiU2VsZWN0IEFsbFwiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiVHJhbnNmZXIgVW5hdmFpbGFibGVcIixcblx0XHRcdGVycm9yOiBcIkFjY291bnQgZG9lcyBub3QgZXhpc3RcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwiTGVkZ2VyIHN1cHBvcnQgcmVxdWlyZWRcIixcblx0XHRcdG5vQmFsYW5jZTogXCJBY2NvdW50IG5vdCBmdW5kZWRcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiQ29weSBUZW1wb3JhcnkgUGFzc3dvcmRcIixcblx0XHRcdGRlc2M6IFwiWW914oCZbGwgbmVlZCB0byBlbnRlciB0aGlzIHBhc3N3b3JkIHdoZW4geW91IGJlZ2luIGV4cG9ydGluZyB5b3VyIGFjY291bnRzIHRvIGEgZGlmZmVyZW50IHdhbGxldC5cIixcblx0XHRcdGJ1dHRvbjogXCJDb250aW51ZVwiLFxuXHRcdFx0dHJhbnNmZXJCdXR0b246IFwiVHJhbnNmZXIgQWNjb3VudHNcIixcblx0XHRcdGxhYmVsOiBcIkNsaWNrIHRvIENvcHlcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiSSBjb3BpZWQgb3Igd3JvdGUgZG93biB0aGUgcGFzc3dvcmRcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcIkNvbXBsZXRlIHRoZSBUcmFuc2ZlclwiLFxuXHRcdFx0ZGVzY09uZTogXCJZb3Ugd2lsbCBub3cgYmUgcmVkaXJlY3RlZCB0byB0aGUgd2FsbGV0IHlvdSBzZWxlY3RlZCB0byBjb21wbGV0ZSB0aGUgdHJhbnNmZXIuXCIsXG5cdFx0XHRkZXNjVHdvOiBcIk9uY2UgaW1wb3J0IHBhcnQgb2YgcHJvY2VzcyBpcyBjb21wbGV0ZWQgZnJvbSBzZWxlY3RlZCB3YWxsZXQsIHByZXNzIGJ1dHRvbiB0byBjb21wbGV0ZSB0aGUgdHJhbnNmZXIgcHJvY2Vzcy5cIixcblx0XHRcdHN0YXJ0T3ZlckJ1dHRvbjogXCJTdGFydCBPdmVyXCIsXG5cdFx0XHRidXR0b246IFwiQ29tcGxldGVcIlxuXHRcdH1cblx0fVxufTtcbnZhciBjb21wb25lbnQkMSA9IHtcblx0Y2xpY2tUb0NvcHk6IHtcblx0XHRsYWJlbDogXCJDb3BpZWRcIixcblx0XHR0b29sdGlwOiBcIkNsaWNrIHRvIGNvcHlcIlxuXHR9XG59O1xudmFyIGVuID0ge1xuXHRtb2RhbDogbW9kYWwkYixcblx0Y29tcG9uZW50OiBjb21wb25lbnQkMVxufTtcblxudmFyIG1vZGFsJGEgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIkNvbmVjdGEgVHUgQmlsbGV0ZXJhXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLCv1F1ZSBlcyB1bmEgQmlsbGV0ZXJhP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJSZXNndWFyZGEgeSBBZG1pbmlzdHJhciBUdXMgQWN0aXZvcyBEaWdpdGFsZXNcIixcblx0XHRzYWZlbHlTdG9yZTogXCJBbG1hY2VuYSBkZSBmb3JtYSBzZWd1cmEgeSB0cmFuc2ZpZXJlIHR1cyBjcnlwdG9zIHkgTkZUJ3NcIixcblx0XHRsb2dJblRvQW55OiBcIkluaWNpZSBzZXNpw7NuIGVuIEN1YWxxdWllciBBcGxpY2FjaW9uIE5FQVJcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJObyBlcyBuZWNlc2FyaW8gY3JlYXIgbnVldmFzIGN1ZW50YXMgbyBjcmVkZW5jaWFsZXMsIMKhQ29uZWN0YSB0dSBiaWxsZXRlcmEgeSBsaXN0byFcIixcblx0XHRnZXRBV2FsbGV0OiBcIk9idGVuIHVuYSBCaWxsZXRlcmFcIixcblx0XHR1c2VBV2FsbGV0OiBcIlVzYSB0dSBCaWxsZXRlcmEgcGFyYSByZXNndWFyZGFyIHkgYWRtaW5pc3RyYXIgdHVzIGFjdGl2b3MgZW4gTkVBUiwgZSBJbmljaWFyIHNlc2nDs24gZW4gY3VhbHF1aWVyIGFwbGljYWNpb24gTkVBUiBzaW4gbGEgbmVjZXNpZGFkIGRlIG5vbWJyZXMgZGUgdXN1YXJpb3MgeSBjb250cmFzZcOxYXNcIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIkNvbmV4acOzbiBGYWxsaWRhXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiQ29uZXhpw7NuIEV4aXN0b3NhXCIsXG5cdFx0Y29ubmVjdGVkOiBcIkNvbmVjdGFkb1wiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCJDb25lY3RhbmRvIGEgXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIkNvbmZpcm1lIGxhIGNvbmV4acOzbiBlbiBsYSB2ZW50YW5hIGRlIGV4dGVuc2nDs25cIixcblx0XHRcdGJyb3dzZXI6IFwiQ29uZmlybWUgbGEgY29uZXhpw7NuIGVuIGxhIGJpbGxldGVyYSBkZXNwdcOpcyBkZSBsYSByZWRpcmVjY2nDs25cIixcblx0XHRcdGhhcmR3YXJlOiBcIkNvbmZpcm1lIGxhIGNvbmV4acOzbiBlbiBlbCBkaXNwb3NpdGl2byBkZSBsaWJybyBtYXlvclwiLFxuXHRcdFx0YnJpZGdlOiBcIkNvbmZpcm1hciBsYSBjb25leGnDs24gZW4gbGEgYmlsbGV0ZXJhXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIkNvbmVjdGFyIGNvbiBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwiQXNlZ8O6cmVzZSBkZSBxdWUgc3UgbGVkZ2VyIGVzdMOhIGNvbmVjdGFkYSBkZSBmb3JtYSBzZWd1cmEgeSBxdWUgbGEgYXBsaWNhY2lvbiBORUFSIGVzdMOpIGFiaWVydGEgZW4gc3UgZGlzcG9zaXRpdm9cIixcblx0XHRcImNvbnRpbnVlXCI6IFwiQ29udGludWFyXCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCJFc3BlY2lmaXF1ZSBsYSBydXRhIEhEXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIkluZ3Jlc2Ugc3UgcnV0YSBIRCBwcmVyaWRhLHkgbHVlZ28gYnVzcXVlIGN1YWxxdWllciBjdWVudGEgYWN0aXZhLlwiLFxuXHRcdHNjYW46IFwiRXNjYW5lYXJcIixcblx0XHRyZXRyeTogXCJSZWludGVudGFyXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiRWwgTGVkZ2VyIG5vIGVzdMOhIGRpc3BvbmlibGVcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJBY2Nlc28gZGVuZWdhZG8gcGFyYSB1c2FyIGVsIGRpc3Bvc2l0aXZvIGxlZGdlclwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCJObyBzZSBlbmNvbnRyYXJvbiBjdWVudGFzXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIlNlbGVjY2lvbmEgdHVzIGN1ZW50YXNcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwiQ29uZWN0YW5kbyBhIDEgY3VlbnRhXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIk5vIHNlIHB1ZG8gZW5jb250cmFyIG5pbmd1bmEgY3VlbnRhIGFzb2NpYWRhIGNvbiBlc3RlIGxlZGdlcixQb3IgZmF2b3IgY3JlYSB1bmEgbnVldmEgY3VlbnRhIGVuIE5FQVJcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwibyBjb25lY3RhIG90cm8gbGVkZ2VyXCIsXG5cdFx0Y29ubmVjdGluZzogXCJDb25lY3RhbmRvXCIsXG5cdFx0b2ZBY2NvdW50czogXCJkZSBDdWVudGFzXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIk5vIHNlIHB1ZG8gZW5jb250cmFyIGF1dG9tYXRpY2FtZW50ZSBlbCBpZCBkZSBsYSBjdWVudGEsSW5ncmVzYWxvIG1hbnVhbG1lbnRlOlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCJSZXZpc2UgbGEgbGlzdGEgZGUgbGFzIGN1ZW50YXMgYXV0b3JpemFkYXMsQ29tcGxldGUgZWwgaW5pY2lvIGRlIHNlc2nDs24gaGFjaWVkbyBjbGljayBhIGNvdW50aW51YWNpb24uXCIsXG5cdFx0ZmluaXNoOiBcIkZpbmFsaXphclwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwiVGVuZHLDoXMgcXVlIGluc3RhbGFyXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCJQYXJhIGNvbnRpbnVhciwgRGVzcHVlcyBkZSBpbnN0YWxhclwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIlJlY2FyZ2EgbGEgcGFnaW5hXCIsXG5cdFx0b3BlbjogXCJBYnJpclwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwiQ29waWFkbyBhbCBQb3J0YXBhcGVsZXNcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiRmFsbMOzIGxhIGNvcGlhIGFsIFBvcnRhcGFwZWxlc1wiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCJCdXNjYSBjb24gdHUgZGlzcG9zaXRpdm8gbW92aWxcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIENvcGlhciBhbCBQb3J0YXBhcGVsZXNcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLCv1ByZWZpcmVzIGVsIGRpw6Fsb2dvIG9maWNpYWwgZGVcIixcblx0XHRvcGVuOiBcIkFicmlyXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fVxufTtcbnZhciBlcyA9IHtcblx0bW9kYWw6IG1vZGFsJGFcbn07XG5cbnZhciBtb2RhbCQ5ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLov57mjqXkvaDnmoTpkrHljIVcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIuS7gOS5iOaYr+mSseWMhe+8n1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLkv53miqTlkoznrqHnkIbkvaDnmoTmlbDlrZfotYTkuqdcIixcblx0XHRzYWZlbHlTdG9yZTogXCLlronlhajlrZjlgqjlkozovaznp7vkvaDnmoTliqDlr4botKfluIHlkoxORlRcIixcblx0XHRsb2dJblRvQW55OiBcIueZu+W9leS7u+S9lSBORUFSIOW6lOeUqFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIuS4jemcgOimgeWIm+W7uuaWsOi0puaIt+aIluWvhueggeOAgui/nuaOpeS9oOeahOmSseWMhe+8jOWNs+WPr+W8gOWni+S9v+eUqO+8gVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi6I635Y+W5paw6LSm5oi3XCIsXG5cdFx0dXNlQVdhbGxldDogXCLkvb/nlKjpkrHljIXmnaXkv53miqTlkoznrqHnkIbkvaDnmoQgTkVBUiDotYTkuqfvvIzml6DpnIDnlKjmiLflkI3lkozlr4bnoIHljbPlj6/nmbvlvZXku7vkvZUgTkVBUiDlupTnlKhcIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIui/nuaOpeWksei0pVwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIui/nuaOpeaIkOWKn1wiLFxuXHRcdGNvbm5lY3RlZDogXCLlt7Lov57mjqVcIixcblx0XHRjb25uZWN0aW5nVG86IFwi5q2j5Zyo6L+e5o6lXCJcblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi6L+e5o6lIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLnoa7kv53kvaDnmoQgTGVkZ2VyIOW3sue7j+WuieWFqOi/nuaOpe+8jOW5tuS4lCBORUFSIOW6lOeUqOW3sue7j+WcqOS9oOiuvuWkh+S4iuaJk+W8gFwiLFxuXHRcdFwiY29udGludWVcIjogXCLnu6fnu61cIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIuaMh+WumiBIRCDot6/lvoRcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi6L6T5YWl5L2g5YGP5aW955qEIEhEIOi3r+W+hO+8jOeEtuWQjuS4uuS7u+aEj+a0u+i3g+i0puaIt+aJq+eggVwiLFxuXHRcdHNjYW46IFwi5omr56CBXCIsXG5cdFx0cmV0cnk6IFwi6YeN6K+VXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIOS4jeWPr+eUqFwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIuiuv+mXriBMZWRnZXIg6K6+5aSH6KKr5ouS57udXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIuayoeacieaJvuWIsOi0puaIt1wiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLpgInmi6nkvaDnmoTotKbmiLdcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi5q2j5Zyo6L+e5o6lMeS4qui0puaIt1wiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLmsqHmnInmib7liLDku7vkvZXkuI7ov5nkuKogTGVkZ2VyIOebuOWFs+iBlOeahOi0puaIt+OAguivt+WIm+W7uuaWsOi0puaIt+S6jlwiLFxuXHRcdFwib3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyLlwiOiBcIuaIlui/nuaOpeWPpuS4gOS4qiBMZWRnZXJcIixcblx0XHRjb25uZWN0aW5nOiBcIuato+WcqOi/nuaOpVwiLFxuXHRcdG9mQWNjb3VudHM6IFwi5Liq6LSm5oi3XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIuaXoOazleiHquWKqOaJvuWIsOi0puaIt0lE77yM6K+35Li75Yqo5o+Q5L6b77yaXCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIuivt+afpeeci+W3suaOiOadg+eahOi0puaIt+WIl+ihqO+8jOeCueWHu+S7peS4i+aMiemSruWujOaIkOeZu+W9lVwiLFxuXHRcdGZpbmlzaDogXCLlrozmiJBcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIuS9oOWwhumcgOimgeWuieijhVwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi5Lul57un57ut44CC5a6J6KOF5a6MXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi6K+35Yi35paw6aG16Z2iXCIsXG5cdFx0b3BlbjogXCLmiZPlvIBcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIuWkjeWItuWIsOS6huWJqui0tOadv1wiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLlpI3liLbliLDliarotLTmnb/lpLHotKVcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi55So5L2g55qE56e75Yqo6K6+5aSH5omr56CBXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiDlpI3liLbliLDliarotLTmnb9cIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLluIzmnJvkvb/nlKjlrpjmlrnlr7nor53moYbkuo5cIixcblx0XHRvcGVuOiBcIuaJk+W8gFwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH1cbn07XG52YXIgemggPSB7XG5cdG1vZGFsOiBtb2RhbCQ5XG59O1xuXG52YXIgbW9kYWwkOCA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi0KHQstGK0YDQttC10YLQtSDQstCw0YjQuNGPINCf0L7RgNGC0YTQtdC50LtcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcItCa0LDQutCy0L4g0LUg0J/QvtGA0YLRhNC10LnQuz9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi0JfQsNGJ0LjRgtC10YLQtSDQuCDRg9C/0YDQsNCy0LvRj9Cy0LDQudGC0LUg0LTQuNCz0LjRgtCw0LvQvdC40YLQtSDRgdC4INCw0LrRgtC40LLQuFwiLFxuXHRcdHNhZmVseVN0b3JlOiBcItCh0YrRhdGA0LDQvdGP0LLQsNC50YLQtSDQuCDQv9GA0LXRhdCy0YrRgNC70Y/QudGC0LUg0LHQtdC30L7Qv9Cw0YHQvdC+INCy0LDRiNC40YLQtSDQutGA0LjQv9GC0L4g0LggTkZULlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi0JjQt9C/0L7Qu9C30LLQsNC50YLQtSDQstGB0Y/QutC+INC/0YDQuNC70L7QttC10L3QuNC1INC90LAgTkVBUlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcItCd0Y/QvNCwINC90YPQttC00LAg0LTQsCDRgdGK0LfQtNCw0LLQsNGC0LUg0L3QvtCy0Lgg0L/RgNC+0YTQuNC70LguINCh0LLRitGA0LbQtdGC0LUg0L/QvtGA0YLRhNC10LnQu9CwINGB0Lgg0Lgg0YHRgtC1INCz0L7RgtC+0LLQuCFcIixcblx0XHRnZXRBV2FsbGV0OiBcItCh0YrQt9C00LDQudGC0LUg0J/QvtGA0YLRhNC10LnQu1wiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi0JjQt9C/0L7Qu9C30LLQsNC50YLQtSDQv9C+0YDRgtGE0LXQudC70LAsINC30LAg0LTQsCDQt9Cw0YnQuNGC0LjRgtC1INC4INGD0L/RgNCw0LLQu9GP0LLQsNGC0LUg0LDQutGC0LjQstC40YLQtSDRgdC4INC90LAgTkVBUiDQutCw0LrRgtC+INC4INC00LAg0LjQt9C/0L7Qu9C30LLQsNGC0LUg0LLRgdGP0LrQviDQv9GA0LjQu9C+0LbQtdC90LjQtSDQvdCwIE5FQVIg0LHQtdC3INC90YPQttC00LAg0L7RgiDQv9C+0YLRgNC10LHQuNGC0LXQu9GB0LrQuCDQuNC80LXQvdCwINC4INC/0LDRgNC+0LvQuC5cIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcItCh0LLRitGA0LfQstCw0L3QtdGC0L4g0L3QtdGD0YHQv9C10YjQvdC+XCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi0KHQstGK0YDQt9Cy0LDQvdC10YLQviDRg9GB0L/QtdGI0L3QvlwiLFxuXHRcdGNvbm5lY3RlZDogXCLQodCy0YrRgNC30LDQvVwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLQodCy0YrRgNC30LLQsNC90LUg0LrRitC8XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcItCf0L7RgtCy0YrRgNC00LXRgtC1INGB0LLRitGA0LfQstCw0L3QtdGC0L4g0LIg0L/RgNC+0LfQvtGA0LXRhtCwINC90LAg0YDQsNC30YjQuNGA0LXQvdC40LXRgtC+XCIsXG5cdFx0XHRicm93c2VyOiBcItCf0L7RgtCy0YrRgNC00LXRgtC1INGB0LLRitGA0LfQstCw0L3QtdGC0L4g0LIg0L/QvtGA0YLRhNC10LnQu9CwINGB0LvQtdC0INC/0YDQtdC90LDRgdC+0YfQstCw0L3QtdGC0L5cIixcblx0XHRcdGhhcmR3YXJlOiBcItCf0L7RgtCy0YrRgNC00LXRgtC1INGB0LLRitGA0LfQstCw0L3QtdGC0L4g0LIg0YXQsNGA0LTRg9C10YDQvdC40Y8g0L/QvtGA0YLRhNC10LnQu1wiLFxuXHRcdFx0YnJpZGdlOiBcItCf0L7RgtCy0YrRgNC00LXRgtC1INCy0YDRitC30LrQsNGC0LAg0LIg0L/QvtGA0YLRhNC10LnQu9CwXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcItCh0LLRitGA0LbQtdGC0LUg0YHQtSDRgSBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi0KPQstC10YDQtdGC0LUg0YHQtSwg0YfQtSDQstCw0YjQuNGP0YIgTGVkZ2VyINC1INGB0LLRitGA0LfQsNC9INC4INGH0LUg0L/RgNC40LvQvtC20LXQvdC40LXRgtC+IE5FQVIg0LUg0L7RgtCy0L7RgNC10L3QviDQvWEg0L3QtdCz0L4uXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItCf0YDQvtC00YrQu9C20LXRgtC1XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLQn9C+0YHQvtGH0LXRgtC1IEhEINC/0YrRglwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLQktGK0LLQtdC00LXRgtC1INC/0YDQtdC00L/QvtGH0LjRgtCw0L3QuNGPIEhEINC/0YrRgiwg0YHQu9C10LQg0LrQvtC10YLQviDRgdC60LDQvdC40YDQsNC50YLQtSDQt9CwINCw0LrRgtC40LLQvdC4INCw0LrQsNGD0L3RgtC4LlwiLFxuXHRcdHNjYW46IFwi0KHQutCw0L3QuNGA0LDQudGC0LVcIixcblx0XHRyZXRyeTogXCLQntC/0LjRgtCw0LnRgtC1INC+0YLQvdC+0LLQvlwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciDRg9GB0YLRgNC+0LnRgdGC0LLQvtGC0L4g0L3QtSDQtSDQtNC+0YHRgtGK0L/QvdC+XCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi0JTQvtGB0YLRitC/0YrRgiDQt9CwINC40LfQv9C+0LvQt9Cy0LDQvdC1INC90LAgTGVkZ2VyINC1INC+0YLQutCw0LfQsNC9XCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcItCd0Y/QvNCwINC90LDQvNC10YDQtdC90Lgg0L/RgNC+0YTQuNC70LhcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi0JjQt9Cx0LXRgNC10YLQtSDQstCw0YjQuNGC0LUg0L/RgNC+0YTQuNC70LhcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi0KHQstGK0YDQt9Cy0LDQvdC1INC90LAgMSDQv9GA0L7RhNC40LtcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi0J3Rj9C80LAg0L3QsNC80LXRgNC10L3QuCDQv9GA0L7RhNC40LvQuCwg0YHRitCy0YDQt9Cw0L3QuCDRgSDRgtC+0LfQuCBMZWRnZXIuINCc0L7Qu9GPLCDRgdGK0LfQtNCw0LnRgtC1INC90L7QsiBORUFSINC/0YDQvtGE0LjQuyDQvdCwXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcItC40LvQuCDRgdCy0YrRgNC20LXRgtC1INC00YDRg9CzIExlZGdlci5cIixcblx0XHRjb25uZWN0aW5nOiBcItCh0LLRitGA0LfQstCw0L3QtVwiLFxuXHRcdG9mQWNjb3VudHM6IFwi0L7RgiDQv9GA0L7RhNC40LvQuFwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLQkNCy0YLQvtC80LDRgtC40YfQvdC+0YLQviDQvdCw0LzQuNGA0LDQvdC1INC90LAg0L/RgNC+0YTQuNC70LAg0L3QtSDQsdC1INGD0YHQv9C10YjQvdC+LiDQktGK0LLQtdC00LXRgtC1INCz0L4g0YDRitGH0L3QvjpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi0J/RgNC10LPQu9C10LTQsNC50YLQtSDRgdC/0LjRgdGK0LrQsCDRgSDRg9C/0YrQu9C90L7QvNC+0YnQtdC90Lgg0L/RgNC+0YTQuNC70LgsINC30LDQstGK0YDRiNC10YLQtSDQstC70LjQt9Cw0L3QtdGC0L4sINC60LDRgtC+INGJ0YDQsNC60L3QtdGC0LUg0LLRitGA0YXRgyDQsdGD0YLQvtC90LAg0L/Qvi3QtNC+0LvRgy4uXCIsXG5cdFx0ZmluaXNoOiBcItCX0LDQstGK0YDRiNC10YLQtVwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi0KnQtSDRgtGA0Y/QsdCy0LAg0LTQsCDQuNC90YHRgtCw0LvQuNGA0LDRgtC1XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLQt9CwINC00LAg0L/RgNC+0LTRitC70LbQuNGC0LUuINCh0LvQtdC0INC40L3RgdGC0LDQu9C40YDQsNC90LVcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLQv9GA0LXQt9Cw0YDQtdC00LXRgtC1INGB0YLRgNCw0L3QuNGG0LDRgtCwLlwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC10YLQtVwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi0JrQvtC/0LjRgNCw0L3QviDQsiDQutC70LjQv9Cx0L7RgNC00LBcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi0J3QtdGD0YHQv9C10YjQvdC+INC60L7Qv9C40YDQsNC90LUg0LIg0LrQu9C40L/QsdC+0YDQtNCwXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIiDQodC60LDQvdC40YDQsNC50YLQtSDRgSDQvNC+0LHQuNC70L3QvtGC0L4g0YHQuCDRg9GB0YLRgNC+0LnRgdGC0LLQvlwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIg0JrQvtC/0LjRgNCw0LnRgtC1INCyINC60LvQuNC/0LHQvtGA0LTQsFwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItCf0YDQtdC00L/QvtGH0LjRgtCw0L0g0LXQt9C40Log0LfQsCDQutC+0YDQtdGB0L/QvtC90LTQtdC90YbQuNGPXCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LXRgtC1XCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fVxufTtcbnZhciBiZyA9IHtcblx0bW9kYWw6IG1vZGFsJDhcbn07XG5cbnZhciBtb2RhbCQ3ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLsp4DqsJEg7Jew6rKw7ZWY6riwXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLsp4DqsJHsnYAg66y07IqoIOyXre2VoOydhCDtlZjrgpjsmpQ/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIuuLueyLoOydmCDrlJTsp4DthLgg7J6Q7IKw7J2EIOuztO2YuO2VmOqzoCDqtIDrpqztlanri4jri6QuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi7JWU7Zi47ZmU7Y+Q7JmAIE5GVOulvCDslYjsoITtlZjqsowg7KCA7J6l7ZWY6rOgIOyghOyGoe2VoCDsiJgg7J6I7Iq164uI64ukLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiTkVBUiBBcHDsl5Ag66Gc6re47J247ZWp64uI64ukLlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIuyDiOuhnOyatCDqs4TsoJXsnbTrgpgg67mE67CA67KI7Zi466W8IOunjOuTpCDtlYTsmpQg7JeG7J20IOyngOqwkeydhCDsl7DqsrDtlZwg7ZuEIOuwlOuhnCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpC5cIixcblx0XHRnZXRBV2FsbGV0OiBcIuyngOqwkSDqsIDsoLjsmKTquLBcIixcblx0XHR1c2VBV2FsbGV0OiBcIuyngOqwkeydhCDsgqzsmqntlZjsl6wgTkVBUiDsnpDsgrDsnYQg67O07Zi4wrfqtIDrpqztlZjqs6AsIOyVhOydtOuUlOyZgCDruYTrsIDrsojtmLgg7JeG7J20IE5FQVIg7JWx7JeQIOuhnOq3uOyduO2VoCDsiJgg7J6I7Iq164uI64ukLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi7Jew6rKwIOyLpO2MqFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIuyXsOqysCDshLHqs7VcIixcblx0XHRjb25uZWN0ZWQ6IFwiQ29ubmVjdGVkXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIuyXsOqysCDspJE6IFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLsnbXsiqTthZDshZgg7LC97JeQ7IScIOyXsOqysOydhCDtmZXsnbjtlZjshLjsmpRcIixcblx0XHRcdGJyb3dzZXI6IFwi66as64uk7J2066CJ7Yq4IOuQnCDsp4DqsJHsl5DshJwg7Jew6rKw7J2EIO2ZleyduO2VmOyEuOyalFwiLFxuXHRcdFx0aGFyZHdhcmU6IFwiTGVkZ2VyIOq4sOq4sOyXkOyEnCDsl7DqsrDsnYQg7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XHRicmlkZ2U6IFwi7KeA6rCR7JeQ7IScIOyXsOqysCDtmZXsnbhcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiTGVkZ2VyIOyXsOqysO2VmOq4sFwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJMZWRnZXLqsIAg7JWI7KCE7ZWY6rKMIOyXsOqysOuQmOyWtCDsnojqs6AsIE5FQVIg7JWx7J20IOyXtOugpCDsnojripQg7KeAIO2ZleyduO2VmOyEuOyalFwiLFxuXHRcdFwiY29udGludWVcIjogXCLqs4Tsho3tlZjquLBcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkhEIFBhdGgg7KeA7KCV7ZWY6riwXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIuybkO2VmOuKlCBIRCBQYXRo66W8IOyEoO2Dne2VmOqzoCwg7Zmc7ISx7ZmU65CcIOqzhOygleydtCDsnojripQg7KeAIOqygOyDie2VmOyEuOyalFwiLFxuXHRcdHNjYW46IFwi6rKA7IOJXCIsXG5cdFx0cmV0cnk6IFwi64uk7IucIOyLnOuPhFwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlcuulvCDsgqzsmqntlaAg7IiYIOyXhuyKteuLiOuLpFwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIkxlZGdlciDquLDquLAg7KCR6re8IOq2jO2VnOydtCDqsbDrtoDrkJjsl4jsirXri4jri6RcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi6rOE7KCV7J2EIOywvuydhCDsiJgg7JeG7Iq164uI64ukXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIuqzhOyglSDshKDtg53tlZjquLBcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi7ZWY64KY7J2YIOqzhOygleyXkCDsl7DqsrBcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiTGVkZ2Vy7JmAIOyXsOqysOuQnCDqs4TsoJXsnYQg7LC+7J2EIOyImCDsl4bsirXri4jri6QuIOyDiOuhnOyatCDqs4TsoJXsnYQg7IOd7ISx7ZWY6rGw64KYIFwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLri6TrpbggTGVkZ2Vy66W8IOyXsOqysO2VmOyEuOyalFwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi6rOE7KCVIOyXsOqysO2VmOq4sDogXCIsXG5cdFx0b2ZBY2NvdW50czogXCLqsJwg6rOE7KCV7J2EIOywvuyVmOyKteuLiOuLpFwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLqs4TsoJUgSUTrpbwg7LC+7KeAIOuqu+2WiOyKteuLiOuLpC4g7IiY64+Z7Jy866GcIOyeheugpe2VtOyjvOyEuOyalC5cIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi7J247Kad65CcIOqzhOyglSDrqqnroZ3snYQg7ZmV7J247ZWcIO2bhCDslYTrnpgg67KE7Yq87J2EIO2BtOumre2VmOyXrCDroZzqt7jsnbjsnYQg7JmE66OM7ZWY7IS47JqUXCIsXG5cdFx0ZmluaXNoOiBcIuyZhOujjFwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwi7ZWY65Oc7Juo7Ja0IOyngOqwkVwiLFxuXHRcdGJyb3dzZXI6IFwi67iM65287Jqw7KCAIOyngOqwkVwiLFxuXHRcdGluamVjdGVkOiBcIuyngOqwkSDtmZXsnqVcIixcblx0XHRicmlkZ2U6IFwi67iM66as7KeAIOyngOqwkVwiLFxuXHRcdG1vYmlsZTogXCLrqqjrsJTsnbwg7KeA6rCRXCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCLsnbjsiqTthLTtirgg7KeA6rCRXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLri6TsnYwg7ZmV7J6lIO2UhOuhnOq3uOueqOydhCDshKTsuZjtlbTso7zshLjsmpQ6XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCIuIOyEpOy5mCDsmYTro4wg7ZuEIO2OmOydtOyngCDsg4jroZwg6rOg7Lmo7J20IO2VhOyalO2VqeuLiOuLpC4gXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi7IOI66GcIOqzoOy5qFwiLFxuXHRcdG9wZW46IFwiT3BlblwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi7YG066a967O065Oc7JeQIOuzteyCrCDsmYTro4xcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi7YG066a967O065Oc7JeQIOuzteyCrCDsi6TtjKhcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi66qo67CU7J28IOyepey5mOulvCDsgqzsmqntlZjsl6wg7Iqk7LqU7ZW07KO87IS47JqUXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiDtgbTrpr3rs7Trk5zsl5Ag67O17IKs7ZWY6riwXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi64uk7J2MIO2UhOuhnOq3uOueqOyXkOyEnCDsoJzqs7XtlZjripQg6rO17IudIO2UhOuhnOyEuOyKpOulvCDshKDtmLjtlZjsi63ri4jquYw6IFwiLFxuXHRcdG9wZW46IFwiT3BlblwiXG5cdH1cbn07XG52YXIga28gPSB7XG5cdG1vZGFsOiBtb2RhbCQ3XG59O1xuXG52YXIgbW9kYWwkNiA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwiS+G6v3QgbuG7kWkgdsOtIGPhu6dhIGLhuqFuXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCJWw60gbMOgIGfDrD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwiQuG6o28gbeG6rXQgJiBRdeG6o24gbMO9IHTDoGkgc+G6o24gc+G7kSBj4bunYSBi4bqhblwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIkzGsHUgdHLhu68gdsOgIGNodXnhu4NuIHRp4buBbiDEkWnhu4duIHThu60gdsOgIE5GVCBj4bunYSBi4bqhbiBt4buZdCBjw6FjaCBhbiB0b8Ogbi5cIixcblx0XHRsb2dJblRvQW55OiBcIsSQxINuZyBuaOG6rXAgdsOgbyBi4bqldCBr4buzIOG7qW5nIGThu6VuZyB0csOqbiBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiS2jDtG5nIGPhuqduIHThuqFvIHTDoGkga2hv4bqjbiBob+G6t2MgdGjDtG5nIHRpbiDEkcSDbmcgbmjhuq1wIG3hu5tpLiBL4bq/dCBu4buRaSB2w60gY+G7p2EgYuG6oW4gdsOgIGLhuq90IMSR4bqndSFcIixcblx0XHRnZXRBV2FsbGV0OiBcIlThuqFvIFbDrVwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiU+G7rSBk4bulbmcgdsOtIMSR4buDIGLhuqNvIG3huq10IHbDoCBxdeG6o24gbMO9IHTDoGkgc+G6o24gdHLDqm4gTkVBUiBj4bunYSBi4bqhbiB2w6AgxJHEg25nIG5o4bqtcCB2w6BvIGLhuqV0IGvhu7Mg4bupbmcgZOG7pW5nIE5FQVIgbsOgbywga2jDtG5nIGPhuqduIHTDqm4gbmfGsOG7nWkgZMO5bmcgdsOgIG3huq10IGto4bqpdS5cIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIkvhur90IG7hu5FpIHRo4bqldCBi4bqhaVwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIkvhur90IG7hu5FpIHRow6BuaCBjw7RuZ1wiLFxuXHRcdGNvbm5lY3RlZDogXCLEkMOjIGvhur90IG7hu5FpXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIsSQYW5nIGvhur90IG7hu5FpIHThu5tpXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIljDoWMgbmjhuq1uIGvhur90IG7hu5FpIHRyb25nIGPhu61hIHPhu5UgdGnhu4duIMOtY2ggbeG7nyBy4buZbmdcIixcblx0XHRcdGJyb3dzZXI6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgdHJvbmcgdsOtIHNhdSBraGkgxJHGsOG7o2MgY2h1eeG7g24gaMaw4bubbmdcIixcblx0XHRcdGhhcmR3YXJlOiBcIljDoWMgbmjhuq1uIGvhur90IG7hu5FpIHbhu5tpIHbDrSBs4bqhbmhcIixcblx0XHRcdGJyaWRnZTogXCJYw6FjIG5o4bqtbiBr4bq/dCBu4buRaSB0cm9uZyB2w61cIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiS+G6v3QgbuG7kWkgdsOtIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLEkOG6o20gYuG6o28gTGVkZ2VyIGPhu6dhIGLhuqFuIMSRxrDhu6NjIGvhur90IG7hu5FpIGFuIHRvw6BuIHbDoCDhu6luZyBk4bulbmcgTkVBUiDEkWFuZyBt4bufIHPhurVuIHRyw6puIHRoaeG6v3QgYuG7i1wiLFxuXHRcdFwiY29udGludWVcIjogXCJUaeG6v3AgdOG7pWNcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkNo4buJIMSR4buLbmggSEQgUGF0aFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCJOaOG6rXAgSEQgUGF0aCBj4bunYSBi4bqhbiwgc2F1IMSRw7MgcXXDqXQgdMOsbSBjw6FjIHTDoGkga2hv4bqjbiBob+G6oXQgxJHhu5luZ1wiLFxuXHRcdHNjYW46IFwiUXXDqXRcIixcblx0XHRyZXRyeTogXCJUaOG7rSBs4bqhaVwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciBraMO0bmcga2jhuqMgZOG7pW5nXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiVHJ1eSBj4bqtcCBMZWRnZXIgYuG7iyB04burIGNo4buRaVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCJLaMO0bmcgdMOsbSB0aOG6pXkgdMOgaSBraG/huqNuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIkNo4buNbiB0w6BpIGtob+G6o24gY+G7p2EgYuG6oW5cIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwixJBhbmcga+G6v3QgbuG7kWkgMSB0w6BpIGtob+G6o25cIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiS2jDtG5nIHRo4buDIHTDrG0gdGjhuqV5IGLhuqV0IGvhu7MgdMOgaSBraG/huqNuIG7DoG8gxJHGsOG7o2MgbGnDqm4ga+G6v3QgduG7m2kgTGVkZ2VyIG7DoHkuIFZ1aSBsw7JuZyB04bqhbyBt4buZdCB0w6BpIGtob+G6o24gTkVBUiBt4bubaVwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJob+G6t2Mga+G6v3QgbuG7kWkgduG7m2kgdsOtIExlZGdlciBraMOhYy5cIixcblx0XHRjb25uZWN0aW5nOiBcIsSQYW5nIGvhur90IG7hu5FpXCIsXG5cdFx0b2ZBY2NvdW50czogXCJj4bunYSB0w6BpIGtob+G6o25cIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwiS2jDtG5nIHRo4buDIHThu7EgxJHhu5luZyB0w6xtIGlkIHTDoGkga2hv4bqjbi4gTmjhuq1wIHRo4bunIGPDtG5nOlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCJU4buVbmcgcXVhbiBkYW5oIHPDoWNoIGPDoWMgdMOgaSBraG/huqNuIMSRxrDhu6NjIOG7p3kgcXV54buBbiwgaG/DoG4gdOG6pXQgxJHEg25nIG5o4bqtcCBi4bqxbmcgY8OhY2ggYuG6pW0gdsOgbyBuw7p0IGLDqm4gZMaw4bubaS5cIixcblx0XHRmaW5pc2g6IFwiSG/DoG4gdGjDoG5oXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJC4bqhbiBz4bq9IGPhuqduIGPDoGkgxJHhurd0XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLEkeG7gyBi4bqvdCDEkeG6p3UuIFNhdSBraGkgY8OgaSDEkeG6t3QgeG9uZ1wiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIlThuqNpIGzhuqFpIHRyYW5nLlwiLFxuXHRcdG9wZW46IFwiTeG7n1wiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwixJDDoyBzYW8gY2jDqXAgdsOgbyBi4bqjbmcgZ2hpIHThuqFtXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIlNhbyBjaMOpcCB2w6BvIGLhuqNuZyBnaGkgdOG6oW0gdGjhuqV0IGLhuqFpXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIlF1w6l0IHbhu5tpIMSRaeG7h24gdGhv4bqhaSBj4bunYSBi4bqhblwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgU2FvIGNow6lwIHbDoG8gYuG6o25nIGdoaSB04bqhbVwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIkRpYWxvZ3VlIGNow61uaCB0aOG7qWMgY+G7p2FcIixcblx0XHRvcGVuOiBcIk3hu59cIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIlbDrSBs4bqhbmhcIixcblx0XHRicm93c2VyOiBcIlbDrSB0csOsbmggZHV54buHdFwiLFxuXHRcdGluamVjdGVkOiBcIlbDrSB0aeG7h24gw61jaCBt4bufIHLhu5luZ1wiLFxuXHRcdGJyaWRnZTogXCJWw60gQ+G6p3VcIixcblx0XHRtb2JpbGU6IFwiVsOtIE1vYmlsZVwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiVsOtIHThu6ljIHRow6xcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwiQ2jhu41uIHbDrVwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcIkNodXnhu4NuIHTDoGkga2hv4bqjblwiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwiQ2jhu41uIHbDrSBwaMO5IGjhu6NwIHbhu5tpIG5odSBj4bqndSBj4bunYSBi4bqhbiwgdsOtIMSRxrDhu6NjIGNo4buNbiBj4bqnbiBo4buXIHRy4bujIGPDoWMgdMOgaSBraG/huqNuIMSRYW5nIHPhu60gZOG7pW5nLlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJDaOG7jW4gdMOgaSBraG/huqNuXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiU2F1IGtoaSBjaOG7jW4gxJHGsOG7o2MgdMOgaSBraG/huqNuIGLhuqFuIGPDsyBjaHV54buDbi5cIixcblx0XHRkaXNjbGFpbWVyOiBcIkLhuqFuIGtow7RuZyB0aOG7gyBjaHV54buDbiB0w6BpIGtob+G6o24gbuG6v3UgdMOgaSBraG/huqNuIMSRw7MgY2jGsGEgxJHGsOG7o2Mgbmjhuq1uIHRp4buBbiBob+G6t2MgY2jGsGEgcGjDoXQgc2luaCBnaWFvIGThu4tjaCB0csOqbiBORUFSLlwiLFxuXHRcdHdhcm5pbmc6IFwia2jDtG5nIGjhu5cgdHLhu6MgeHXhuqV0IHTDoGkga2hv4bqjbi4gVnVpIGzDsm5nIGNo4buNbiB2w60ga2jDoWMuXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcIlbDrSBs4bqhbmhcIixcblx0XHRcdGJyb3dzZXI6IFwiVsOtIHRyw6xuaCBkdXnhu4d0XCIsXG5cdFx0XHRpbmplY3RlZDogXCJWw60gdGnhu4duIMOtY2ggbeG7nyBy4buZbmdcIixcblx0XHRcdGJyaWRnZTogXCJWw60gQ+G6p3VcIixcblx0XHRcdG1vYmlsZTogXCJWw60gTW9iaWxlXCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCJDaOG7jW4gdMOgaSBraG/huqNuIMSR4buDIGNodXnhu4NuXCIsXG5cdFx0XHRidXR0b246IFwiTOG6pXkgY+G7pW0gbeG6rXQga2jhuql1XCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCJC4buPIGNo4buNbiB04bqldCBj4bqjXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiQ2jhu41uIHThuqV0IGPhuqNcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcIkNodXnhu4NuIGtow7RuZyBraOG6oyBk4bulbmdcIixcblx0XHRcdGVycm9yOiBcIlTDoGkga2hv4bqjbiBraMO0bmcgdOG7k24gdOG6oWlcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwiWcOqdSBj4bqndSBo4buXIHRy4bujIExlZGdlclwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIlTDoGkga2hv4bqjbiB0cuG7kW5nXCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcIlNhbyBjaMOpcCBt4bqtdCBraOG6qXUgdOG6oW0gdGjhu51pXCIsXG5cdFx0XHRkZXNjOiBcIkLhuqFuIHPhur0gY+G6p24gbmjhuq1wIG3huq10IGto4bqpdSBraGkgYuG6r3QgxJHhuqd1IHh14bqldCBjw6FjIGtob+G6o24gdOG7m2kgdsOtIGtow6FjLlwiLFxuXHRcdFx0YnV0dG9uOiBcIlRp4bq/cCB04bulY1wiLFxuXHRcdFx0bGFiZWw6IFwiQuG6pW0gxJHhu4Mgc2FvIGNow6lwXCIsXG5cdFx0XHRjaGVja0xhYmVsOiBcIlTDtGkgxJHDoyBjaMOpcCBob+G6t2MgZ2hpIGzhuqFpIG3huq10IGto4bqpdVwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiSG/DoG4gdGjDoG5oIGNodXnhu4NuXCIsXG5cdFx0XHRkZXNjT25lOiBcIkLhuqFuIHPhur0gxJHGsOG7o2MgY2h1eeG7g24gaMaw4bubbmcgdOG7m2kgdMOgaSBraG/huqNuIMSRw6MgY2jhu41uIMSR4buDIGhvw6BuIHThuqV0IHF1w6EgdHLDrG5oLlwiLFxuXHRcdFx0ZGVzY1R3bzogXCJTYXUga2hpIG5o4bqtcCwgbmjhuqVuIG7DunQgxJHhu4MgaG/DoG4gdOG6pXQgcXV5IHRyw6xuaCBjaHV54buDbi5cIixcblx0XHRcdGJ1dHRvbjogXCJIb8OgbiB0aMOgbmhcIlxuXHRcdH1cblx0fVxufTtcbnZhciBjb21wb25lbnQgPSB7XG5cdGNsaWNrVG9Db3B5OiB7XG5cdFx0bGFiZWw6IFwixJDDoyBzYW8gY2jDqXBcIixcblx0XHR0b29sdGlwOiBcIkLhuqVtIMSR4buDIHNhbyBjaMOpcFwiXG5cdH1cbn07XG52YXIgdmkgPSB7XG5cdG1vZGFsOiBtb2RhbCQ2LFxuXHRjb21wb25lbnQ6IGNvbXBvbmVudFxufTtcblxudmFyIG1vZGFsJDUgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIuCkheCkquCkqOCkviDgpLXgpYngpLLgpYfgpJ8gKFdhbGxldCkg4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkguClpFwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi4KS14KWJ4KSy4KWH4KSfIOCkleCljeCkr+CkviDgpLngpYg/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIuCkuOClgeCksOCkleCljeCkt+Ckv+CkpCDgpJTgpLAg4KSq4KWN4KSw4KSs4KSC4KSn4KS/4KSkIOCkleCksOClh+CkguClpFwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIuCkheCkquCkqOClgCDgpJXgpY3gpLDgpL/gpKrgpY3gpJ/gpYvgpJXgpLDgpYfgpILgpLjgpYAg4KSU4KSwIOCkj+CkqOCkj+Ckq+Ckn+ClgCDgpJXgpYsg4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCksOClguCkqiDgpLjgpYcg4KS44KWN4KSf4KWL4KSwIOCklOCksCDgpJ/gpY3gpLDgpL7gpILgpLjgpKvgpLAg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0bG9nSW5Ub0FueTogXCJORUFSIOCkquCksCDgpJXgpL/gpLjgpYAg4KSt4KWAIOCkkOCkqiDgpK7gpYfgpIIg4KS44KS+4KSH4KSoIOCkh+CkqCDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCLgpKjgpI8g4KSW4KS+4KSk4KWHIOCkr+CkviDgpLLgpYngpJfgpL/gpKgg4KSs4KSo4KS+4KSo4KWHIOCkleClgCDgpIbgpLXgpLbgpY3gpK/gpJXgpKTgpL4g4KSo4KS54KWA4KSCIOCkueCliOClpCDgpIXgpKrgpKjgpL4g4KS14KWJ4KSy4KWH4KSfKE5FQVIgV2FsbGV0KeCkleCkqOClh+CkleCljeCknyDgpJXgpLDgpYfgpIIg4KSU4KSwIOCkhuCksOCkguCkrSDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRnZXRBV2FsbGV0OiBcIuCkj+CklSDgpLXgpYngpLLgpYfgpJ8g4KSs4KSo4KS+4KSP4KSB4KWkXCIsXG5cdFx0dXNlQVdhbGxldDogXCLgpIXgpKrgpKjgpYAgTkVBUiDgpLjgpILgpKrgpKTgpY3gpKTgpL/gpK/gpYvgpIIg4KSV4KWLIOCkuOClgeCksOCkleCljeCkt+Ckv+CkpCDgpJTgpLAg4KSq4KWN4KSw4KSs4KSC4KSn4KS/4KSkIOCkleCksOCkqOClhyDgpJXgpYcg4KSy4KS/4KSPIOCkteClieCksuClh+CknyDgpJXgpL4g4KSJ4KSq4KSv4KWL4KSXIOCkleCksOClh+CkgiDgpJTgpLAg4KSV4KS/4KS44KWAIOCkreClgCBORUFSIOCkkOCkqiAoYXBwKSDgpK7gpYfgpIIg4KSy4KWJ4KSXIOCkh+CkqCDgpJXgpLDgpYfgpIIsIOCkleCkv+CkuOClgCDgpIngpKrgpK/gpYvgpJfgpJXgpLDgpY3gpKTgpL4gKHVzZXIpIOCkqOCkvuCkriDgpJTgpLAg4KSq4KS+4KS44KS14KSw4KWN4KShIOCkleClgCDgpIbgpLXgpLbgpY3gpK/gpJXgpKTgpL4g4KSo4KS54KWA4KSCIOCkueCliOClpFwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi4KSV4KSo4KWH4KSV4KWN4KS24KSoIOCkteCkv+Ckq+CksnxcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLgpJXgpKjgpYfgpJXgpY3gpLbgpKgg4KS44KSr4KSyfFwiLFxuXHRcdGNvbm5lY3RlZDogXCLgpLXgpYngpLLgpYfgpJ8g4KSc4KWB4KWcIOCkl+Ckr+CkvnxcIixcblx0XHRjb25uZWN0aW5nVG86IFwi4KS14KWJ4KSy4KWH4KSfIOCknOClgeClnCDgpLDgpLngpL4g4KS54KWHfFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLgpI/gpJXgpY3gpLjgpJ/gpYfgpILgpLbgpKgg4KS14KS/4KSC4KSh4KWLIOCkruClh+CkgiDgpJXgpKjgpYfgpJXgpY3gpLbgpKgg4KSV4KWAIOCkquClgeCkt+CljeCkn+CkvyDgpJXgpLDgpYfgpIJ8XCIsXG5cdFx0XHRicm93c2VyOiBcIuCksOClgOCkoeCkvuCkr+CksOClh+CkleCljeCknyDgpLngpYvgpKjgpYcg4KSV4KWHIOCkrOCkvuCkpiDgpLXgpYngpLLgpYfgpJ8g4KSu4KWH4KSCIOCkleCkqOClh+CkleCljeCktuCkqCDgpJXgpYAg4KSq4KWB4KS34KWN4KSf4KS/IOCkleCksOClh+CkgnxcIixcblx0XHRcdGhhcmR3YXJlOiBcIuCkleCli+CksuCljeCkoSDgpLXgpYngpLLgpYfgpJ8g4KSV4KWHIOCkuOCkvuCkpSDgpJXgpKjgpYfgpJXgpY3gpLbgpKgg4KSV4KWAIOCkquClgeCkt+CljeCkn+CkvyDgpJXgpLDgpYfgpIJ8XCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIuCksuClh+CknOCksChMZWRnZXIp4KS14KWJ4KSy4KWH4KSfIOCkleCkqOClh+CkleCljeCknyDgpJXgpLDgpYfgpIJ8XCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIuCkuOClgeCkqOCkv+CktuCljeCkmuCkv+CkpCDgpJXgpLDgpYfgpIIg4KSV4KS/IOCkhuCkquCkleCkviDgpLLgpYfgpJzgpLAg4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCksOClguCkqiDgpLjgpYcg4KSc4KWB4KSh4KS84KS+IOCkueClgeCkhiDgpLngpYgg4KSU4KSwIE5FQVIg4KSQ4KSqIOCkhuCkquCkleClhyDgpKHgpL/gpLXgpL7gpIfgpLggKERldmljZSngpKrgpLAg4KSq4KS54KSy4KWHIOCkuOClhyDgpLngpYAg4KSW4KWB4KSy4KS+IOCkueCliHxcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi4KSc4KS+4KSw4KWAIOCksOCkluClh3xcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIuCkueCkvuCksOCljeCkoSDgpKHgpL/gpLjgpY3gpJUoSGFyZCBEaXNrKeCkquCkpShQYXRoKeCkqOCkv+CksOCljeCkp+CkvuCksOCkv+CkpCDgpJXgpLDgpYd8XCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIuCkheCkquCkqOCkviDgpI/gpJrgpKHgpYAg4KSq4KSlIOCkpuCksOCljeCknCDgpJXgpLDgpYfgpIIsIOCkq+Ckv+CksCDgpLjgpJXgpY3gpLDgpL/gpK8g4KSW4KS+4KSk4KWL4KSCIOCkleClhyDgpLLgpL/gpI8g4KS44KWN4KSV4KWI4KSoIOCkleCksOClh+CkgnxcIixcblx0XHRzY2FuOiBcIuCkuOCljeCkleCliOCkqCDgpJXgpLDgpYd8XCIsXG5cdFx0cmV0cnk6IFwi4KSm4KWL4KSs4KS+4KSw4KS+IOCkquCljeCksOCkr+CkvuCkuCDgpJXgpLDgpYd8XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwi4KSy4KWH4KSc4KSwIOCkieCkquCksuCkrOCljeCkpyDgpKjgpLngpYDgpIIg4KS54KWIfFwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIuCksuClh+CknOCksCDgpKHgpL/gpLXgpL7gpIfgpLgg4KSV4KS+IOCkieCkquCkr+Cli+CklyDgpJXgpLDgpKjgpYcg4KSV4KWHIOCksuCkv+CkjyDgpKrgpY3gpLDgpLXgpYfgpLYg4KSo4KS/4KS34KWH4KSnfFwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLgpJbgpL7gpKTgpL4g4KSo4KS54KWA4KSCIOCkruCkv+CksuCkvnxcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi4KSF4KSq4KSo4KWHIOCkluCkvuCkpOClhyDgpJrgpYHgpKjgpYfgpIJ8XCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcIuCkj+CklSDgpJbgpL7gpKTgpL4g4KSV4KSo4KWH4KSV4KWN4KSfIOCkueCliyDgpLDgpLngpL4g4KS54KWIfFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLgpIfgpLgg4KSy4KWH4KSc4KSwIOCkuOClhyDgpJzgpYHgpKHgpLzgpL4g4KSV4KWL4KSIIOCkluCkvuCkpOCkviDgpKjgpLngpYDgpIIg4KSu4KS/4KSy4KS+4KWkIOCkleClg+CkquCkr+CkviDgpI/gpJUg4KSo4KSv4KS+IE5FQVIg4KSW4KS+4KSk4KS+IOCkrOCkqOCkvuCkj+CkgXxcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi4KSF4KSl4KS14KS+IOCkpuClguCkuOCksOClhyDgpLLgpYfgpJzgpLAg4KS14KWJ4KSy4KWH4KSfIOCkuOClhyDgpJXgpKjgpYfgpJXgpY3gpJ8g4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0Y29ubmVjdGluZzogXCLgpJzgpYHgpZwg4KSw4KS54KS+IOCkueClh3xcIixcblx0XHRvZkFjY291bnRzOiBcIuCkluCkvuCkpOCkviDgpIXgpKwg4KSc4KWB4KWc4KS+IOCkqOCkueClgOCkgiDgpLngpYd8XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIuCkluCkvuCkpOCkviDgpIbgpIjgpKHgpYAg4KS44KWN4KS14KSa4KS+4KSy4KS/4KSkIOCksOClguCkqiDgpLjgpYcg4KSW4KWL4KSc4KSo4KWHIOCkruClh+CkgiDgpIXgpLjgpK7gpLDgpY3gpKXgpaQg4KSu4KWI4KSo4KWN4KSv4KWB4KSF4KSyIChNYW51YWxsKSDgpLDgpYLgpKog4KS44KWHIOCkleCli+CktuCkv+CktiDgpJXgpLDgpYfgpIJ8XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIuCkheCkteCksuCli+CkleCkqCDgpIXgpKfgpL/gpJXgpYPgpKQg4KSV4KWAIOCkuOClguCkmuClgCwg4KSo4KWA4KSa4KWHIOCkpuCkv+CkjyDgpJfgpI8g4KSs4KSf4KSoIOCkquCksCDgpJXgpY3gpLLgpL/gpJUg4KSV4KSw4KSV4KWHIOCksuClieCkl+Ckv+CkqCDgpKrgpYLgpLDgpL4g4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0ZmluaXNoOiBcIuCkuOCkruCkvuCkquCljeCkpHxcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIuCkhuCkquCkleCliyDgpIfgpILgpLjgpY3gpJ/gpYngpLIg4KSV4KSw4KSo4KS+IOCkueCli+Ckl+CkvnxcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIuCkh+CkguCkuOCljeCkn+ClieCksiDgpJXgpLDgpKjgpYcg4KSV4KWHIOCkrOCkvuCkpiDgpJzgpL7gpLDgpYAg4KSw4KSW4KWHfFwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIuCkquClgeCkqDog4KSy4KWL4KShIOCkleCksOClh+CkguClpFwiLFxuXHRcdG9wZW46IFwi4KSW4KWL4KSy4KWHfFwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi4KSV4KWN4KSy4KS/4KSq4KSs4KWL4KSw4KWN4KShKENsaXBib2FyZCngpKrgpLAg4KSV4KWJ4KSq4KWAIOCkleCkv+Ckr+CkviDgpJfgpK/gpL58XCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIuCkleCljeCksuCkv+CkquCkrOCli+CksOCljeCkoSDgpKrgpLAg4KSV4KWJ4KSq4KWAIOCkleCksOCkqOCkviDgpLXgpL/gpKvgpLIg4KSw4KS54KS+fFwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLgpIXgpKrgpKjgpYcg4KSr4KWL4KSoIChNb2JpbGUp4KS44KWHIOCkuOCljeCkleCliOCkqCDgpJXgpLDgpYfgpIJ8XCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiDgpJXgpY3gpLLgpL/gpKrgpKzgpYvgpLDgpY3gpKEg4KSq4KSwIOCkleClieCkquClgCDgpJXgpLDgpYfgpIJ8XCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi4KSG4KSn4KS/4KSV4KS+4KSw4KS/4KSVIOCkuOCkguCkteCkvuCkpiDgpJXgpYsg4KSq4KWN4KSw4KS+4KSl4KSu4KS/4KSV4KSk4KS+IOCkpuClh+CkgnxcIixcblx0XHRvcGVuOiBcIuCkluCli+CksuClh3xcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGhpID0ge1xuXHRtb2RhbDogbW9kYWwkNVxufTtcblxudmFyIG1vZGFsJDQgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIti12YQg2YXYrdmB2LjYqtmDXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLZhdinINmH2Yog2KfZhNmF2K3Zgdi42KnYn1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLYqtij2YXZitmGINmI2KXYr9in2LHYqSDYp9mE2YXZhdiq2YTZg9in2Kog2KfZhNix2YLZhdmK2Kkg2KfZhNiu2KfYtdipINio2YNcIixcblx0XHRzYWZlbHlTdG9yZTogXCLZgtmFINio2KrYrtiy2YrZhiDZiCDYp9ix2LPYp9mEINi52YXZhNin2KrZgyDZiCDYo9i12YjZhNmDINin2YTYsdmC2YXZitipINio2KPZhdin2YZcIixcblx0XHRsb2dJblRvQW55OiBcItiz2KzZhCDYp9mE2K/YrtmI2YQg2KXZhNmJINij2Yog2KrYt9io2YrZgiDZitiz2KrYrtiv2YUg2YbZitixXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiLtmE2Kcg2K/Yp9i52Yog2YTYpdmG2LTYp9ihINit2LPYp9ioINis2K/ZitivLiDZgdmC2Lcg2YLZhSDYqNiq2YjYtdmK2YQg2YXYrdmB2LjYqtmDINmI2KfZhti32YTZglwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi2KfYrdi12YQg2LnZhNmJINmF2K3Zgdi42KlcIixcblx0XHR1c2VBV2FsbGV0OiBcItin2LPYqtiu2K/ZhSDZhdit2YHYuNipINmE2KrYo9mF2YrZhiDZiNil2K/Yp9ix2Kkg2KPYtdmI2YQg2YbZitixINin2YTYrtin2LXYqSDYqNmD2Iwg2YjYp9iv2K7ZhCDZhNij2Yog2KrYt9io2YrZgiDZitiz2KrYrtiv2YUg2YbZitixINiv2YjZhiDYp9mE2K3Yp9is2Kkg2KXZhNmJINin2LPZhSDYp9mE2YXYs9iq2K7Yr9mFINmI2YPZhNmF2KnYp9mE2YXYsdmI2LFcIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcItin2KrYtdin2YQg2YHYp9i02YRcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLYp9iq2LXYp9mEINmG2KfYrNitXCIsXG5cdFx0Y29ubmVjdGVkOiBcItmF2KrYtdmEXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItis2KfYsdmKINin2YTYp9iq2LXYp9mEINioXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcItmI2KfZgdmCINi52YTZiSDYp9mE2KfYqti12KfZhCDZgdmKINmG2KfZgdiw2Kkg2KfZhNil2LbYp9mB2KlcIixcblx0XHRcdGJyb3dzZXI6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2KfZhNmF2K3Zgdi42Kkg2KjYudivINil2LnYp9iv2Kkg2KrZiNis2YrZh1wiLFxuXHRcdFx0aGFyZHdhcmU6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2KzZh9in2LIg2YTZitiv2KzYsVwiLFxuXHRcdFx0YnJpZGdlOiBcItmI2KfZgdmCINi52YTZiSDYp9mE2KfYqti12KfZhCDZgdmKINin2YTZhdit2YHYuNipXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcItin2KrYtdmEINmF2Lkg2YTZitiv2KzYsVwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLYqtij2YPYryDYo9mGINmE2YrYr9is2LEg2YXYqti12YQg2KjYo9mF2KfZhiwg2Ygg2KPZhiDYqti32KjZitmCINmG2YrYsSDZhdmB2KrZiNitINmB2Yog2KzZh9in2LLZg1wiLFxuXHRcdFwiY29udGludWVcIjogXCLYqtin2KjYuVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi2K3Yr9ivINmF2LPYp9ixINin2YTYrdiz2KfYqFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLYo9iv2K7ZhCDZhdiz2KfYsSDYp9mE2K3Ys9in2Kgg2KfZhNmF2YHYttmE2Iwg2KvZhSDYp9io2K3YqyDYudmGINmD2YQg2KfZhNit2LPYp9io2KfYqiDYp9mE2YbYtNi32KlcIixcblx0XHRzY2FuOiBcItmF2LPYrVwiLFxuXHRcdHJldHJ5OiBcItij2LnYryDYp9mE2YXYrdin2YjZhNipXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwi2YTZitiv2KzYsSDYutmK2LEg2YXYqtmI2YHYsVwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcItiq2YUg2LHZgdi2INin2YTYp9iq2LXYp9mEINio2YTZitiv2KzYsVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLZhNmFINmK2KrZhSDYp9mE2LnYq9mI2LEg2LnZhNmJINij2Yog2K3Ys9in2KjYp9iqXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItit2K/YryDYrdiz2KfYqNin2KrZg1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLYrNin2LHZiiDYp9mE2KfYqti12KfZhCDYqNit2LPYp9ioINmI2KfYrdivXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcItmE2Kcg2YrZhdmD2YYg2KfZhNi52KvZiNixINi52YTZiSDYo9mKINit2LPYp9ioINmF2LHYqtio2Lcg2KjZh9iw2Kcg2YTZitiv2KzYsSDYp9mE2LHYrNin2KEg2KXZhti02KfYoSDYrdiz2KfYqCDZhtmK2LEg2KzYr9mK2K8g2LnZhNmJXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcItin2Ygg2KfYsdio2Lcg2KzZh9in2LIg2YTZitiv2KzYsSDYotiu2LFcIixcblx0XHRjb25uZWN0aW5nOiBcItis2KfYsdmKINin2YTYp9iq2LXYp9mEXCIsXG5cdFx0b2ZBY2NvdW50czogXCLZhdmGINin2YTYrdiz2KfYqNin2KpcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi2YHYtNmEINmB2Yog2KfZhNin2KrYtdin2YQg2KjYp9mE2K3Ys9in2Kgg2KrZhNmC2KfYptmK2KcuINmK2LHYrNmJINin2YTYp9iq2LXYp9mEINio2KfZhNit2LPYp9ioINmK2K/ZiNmK2KdcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi2YTYp9im2K3YqSDYp9mE2K3Ys9in2KjYp9iqINin2YTZhdi12LHYrSDYqNmH2KcsINij2YPZhdmEINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINio2KfZhNmG2YLYsSDYudmE2Ykg2KfZhNiy2LEg2KPYr9mG2KfZh1wiLFxuXHRcdGZpbmlzaDogXCLYpdmG2YfYp9ihXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLYs9iq2K3Yqtin2Kwg2YTYqtir2KjZitiqXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLZhNmE2KfYs9iq2YPZhdin2YQuINio2LnYryDYp9mE2KrYq9io2YrYqlwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItmC2YUg2KjYqtit2K/ZitirINin2YTYtdmB2K3YqVwiLFxuXHRcdG9wZW46IFwi2KfZgdiq2K1cIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcItiq2YUg2KfZhNmG2LPYrlwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLZgdi02YQg2KfZhNmG2LPYrlwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLYp9mF2LPYrSDYqNis2YfYp9iy2YMg2KfZhNmF2K3ZhdmI2YRcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwi2YbYs9iuXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi2KrZgdi22YQg2KfZhNit2YjYp9ixINin2YTYsdiz2YXZiiDZhFwiLFxuXHRcdG9wZW46IFwi2YHYqtitXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fVxufTtcbnZhciBhciA9IHtcblx0bW9kYWw6IG1vZGFsJDRcbn07XG5cbnZhciBtb2RhbCQzID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCJTcG9qaXRlIGNyeXB0byBub3bEjWFuaWshXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLFoHRvIGplIHRvIGNyeXB0byBub3bEjWFuaWs/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIk9zaWd1cmFqdGUgaSB1cHJhdmxqYWp0ZSBzdm9qb20gZGlnaXRhbG5vbSBpbW92aW5vbS5cIixcblx0XHRzYWZlbHlTdG9yZTogXCJTaWd1cm5vIHBvaHJhbml0ZSBpIHByZWJhY2l0ZSBzdm9qIGNyeXB0byBpIE5GVC1ldmUuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCIgUHJpamF2aXRlIHNlIHUgYmlsbyBrb2p1IE5FQVIgYXBsaWthY2lqdVwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIk5lbWEgcG90cmViZSB6YSBzdHZhcmFuamVtIG5vdmloIG5hbG9nYSBpbGkga29yaXNuacSNa2loIHBvZGF0YWthLiBTcG9qaXRlIHN2b2ogY3J5cHRvIG5vdsSNYW5payBpIHNwcmVtbmkgc3RlIVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiT3R2b3JpdGUgY3J5cHRvIG5vdsSNYW5pa1wiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiS29yaXN0aXRlIGNyeXB0byBub3bEjWFuaWsgZGEgYmlzdGUgb3NpZ3VyYWxpIGkgdXByYXZsamFsaSBzdm9qb20gTkVBUiBpbW92aW5vbSwgdGUgc2UgcHJpamF2aXRlIHUgYmlsbyBrb2p1IE5FQVIgYXBsaWthY2lqdSBiZXoga29yaXNuacSNa29nIGltZW5hIGkgbG96aW5rZS5cIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIk5ldXNwamXFoW5vIHBvdmV6aXZhbmplLlwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIlVzcGplxaFubyBwb3Zleml2YW5qZS5cIixcblx0XHRjb25uZWN0ZWQ6IFwiUG92ZXphbm8uXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIlBvdmV6aXZhbmplIHUgdGlqZWt1XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIlBvdHZyZGl0ZSB2ZXp1IHUgZWtzdGVybm9tIHByb3pvcnVcIixcblx0XHRcdGJyb3dzZXI6IFwiTmFrb24gcmVkaXJla2NpamUsIHBvdHZyZGl0ZSB2ZXp1IHUgbm92xI1hbmlrdVwiLFxuXHRcdFx0aGFyZHdhcmU6IFwiUG90dnJkaXRlIHZlenUgc2Egbm92xI1hbmlrb21cIixcblx0XHRcdGJyaWRnZTogXCJQb3R2cmRpdGUgdmV6dSB1IG5vdsSNYW5pa3VcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiUG92ZcW+aXRlIHNlIGhhcmR2ZXJza2ltIG5vdsSNYW5pa29tXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIk9zaWd1cmFqdGUgc2lndXJudSB2ZXp1IHMgaGFyZHZlcnNraW0gbm92xI1hbmlrb20sIHRlIGRhIGplIE5FQVIgYXBsaWthY2lqYSBvdHZvcmVuYSBuYSB2YcWhZW0gdXJlxJFhanVcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiTmFzdGF2aXRlXCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCJTcGVjaWZpY2lyYWp0ZSBIRCBwdXRhbmp1XCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIlVwacWhaXRlIHByZWZlcmlyYW51IEhEIHB1dGFuanUsIHphdGltIHNrZW5pcmFqdGUgYWt0aXZuZSBuYWxvZ2VcIixcblx0XHRzY2FuOiBcIlNrZW5pcmFqdGVcIixcblx0XHRyZXRyeTogXCJQb2t1xaFhanRlIHBvbm92bm9cIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJIYXJkdmVyc2tpIG5vdsSNYW5payBuaWplIGRvc3R1cGFuLlwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIk9kYmlqZW4gcHJpc3R1cCB6YSBrb3JpxaF0ZW5qZW0gaGFyZHZlcnNrb2cgbm92xI1hbmlrYVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCJOYWxvemkgbmlzdSBwcm9uYcSRZW5pXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIk9kYWJlcml0ZSBzdm9qZSBuYWxvZ2VcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwiUG92ZXppdmFuamUgMSBuYWxvZ2FcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiTmlqZSBtb2d1xIdlIHByb25hxIdpIG5pdGkgamVkYW4gbmFsb2cgcG92ZXphbiBzIG92aW0gaGFyZHZlcnNraW0gbm92xI1hbmlrb20uIE1vbGltbyB2YXMsIGtyZWlyYWp0ZSBub3ZpIE5FQVIgbmFsb2dcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwiSWxpIHBvdmXFvml0ZSBkcnVnaSBoYXJkdmVyc2tpIG5vdsSNYW5pay5cIixcblx0XHRjb25uZWN0aW5nOiBcIlBvdmV6aXZhbmplXCIsXG5cdFx0b2ZBY2NvdW50czogXCJuYWxvZ2FcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwiTmV1c3BqZcWhbm8gYXV0b21hdHNrbyBwcm9uYWxhxb5lbmplIElEIG5hbG9nYS4gVW5lc2l0ZSBydcSNbm86XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIlByZWdsZWRhanRlIHBvcGlzIG9kb2JyZW5paCBuYWxvZ2EsIHphdnLFoWl0ZSBwcmlqYXZ1IHByaXRpc2tvbSBuYSBuacW+ZSBwcmlrYXphbmkgZ3VtYi5cIixcblx0XHRmaW5pc2g6IFwiWmF2csWhaXRlXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCIgUG90cmVibm8gamUgaW5zdGFsaXJhdGkgbW9kYWxcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcInphIG5hc3RhdmFrLiBOYWtvbiBpbnN0YWxhY2lqZVwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIm9zdmplxb5pdGUgc3RyYW5pY3UuXCIsXG5cdFx0b3BlbjogXCJPdHZvcml0ZSBRUiBtb2RhbFwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwiS29waXJhbm8gdSBtZcSRdXNwcmVtbmlrXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIk5ldXBzamXFoW5vIGtvcGlyYW5qZSB1IG1lxJF1c3ByZW1uaWtcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiU2tlbmlyYWp0ZSBzdm9qaW0gbW9iaWxuaW0gdXJlxJFhamVtXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiBLb3BpcmFqdGUgdSBtZcSRdXNwcmVtbmlrXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiT2RhYmVyaXRlIHNsdcW+YmVuaSBkaWphbG9nXCIsXG5cdFx0b3BlbjogXCJPdHZvcml0ZVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCJPZGFiZXJpIFdhbGxldFwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcIlByZW5lc2kgc3ZvamUgbmFsb2dlXCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCJPZGFiZXJpdGUgd2FsbGV0IGtvamkgb2Rnb3ZhcmEgdmHFoWltIHBvdHJlYmFtYSBpIHBvZHLFvmF2YSB2YcWhZSBwb3ZlemFuZSBuYWxvZ2UuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIk9kYWJlcmkgc3ZvamUgbmFsb2dlXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiTmFrb24gxaF0byBvZGx1xI1pdGUga29qaSB3YWxsZXQga29yaXN0aXRlLCBtb8W+ZXRlIG9kYWJyYXRpIGtvamUgcmHEjXVuZSDFvmVsaXRlIHByZWJhY2l0aS5cIixcblx0XHRkaXNjbGFpbWVyOiBcIk5lxIdldGUgbW/Eh2kgcHJlYmFjaXRpIG5hbG9nZSBrb2ppIG5pc3UgbmlrYWRhIGJpbGkga29yacWhdGVuaSBuYSBORUFSLXUuXCIsXG5cdFx0d2FybmluZzogXCJuZSBwb2Ryxb5hdmEgaXp2b3ogbmFsb2dhIHUgb3ZvbSB0cmVudXRrdS4gTW9saW1vIG9kYWJlcml0ZSBkcnVnaSB3YWxsZXQuXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCJPZGFiZXJpIG5hbG9nZSB6YSBwcmlqZW5vc1wiLFxuXHRcdFx0YnV0dG9uOiBcIkdlbmVyaXJhaiBsb3ppbmt1XCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCJNYWtuaSBvZGFiaXIgc2Egc3ZpaFwiLFxuXHRcdFx0c2VsZWN0QWxsOiBcIk9kYWJlcmkgc3ZlXCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCJQcmlqZW5vcyBuaWplIGRvc3R1cGFuXCIsXG5cdFx0XHRlcnJvcjogXCJOYWxvZyBuZSBwb3N0b2ppXCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcIlBvdHJlYm5hIGxlZGdlciBwb2RyxaFrYVwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIk5hbG9nIG5lbWEgc3JlZHN0YXZhXCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcIktvcGlyYWogcHJpdnJlbWVudSBsb3ppbmt1XCIsXG5cdFx0XHRkZXNjOiBcIkJpdCDEh2UgcG90cmVibm8gdW5pamV0aSBvdnUgbG96aW5rdSBuYSBwb8SNZXRrdSBpenZvemEgbmFsb2dhIG5hIGRydWdpIHdhbGxldC5cIixcblx0XHRcdGJ1dHRvbjogXCJOYXN0YXZpXCIsXG5cdFx0XHRsYWJlbDogXCJLbGlrbmkgemEga29waWp1XCIsXG5cdFx0XHRjaGVja0xhYmVsOiBcIktvcGlyYW8gc2FtIGlsaSB6YXBpc2FvIGxvemlua3VcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcIlphdnLFoWkgcHJpamVub3NcIixcblx0XHRcdGRlc2NPbmU6IFwiWW91IHdpbGwgbm93IGJlIHJlZGlyZWN0ZWQgdG8gdGhlIHdhbGxldCB5b3Ugc2VsZWN0ZWQgdG8gY29tcGxldGUgdGhlIHRyYW5zZmVyLlwiLFxuXHRcdFx0ZGVzY1R3bzogXCJLYWRhIGplIHVub3MgcyBvZGFicmFub2cgd2FsbGV0YSB6YXZyxaFlbiwgcHJpdGlzbml0ZSBndW1iIGRhIGJpc3RlIHphdnLFoWlsaSBwcmlqZW5vcy5cIixcblx0XHRcdGJ1dHRvbjogXCJaYXZyxaFpXCJcblx0XHR9XG5cdH1cbn07XG52YXIgaHIgPSB7XG5cdG1vZGFsOiBtb2RhbCQzXG59O1xuXG52YXIgbW9kYWwkMiA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi0J/QvtCy0YDQt9C10YLQtSDQs9C+INCy0LDRiNC40L7RgiDQvdC+0LLRh9Cw0L3QuNC6IVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi0KjRgtC+INC1INC90L7QstGH0LDQvdC40Lo/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcItCX0LDRiNGC0LjRgtC10YLQtSDQs9C4INC4INGD0L/RgNCw0LLRg9Cy0LDRmNGC0LUg0YHQviDQstCw0YjQuNGC0LUg0LTQuNCz0LjRgtCw0LvQvdC4INGB0YDQtdC00YHRgtCy0LAuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi0JHQtdC30LHQtdC00L3QviDRgdC60LvQsNC00LjRgNCw0ZjRgtC1INC4INC40LfQstGA0YjRg9Cy0LDRmNGC0LUg0YLRgNCw0L3RgdCw0LrRhtC40Lgg0YHQviDQstCw0YjQuNGC0LUg0LrRgNC40L/RgtC+INC4IE5GVC5cIixcblx0XHRsb2dJblRvQW55OiBcItCd0LDRmNCw0LLQtdGC0LUg0YHQtSDQvdCwINC60L7RmNCwINCx0LjQu9C+IE5FQVIg0LDQv9C70LjQutCw0YbQuNGY0LBcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCLQndC10LzQsCDQv9C+0YLRgNC10LHQsCDQtNCwINC60YDQtdC40YDQsNGC0LUg0L3QvtCy0Lgg0YHQvNC10YLQutC4INC40LvQuCDQuNC90LPQtdGA0LXQvdGG0LjQuC4g0J/QvtCy0YDQt9C10YLQtSDQs9C+INCy0LDRiNC40L7RgiDQv9Cw0YDQuNGH0L3QuNC6INC4INGB0YLQtSDQv9C+0LTQs9C+0YLQstC10L3QuCFcIixcblx0XHRnZXRBV2FsbGV0OiBcItCd0LDQv9GA0LDQstC10YLQtSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0dXNlQVdhbGxldDogXCLQmtC+0YDQuNGB0YLQtdGC0LUg0L/QsNGA0LjRh9C90LjQuiDQt9CwINC00LAg0LPQuCDQt9Cw0YjRgtC40YLQuNGC0LUg0Lgg0YPQv9GA0LDQstGD0LLQsNGC0LUg0LLQsNGI0LjRgtC1IE5FQVIg0YHRgNC10LTRgdGC0LLQsCDQuCDQtNCwINGB0LUg0L3QsNGY0LDQstC40YLQtSDQvdCwINC60L7RmNCwINCx0LjQu9C+IE5FQVIg0LDQv9C70LjQutCw0YbQuNGY0LAg0LHQtdC3INC/0L7RgtGA0LXQsdCwINC+0LQg0LrQvtGA0LjRgdC90LjRh9C60Lgg0LjQvNC40ZrQsCDQuCDQu9C+0LfQuNC90LrQuC5cIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcItCf0L7QstGA0LfRg9Cy0LDRmtC10YLQviDQvdC1INCx0LXRiNC1INGD0YHQv9C10YjQvdC+LlwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItCj0YHQv9C10YjQvdC+INC/0L7QstGA0LfRg9Cy0LDRmtC1LlwiLFxuXHRcdGNvbm5lY3RlZDogXCLQn9C+0LLRgNC30LDQvdC+LlwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLQn9C+0LLRgNC30YPQstCw0ZrQtSDRgdC+XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcItCf0L7RgtCy0YDQtNC10YLQtSDQs9C+INC/0L7QstGA0LfRg9Cy0LDRmtC10YLQviDQstC+INC10LrRgdGC0LXRgNC90LjQvtGCINC/0YDQvtC30L7RgNC10YZcIixcblx0XHRcdGJyb3dzZXI6IFwi0J/QviDQv9GA0LXRg9GB0LzQtdGA0YPQstCw0ZrQtdGC0L4sINC/0L7RgtCy0YDQtNC10YLQtSDQs9C+INC/0L7QstGA0LfRg9Cy0LDRmtC10YLQviDQvtC0INC90L7QstGH0LDQvdC40L7QutGCXCIsXG5cdFx0XHRoYXJkd2FyZTogXCLQn9C+0YLQstGA0LTQtdGC0LUg0LPQviDQv9C+0LLRgNC30YPQstCw0ZrQtdGC0L4g0YHQviDQu9Cw0LTQtdC9INC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdGJyaWRnZTogXCLQn9C+0YLQstGA0LTQtdGC0LUg0ZjQsCDQstGA0YHQutCw0YLQsCDQstC+INC90L7QstGH0LDQvdC40LrQvtGCXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcItCf0L7QstGA0LfQtdGC0LUg0YHQtSDRgdC+INCb0LXRn9C10YBcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi0J7RgdC40LPRg9GA0LDRmNGC0LUg0YHQtSDQtNC10LrQsCDQstCw0YjQuNC+0YIg0JvQtdGf0LXRgCDQtSDQv9C+0LLRgNC30LDQvSDQsdC10LfQsdC10LTQvdC+LCDQuCDQtNC10LrQsCBORUFSINCw0L/Qu9C40LrQsNGG0LjRmNCw0YLQsCDQtSDQvtGC0LLQvtGA0LXQvdCwINC90LAg0LLQsNGI0LjQvtGCINGD0YDQtdC0XCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItCf0YDQvtC00L7Qu9C20LXRgtC1XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLQndCw0LLQtdC00LXRgtC1INCl0JQg0LvQvtC60LDRhtC40ZjQsFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLQktC90LXRgdC10YLQtSDRmNCwINCy0LDRiNCw0YLQsCDQv9GA0LXRhNC10YDQuNGA0LDQvdCwINCl0JQg0LvQvtC60LDRhtC40ZjQsCwg0LAg0L/QvtGC0L7QsCDRgdC60LXQvdC40YDQsNGY0YLQtSDQtNCwINCz0Lgg0L3QsNGY0LTQtdGC0LUg0LDQutGC0LjQstC90LjRgtC1INGB0LzQtdGC0LrQuC5cIixcblx0XHRzY2FuOiBcItCh0LrQtdC90LjRgNCw0ZjRgtC1XCIsXG5cdFx0cmV0cnk6IFwi0J7QsdC40LTQtdGC0LUg0YHQtSDQv9C+0LLRgtC+0YDQvdC+XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwi0JvQtdGf0LXRgNC+0YIg0L3QtSDQtSDQtNC+0YHRgtCw0L/QtdC9LlwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcItCf0YDQuNGB0YLQsNC/0L7RgiDQt9CwINC60L7RgNC40YHRgtC10ZrQtSDQvdCwINCb0LXRn9C10YAg0YPRgNC10LQg0LUg0L7QtNCx0LjQtdC9XCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcItCd0LXQvNCwINC90LDRmNC00LXQvdC4INGB0LzQtdGC0LrQuFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LHQtdGA0LXRgtC1INCz0Lgg0LLQsNGI0LjRgtC1INGB0LzQtdGC0LrQuFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLQn9C+0LLRgNC30YPQstCw0ZrQtSDQvdCwINC10LTQvdCwINGB0LzQtdGC0LrQsFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLQndC1INGB0LUg0L3QsNGY0LTQtdC90Lgg0YHQvNC10YLQutC4INC/0L7QstGA0LfQsNC90Lgg0YHQviDQvtCy0L7RmCDQm9C10Z/QtdGALiDQktC1INC80L7Qu9C40LzQtSDQutGA0LXQuNGA0LDRmNGC0LUg0L3QvtCy0LAgTkVBUiDRgdC80LXRgtC60LAgXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcItC40LvQuCDQv9C+0LLRgNC30LXRgtC1INC00YDRg9CzINCb0LXRn9C10YAuXCIsXG5cdFx0Y29ubmVjdGluZzogXCLQn9C+0LLRgNC30YPQstCw0ZrQtVwiLFxuXHRcdG9mQWNjb3VudHM6IFwi0L3QsCDRgdC80LXRgtC60LhcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi0J3QtdGD0YHQv9C10YjQvdC+INCw0LLRgtC+0LzQsNGC0YHQutC+INCx0LDRgNCw0ZrQtSDQvdCwINCY0JQg0L3QsCDRgdC80LXRgtC60LDRgtCwLiDQktC90LXRgdC10YLQtSDQs9C+INGA0LDRh9C90L46XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcItCf0YDQtdCz0LvQtdC0INC90LAg0LvQuNGB0YLQsNGC0LAg0L3QsCDQvtCy0LvQsNGB0YLQtdC90Lgg0YHQvNC10YLQutC4LCDQt9Cw0LLRgNGI0LXRgtC1INGB0LUg0L3QsNGY0LDQstCw0YLQsCDRgdC+INC60LvQuNC60L3Rg9Cy0LDRmtC1INC90LAg0LrQvtC/0YfQtdGC0L4g0L/QvtC00L7Qu9GDLlwiLFxuXHRcdGZpbmlzaDogXCLQl9Cw0LLRgNGI0LXRgtC1XCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLQotGA0LXQsdCwINC00LAg0LjQvdGB0YLQsNC70LjRgNCw0YLQtVwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi0LfQsCDQtNCwINC/0YDQvtC00L7Qu9C20LjRgtC1LiDQn9C+INC40L3RgdGC0LDQu9C40YDQsNGa0LXRgtC+XCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi0J7RgdCy0LXQttC10YLQtSDRmNCwINGB0YLRgNCw0L3QsNGC0LAuXCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LXRgtC1XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDQvdC+INC90LAg0LrQu9C40L/QsdC+0YDQtNC+0YJcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi0J3QtdGD0YHQv9C10YjQvdC+INC60L7Qv9C40YDQsNGa0LUg0L3QsCDQutC70LjQv9Cx0L7RgNC0XCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcItCh0LrQtdC90LjRgNCw0ZjRgtC1INGB0L4g0LLQsNGI0LjQvtGCINGC0LXQu9C10YTQvtC90YHQutC4INGD0YDQtdC0XCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcItCa0L7Qv9C40YDQsNGY0YLQtSDQvdCwINC60LvQuNC/0LHQvtGA0LRcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLQn9GA0LXRhNC10YDQuNGA0LDRmNGC0LUg0L7RhNC40YbQuNGY0LDQu9C10L0g0LTQuNCw0LvQvtCzINC90LBcIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L3QsCDQuNC90YLQtdGA0L3QtdGCINC/0YDQtdC70LjRgdGC0YPQstCw0YdcIixcblx0XHRpbmplY3RlZDogXCLQldC60YHRgtC10L3Qt9C40ZjQsCDQt9CwINC90L7QstGH0LDQvdC40LpcIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C10L0g0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwi0JjQvdGB0YLQsNC90YIg0L/QsNGA0LjRh9C90LjQulwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCLQntC00LHQtdGA0LXRgtC1INC/0LDRgNC40YfQvdC40LpcIixcblx0XHR0cmFuc2ZlcllvdXJBY2NvdW50czogXCLQn9GA0LXRhNGA0LvQtdGC0LUg0LPQuCDQstCw0YjQuNGC0LUg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4XCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCLQmNC30LHQtdGA0LXRgtC10L0g0L3QvtCy0YfQsNC90LjQuiDQutC+0Zgg0LPQuCDQt9Cw0LTQvtCy0L7Qu9GD0LLQsCDQstCw0YjQuNGC0LUg0LHQsNGA0LDQvdGa0LAg0Lgg0LPQuCDQv9C+0LTQtNGA0LbRg9Cy0LAg0LLQsNGI0LjRgtC1INC/0L7QstGA0LfQsNC90Lgg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4LlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LHQtdGA0LXRgtC1INCz0Lgg0LLQsNGI0LjRgtC1INC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuFwiLFxuXHRcdGFmdGVyRGVjaWRlOiBcItCe0LTQutCw0LrQviDRnNC1INC40LfQsdC10YDQtdGC0LUg0L3QvtCy0YfQsNC90LjQuiwg0LzQvtC20LXRgtC1INC00LAg0LjQt9Cx0LXRgNC10YLQtSDQutC+0Lgg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4INGB0LDQutCw0YLQtSDQtNCwINCz0Lgg0L/RgNC10YTRgNC70LjRgtC1LlwiLFxuXHRcdGRpc2NsYWltZXI6IFwi0J3QtSDQvNC+0LbQtdGC0LUg0LTQsCDQv9GA0YTRgNC70LDRgtC1INC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuCDQutC+0Lgg0L3QuNC60L7Qs9Cw0Ygg0L3QtSDQsdC40LvQtSDQvdCw0LTQvtC/0L7Qu9C90LDRgtC4INC40LvQuCDQutC+0YDQuNGB0YLQtdC90Lgg0L3QsCBORUFSLlwiLFxuXHRcdHdhcm5pbmc6IFwi0L3QtSDQv9C+0LTQtNGA0LbRg9Cy0LAg0LjQt9Cy0LXQt9GD0LLQsNGa0LUg0L3QsCDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60Lgg0LLQviDQvtCy0L7RmCDQvNC+0LzQtdC90YIuINCS0LUg0LzQvtC70LjQvNC1INC40LfQsdC10YDQtdGC0LUg0LTRgNGD0LMg0L3QvtCy0YfQsNC90LjQui5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwi0KXQsNGA0LTQstC10YDRgdC60Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJvd3NlcjogXCLQndC+0LLRh9Cw0L3QuNC6INC90LAg0LjQvdGC0LXRgNC90LXRgiDQv9GA0LXQu9C40YHRgtGD0LLQsNGHXCIsXG5cdFx0XHRpbmplY3RlZDogXCLQldC60YHRgtC10L3Qt9C40ZjQsCDQt9CwINC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdGJyaWRnZTogXCJCcmlkZ2Ug0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0bW9iaWxlOiBcItCc0L7QsdC40LvQtdC9INC90L7QstGH0LDQvdC40LpcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcItCY0LfQsdC10YDQtdGC0LUg0LPQuCDQutC+0YDQuNGB0L3QuNGH0LrQuNGC0LUg0YHQvNC10YLQutC4INC30LAg0LTQsCDQs9C4INC/0YDQtdGE0YDQu9C40YLQtS5cIixcblx0XHRcdGJ1dHRvbjogXCLQlNC+0LHQuNGY0YLQtSDQu9C+0LfQuNC90LrQsFwiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwi0J7RgtGB0LXQu9C10LrRgtC40YDQsNGY0YLQtSDRgdC1XCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwi0JjQt9Cx0LXRgNC10YLQtSDRgdC1XCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCLQotGA0LDQvdGB0YTQtdGA0L7RgiDQtSDQvdC10LTQvtGB0YLQsNC/0LXQvVwiLFxuXHRcdFx0ZXJyb3I6IFwi0JrQvtGA0LjRgdC90LjRh9C60LDRgtCwINGB0LzQtdGC0LrQsCDQvdC1INC/0L7RgdGC0L7QuFwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCLQn9C+0YLRgNC10LHQvdCwINC1INC/0L7QtNC00YDRiNC60LAg0L7QtCDQm9C10Z/QtdGAXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwi0KHQvNC10YLQutCw0YLQsCDQvdC1INC1INGE0LjQvdCw0L3RgdC40YDQsNC90LBcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwi0JrQvtC/0LjRgNCw0ZjRgtC1INGY0LAg0L/RgNC40LLRgNC10LzQtdC90LDRgtCwINC70L7Qt9C40L3QutCwXCIsXG5cdFx0XHRkZXNjOiBcItCM0LUg0YLRgNC10LHQsCDQtNCwINGY0LAg0LLQvdC10YHQtdGC0LUg0L7QstCw0LAg0LvQvtC30LjQvdC60LAg0LrQvtCz0LAg0ZzQtSDQt9Cw0L/QvtGH0L3QtdGC0LUg0LTQsCDQs9C4INC40LfQstC10LfRg9Cy0LDRgtC1INCy0LDRiNC40YLQtSDRgdC80LXRgtC60Lgg0L3QsCDQtNGA0YPQsyDQvdC+0LLRh9Cw0L3QuNC6LlwiLFxuXHRcdFx0YnV0dG9uOiBcItCf0YDQvtC00L7Qu9C20LXRgtC1XCIsXG5cdFx0XHRsYWJlbDogXCLQmtC70LjQutC90LXRgtC1INC30LAg0LTQsCDQutC+0L/QuNGA0LDRgtC1XCIsXG5cdFx0XHRjaGVja0xhYmVsOiBcItCI0LAg0LrQvtC/0LjRgNCw0LIg0LjQu9C4INC30LDQv9C40YjQsNCyINC70L7Qt9C40L3QutCw0YLQsFwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwi0JfQsNCy0YDRiNC10YLQtSDQs9C+INC/0YDQtdC90L7RgdC+0YJcIixcblx0XHRcdGRlc2NPbmU6IFwi0KHQtdCz0LAg0ZzQtSDQsdC40LTQtdGC0LUg0L/RgNC10L3QsNGB0L7Rh9C10L3QuCDQvdCwINC40LfQsdGA0LDQvdC40L7RgiDQvdC+0LLRh9Cw0L3QuNC6INC30LAg0LfQsNCy0YDRiNGD0LLQsNGa0LUg0L3QsCDQv9GA0LXQvdC+0YHQvtGCLlwiLFxuXHRcdFx0ZGVzY1R3bzogXCLQntGC0LrQsNC60L4g0ZzQtSDQt9Cw0LLRgNGI0Lgg0YPQstC+0LfQvtGCINC+0LQg0LjQt9Cx0YDQsNC90LjQvtGCINC90L7QstGH0LDQvdC40LosINC/0YDQuNGC0LjRgdC90LXRgtC1INCz0L4g0LrQvtC/0YfQtdGC0L4g0LfQsCDQtNCwINCz0L4g0LfQsNCy0YDRiNC40YLQtSDQv9GA0LXQvdC+0YHQvtGCLlwiLFxuXHRcdFx0YnV0dG9uOiBcItCX0LDQstGA0YjQtdGC0LVcIlxuXHRcdH1cblx0fVxufTtcbnZhciBtayA9IHtcblx0bW9kYWw6IG1vZGFsJDJcbn07XG5cbnZhciBtb2RhbCQxID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCJQb3Zlxb5pdGUgc3Zvam8gZGVuYXJuaWNvIVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwiS2FqIGplIGRlbmFybmljYT9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwiWmF2YXJ1anRlIGluIHVwcmF2bGphanRlIHN2b2phIGRpZ2l0YWxuYSBzcmVkc3R2YS5cIixcblx0XHRzYWZlbHlTdG9yZTogXCJWYXJubyBzaHJhbmp1anRlIGluIHByZW5hxaFhanRlIHN2b2plIGtyaXB0b3ZhbHV0ZSBpbiBORlRqZS5cIixcblx0XHRsb2dJblRvQW55OiBcIlByaWphdml0ZSBzZSB2IGthdGVybyBrb2xpIGFwbGlrYWNpam8gbmEgTkVBUlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIk5pIHZhbSB0cmViYSB1c3R2YXJqYXRpIG5vdmloIHJhxI11bm92LiBQb3Zlxb5pdGUgc3Zvam8gZGVuYXJuaWNvIGluIHphxI1uaXRlIVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiVXN0dmFyaXRlIGRlbmFybmljb1wiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiVXBvcmFiaXRlIGRlbmFybmljbywgZGEgYmkgemF2YXJvdmFsaSBpbiB1cHJhdmxqYWxpIHMgc3ZvamEgTkVBUiBkaWdpdGFsbmEgc3JlZHN0dmEsIGluIHNlIHByaWphdml0ZSB2IGthdGVybyBrb2xpIGFwbGlrYWNpam8gZWtvc2lzdGVtYSBORUFSXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCJQb3ZlemF2YSBuaSBiaWxhIHVzcGXFoW5hLlwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIlBvdmV6YXZhIGplIGJpbGEgdXNwZcWhbmEuXCIsXG5cdFx0Y29ubmVjdGVkOiBcIlZhxaFhIGRlbmFybmljYSBqZSBwb3ZlemFuYS5cIixcblx0XHRjb25uZWN0aW5nVG86IFwiUG92ZXpvdmFuamUgelwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCJQb3RyZGl0ZSBwb3ZlemF2byB2IG9rbnUgcmF6xaFpcml0dmVcIixcblx0XHRcdGJyb3dzZXI6IFwiUG8gcHJldXNtZXJpdHZpIHBvdHJkaXRlIHBvdmV6YXZvIHYgZGVuYXJuaWNpXCIsXG5cdFx0XHRoYXJkd2FyZTogXCJQb3RyZGl0ZSBwb3ZlemF2byBzIGhsYWRubyBkZW5hcm5pY29cIixcblx0XHRcdGJyaWRnZTogXCJQb3RyZGl0ZSBwb3ZlemF2byB2IGRlbmFybmljaVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJQb3Zlxb5pdGUgc2UgeiBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwiUHJlcHJpxI1hanRlIHNlLCBkYSBqZSB2YcWhIExlZGdlciB2YXJubyBwb3ZlemFuIGluIGRhIGplIGFwbGlrYWNpamEgTkVBUiBvZHBydGEgdiB2YcWhaSBuYXByYXZpXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIk5hZGFsanVqXCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCJEb2xvxI1pdGUgSEQgcG90XCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIlZuZXNpdGUgxb5lbGVubyBIRCBwb3QsIG5hdG8gcG9pxaHEjWl0ZSB2c2UgYWt0aXZuZSByYcSNdW5lLlwiLFxuXHRcdHNjYW46IFwiU2tlbmlyYWp0ZVwiLFxuXHRcdHJldHJ5OiBcIlBvc2t1c2l0ZSB6bm92YVwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciBuaSBuYSB2b2xqb1wiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIkRvc3RvcCB6YSB1cG9yYWJvIG5hcHJhdmUgTGVkZ2VyIHphdnJuamVuXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5pIG5hamRlbmloIHJhxI11bm92XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIkl6YmVyaXRlIFZhxaFpIHJhxI11bmlcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwiUG92ZXpvdmFuamUgZW5lZ2EgcmHEjXVuYVwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJOaSBtb2dvxI1lIG5hanRpIG5vYmVuZWdhIHJhxI11bmEsIHBvdmV6YW5lZ2EgcyB0ZW0gTGVkZ2VyamVtLiBVc3R2YXJpdGUgbm92IE5FQVIgcmHEjXVuIFwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJhbGkgcG92ZcW+aXRlIGRydWcgTGVkZ2VyLi5cIixcblx0XHRjb25uZWN0aW5nOiBcIlBvdmV6b3ZhbmplXCIsXG5cdFx0b2ZBY2NvdW50czogXCJyYcSNdW5vdlwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJJRC1qYSByYcSNdW5hIG5pIGJpbG8gbW9nb8SNZSBzYW1vZGVqbm8gbmFqdGkuIFphZ290b3ZpdGUgZ2Egcm/EjW5vOlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCJPZ2xlanRlIHNpIHNlem5hbSBwb29ibGHFocSNZW5paCByYcSNdW5vdiwgZG9rb27EjWFqdGUgcHJpamF2byBzIGtsaWtvbSBuYSBzcG9kbmppIGd1bWIuXCIsXG5cdFx0ZmluaXNoOiBcIktvbsSNYWp0ZVwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwiTW9yYWxpIGdhIGJvc3RlIG5hbWVzdGl0aVwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwibmFkYWxqZXZhdGkuIFBvIG5hbWVzdGl0dmlcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCJPc3Zlxb5pdGUgc3RyYW4uXCIsXG5cdFx0b3BlbjogXCJPZHByaXRlXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJLb3BpcmFubyB2IHBvZGxvxb5uaSBtYXBpXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIktvcGlyYW5qZSB2IHBvZGxvxb5uaSBtYXBpIG5pIHVzcGVsb1wiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCJTa2VuaXJhanRlIHMgc3Zvam8gbW9iaWxubyBuYXByYXZvXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiBLb3BpcmFqdGUgdiBwb2Rsb8W+bmkgbWFwaVwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIlByZWZlcmlyYWp0ZSB1cmFkbm8gcG9nb3Zvcm5vIG9rbm9cIixcblx0XHRvcGVuOiBcIk9kcHJpdGVcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhsYWRuYSBkZW5hcm5pY2FcIixcblx0XHRicm93c2VyOiBcIkRlbmFybmljYSBicnNrYWxuaWthXCIsXG5cdFx0aW5qZWN0ZWQ6IFwiUmF6xaFpcml0ZXYgemEgZGVuYXJuaWNvXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBkZW5hcm5pY2FcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxuYSBkZW5hcm5pY2FcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIlRha29qxaFuamEgZGVuYXJuaWNhXCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIkl6YmVyaXRlIGRlbmFybmljb1wiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcIlByZW5lc2l0ZSBzdm9qZSByYcSNdW5lXCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCJJemJlcml0ZSBkZW5hcm5pY28sIGtpIHVzdHJlemEgdmHFoWltIHBvdHJlYmFtIGluIHBvZHBpcmEgdmHFoWUgcG92ZXphbmUgcmHEjXVuZS5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiSXpiZXJpdGUgdmHFoWkgcmHEjXVuaVwiLFxuXHRcdGFmdGVyRGVjaWRlOiBcIktvIHNlIG9kbG/EjWl0ZSB6YSBkZW5hcm5pY28sIGxhaGtvIGl6YmVyZXRlLCBrYXRlcmUgcmHEjXVuZSDFvmVsaXRlIHByZW5lc3RpLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiTmUgYm9zdGUgbW9nbGkgcHJlbmVzdGkgUmHEjXVub3YsIGtpIG5pa29saSBuaXNvIGJpbGkgZmluYW5jaXJhbmkgYWxpIHVwb3JhYmxqZW5pIG5hIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCJ0cmVudXRubyBuZSBwb2RwaXJhIGl6dm96YSByYcSNdW5hLiBJemJlcml0ZSBkcnVnbyBkZW5hcm5pY29cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiSGxhZG5hIGRlbmFybmljYVwiLFxuXHRcdFx0YnJvd3NlcjogXCJEZW5hcm5pY2EgYnJza2FsbmlrYVwiLFxuXHRcdFx0aW5qZWN0ZWQ6IFwiUmF6xaFpcml0ZXYgemEgZGVuYXJuaWNvXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlIGRlbmFybmljYVwiLFxuXHRcdFx0bW9iaWxlOiBcIk1vYmlsbmEgZGVuYXJuaWNhXCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCJJemJlcml0ZSByYcSNdW5pIHphIHByZW5vcy5cIixcblx0XHRcdGJ1dHRvbjogXCJQcmlkb2JpdGUgZ2VzbG9cIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIlByZWtsacSNaSBpemJpcm8gdnNlaFwiLFxuXHRcdFx0c2VsZWN0QWxsOiBcIkl6YmVyaSB2c2VcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcIlByZW5vcyBuaSBuYSB2b2xqb1wiLFxuXHRcdFx0ZXJyb3I6IFwiUmHEjXVuIG5lIG9ic3RhamFcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwiUG90cmVibmEgamUgcG9kcG9yYSB6YSBMZWRnZXJcIixcblx0XHRcdG5vQmFsYW5jZTogXCJSYcSNdW4gbmkgZmluYW5jaXJhblwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCJLb3BpcmFqIHphxI1hc25vIGdlc2xvXCIsXG5cdFx0XHRkZXNjOiBcIlRvIGdlc2xvIGJvc3RlIG1vcmFsaSB2bmVzdGksIGtvIGJvc3RlIHphxI1lbGkgaXp2YcW+YXRpIHN2b2plIHJhxI11bmUgdiBkcnVnbyBkZW5hcm5pY28uXCIsXG5cdFx0XHRidXR0b246IFwiTmFkYWxqdWp0ZVwiLFxuXHRcdFx0bGFiZWw6IFwiS2xpa25pdGUgemEga29waXJhbmplXCIsXG5cdFx0XHRjaGVja0xhYmVsOiBcIkdlc2xvIHNlbSBrb3BpcmFsIGFsaSB6YXBpc2FsXCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCJEb2tvbsSNYWp0ZSBwcmVub3NcIixcblx0XHRcdGRlc2NPbmU6IFwiWmRhaiBib3N0ZSBwcmV1c21lcmplbmkgdiBkZW5hcm5pY28sIGtpIHN0ZSBqbyBpemJyYWxpIHphIGRva29uxI1hbmplIHByZW5vc2EuXCIsXG5cdFx0XHRkZXNjVHdvOiBcIktvIGplIHV2b3puaSBkZWwgcG9zdG9wa2Ega29uxI1hbiBpeiBpemJyYW5lIGRlbmFybmljZSwgcHJpdGlzbml0ZSBndW1iIHphIGRva29uxI1hbmplIHBvc3RvcGthIHByZW5vc2EuXCIsXG5cdFx0XHRidXR0b246IFwiS29uxI1hanRlXCJcblx0XHR9XG5cdH1cbn07XG52YXIgc2wgPSB7XG5cdG1vZGFsOiBtb2RhbCQxXG59O1xuXG52YXIgbW9kYWwgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcItCf0L7QstC10LbQuNGC0LUg0YHQstC+0Zgg0L3QvtCy0YfQsNC90LjQuiFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcItCo0YLQsCDRmNC1INC90L7QstGH0LDQvdC40Lo/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcItCe0LHQtdC30LHQtdC00LjRgtC1INC4INGD0L/RgNCw0LLRmdCw0ZjRgtC1INGB0LLQvtGY0L7QvCDQtNC40LPQuNGC0LDQu9C90L7QvCDQuNC80L7QstC40L3QvtC8LlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcItCR0LXQt9Cx0LXQtNC90L4g0YfRg9Cy0LDRmNGC0LUg0Lgg0L/RgNC10L3QvtGB0LjRgtC1INGB0LLQvtGY0LUg0LrRgNC40L/RgtC+0LLQsNC70YPRgtC1INC4IE5GVC5cIixcblx0XHRsb2dJblRvQW55OiBcItCf0YDQuNGY0LDQstC40YLQtSDRgdC1INC90LAg0LHQuNC70L4g0LrQvtGY0YMg0LDQv9C70LjQutCw0YbQuNGY0YMgTkVBUlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcItCd0LXQvNCwINC/0L7RgtGA0LXQsdC1INC00LAg0LrRgNC10LjRgNCw0YLQtSDQvdC+0LLQtSDQvdCw0LvQvtCz0LUg0LjQu9C4INCw0LrRgNC10LTQuNGC0LjQstC1LiDQn9C+0LLQtdC20LjRgtC1INC90L7QstGH0LDQvdC40Log0Lgg0YHQv9GA0LXQvNC90Lgg0YHRgmUhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLQndCw0LHQsNCy0LjRgtC1INC90L7QstGH0LDQvdC40LpcIixcblx0XHR1c2VBV2FsbGV0OiBcItCa0L7RgNC40YHRgtC40YLQtSDQvdC+0LLRh9Cw0L3QuNC6INC00LAg0L7QsdC10LfQsdC10LTQuNGC0LUg0Lgg0YPQv9GA0LDQstGZ0LDRgtC1INGB0LLQvtGY0LjQvCBORUFSINGB0YDQtdC00YHRgtCy0LjQvNCwINC4INC00LAg0YHQtSDQv9GA0LjRmNCw0LLQuNGC0LUg0YMg0LHQuNC70L4g0LrQvtGY0YMg0LDQv9C70LjQutCw0YbQuNGY0YMgTkVBUiDQsdC10Lcg0L/QvtGC0YDQtdCx0LUg0LfQsCDQutC+0YDQuNGB0L3QuNGH0LrQuNC8INC40LzQtdC90LjQvNCwINC4INC70L7Qt9C40L3QutCw0LzQsC5cIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcItCS0LXQt9CwINC90LjRmNC1INGD0YHQv9C+0YHRgtCw0LLRmdC10L3QsC5cIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLQktC10LfQsCDRmNC1INGD0YHQv9C10LvQsC5cIixcblx0XHRjb25uZWN0ZWQ6IFwi0J/QvtCy0LXQt9Cw0L0uXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItCf0L7QstC10LfQuNCy0LDRmtC1INC90LBcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi0J/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGDINGB0L/QvtGZ0L3QvtC8INC/0YDQvtC30L7RgNGDXCIsXG5cdFx0XHRicm93c2VyOiBcItCd0LDQutC+0L0g0L/RgNC10YPRgdC80LXRgNCw0LLQsNGa0LAsINC/0L7RgtCy0YDQtNC40YLQtSDQstC10LfRgyDRgyDQvdC+0LLRh9Cw0L3QuNC60YNcIixcblx0XHRcdGhhcmR3YXJlOiBcItCf0L7RgtCy0YDQtNC40YLQtSDQstC10LfRgyDRgdCwINGF0LvQsNC00L3QuNC8INC90L7QstGH0LDQvdC40LrQvtC8XCIsXG5cdFx0XHRicmlkZ2U6IFwi0J/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGB0LAg0L3QvtCy0YfQsNC90LjQutC+0LxcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi0J/QvtCy0LXQttC40YLQtSDRgdC1INGB0LAgTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcItCj0LLQtdGA0LjRgtC1INGB0LUg0LTQsCDRmNC1INCy0LDRiCBMZWRnZXIg0LHQtdC30LHQtdC00L3QviDQv9C+0LLQtdC30LDQvSDQuCDQtNCwINGY0LUg0LDQv9C70LjQutCw0YbQuNGY0LAgTkVBUiDQvtGC0LLQvtGA0LXQvdCwINC90LAg0LLQsNGI0LXQvCDRg9GA0LXRktCw0ZjRg1wiLFxuXHRcdFwiY29udGludWVcIjogXCLQndCw0YHRgtCw0LLQuFwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi0J3QsNCy0LXQtNC40YLQtSDQpdCUINC/0YPRgtCw0ZrRg1wiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLQo9C90LXRgdC40YLQtSDQttC10ZnQtdC90YMg0LbQtdGZ0LXQvdGDINCl0JQg0L/Rg9GC0LDRmtGDLCDQsCDQt9Cw0YLQuNC8INGB0LrQtdC90LjRgNCw0ZjRgtC1INGB0LLQtSDQsNC60YLQuNCy0L3QtSDQvdCw0LvQvtCz0LUuXCIsXG5cdFx0c2NhbjogXCLQodC60LXQvdC40YDQsNGY0YLQtVwiLFxuXHRcdHJldHJ5OiBcItCf0L7QutGD0YjQsNGYINC/0L7QvdC+0LLQvlwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciDQvdC40ZjQtSDQtNC+0YHRgtGD0L/QsNC9LlwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcItCf0YDQuNGB0YLRg9C/INGY0LUg0L7QtNCx0LjRmNC10L0g0LfQsCDQutC+0YDQuNGI0ZvQtdGa0LUgTGVkZ2VyINGD0YDQtdGS0LDRmNCwXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcItCd0LBs0L7Qt9C4INC90LjRgdGDINC/0YDQvtC90LDRktC10L3QuFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LDQsdC10YDQuNGC0LUg0JLQsNGIINC90LBs0L7Qs1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLQn9C+0LLQtdC30LDRgtC4IDEg0L3QsGzQvtCzXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcItCd0LjRmNC1INC80L7Qs9GD0ZvQtSDQv9GA0L7QvdCw0ZvQuCDQvdC40ZjQtdC00LDQvSDQvdCwbNC+0LMg0L/QvtCy0LXQt9Cw0L0g0YHQsCDQvtCy0LjQvCBMZWRnZXIt0L7QvC4g0J3QsNC/0YDQsNCy0LjRgtC1INC90L7QstC4IE5FQVIg0L3QsGzQvtCzXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcItC40LvQuCDQv9C+0LLQtdC20LjRgtC1INC00YDRg9Cz0LggTGVkZ2VyLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi0J/QvtCy0LXQt9C40LLQsNGa0LVcIixcblx0XHRvZkFjY291bnRzOiBcItC90LBs0L7Qs9CwXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcItCQ0YPRgtC+0LzQsNGC0YHQutC+INC/0YDQvtC90LDQu9Cw0LbQtdGa0LUgSUQtYSDQvdCwbNC+0LPQsCDQvdC40ZjQtSDRg9GB0L/QtdC70L4uINCd0LDQstC10LTQuNGC0LUg0LPQsCDRgNGD0YfQvdC+OlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLQn9GA0LXQs9C70LXQtNCw0ZjRgtC1INC70LjRgdGC0YMg0L7QstC70LDRiNGb0LXQvdC40YUg0YDQsNGH0YPQvdCwLCDQt9Cw0LLRgNGI0LjRgtC1INC/0YDQuNGY0LDQstGDINC60LvQuNC60L7QvCDQvdCwINC00YPQs9C80LUg0LjRgdC/0L7QtC5cIixcblx0XHRmaW5pc2g6IFwi0JfQsNCy0YDRiNC4XCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLQnNC+0YDQsNGb0LXRgtC1INC00LAg0LjQvdGB0YLQsNC70LjRgNCw0YLQtVwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi0LfQsCDQvdCw0YHRgtCw0LLQsNC6LiDQndCw0LrQvtC9INC40L3RgdGC0LDQu9C40YDQsNGa0LBcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLQv9C+0L3QvtCy0L4g0YPRh9C40YLQsNGC0Lgg0YHRgtGA0LDQvdC40YbRgy5cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQuFwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi0JrQvtC/0LjRgNCw0L3QviDRgyDQvNC10ZLRg9GB0L/RgNC10LzQvdC40LpcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi0JrQvtC/0LjRgNCw0ZrQtSDRgyDQvNC10ZLRg9GB0L/RgNC10LzQvdC40Log0L3QuNGY0LUg0YPRgdC/0LXQu9C+XCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcItCh0LrQtdC90LjRgNCw0ZjRgtC1INC/0L7QvNC+0ZvRgyDQvNC+0LHQuNC70L3QvtCzINGD0YDQtdGS0LDRmNCwXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiDQmtC+0L/QuNGA0LDRmCDRgyDQvNC10ZLRg9GB0L/RgNC10LzQvdC40LpcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLQn9GA0LXRhNC10YDQuNGA0LDRgtC1INC30LLQsNC90LjRh9C90Lgg0LTQuNGY0LDQu9C+0LMg0L7QtFwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC4XCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCLQpdCw0YDQtNCy0LXRgNGB0LrQuCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0YnJvd3NlcjogXCLQndC+0LLRh9Cw0L3QuNC6INC/0YDQtdGC0YDQsNC20LjQstCw0YfQsCxcIixcblx0XHRpbmplY3RlZDogXCLQlNC+0LTQsNGC0LDQuiDQt9CwINC90L7QstGH0LDQvdC40LosXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0bW9iaWxlOiBcItCc0L7QsdC40LvQvdC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcItCY0L3RgdGC0LDQvdGCINC90L7QstGH0LDQvdC40LpcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INC90L7QstGH0LDQvdC40LpcIixcblx0XHR0cmFuc2ZlcllvdXJBY2NvdW50czogXCLQn9GA0LXQvdC10YHQuNGC0LUg0YHQstC+0ZjQtSDQvdCw0LvQvtCz0LVcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcItCY0LfQsNCx0LXRgNC40YLQtSDQvdC+0LLRh9Cw0L3QuNC6INC60L7RmNC4INC+0LTQs9C+0LLQsNGA0LAg0LLQsNGI0LjQvCDQv9C+0YLRgNC10LHQsNC80LAg0Lgg0LrQvtGY0Lgg0L/QvtC00YDQttCw0LLQsCDQstCw0YjQtSDQv9C+0LLQtdC30LDQvdC1INC90LDQu9C+0LPQtS5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INCy0LDRiNC1INC90LDQu9C+0LPQtVwiLFxuXHRcdGFmdGVyRGVjaWRlOiBcItCd0LDQutC+0L0g0YjRgtC+INGB0LUg0L7QtNC70YPRh9C40YLQtSDQt9CwINC90L7QstGH0LDQvdC40LosINC80L7QttC10YLQtSDQuNC30LDQsdGA0LDRgtC4INC60L7RmNC1INC90LDQu9C+0LPQtSDQttC10LvQuNGC0LUg0LTQsCDQv9GA0LXQvdC10YHQtdGC0LUuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCLQndC10ZvQtdGC0LUg0LzQvtGb0Lgg0LTQsCDQv9GA0LXQvdC10YHQtdGC0LUg0L3QsNC70L7Qs9C1INC60L7RmNC4INC90LjQutCw0LTQsCDQvdC40YHRgyDQsdC40LvQuCDRhNC40L3QsNC90YHQuNGA0LDQvdC4INC40LvQuCDQutC+0YDQuNGI0ZvQtdC90Lgg0L3QsCAgTkVBUi5cIixcblx0XHR3YXJuaW5nOiBcItGC0YDQtdC90YPRgtC90L4g0L3QtSDQv9C+0LTRgNC20LDQstCwINC40LfQstC+0Lcg0L3QsNC70L7Qs9CwLiDQmNC30LDQsdC10YDQuNGC0LUg0LTRgNGD0LPQuCDQvdC+0LLRh9Cw0L3QuNC6LlwiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCLQpdCw0YDQtNCy0LXRgNGB0LrQuCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L/RgNC10YLRgNCw0LbQuNCy0LDRh9CwLFwiLFxuXHRcdFx0aW5qZWN0ZWQ6IFwi0JTQvtC00LDRgtCw0Log0LfQsCDQvdC+0LLRh9Cw0L3QuNC6LFwiLFxuXHRcdFx0YnJpZGdlOiBcIkJyaWRnZSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C90Lgg0L3QvtCy0YfQsNC90LjQulwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INC90LDQu9C+0LPQtSDQt9CwINC/0YDQtdC90L7RgS5cIixcblx0XHRcdGJ1dHRvbjogXCLQlNC+0LHQuNGY0YLQtSDQv9GA0LjRgdGC0YPQv9C90YMg0YTRgNCw0LfRg1wiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwi0J/QvtC90LjRiNGC0LjRgtC1INC40LfQsdC+0YBcIixcblx0XHRcdHNlbGVjdEFsbDogXCLQmNC30LDQsdC10YDQuNGC0LUg0YHQstC1XCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCLQotGA0LDQvdGB0YTQtdGAINC90LjRmNC1INC00L7RgdGC0YPQv9Cw0L1cIixcblx0XHRcdGVycm9yOiBcItCd0LDQu9C+0LMg0L3QtSDQv9C+0YHRgtC+0ZjQuFwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCLQn9C+0YLRgNC10LHQvdCwINC/0L7QtNGA0YjQutCwINC30LAgTGVkZ2VyXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwi0J3QsNC70L7QsyDQvdC40ZjQtSDRhNC40L3QsNC90YHQuNGA0LDQvVwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCLQmtC+0L/QuNGA0LDRmCDQv9GA0LjQstGA0LXQvNC10L3RgyDQu9C+0LfQuNC90LrRg1wiLFxuXHRcdFx0ZGVzYzogXCLQnNC+0YDQsNGb0LXRgtC1INC00LAg0YPQvdC10YHQtdGC0LUg0L7QstGDINC70L7Qt9C40L3QutGDINC60LDQtNCwINC/0L7Rh9C90LXRgtC1INC00LAg0LjQt9Cy0L7Qt9C40YLQtSDRgdCy0L7RmNC1INC90LDQu9C+0LPQtSDRgyDQtNGA0YPQs9C4INC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0XHRidXR0b246IFwi0J3QsNGB0YLQsNCy0LjRgtC1XCIsXG5cdFx0XHRsYWJlbDogXCLQmtC70LjQutC90LjRgtC1INC00LAg0LHQuNGB0YLQtSDQutC+0L/QuNGA0LDQu9C4XCIsXG5cdFx0XHRjaGVja0xhYmVsOiBcItCa0L7Qv9C40YDQsNC+INGB0LDQvCDQuNC70Lgg0LfQsNC/0LjRgdCw0L4g0LvQvtC30LjQvdC60YNcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcItCU0L7QstGA0YjQuNGC0LUg0YLRgNCw0L3RgdGE0LXRgFwiLFxuXHRcdFx0ZGVzY09uZTogXCLQodCw0LTQsCDRm9C10YLQtSDQsdC40YLQuCDQv9GA0LXRg9GB0LzQtdGA0LXQvdC4INC90LAg0L3QvtCy0YfQsNC90LjQuiDQutC+0ZjQuCDRgdGC0LUg0LjQt9Cw0LHRgNCw0LvQuCDQtNCwINC30LDQstGA0YjQuNGC0LUg0YLRgNCw0L3RgdGE0LXRgC5cIixcblx0XHRcdGRlc2NUd286IFwi0JrQsNC00LAg0YHQtSDQtNC10L4g0L/RgNC+0YbQtdGB0LAg0YPQstC+0LfQsCDQt9Cw0LLRgNGI0Lgg0LjQtyDQuNC30LDQsdGA0LDQvdC+0LMg0L3QvtCy0YfQsNC90LjQutCwLCDQv9GA0LjRgtC40YHQvdC40YLQtSDQtNGD0LPQvNC1INC00LAg0LfQsNCy0YDRiNC40YLQtSDQv9GA0L7RhtC10YEg0L/RgNC10L3QvtGB0LAuXCIsXG5cdFx0XHRidXR0b246IFwi0JfQsNCy0YDRiNC40YLQtVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIHNyID0ge1xuXHRtb2RhbDogbW9kYWxcbn07XG5cbmNvbnN0IGdldExhbmd1YWdlID0gbGFuZ3VhZ2VDb2RlID0+IHtcbiAgc3dpdGNoIChsYW5ndWFnZUNvZGUpIHtcbiAgICBjYXNlIFwiZW5cIjpcbiAgICAgIHJldHVybiBlbjtcbiAgICBjYXNlIFwiZXNcIjpcbiAgICAgIHJldHVybiBlcztcbiAgICBjYXNlIFwiemhcIjpcbiAgICAgIHJldHVybiB6aDtcbiAgICBjYXNlIFwiYmdcIjpcbiAgICAgIHJldHVybiBiZztcbiAgICBjYXNlIFwia29cIjpcbiAgICAgIHJldHVybiBrbztcbiAgICBjYXNlIFwidmlcIjpcbiAgICAgIHJldHVybiB2aTtcbiAgICBjYXNlIFwiaGlcIjpcbiAgICAgIHJldHVybiBoaTtcbiAgICBjYXNlIFwiYXJcIjpcbiAgICAgIHJldHVybiBhcjtcbiAgICBjYXNlIFwiaHJcIjpcbiAgICAgIHJldHVybiBocjtcbiAgICBjYXNlIFwibWtcIjpcbiAgICAgIHJldHVybiBtaztcbiAgICBjYXNlIFwic2xcIjpcbiAgICAgIHJldHVybiBzbDtcbiAgICBjYXNlIFwic3JcIjpcbiAgICAgIHJldHVybiBzcjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGVuO1xuICB9XG59O1xubGV0IGNob3Nlbkxhbmc7XG5jb25zdCBhbGxvd09ubHlMYW5ndWFnZSA9IGxhbmdDb2RlID0+IHtcbiAgY2hvc2VuTGFuZyA9IGxhbmdDb2RlO1xufTtcbi8vIChpLmUgZW4tQ0EgcmV0dXJucyBqdXN0IGVuKVxuY29uc3Qgc2hvcnRlbkxhbmd1YWdlQ29kZSA9IGxhbmcgPT4ge1xuICByZXR1cm4gbGFuZy5pbmRleE9mKFwiLVwiKSAhPT0gLTEgPyBsYW5nLnNwbGl0KFwiLVwiKVswXSA6IGxhbmcuc3BsaXQoXCJfXCIpWzBdO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBmaW5kT2JqZWN0UHJvcEJ5U3RyaW5nUGF0aCA9IChvYmosIHByb3ApID0+IHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCBfaW5kZXggPSBwcm9wLmluZGV4T2YoXCIuXCIpO1xuICBpZiAoX2luZGV4ID4gLTEpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvcCA9IHByb3Auc3Vic3RyaW5nKDAsIF9pbmRleCk7XG4gICAgY29uc3QgbmV4dFByb3AgPSBwcm9wLnN1YnN0cmluZyhfaW5kZXggKyAxKTtcbiAgICByZXR1cm4gZmluZE9iamVjdFByb3BCeVN0cmluZ1BhdGgob2JqW2N1cnJlbnRQcm9wXSwgbmV4dFByb3ApO1xuICB9XG4gIHJldHVybiBvYmpbcHJvcF07XG59O1xuY29uc3QgdHJhbnNsYXRlID0gcGF0aCA9PiB7XG4gIGxldCBicm93c2VyTGFuZyA9IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2VzID8gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXNbMF0gOiBudWxsO1xuICBicm93c2VyTGFuZyA9IGJyb3dzZXJMYW5nIHx8IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2U7XG4gIGNvbnN0IGxhbmd1YWdlQ29kZSA9IHNob3J0ZW5MYW5ndWFnZUNvZGUoY2hvc2VuTGFuZyB8fCBicm93c2VyTGFuZyk7XG4gIGNvbnN0IHNlbGVjdGVkTGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShsYW5ndWFnZUNvZGUpO1xuICBjb25zdCB0ZXh0ID0gZmluZE9iamVjdFByb3BCeVN0cmluZ1BhdGgoc2VsZWN0ZWRMYW5ndWFnZSwgcGF0aCk7XG4gIHJldHVybiB0ZXh0ICYmIHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiID8gdGV4dCA6IHBhdGg7XG59O1xuXG5leHBvcnQgeyBFdmVudEVtaXR0ZXIsIGFsbG93T25seUxhbmd1YWdlLCBnZXRBY3RpdmVBY2NvdW50LCBpc0N1cnJlbnRCcm93c2VyU3VwcG9ydGVkLCBzZXJpYWxpemVOZXA0MTMsIHNldHVwV2FsbGV0U2VsZWN0b3IsIHRyYW5zbGF0ZSwgdmVyaWZ5RnVsbEtleUJlbG9uZ3NUb1VzZXIsIHZlcmlmeVNpZ25hdHVyZSwgd2FpdEZvciB9O1xuIl0sIm5hbWVzIjpbIm5lYXJBUEkiLCJ1dGlscyIsInByb3ZpZGVycyIsIkV2ZW50RW1pdHRlciIsIkV2ZW50RW1pdHRlciQxIiwiQmVoYXZpb3JTdWJqZWN0IiwiU3ViamVjdCIsInNjYW4iLCJzZXJpYWxpemUiLCJzaGEyNTYiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJTdXBwcmVzc2VkRXJyb3IiLCJlcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwiRXJyb3IiLCJuYW1lIiwiUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsInVybCIsInByb3ZpZGVyIiwiSnNvblJwY1Byb3ZpZGVyIiwicXVlcnkiLCJwYXJhbXMiLCJ2aWV3QWNjZXNzS2V5IiwiYWNjb3VudElkIiwicHVibGljS2V5IiwicmVxdWVzdF90eXBlIiwiZmluYWxpdHkiLCJhY2NvdW50X2lkIiwicHVibGljX2tleSIsImJsb2NrIiwicmVmZXJlbmNlIiwic2VuZFRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJLRVlfREVMSU1JVEVSIiwiSnNvblN0b3JhZ2UiLCJzdG9yYWdlIiwibmFtZXNwYWNlIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsInJlc29sdmVLZXkiLCJrZXkiLCJnZXRJdGVtIiwiaXRlbSIsIkpTT04iLCJwYXJzZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJyZW1vdmVJdGVtIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImNoZWNrIiwiaXQiLCJNYXRoIiwiZ2xvYmFsJHQiLCJGdW5jdGlvbiIsIm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZhaWxzJHMiLCJleGVjIiwiZmFpbHMkciIsImRlc2NyaXB0b3JzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJmYWlscyRxIiwiZnVuY3Rpb25CaW5kTmF0aXZlIiwidGVzdCIsImJpbmQiLCJoYXNPd25Qcm9wZXJ0eSIsIk5BVElWRV9CSU5EJDMiLCJjYWxsJGwiLCJwcm90b3R5cGUiLCJjYWxsIiwiZnVuY3Rpb25DYWxsIiwiYXJndW1lbnRzIiwib2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciQyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiTkFTSE9STl9CVUciLCJmIiwiViIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDUiLCJiaXRtYXAiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk5BVElWRV9CSU5EJDIiLCJGdW5jdGlvblByb3RvdHlwZSQyIiwiYmluZCQ3IiwiY2FsbCRrIiwidW5jdXJyeVRoaXMkcCIsImZ1bmN0aW9uVW5jdXJyeVRoaXMiLCJmbiIsInVuY3VycnlUaGlzJG8iLCJ0b1N0cmluZyQ3IiwidG9TdHJpbmciLCJzdHJpbmdTbGljZSQzIiwic2xpY2UiLCJjbGFzc29mUmF3JDEiLCJ1bmN1cnJ5VGhpcyRuIiwiZmFpbHMkcCIsImNsYXNzb2YkYiIsIiRPYmplY3QkNCIsInNwbGl0IiwiaW5kZXhlZE9iamVjdCIsIiRUeXBlRXJyb3IkZiIsIlR5cGVFcnJvciIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkNiIsInVuZGVmaW5lZCIsIkluZGV4ZWRPYmplY3QkMyIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkNSIsInRvSW5kZXhlZE9iamVjdCQ2IiwiaXNDYWxsYWJsZSRuIiwiYXJndW1lbnQiLCJpc0NhbGxhYmxlJG0iLCJpc09iamVjdCRkIiwiZ2xvYmFsJHMiLCJpc0NhbGxhYmxlJGwiLCJhRnVuY3Rpb24iLCJnZXRCdWlsdEluJDgiLCJtZXRob2QiLCJsZW5ndGgiLCJ1bmN1cnJ5VGhpcyRtIiwib2JqZWN0SXNQcm90b3R5cGVPZiIsImlzUHJvdG90eXBlT2YiLCJnZXRCdWlsdEluJDciLCJlbmdpbmVVc2VyQWdlbnQiLCJnbG9iYWwkciIsInVzZXJBZ2VudCQ1IiwicHJvY2VzcyQzIiwicHJvY2VzcyIsIkRlbm8kMSIsIkRlbm8iLCJ2ZXJzaW9ucyIsInZlcnNpb24iLCJ2OCIsIm1hdGNoIiwiZW5naW5lVjhWZXJzaW9uIiwiVjhfVkVSU0lPTiQxIiwiZmFpbHMkbyIsIm5hdGl2ZVN5bWJvbCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbCIsIlN5bWJvbCIsIlN0cmluZyIsInNoYW0iLCJOQVRJVkVfU1lNQk9MJDEiLCJ1c2VTeW1ib2xBc1VpZCIsIml0ZXJhdG9yIiwiZ2V0QnVpbHRJbiQ2IiwiaXNDYWxsYWJsZSRrIiwiaXNQcm90b3R5cGVPZiQ0IiwiVVNFX1NZTUJPTF9BU19VSUQkMSIsIiRPYmplY3QkMyIsImlzU3ltYm9sJDMiLCIkU3ltYm9sIiwiJFN0cmluZyQzIiwidHJ5VG9TdHJpbmckNSIsImlzQ2FsbGFibGUkaiIsInRyeVRvU3RyaW5nJDQiLCIkVHlwZUVycm9yJGUiLCJhQ2FsbGFibGUkOSIsImFDYWxsYWJsZSQ4IiwiZ2V0TWV0aG9kJDQiLCJmdW5jIiwiY2FsbCRqIiwiaXNDYWxsYWJsZSRpIiwiaXNPYmplY3QkYyIsIiRUeXBlRXJyb3IkZCIsIm9yZGluYXJ5VG9QcmltaXRpdmUkMSIsImlucHV0IiwicHJlZiIsInZhbCIsInZhbHVlT2YiLCJzaGFyZWQkNCIsImV4cG9ydHMiLCJnbG9iYWwkcSIsImRlZmluZVByb3BlcnR5JDciLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzIiwiZ2xvYmFsJHAiLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyIiwiU0hBUkVEIiwic3RvcmUkMyIsInNoYXJlZFN0b3JlIiwic3RvcmUkMiIsInB1c2giLCJtb2RlIiwiY29weXJpZ2h0IiwibGljZW5zZSIsInNvdXJjZSIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkNCIsIiRPYmplY3QkMiIsInRvT2JqZWN0JDciLCJ1bmN1cnJ5VGhpcyRsIiwidG9PYmplY3QkNiIsImhhc093blByb3BlcnR5XzEiLCJoYXNPd24iLCJ1bmN1cnJ5VGhpcyRrIiwiaWQiLCJwb3N0Zml4IiwicmFuZG9tIiwidG9TdHJpbmckNiIsInVpZCQzIiwiZ2xvYmFsJG8iLCJzaGFyZWQkMyIsImhhc093biRiIiwidWlkJDIiLCJOQVRJVkVfU1lNQk9MIiwiVVNFX1NZTUJPTF9BU19VSUQiLCJXZWxsS25vd25TeW1ib2xzU3RvcmUiLCJTeW1ib2wkMSIsInN5bWJvbEZvciIsImNyZWF0ZVdlbGxLbm93blN5bWJvbCIsIndpdGhvdXRTZXR0ZXIiLCJ3ZWxsS25vd25TeW1ib2wkaiIsImRlc2NyaXB0aW9uIiwiY2FsbCRpIiwiaXNPYmplY3QkYiIsImlzU3ltYm9sJDIiLCJnZXRNZXRob2QkMyIsIm9yZGluYXJ5VG9QcmltaXRpdmUiLCJ3ZWxsS25vd25TeW1ib2wkaSIsIiRUeXBlRXJyb3IkYyIsIlRPX1BSSU1JVElWRSIsInRvUHJpbWl0aXZlJDIiLCJleG90aWNUb1ByaW0iLCJ0b1ByaW1pdGl2ZSQxIiwiaXNTeW1ib2wkMSIsInRvUHJvcGVydHlLZXkkNCIsImdsb2JhbCRuIiwiaXNPYmplY3QkYSIsImRvY3VtZW50JDMiLCJkb2N1bWVudCIsIkVYSVNUUyQxIiwiY3JlYXRlRWxlbWVudCIsImRvY3VtZW50Q3JlYXRlRWxlbWVudCQyIiwiREVTQ1JJUFRPUlMkZCIsImZhaWxzJG4iLCJjcmVhdGVFbGVtZW50JDEiLCJpZThEb21EZWZpbmUiLCJhIiwiREVTQ1JJUFRPUlMkYyIsImNhbGwkaCIsInByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCIsInRvSW5kZXhlZE9iamVjdCQ1IiwidG9Qcm9wZXJ0eUtleSQzIiwiaGFzT3duJGEiLCJJRThfRE9NX0RFRklORSQxIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIiwiTyIsIm9iamVjdERlZmluZVByb3BlcnR5IiwiREVTQ1JJUFRPUlMkYiIsImZhaWxzJG0iLCJ2OFByb3RvdHlwZURlZmluZUJ1ZyIsImlzT2JqZWN0JDkiLCIkU3RyaW5nJDIiLCIkVHlwZUVycm9yJGIiLCJhbk9iamVjdCRlIiwiREVTQ1JJUFRPUlMkYSIsIklFOF9ET01fREVGSU5FIiwiVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSIsImFuT2JqZWN0JGQiLCJ0b1Byb3BlcnR5S2V5JDIiLCIkVHlwZUVycm9yJGEiLCIkZGVmaW5lUHJvcGVydHkiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRU5VTUVSQUJMRSIsIkNPTkZJR1VSQUJMRSQxIiwiV1JJVEFCTEUiLCJBdHRyaWJ1dGVzIiwiY3VycmVudCIsIkRFU0NSSVBUT1JTJDkiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ2IiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkOCIsIm9iamVjdCIsIm1ha2VCdWlsdEluJDIiLCJERVNDUklQVE9SUyQ4IiwiaGFzT3duJDkiLCJGdW5jdGlvblByb3RvdHlwZSQxIiwiZ2V0RGVzY3JpcHRvciIsIkVYSVNUUyIsIlBST1BFUiIsInNvbWV0aGluZyIsIkNPTkZJR1VSQUJMRSIsImZ1bmN0aW9uTmFtZSIsInVuY3VycnlUaGlzJGoiLCJpc0NhbGxhYmxlJGgiLCJzdG9yZSQxIiwiZnVuY3Rpb25Ub1N0cmluZyIsImluc3BlY3RTb3VyY2UiLCJpbnNwZWN0U291cmNlJDQiLCJnbG9iYWwkbSIsImlzQ2FsbGFibGUkZyIsImluc3BlY3RTb3VyY2UkMyIsIldlYWtNYXAkMSIsIldlYWtNYXAiLCJuYXRpdmVXZWFrTWFwIiwic2hhcmVkJDIiLCJ1aWQkMSIsImtleXMkMSIsInNoYXJlZEtleSQzIiwiaGlkZGVuS2V5cyQ0IiwiTkFUSVZFX1dFQUtfTUFQIiwiZ2xvYmFsJGwiLCJ1bmN1cnJ5VGhpcyRpIiwiaXNPYmplY3QkOCIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ3IiwiaGFzT3duJDgiLCJzaGFyZWQkMSIsInNoYXJlZEtleSQyIiwiaGlkZGVuS2V5cyQzIiwiT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQiLCJUeXBlRXJyb3IkMyIsInNldCQyIiwiZ2V0JDEiLCJoYXMiLCJlbmZvcmNlIiwiZ2V0dGVyRm9yIiwiVFlQRSIsInN0YXRlIiwidHlwZSIsInN0b3JlIiwid21nZXQiLCJ3bWhhcyIsIndtc2V0Iiwic2V0IiwibWV0YWRhdGEiLCJmYWNhZGUiLCJTVEFURSIsImludGVybmFsU3RhdGUiLCJmYWlscyRsIiwiaXNDYWxsYWJsZSRmIiwiaGFzT3duJDciLCJERVNDUklQVE9SUyQ3IiwiQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMiIsImluc3BlY3RTb3VyY2UkMiIsIkludGVybmFsU3RhdGVNb2R1bGUkNSIsImVuZm9yY2VJbnRlcm5hbFN0YXRlJDIiLCJnZXRJbnRlcm5hbFN0YXRlJDUiLCJkZWZpbmVQcm9wZXJ0eSQ2IiwiQ09ORklHVVJBQkxFX0xFTkdUSCIsIlRFTVBMQVRFIiwibWFrZUJ1aWx0SW4kMSIsIm9wdGlvbnMiLCJyZXBsYWNlIiwiZ2V0dGVyIiwic2V0dGVyIiwiYXJpdHkiLCJpc0NhbGxhYmxlJGUiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1IiwibWFrZUJ1aWx0SW4iLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxIiwiZGVmaW5lQnVpbHRJbiQ4Iiwic2ltcGxlIiwidW5zYWZlIiwibm9uQ29uZmlndXJhYmxlIiwibm9uV3JpdGFibGUiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY2VpbCIsImZsb29yJDMiLCJmbG9vciIsIm1hdGhUcnVuYyIsInRydW5jIiwieCIsIm4iLCJ0b0ludGVnZXJPckluZmluaXR5JDYiLCJudW1iZXIiLCJ0b0ludGVnZXJPckluZmluaXR5JDUiLCJtYXgkMSIsIm1heCIsIm1pbiQyIiwibWluIiwidG9BYnNvbHV0ZUluZGV4JDQiLCJpbmRleCIsImludGVnZXIiLCJ0b0ludGVnZXJPckluZmluaXR5JDQiLCJtaW4kMSIsInRvTGVuZ3RoJDYiLCJ0b0xlbmd0aCQ1IiwibGVuZ3RoT2ZBcnJheUxpa2UkOCIsIm9iaiIsInRvSW5kZXhlZE9iamVjdCQ0IiwidG9BYnNvbHV0ZUluZGV4JDMiLCJsZW5ndGhPZkFycmF5TGlrZSQ3IiwiY3JlYXRlTWV0aG9kJDQiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZWwiLCJmcm9tSW5kZXgiLCJhcnJheUluY2x1ZGVzIiwiaW5jbHVkZXMiLCJpbmRleE9mIiwidW5jdXJyeVRoaXMkaCIsImhhc093biQ2IiwidG9JbmRleGVkT2JqZWN0JDMiLCJpbmRleE9mJDEiLCJoaWRkZW5LZXlzJDIiLCJwdXNoJDIiLCJvYmplY3RLZXlzSW50ZXJuYWwiLCJuYW1lcyIsImkiLCJlbnVtQnVnS2V5cyQzIiwiaW50ZXJuYWxPYmplY3RLZXlzJDEiLCJlbnVtQnVnS2V5cyQyIiwiaGlkZGVuS2V5cyQxIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyIsImdldEJ1aWx0SW4kNSIsInVuY3VycnlUaGlzJGciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEiLCJhbk9iamVjdCRjIiwiY29uY2F0JDEiLCJvd25LZXlzJDEiLCJvd25LZXlzIiwia2V5cyIsImhhc093biQ1IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0IiwiY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxIiwidGFyZ2V0IiwiZXhjZXB0aW9ucyIsImZhaWxzJGsiLCJpc0NhbGxhYmxlJGQiLCJyZXBsYWNlbWVudCIsImlzRm9yY2VkJDIiLCJmZWF0dXJlIiwiZGV0ZWN0aW9uIiwiZGF0YSIsIm5vcm1hbGl6ZSIsIlBPTFlGSUxMIiwiTkFUSVZFIiwic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJpc0ZvcmNlZF8xIiwiZ2xvYmFsJGsiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2IiwiZGVmaW5lQnVpbHRJbiQ3IiwiZGVmaW5lR2xvYmFsUHJvcGVydHkiLCJjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzIiwiaXNGb3JjZWQkMSIsIl9leHBvcnQiLCJUQVJHRVQiLCJHTE9CQUwiLCJTVEFUSUMiLCJzdGF0IiwiRk9SQ0VEIiwidGFyZ2V0UHJvcGVydHkiLCJzb3VyY2VQcm9wZXJ0eSIsImRvbnRDYWxsR2V0U2V0IiwiZm9yY2VkIiwiY2xhc3NvZiRhIiwiZ2xvYmFsJGoiLCJlbmdpbmVJc05vZGUiLCJpc0NhbGxhYmxlJGMiLCIkU3RyaW5nJDEiLCIkVHlwZUVycm9yJDkiLCJhUG9zc2libGVQcm90b3R5cGUkMSIsInVuY3VycnlUaGlzJGYiLCJhbk9iamVjdCRiIiwiYVBvc3NpYmxlUHJvdG90eXBlIiwib2JqZWN0U2V0UHJvdG90eXBlT2YiLCJzZXRQcm90b3R5cGVPZiIsIkNPUlJFQ1RfU0VUVEVSIiwicHJvdG8iLCJfX3Byb3RvX18iLCJkZWZpbmVQcm9wZXJ0eSQ1IiwiaGFzT3duJDQiLCJ3ZWxsS25vd25TeW1ib2wkaCIsIlRPX1NUUklOR19UQUckNCIsInNldFRvU3RyaW5nVGFnJDQiLCJUQUciLCJnZXRCdWlsdEluJDQiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzIiwid2VsbEtub3duU3ltYm9sJGciLCJERVNDUklQVE9SUyQ2IiwiU1BFQ0lFUyQ0Iiwic2V0U3BlY2llcyQyIiwiQ09OU1RSVUNUT1JfTkFNRSIsIkNvbnN0cnVjdG9yIiwiaXNQcm90b3R5cGVPZiQzIiwiJFR5cGVFcnJvciQ4IiwiYW5JbnN0YW5jZSQzIiwiUHJvdG90eXBlIiwid2VsbEtub3duU3ltYm9sJGYiLCJUT19TVFJJTkdfVEFHJDMiLCJ0b1N0cmluZ1RhZ1N1cHBvcnQiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJpc0NhbGxhYmxlJGIiLCJjbGFzc29mUmF3Iiwid2VsbEtub3duU3ltYm9sJGUiLCJUT19TVFJJTkdfVEFHJDIiLCIkT2JqZWN0JDEiLCJDT1JSRUNUX0FSR1VNRU5UUyIsInRyeUdldCIsImNsYXNzb2YkOSIsInRhZyIsImNhbGxlZSIsInVuY3VycnlUaGlzJGUiLCJmYWlscyRqIiwiaXNDYWxsYWJsZSRhIiwiY2xhc3NvZiQ4IiwiZ2V0QnVpbHRJbiQzIiwiaW5zcGVjdFNvdXJjZSQxIiwibm9vcCIsImVtcHR5IiwiY29uc3RydWN0IiwiY29uc3RydWN0b3JSZWdFeHAiLCJleGVjJDIiLCJJTkNPUlJFQ1RfVE9fU1RSSU5HIiwiaXNDb25zdHJ1Y3Rvck1vZGVybiIsImlzQ29uc3RydWN0b3IiLCJpc0NvbnN0cnVjdG9yTGVnYWN5IiwiaXNDb25zdHJ1Y3RvciQyIiwiY2FsbGVkIiwiaXNDb25zdHJ1Y3RvciQxIiwidHJ5VG9TdHJpbmckMyIsIiRUeXBlRXJyb3IkNyIsImFDb25zdHJ1Y3RvciQyIiwiYW5PYmplY3QkYSIsImFDb25zdHJ1Y3RvciQxIiwid2VsbEtub3duU3ltYm9sJGQiLCJTUEVDSUVTJDMiLCJzcGVjaWVzQ29uc3RydWN0b3IkMyIsImRlZmF1bHRDb25zdHJ1Y3RvciIsIkMiLCJTIiwiTkFUSVZFX0JJTkQkMSIsIkZ1bmN0aW9uUHJvdG90eXBlIiwiYXBwbHkkMyIsImNhbGwkZyIsImZ1bmN0aW9uQXBwbHkiLCJSZWZsZWN0IiwidW5jdXJyeVRoaXMkZCIsImFDYWxsYWJsZSQ3IiwiTkFUSVZFX0JJTkQiLCJiaW5kJDYiLCJmdW5jdGlvbkJpbmRDb250ZXh0IiwidGhhdCIsImdldEJ1aWx0SW4kMiIsImh0bWwkMiIsInVuY3VycnlUaGlzJGMiLCJhcnJheVNsaWNlJDUiLCIkVHlwZUVycm9yJDYiLCJ2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxIiwicGFzc2VkIiwicmVxdWlyZWQiLCJ1c2VyQWdlbnQkNCIsImVuZ2luZUlzSW9zIiwiZ2xvYmFsJGkiLCJhcHBseSQyIiwiYmluZCQ1IiwiaXNDYWxsYWJsZSQ5IiwiaGFzT3duJDMiLCJmYWlscyRpIiwiaHRtbCQxIiwiYXJyYXlTbGljZSQ0IiwidmFsaWRhdGVBcmd1bWVudHNMZW5ndGgiLCJJU19JT1MkMSIsIklTX05PREUkMyIsInNldCQxIiwic2V0SW1tZWRpYXRlIiwiY2xlYXIiLCJjbGVhckltbWVkaWF0ZSIsInByb2Nlc3MkMiIsIkRpc3BhdGNoIiwiRnVuY3Rpb24kMSIsIk1lc3NhZ2VDaGFubmVsIiwiU3RyaW5nJDEiLCJjb3VudGVyIiwicXVldWUkMSIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImxvY2F0aW9uIiwiZGVmZXIiLCJjaGFubmVsIiwicG9ydCIsInJ1biIsInJ1bm5lciIsImxpc3RlbmVyIiwiZXZlbnQiLCJwb3N0IiwicG9zdE1lc3NhZ2UiLCJwcm90b2NvbCIsImhvc3QiLCJoYW5kbGVyIiwiYXJncyIsIm5leHRUaWNrIiwibm93IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbXBvcnRTY3JpcHRzIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsInNldFRpbWVvdXQiLCJ0YXNrJDEiLCJ1c2VyQWdlbnQkMyIsImdsb2JhbCRoIiwiZW5naW5lSXNJb3NQZWJibGUiLCJQZWJibGUiLCJ1c2VyQWdlbnQkMiIsImVuZ2luZUlzV2Vib3NXZWJraXQiLCJnbG9iYWwkZyIsImJpbmQkNCIsIm1hY3JvdGFzayIsIklTX0lPUyIsIklTX0lPU19QRUJCTEUiLCJJU19XRUJPU19XRUJLSVQiLCJJU19OT0RFJDIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImRvY3VtZW50JDIiLCJwcm9jZXNzJDEiLCJQcm9taXNlJDEiLCJxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IiLCJxdWV1ZU1pY3JvdGFzayIsImZsdXNoIiwiaGVhZCIsImxhc3QiLCJub3RpZnkkMSIsInRvZ2dsZSIsIm5vZGUiLCJwcm9taXNlIiwicGFyZW50IiwiZG9tYWluIiwiZXhpdCIsImVudGVyIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsIm1pY3JvdGFzayQxIiwidGFzayIsImdsb2JhbCRmIiwiaG9zdFJlcG9ydEVycm9ycyQxIiwiYiIsImNvbnNvbGUiLCJwZXJmb3JtJDMiLCJRdWV1ZSQxIiwidGFpbCIsImFkZCIsImVudHJ5IiwicXVldWUiLCJnbG9iYWwkZSIsInByb21pc2VOYXRpdmVDb25zdHJ1Y3RvciIsImVuZ2luZUlzQnJvd3NlciIsImdsb2JhbCRkIiwiTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMiLCJpc0NhbGxhYmxlJDgiLCJpc0ZvcmNlZCIsIndlbGxLbm93blN5bWJvbCRjIiwiSVNfQlJPV1NFUiIsIlY4X1ZFUlNJT04iLCJTUEVDSUVTJDIiLCJTVUJDTEFTU0lORyIsIk5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSIsIlBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFIiwiR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSIsIkZha2VQcm9taXNlIiwicHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uIiwiQ09OU1RSVUNUT1IiLCJSRUpFQ1RJT05fRVZFTlQiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSQyIiwiYUNhbGxhYmxlJDYiLCJQcm9taXNlQ2FwYWJpbGl0eSIsIiQkcmVzb2x2ZSIsIiQkcmVqZWN0IiwiJCRlIiwiSVNfTk9ERSQxIiwiZ2xvYmFsJGMiLCJjYWxsJGYiLCJkZWZpbmVCdWlsdEluJDYiLCJzZXRQcm90b3R5cGVPZiQ1Iiwic2V0VG9TdHJpbmdUYWckMyIsInNldFNwZWNpZXMkMSIsImFDYWxsYWJsZSQ1IiwiaXNDYWxsYWJsZSQ3IiwiaXNPYmplY3QkNyIsImFuSW5zdGFuY2UkMiIsInNwZWNpZXNDb25zdHJ1Y3RvciQyIiwibWljcm90YXNrIiwiaG9zdFJlcG9ydEVycm9ycyIsInBlcmZvcm0kMiIsIlF1ZXVlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0IiwiTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIiLCJQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24iLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzIiwiUFJPTUlTRSIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQiLCJOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQiLCJOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyIsImdldEludGVybmFsUHJvbWlzZVN0YXRlIiwic2V0SW50ZXJuYWxTdGF0ZSQzIiwiTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxIiwiUHJvbWlzZUNvbnN0cnVjdG9yIiwiUHJvbWlzZVByb3RvdHlwZSIsIlR5cGVFcnJvciQyIiwiZG9jdW1lbnQkMSIsIm5ld1Byb21pc2VDYXBhYmlsaXR5JDEiLCJuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkiLCJESVNQQVRDSF9FVkVOVCIsImNyZWF0ZUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIlVOSEFORExFRF9SRUpFQ1RJT04iLCJSRUpFQ1RJT05fSEFORExFRCIsIlBFTkRJTkciLCJGVUxGSUxMRUQiLCJSRUpFQ1RFRCIsIkhBTkRMRUQiLCJVTkhBTkRMRUQiLCJJbnRlcm5hbCIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiUHJvbWlzZVdyYXBwZXIiLCJuYXRpdmVUaGVuIiwiaXNUaGVuYWJsZSIsImNhbGxSZWFjdGlvbiIsInJlYWN0aW9uIiwib2siLCJmYWlsIiwiZXhpdGVkIiwicmVqZWN0aW9uIiwib25IYW5kbGVVbmhhbmRsZWQiLCJub3RpZnkiLCJpc1JlamVjdCIsIm5vdGlmaWVkIiwicmVhY3Rpb25zIiwib25VbmhhbmRsZWQiLCJyZWFzb24iLCJpbml0RXZlbnQiLCJJU19VTkhBTkRMRUQiLCJpc1VuaGFuZGxlZCIsImVtaXQiLCJiaW5kJDMiLCJ1bndyYXAiLCJpbnRlcm5hbFJlamVjdCIsImludGVybmFsUmVzb2x2ZSIsIndyYXBwZXIiLCJleGVjdXRvciIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsIndyYXAiLCJpdGVyYXRvcnMiLCJ3ZWxsS25vd25TeW1ib2wkYiIsIkl0ZXJhdG9ycyQ0IiwiSVRFUkFUT1IkNSIsIkFycmF5UHJvdG90eXBlJDEiLCJpc0FycmF5SXRlcmF0b3JNZXRob2QkMiIsImNsYXNzb2YkNyIsImdldE1ldGhvZCQyIiwiSXRlcmF0b3JzJDMiLCJ3ZWxsS25vd25TeW1ib2wkYSIsIklURVJBVE9SJDQiLCJnZXRJdGVyYXRvck1ldGhvZCQzIiwiY2FsbCRlIiwiYUNhbGxhYmxlJDQiLCJhbk9iamVjdCQ5IiwidHJ5VG9TdHJpbmckMiIsImdldEl0ZXJhdG9yTWV0aG9kJDIiLCIkVHlwZUVycm9yJDUiLCJnZXRJdGVyYXRvciQyIiwidXNpbmdJdGVyYXRvciIsIml0ZXJhdG9yTWV0aG9kIiwiY2FsbCRkIiwiYW5PYmplY3QkOCIsImdldE1ldGhvZCQxIiwiaXRlcmF0b3JDbG9zZSQxIiwia2luZCIsImlubmVyUmVzdWx0IiwiaW5uZXJFcnJvciIsImJpbmQkMiIsImNhbGwkYyIsImFuT2JqZWN0JDciLCJ0cnlUb1N0cmluZyQxIiwiaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEiLCJsZW5ndGhPZkFycmF5TGlrZSQ2IiwiaXNQcm90b3R5cGVPZiQyIiwiZ2V0SXRlcmF0b3IkMSIsImdldEl0ZXJhdG9yTWV0aG9kJDEiLCJpdGVyYXRvckNsb3NlIiwiJFR5cGVFcnJvciQ0IiwiUmVzdWx0Iiwic3RvcHBlZCIsIlJlc3VsdFByb3RvdHlwZSIsIml0ZXJhdGUkMiIsIml0ZXJhYmxlIiwidW5ib3VuZEZ1bmN0aW9uIiwiQVNfRU5UUklFUyIsIklTX0lURVJBVE9SIiwiSU5URVJSVVBURUQiLCJpdGVyRm4iLCJzdG9wIiwiY29uZGl0aW9uIiwiY2FsbEZuIiwid2VsbEtub3duU3ltYm9sJDkiLCJJVEVSQVRPUiQzIiwiU0FGRV9DTE9TSU5HIiwiaXRlcmF0b3JXaXRoUmV0dXJuIiwiZnJvbSIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQyIiwiU0tJUF9DTE9TSU5HIiwiSVRFUkFUSU9OX1NVUFBPUlQiLCJOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMSIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxIiwiRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyIsInByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uIiwiYWxsIiwiJCRkIiwiY2FsbCRiIiwiYUNhbGxhYmxlJDMiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyIiwicGVyZm9ybSQxIiwiaXRlcmF0ZSQxIiwiUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSIsImNhcGFiaWxpdHkiLCIkcHJvbWlzZVJlc29sdmUiLCJ2YWx1ZXMiLCJyZW1haW5pbmciLCJhbHJlYWR5Q2FsbGVkIiwiJCRjIiwiRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiIsIk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciIsImdldEJ1aWx0SW4kMSIsImlzQ2FsbGFibGUkNiIsImRlZmluZUJ1aWx0SW4kNSIsIk5hdGl2ZVByb21pc2VQcm90b3R5cGUiLCJyZWFsIiwiJCRiIiwiY2FsbCRhIiwiYUNhbGxhYmxlJDIiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxIiwicGVyZm9ybSIsIml0ZXJhdGUiLCJQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiIsInJhY2UiLCIkJGEiLCJjYWxsJDkiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEiLCJyIiwiYW5PYmplY3QkNiIsImlzT2JqZWN0JDYiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSIsInByb21pc2VSZXNvbHZlJDEiLCJwcm9taXNlQ2FwYWJpbGl0eSIsIiQkOSIsImdldEJ1aWx0SW4iLCJGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiIsInByb21pc2VSZXNvbHZlIiwiV2ViU3RvcmFnZVNlcnZpY2UiLCJsb2NhbFN0b3JhZ2UiLCJvYmplY3REZWZpbmVQcm9wZXJ0aWVzIiwiaW50ZXJuYWxPYmplY3RLZXlzIiwiZW51bUJ1Z0tleXMkMSIsIm9iamVjdEtleXMkMiIsIkRFU0NSSVBUT1JTJDUiLCJWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyIsImRlZmluZVByb3BlcnR5TW9kdWxlJDIiLCJhbk9iamVjdCQ1IiwidG9JbmRleGVkT2JqZWN0JDIiLCJvYmplY3RLZXlzJDEiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiUHJvcGVydGllcyIsInByb3BzIiwiYW5PYmplY3QkNCIsImRlZmluZVByb3BlcnRpZXNNb2R1bGUiLCJlbnVtQnVnS2V5cyIsImhpZGRlbktleXMiLCJodG1sIiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEiLCJzaGFyZWRLZXkkMSIsIkdUIiwiTFQiLCJQUk9UT1RZUEUkMSIsIlNDUklQVCIsIklFX1BST1RPJDEiLCJFbXB0eUNvbnN0cnVjdG9yIiwic2NyaXB0VGFnIiwiY29udGVudCIsIk51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgiLCJhY3RpdmVYRG9jdW1lbnQiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJzcmMiLCJjb250ZW50V2luZG93Iiwib3BlbiIsIkYiLCJOdWxsUHJvdG9PYmplY3QiLCJBY3RpdmVYT2JqZWN0Iiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwid2VsbEtub3duU3ltYm9sJDgiLCJjcmVhdGUkMyIsImRlZmluZVByb3BlcnR5JDQiLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG90eXBlIiwiYWRkVG9VbnNjb3BhYmxlcyQyIiwiZmFpbHMkaCIsImNvcnJlY3RQcm90b3R5cGVHZXR0ZXIiLCJnZXRQcm90b3R5cGVPZiIsImhhc093biQyIiwiaXNDYWxsYWJsZSQ1IiwidG9PYmplY3QkNSIsInNoYXJlZEtleSIsIkNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiIsIklFX1BST1RPIiwiJE9iamVjdCIsIk9iamVjdFByb3RvdHlwZSQyIiwib2JqZWN0R2V0UHJvdG90eXBlT2YiLCJmYWlscyRnIiwiaXNDYWxsYWJsZSQ0IiwiZ2V0UHJvdG90eXBlT2YkMyIsImRlZmluZUJ1aWx0SW4kNCIsIndlbGxLbm93blN5bWJvbCQ3IiwiSVRFUkFUT1IkMiIsIkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSIsIkl0ZXJhdG9yUHJvdG90eXBlJDIiLCJQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUiLCJhcnJheUl0ZXJhdG9yIiwiTkVXX0lURVJBVE9SX1BST1RPVFlQRSIsIml0ZXJhdG9yc0NvcmUiLCJJdGVyYXRvclByb3RvdHlwZSIsIkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMiLCJJdGVyYXRvclByb3RvdHlwZSQxIiwiY3JlYXRlJDIiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiIsInNldFRvU3RyaW5nVGFnJDIiLCJJdGVyYXRvcnMkMiIsInJldHVyblRoaXMkMSIsImNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMSIsIkl0ZXJhdG9yQ29uc3RydWN0b3IiLCJOQU1FIiwiRU5VTUVSQUJMRV9ORVhUIiwiVE9fU1RSSU5HX1RBRyIsIiQkOCIsImNhbGwkOCIsIkZ1bmN0aW9uTmFtZSQxIiwiaXNDYWxsYWJsZSQzIiwiY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciIsImdldFByb3RvdHlwZU9mJDIiLCJzZXRQcm90b3R5cGVPZiQ0Iiwic2V0VG9TdHJpbmdUYWckMSIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1IiwiZGVmaW5lQnVpbHRJbiQzIiwid2VsbEtub3duU3ltYm9sJDYiLCJJdGVyYXRvcnMkMSIsIkl0ZXJhdG9yc0NvcmUiLCJQUk9QRVJfRlVOQ1RJT05fTkFNRSQyIiwiQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSIsIklURVJBVE9SJDEiLCJLRVlTIiwiVkFMVUVTIiwiRU5UUklFUyIsInJldHVyblRoaXMiLCJkZWZpbmVJdGVyYXRvciQxIiwiSXRlcmFibGUiLCJERUZBVUxUIiwiSVNfU0VUIiwiZ2V0SXRlcmF0aW9uTWV0aG9kIiwiS0lORCIsImRlZmF1bHRJdGVyYXRvciIsIkl0ZXJhYmxlUHJvdG90eXBlIiwiZW50cmllcyIsIklOQ09SUkVDVF9WQUxVRVNfTkFNRSIsIm5hdGl2ZUl0ZXJhdG9yIiwiYW55TmF0aXZlSXRlcmF0b3IiLCJDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUiLCJtZXRob2RzIiwiS0VZIiwidG9JbmRleGVkT2JqZWN0JDEiLCJhZGRUb1Vuc2NvcGFibGVzJDEiLCJJdGVyYXRvcnMiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDMiLCJkZWZpbmVQcm9wZXJ0eSQzIiwiZGVmaW5lSXRlcmF0b3IiLCJERVNDUklQVE9SUyQ0IiwiQVJSQVlfSVRFUkFUT1IiLCJzZXRJbnRlcm5hbFN0YXRlJDIiLCJnZXRJbnRlcm5hbFN0YXRlJDQiLCJlc19hcnJheV9pdGVyYXRvciIsIml0ZXJhdGVkIiwiQXJndW1lbnRzIiwiZG9tSXRlcmFibGVzIiwiQ1NTUnVsZUxpc3QiLCJDU1NTdHlsZURlY2xhcmF0aW9uIiwiQ1NTVmFsdWVMaXN0IiwiQ2xpZW50UmVjdExpc3QiLCJET01SZWN0TGlzdCIsIkRPTVN0cmluZ0xpc3QiLCJET01Ub2tlbkxpc3QiLCJEYXRhVHJhbnNmZXJJdGVtTGlzdCIsIkZpbGVMaXN0IiwiSFRNTEFsbENvbGxlY3Rpb24iLCJIVE1MQ29sbGVjdGlvbiIsIkhUTUxGb3JtRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiTWVkaWFMaXN0IiwiTWltZVR5cGVBcnJheSIsIk5hbWVkTm9kZU1hcCIsIk5vZGVMaXN0IiwiUGFpbnRSZXF1ZXN0TGlzdCIsIlBsdWdpbiIsIlBsdWdpbkFycmF5IiwiU1ZHTGVuZ3RoTGlzdCIsIlNWR051bWJlckxpc3QiLCJTVkdQYXRoU2VnTGlzdCIsIlNWR1BvaW50TGlzdCIsIlNWR1N0cmluZ0xpc3QiLCJTVkdUcmFuc2Zvcm1MaXN0IiwiU291cmNlQnVmZmVyTGlzdCIsIlN0eWxlU2hlZXRMaXN0IiwiVGV4dFRyYWNrQ3VlTGlzdCIsIlRleHRUcmFja0xpc3QiLCJUb3VjaExpc3QiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJET01Ub2tlbkxpc3RQcm90b3R5cGUkMSIsImRvbVRva2VuTGlzdFByb3RvdHlwZSIsImdsb2JhbCRiIiwiRE9NSXRlcmFibGVzIiwiRE9NVG9rZW5MaXN0UHJvdG90eXBlIiwiQXJyYXlJdGVyYXRvck1ldGhvZHMiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCIsIndlbGxLbm93blN5bWJvbCQ1IiwiSVRFUkFUT1IiLCJUT19TVFJJTkdfVEFHJDEiLCJBcnJheVZhbHVlcyIsImhhbmRsZVByb3RvdHlwZSIsIkNvbGxlY3Rpb25Qcm90b3R5cGUiLCJDT0xMRUNUSU9OX05BTUUiLCJNRVRIT0RfTkFNRSIsIkxvZ2dlciIsImRlYnVnIiwibG9nIiwiaW5mbyIsIndhcm4iLCJsb2dnZXIiLCIkJDciLCIkaW5jbHVkZXMiLCJmYWlscyRmIiwiYWRkVG9VbnNjb3BhYmxlcyIsIkJST0tFTl9PTl9TUEFSU0UiLCJpc09iamVjdCQ1IiwiY2xhc3NvZiQ2Iiwid2VsbEtub3duU3ltYm9sJDQiLCJNQVRDSCQxIiwiaXNSZWdleHAiLCJpc1JlZ0V4cCIsImlzUmVnRXhwJDEiLCIkVHlwZUVycm9yJDMiLCJub3RBUmVnZXhwIiwiY2xhc3NvZiQ1IiwiJFN0cmluZyIsInRvU3RyaW5nJDUiLCJ3ZWxsS25vd25TeW1ib2wkMyIsIk1BVENIIiwiY29ycmVjdElzUmVnZXhwTG9naWMiLCJyZWdleHAiLCJlcnJvcjEiLCJlcnJvcjIiLCIkJDYiLCJ1bmN1cnJ5VGhpcyRiIiwibm90QVJlZ0V4cCIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkMyIsInRvU3RyaW5nJDQiLCJjb3JyZWN0SXNSZWdFeHBMb2dpYyIsInN0cmluZ0luZGV4T2YiLCJzZWFyY2hTdHJpbmciLCJ3aGl0ZXNwYWNlcyQyIiwidW5jdXJyeVRoaXMkYSIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkMiIsInRvU3RyaW5nJDMiLCJ3aGl0ZXNwYWNlcyQxIiwicmVwbGFjZSQxIiwid2hpdGVzcGFjZSIsImx0cmltIiwiUmVnRXhwIiwicnRyaW0iLCJjcmVhdGVNZXRob2QkMyIsInN0cmluZ1RyaW0iLCJzdGFydCIsImVuZCIsInRyaW0iLCJQUk9QRVJfRlVOQ1RJT05fTkFNRSQxIiwiZmFpbHMkZSIsIndoaXRlc3BhY2VzIiwibm9uIiwic3RyaW5nVHJpbUZvcmNlZCIsIiQkNSIsIiR0cmltIiwiZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCIsIkRFU0NSSVBUT1JTJDMiLCJ1bmN1cnJ5VGhpcyQ5IiwiY2FsbCQ3IiwiZmFpbHMkZCIsIm9iamVjdEtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsInRvT2JqZWN0JDQiLCJJbmRleGVkT2JqZWN0JDIiLCIkYXNzaWduIiwiYXNzaWduIiwiZGVmaW5lUHJvcGVydHkkMiIsIm9iamVjdEFzc2lnbiIsIkEiLCJCIiwiYWxwaGFiZXQiLCJmb3JFYWNoIiwiY2hyIiwiVCIsImFyZ3VtZW50c0xlbmd0aCIsImoiLCIkJDQiLCJlbWl0dGVyIiwib24iLCJldmVudE5hbWUiLCJjYWxsYmFjayIsInJlbW92ZSIsIm9mZiIsIlBBQ0tBR0VfTkFNRSIsIlJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTIiwiQ09OVFJBQ1QiLCJQRU5ESU5HX0NPTlRSQUNUIiwiU0VMRUNURURfV0FMTEVUX0lEIiwiUEVORElOR19TRUxFQ1RFRF9XQUxMRVRfSUQiLCJXYWxsZXRNb2R1bGVzIiwiZmFjdG9yaWVzIiwibW9kdWxlcyIsImluc3RhbmNlcyIsInZhbGlkYXRlV2FsbGV0IiwiYWNjb3VudHMiLCJ3YWxsZXQiLCJnZXRXYWxsZXQiLCJnZXRBY2NvdW50cyIsImNhdGNoIiwiZXJyIiwicmVzb2x2ZVN0b3JhZ2VTdGF0ZSIsImpzb25TdG9yYWdlIiwicGVuZGluZ1NlbGVjdGVkV2FsbGV0SWQiLCJwZW5kaW5nQ29udHJhY3QiLCJfYWNjb3VudHMiLCJzZWxlY3RlZFdhbGxldElkIiwiX3NlbGVjdGVkV2FsbGV0SWQiLCJnZXRTdGF0ZSIsInNlbGVjdGVkV2FsbGV0Iiwic2lnbk91dCIsInJlY2VudGx5U2lnbmVkSW5XYWxsZXRzRnJvbVBlbmRpbmciLCJzZXRXYWxsZXRBc1JlY2VudGx5U2lnbmVkSW4iLCJjb250cmFjdCIsInJlY2VudGx5U2lnbmVkSW5XYWxsZXRzIiwid2FsbGV0SWQiLCJ1bnNoaWZ0Iiwic2lnbk91dFdhbGxldCIsIm9uV2FsbGV0U2lnbmVkT3V0Iiwib25XYWxsZXRTaWduZWRJbiIsImNvbnRyYWN0SWQiLCJtZXRob2ROYW1lcyIsIm1vZHVsZSIsImdldE1vZHVsZSIsImRpc3BhdGNoIiwicGF5bG9hZCIsInNldHVwV2FsbGV0RW1pdHRlciIsIm5ldHdvcmtJZCIsInVyaSIsInZhbGlkYXRlU2lnbk1lc3NhZ2VQYXJhbXMiLCJub25jZSIsInJlY2lwaWVudCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiZGVjb3JhdGVXYWxsZXQiLCJfc2lnbkluIiwic2lnbkluIiwiX3NpZ25PdXQiLCJfc2lnbk1lc3NhZ2UiLCJzaWduTWVzc2FnZSIsInNldHVwSW5zdGFuY2UiLCJhdmFpbGFibGUiLCJpbml0IiwidG9SZWFkT25seSIsImZpbmQiLCJzZXR1cCIsInNvbWUiLCJpbnN0YW5jZSIsInJ1bk9uU3RhcnR1cCIsImdldENvbnRyYWN0SWQiLCJnZXROZXR3b3JrUHJlc2V0Iiwibm9kZVVybCIsImhlbHBlclVybCIsImV4cGxvcmVyVXJsIiwiaW5kZXhlclVybCIsInJlc29sdmVOZXR3b3JrIiwibmV0d29yayIsInJlc29sdmVPcHRpb25zIiwibGFuZ3VhZ2VDb2RlIiwib3B0aW1pemVXYWxsZXRPcmRlciIsInJhbmRvbWl6ZVdhbGxldE9yZGVyIiwicmVsYXllclVybCIsInJlZHVjZXIiLCJhY3Rpb24iLCJhY2NvdW50U3RhdGVzIiwibWFwIiwiYWNjb3VudCIsImFjdGl2ZSIsImFjdGl2ZUFjY291bnRJbmRleCIsImZpbmRJbmRleCIsImFjdGl2ZUFjY291bnQiLCJpc0FjdGl2ZUFjY291bnRSZW1vdmVkIiwiY3JlYXRlU3RvcmUiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSQiLCJhY3Rpb25zJCIsInBpcGUiLCJzdWJzY3JpYmUiLCJzeW5jU3RvcmFnZSIsInByZXZTdGF0ZSIsInN0b3JhZ2VLZXkiLCJwcm9wZXJ0eSIsImdldFZhbHVlIiwib2JzZXJ2YWJsZSIsImFzT2JzZXJ2YWJsZSIsIndhbGxldFNlbGVjdG9ySW5zdGFuY2UiLCJjcmVhdGVTZWxlY3RvciIsIndhbGxldE1vZHVsZXMiLCJzZXRBY3RpdmVBY2NvdW50IiwiaXNTaWduZWRJbiIsIkJvb2xlYW4iLCJzZXR1cFdhbGxldFNlbGVjdG9yIiwiYWxsb3dNdWx0aXBsZVNlbGVjdG9ycyIsIndhaXQiLCJtcyIsInBvbGwiLCJjYiIsImludGVydmFsIiwid2FpdEZvciIsIm9wdHMiLCJ0aW1lb3V0IiwiZ2V0QWN0aXZlQWNjb3VudCIsImFDYWxsYWJsZSQxIiwidG9PYmplY3QkMyIsIkluZGV4ZWRPYmplY3QkMSIsImxlbmd0aE9mQXJyYXlMaWtlJDUiLCIkVHlwZUVycm9yJDIiLCJjcmVhdGVNZXRob2QkMiIsIklTX1JJR0hUIiwiY2FsbGJhY2tmbiIsIm1lbW8iLCJhcnJheVJlZHVjZSIsImxlZnQiLCJyaWdodCIsImZhaWxzJGMiLCJhcnJheU1ldGhvZElzU3RyaWN0JDEiLCIkJDMiLCIkcmVkdWNlIiwiYXJyYXlNZXRob2RJc1N0cmljdCIsIkNIUk9NRV9WRVJTSU9OIiwiSVNfTk9ERSIsIlNUUklDVF9NRVRIT0QiLCJDSFJPTUVfQlVHIiwicmVkdWNlIiwiYW5PYmplY3QkMyIsInJlZ2V4cEZsYWdzJDEiLCJoYXNJbmRpY2VzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImRvdEFsbCIsInVuaWNvZGUiLCJ1bmljb2RlU2V0cyIsInN0aWNreSIsImZhaWxzJGIiLCJnbG9iYWwkYSIsIiRSZWdFeHAkMiIsIlVOU1VQUE9SVEVEX1kkMiIsInJlIiwibGFzdEluZGV4IiwiTUlTU0VEX1NUSUNLWSIsIkJST0tFTl9DQVJFVCIsInJlZ2V4cFN0aWNreUhlbHBlcnMiLCJVTlNVUFBPUlRFRF9ZIiwiZmFpbHMkYSIsImdsb2JhbCQ5IiwiJFJlZ0V4cCQxIiwicmVnZXhwVW5zdXBwb3J0ZWREb3RBbGwiLCJmbGFncyIsImZhaWxzJDkiLCJnbG9iYWwkOCIsIiRSZWdFeHAiLCJyZWdleHBVbnN1cHBvcnRlZE5jZyIsImdyb3VwcyIsImNhbGwkNiIsInVuY3VycnlUaGlzJDgiLCJ0b1N0cmluZyQyIiwicmVnZXhwRmxhZ3MiLCJzdGlja3lIZWxwZXJzJDEiLCJzaGFyZWQiLCJjcmVhdGUkMSIsImdldEludGVybmFsU3RhdGUkMyIsIlVOU1VQUE9SVEVEX0RPVF9BTEwiLCJVTlNVUFBPUlRFRF9OQ0ciLCJuYXRpdmVSZXBsYWNlIiwibmF0aXZlRXhlYyIsInBhdGNoZWRFeGVjIiwiY2hhckF0JDIiLCJjaGFyQXQiLCJzdHJpbmdTbGljZSQyIiwiVVBEQVRFU19MQVNUX0lOREVYX1dST05HIiwicmUxIiwicmUyIiwiVU5TVVBQT1JURURfWSQxIiwiTlBDR19JTkNMVURFRCIsIlBBVENIIiwic3RyIiwicmF3IiwicmVDb3B5IiwiZ3JvdXAiLCJjaGFyc0FkZGVkIiwic3RyQ29weSIsInJlZ2V4cEV4ZWMkMyIsIiQkMiIsImV4ZWMkMSIsIlNFQVJDSEJPWF9VQV9SRUdFWCIsInVzZXJBZ2VudFJ1bGVzIiwibWF0Y2hVc2VyQWdlbnQiLCJ1YSIsIm1hdGNoZWQiLCJicm93c2VyIiwicmVnZXgiLCJ1YU1hdGNoIiwiaXNDdXJyZW50QnJvd3NlclN1cHBvcnRlZCIsInN1cHBvcnRlZEJyb3dzZXIiLCJuYXZpZ2F0b3IiLCJtYXRjaGVkUnVsZSIsInVzZXJBZ2VudCIsImFycmF5QnVmZmVyTmF0aXZlIiwiQXJyYXlCdWZmZXIiLCJEYXRhVmlldyIsIk5BVElWRV9BUlJBWV9CVUZGRVIkMSIsIkRFU0NSSVBUT1JTJDIiLCJnbG9iYWwkNyIsImlzQ2FsbGFibGUkMiIsImlzT2JqZWN0JDQiLCJoYXNPd24kMSIsImNsYXNzb2YkNCIsInRyeVRvU3RyaW5nIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMiLCJkZWZpbmVCdWlsdEluJDIiLCJkZWZpbmVQcm9wZXJ0eSQxIiwiaXNQcm90b3R5cGVPZiQxIiwiZ2V0UHJvdG90eXBlT2YkMSIsInNldFByb3RvdHlwZU9mJDMiLCJ3ZWxsS25vd25TeW1ib2wkMiIsInVpZCIsIkludGVybmFsU3RhdGVNb2R1bGUkMiIsImVuZm9yY2VJbnRlcm5hbFN0YXRlJDEiLCJnZXRJbnRlcm5hbFN0YXRlJDIiLCJJbnQ4QXJyYXkkNCIsIkludDhBcnJheSIsIkludDhBcnJheVByb3RvdHlwZSQxIiwiVWludDhDbGFtcGVkQXJyYXkkMSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUiLCJUeXBlZEFycmF5JDEiLCJUeXBlZEFycmF5UHJvdG90eXBlJDEiLCJPYmplY3RQcm90b3R5cGUkMSIsIlR5cGVFcnJvciQxIiwiVFlQRURfQVJSQVlfVEFHJDEiLCJUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUiIsIk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiIsIm9wZXJhIiwiVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QiLCJVaW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0IiwiQmlnSW50NjRBcnJheSIsIkJpZ1VpbnQ2NEFycmF5IiwiaXNWaWV3Iiwia2xhc3MiLCJnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IiLCJpc1R5cGVkQXJyYXkkMSIsImFUeXBlZEFycmF5JDQiLCJhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDIiLCJleHBvcnRUeXBlZEFycmF5TWV0aG9kJDQiLCJBUlJBWSIsIlR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMSIsIlR5cGVkQXJyYXkiLCJhcnJheUJ1ZmZlclZpZXdDb3JlIiwiTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyIsIlRZUEVEX0FSUkFZX1RBRyIsImFUeXBlZEFycmF5IiwiYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImV4cG9ydFR5cGVkQXJyYXlNZXRob2QiLCJleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kIiwiaXNUeXBlZEFycmF5IiwiVHlwZWRBcnJheVByb3RvdHlwZSIsImdsb2JhbCQ2IiwiZmFpbHMkOCIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiIsIk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSIsIkFycmF5QnVmZmVyJDMiLCJJbnQ4QXJyYXkkMyIsInR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnMiLCJiaW5kJDEiLCJjYWxsJDUiLCJhQ29uc3RydWN0b3IiLCJ0b09iamVjdCQyIiwibGVuZ3RoT2ZBcnJheUxpa2UkNCIsImdldEl0ZXJhdG9yIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJpc0FycmF5SXRlcmF0b3JNZXRob2QiLCJhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDEiLCJ0eXBlZEFycmF5RnJvbSQyIiwibWFwZm4iLCJtYXBwaW5nIiwiVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyQxIiwidHlwZWRBcnJheUZyb20kMSIsImRlZmluZUJ1aWx0SW4kMSIsImRlZmluZUJ1aWx0SW5zJDEiLCJ0b0ludGVnZXJPckluZmluaXR5JDMiLCJ0b0xlbmd0aCQ0IiwiJFJhbmdlRXJyb3IkMiIsIlJhbmdlRXJyb3IiLCJ0b0luZGV4JDIiLCIkQXJyYXkkMiIsImFicyIsInBvdyIsImZsb29yJDIiLCJMTjIiLCJwYWNrIiwibWFudGlzc2FMZW5ndGgiLCJieXRlcyIsImJ1ZmZlciIsImV4cG9uZW50TGVuZ3RoIiwiZU1heCIsImVCaWFzIiwicnQiLCJzaWduIiwiZXhwb25lbnQiLCJtYW50aXNzYSIsImMiLCJJbmZpbml0eSIsInVucGFjayIsIm5CaXRzIiwiTmFOIiwiaWVlZTc1NCIsInRvT2JqZWN0JDEiLCJ0b0Fic29sdXRlSW5kZXgkMiIsImxlbmd0aE9mQXJyYXlMaWtlJDMiLCJhcnJheUZpbGwkMSIsImZpbGwiLCJlbmRQb3MiLCJ0b1Byb3BlcnR5S2V5JDEiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJjcmVhdGVQcm9wZXJ0eSQxIiwicHJvcGVydHlLZXkiLCJ0b0Fic29sdXRlSW5kZXgkMSIsImxlbmd0aE9mQXJyYXlMaWtlJDIiLCJjcmVhdGVQcm9wZXJ0eSIsIiRBcnJheSQxIiwiYXJyYXlTbGljZVNpbXBsZSIsImsiLCJmaW4iLCJnbG9iYWwkNSIsInVuY3VycnlUaGlzJDciLCJERVNDUklQVE9SUyQxIiwiTkFUSVZFX0FSUkFZX0JVRkZFUiIsIkZ1bmN0aW9uTmFtZSIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyIiwiZGVmaW5lQnVpbHRJbnMiLCJmYWlscyQ3IiwiYW5JbnN0YW5jZSQxIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQyIiwidG9MZW5ndGgkMyIsInRvSW5kZXgkMSIsIklFRUU3NTQiLCJzZXRQcm90b3R5cGVPZiQyIiwiZ2V0T3duUHJvcGVydHlOYW1lcyQxIiwiYXJyYXlGaWxsIiwiYXJyYXlTbGljZSQzIiwic2V0VG9TdHJpbmdUYWciLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDEiLCJQUk9QRVJfRlVOQ1RJT05fTkFNRSIsIkNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FIiwiZ2V0SW50ZXJuYWxTdGF0ZSQxIiwic2V0SW50ZXJuYWxTdGF0ZSQxIiwiQVJSQVlfQlVGRkVSIiwiREFUQV9WSUVXIiwiUFJPVE9UWVBFIiwiV1JPTkdfTEVOR1RIJDEiLCJXUk9OR19JTkRFWCIsIk5hdGl2ZUFycmF5QnVmZmVyIiwiJEFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXJQcm90b3R5cGUkMSIsIiREYXRhVmlldyIsIkRhdGFWaWV3UHJvdG90eXBlJDEiLCJPYmplY3RQcm90b3R5cGUiLCJBcnJheSQxIiwiUmFuZ2VFcnJvciQzIiwicmV2ZXJzZSIsInBhY2tJRUVFNzU0IiwidW5wYWNrSUVFRTc1NCIsInBhY2tJbnQ4IiwicGFja0ludDE2IiwicGFja0ludDMyIiwidW5wYWNrSW50MzIiLCJwYWNrRmxvYXQzMiIsInBhY2tGbG9hdDY0IiwiYWRkR2V0dGVyJDEiLCJ2aWV3IiwiY291bnQiLCJpc0xpdHRsZUVuZGlhbiIsImludEluZGV4IiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJjb252ZXJzaW9uIiwiYnVmZmVyTGVuZ3RoIiwib2Zmc2V0IiwiZ2V0SW50OCIsImdldFVpbnQ4IiwiZ2V0SW50MTYiLCJnZXRVaW50MTYiLCJnZXRJbnQzMiIsImdldFVpbnQzMiIsImdldEZsb2F0MzIiLCJnZXRGbG9hdDY0Iiwic2V0SW50OCIsInNldFVpbnQ4Iiwic2V0SW50MTYiLCJzZXRVaW50MTYiLCJzZXRJbnQzMiIsInNldFVpbnQzMiIsInNldEZsb2F0MzIiLCJzZXRGbG9hdDY0IiwiSU5DT1JSRUNUX0FSUkFZX0JVRkZFUl9OQU1FIiwidGVzdFZpZXciLCIkc2V0SW50OCIsImFycmF5QnVmZmVyIiwiJCQxIiwidW5jdXJyeVRoaXMkNiIsImZhaWxzJDYiLCJBcnJheUJ1ZmZlck1vZHVsZSQxIiwiYW5PYmplY3QkMiIsInRvQWJzb2x1dGVJbmRleCIsInRvTGVuZ3RoJDIiLCJzcGVjaWVzQ29uc3RydWN0b3IkMSIsIkFycmF5QnVmZmVyJDIiLCJEYXRhVmlldyQyIiwiRGF0YVZpZXdQcm90b3R5cGUiLCJ1biRBcnJheUJ1ZmZlclNsaWNlIiwiSU5DT1JSRUNUX1NMSUNFIiwiZmlyc3QiLCJ2aWV3U291cmNlIiwidmlld1RhcmdldCIsInR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImlzT2JqZWN0JDMiLCJmbG9vciQxIiwiaXNJbnRlZ3JhbE51bWJlciQxIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaXNGaW5pdGUiLCJ0b0ludGVnZXJPckluZmluaXR5JDEiLCIkUmFuZ2VFcnJvciQxIiwidG9Qb3NpdGl2ZUludGVnZXIkMSIsInRvUG9zaXRpdmVJbnRlZ2VyIiwiJFJhbmdlRXJyb3IiLCJ0b09mZnNldCQyIiwiQllURVMiLCJjbGFzc29mJDMiLCJpc0FycmF5JDEiLCJpc09iamVjdCQyIiwid2VsbEtub3duU3ltYm9sJDEiLCJTUEVDSUVTJDEiLCIkQXJyYXkiLCJhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxIiwib3JpZ2luYWxBcnJheSIsImFycmF5U3BlY2llc0NvbnN0cnVjdG9yIiwiYXJyYXlTcGVjaWVzQ3JlYXRlJDEiLCJ1bmN1cnJ5VGhpcyQ1IiwiSW5kZXhlZE9iamVjdCIsInRvT2JqZWN0IiwibGVuZ3RoT2ZBcnJheUxpa2UkMSIsImFycmF5U3BlY2llc0NyZWF0ZSIsInB1c2gkMSIsImNyZWF0ZU1ldGhvZCQxIiwiSVNfTUFQIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIklTX0ZJTFRFUl9SRUpFQ1QiLCJOT19IT0xFUyIsInNwZWNpZmljQ3JlYXRlIiwiYm91bmRGdW5jdGlvbiIsImFycmF5SXRlcmF0aW9uIiwiZmlsdGVyIiwiZXZlcnkiLCJmaWx0ZXJSZWplY3QiLCJpc0NhbGxhYmxlJDEiLCJpc09iamVjdCQxIiwic2V0UHJvdG90eXBlT2YkMSIsImluaGVyaXRJZlJlcXVpcmVkJDEiLCJkdW1teSIsIldyYXBwZXIiLCJOZXdUYXJnZXQiLCJOZXdUYXJnZXRQcm90b3R5cGUiLCIkIiwiZ2xvYmFsJDQiLCJjYWxsJDQiLCJERVNDUklQVE9SUyIsIlRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMiLCJBcnJheUJ1ZmZlclZpZXdDb3JlJDQiLCJBcnJheUJ1ZmZlck1vZHVsZSIsImFuSW5zdGFuY2UiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSIsImlzSW50ZWdyYWxOdW1iZXIiLCJ0b0xlbmd0aCQxIiwidG9JbmRleCIsInRvT2Zmc2V0JDEiLCJ0b1Byb3BlcnR5S2V5IiwiY2xhc3NvZiQyIiwiaXNPYmplY3QiLCJpc1N5bWJvbCIsInR5cGVkQXJyYXlGcm9tIiwic2V0U3BlY2llcyIsImRlZmluZVByb3BlcnR5TW9kdWxlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSIsImluaGVyaXRJZlJlcXVpcmVkIiwiZ2V0SW50ZXJuYWxTdGF0ZSIsInNldEludGVybmFsU3RhdGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsIm5hdGl2ZURlZmluZVByb3BlcnR5IiwibmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicm91bmQiLCJSYW5nZUVycm9yJDIiLCJBcnJheUJ1ZmZlciQxIiwiQXJyYXlCdWZmZXJQcm90b3R5cGUiLCJEYXRhVmlldyQxIiwiQllURVNfUEVSX0VMRU1FTlQiLCJXUk9OR19MRU5HVEgiLCJmcm9tTGlzdCIsImxpc3QiLCJhZGRHZXR0ZXIiLCJpc0FycmF5QnVmZmVyIiwiaXNUeXBlZEFycmF5SW5kZXgiLCJ3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwid3JhcHBlZERlZmluZVByb3BlcnR5IiwiQ0xBTVBFRCIsIkdFVFRFUiIsIlNFVFRFUiIsIk5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsIlR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSIsImV4cG9ydGVkIiwiYWRkRWxlbWVudCIsIiRsZW5ndGgiLCIkbGVuIiwidHlwZWRBcnJheU9mZnNldCIsImNyZWF0ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsInRvUHJpbWl0aXZlIiwiJFR5cGVFcnJvciQxIiwidG9CaWdJbnQkMSIsInByaW0iLCJCaWdJbnQiLCJBcnJheUJ1ZmZlclZpZXdDb3JlJDMiLCIkZmlsbCIsInRvQmlnSW50IiwiY2xhc3NvZiQxIiwiY2FsbCQzIiwidW5jdXJyeVRoaXMkNCIsImZhaWxzJDUiLCJhVHlwZWRBcnJheSQzIiwiZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQzIiwiQ09OVkVSU0lPTl9CVUciLCJhY3R1YWxWYWx1ZSIsImdsb2JhbCQzIiwiY2FsbCQyIiwiQXJyYXlCdWZmZXJWaWV3Q29yZSQyIiwibGVuZ3RoT2ZBcnJheUxpa2UiLCJ0b09mZnNldCIsInRvSW5kZXhlZE9iamVjdCIsImZhaWxzJDQiLCJSYW5nZUVycm9yJDEiLCJJbnQ4QXJyYXkkMiIsIkludDhBcnJheVByb3RvdHlwZSIsIiRzZXQiLCJhVHlwZWRBcnJheSQyIiwiZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQyIiwiV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTIiwiYXJyYXkiLCJUT19PQkpFQ1RfQlVHIiwiYXJyYXlMaWtlIiwibGVuIiwiYXJyYXlTbGljZSQyIiwibWVyZ2VTb3J0IiwiY29tcGFyZWZuIiwibWlkZGxlIiwiaW5zZXJ0aW9uU29ydCIsIm1lcmdlIiwiZWxlbWVudCIsImxsZW5ndGgiLCJybGVuZ3RoIiwibGluZGV4IiwicmluZGV4IiwiYXJyYXlTb3J0IiwidXNlckFnZW50JDEiLCJmaXJlZm94IiwiZW5naW5lRmZWZXJzaW9uIiwiVUEiLCJlbmdpbmVJc0llT3JFZGdlIiwid2Via2l0IiwiZW5naW5lV2Via2l0VmVyc2lvbiIsImdsb2JhbCQyIiwidW5jdXJyeVRoaXMkMyIsImZhaWxzJDMiLCJhQ2FsbGFibGUiLCJpbnRlcm5hbFNvcnQiLCJBcnJheUJ1ZmZlclZpZXdDb3JlJDEiLCJGRiIsIklFX09SX0VER0UiLCJWOCIsIldFQktJVCIsImFUeXBlZEFycmF5JDEiLCJleHBvcnRUeXBlZEFycmF5TWV0aG9kJDEiLCJ1biRTb3J0Iiwic29ydCIsIkFDQ0VQVF9JTkNPUlJFQ1RfQVJHVU1FTlRTIiwiU1RBQkxFX1NPUlQiLCJleHBlY3RlZCIsIm1vZCIsImdldFNvcnRDb21wYXJlIiwieSIsImdsb2JhbCQxIiwiYXBwbHkkMSIsIkFycmF5QnVmZmVyVmlld0NvcmUiLCJmYWlscyQyIiwiYXJyYXlTbGljZSQxIiwiSW50OEFycmF5JDEiLCIkdG9Mb2NhbGVTdHJpbmciLCJ0b0xvY2FsZVN0cmluZyIsIlRPX0xPQ0FMRV9TVFJJTkdfQlVHIiwiUGF5bG9hZCIsImNhbGxiYWNrVXJsIiwicGF5bG9hZFNjaGVtYSIsIk1hcCIsImZpZWxkcyIsInNlcmlhbGl6ZU5lcDQxMyIsInNpZ25NZXNzYWdlUGFyYW1zIiwidmVyaWZ5U2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiYm9yc2hQYXlsb2FkIiwiaGFzaGVkUGF5bG9hZCIsInJlYWxTaWduYXR1cmUiLCJwayIsIlB1YmxpY0tleSIsInZlcmlmeSIsImZldGNoQWxsVXNlcktleXMiLCJ2ZXJpZnlGdWxsS2V5QmVsb25nc1RvVXNlciIsInBlcm1pc3Npb24iLCJ1bmN1cnJ5VGhpcyQyIiwiZGVmaW5lQnVpbHRJbiIsInJlZ2V4cEV4ZWMkMiIsImZhaWxzJDEiLCJ3ZWxsS25vd25TeW1ib2wiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkiLCJTUEVDSUVTIiwiUmVnRXhwUHJvdG90eXBlIiwiZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMiLCJTSEFNIiwiU1lNQk9MIiwiREVMRUdBVEVTX1RPX1NZTUJPTCIsIkRFTEVHQVRFU19UT19FWEVDIiwiZXhlY0NhbGxlZCIsInVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZCIsIm5hdGl2ZU1ldGhvZCIsImFyZzIiLCJmb3JjZVN0cmluZ01ldGhvZCIsInVuY3VycmllZE5hdGl2ZU1ldGhvZCIsIiRleGVjIiwidW5jdXJyeVRoaXMkMSIsInRvSW50ZWdlck9ySW5maW5pdHkiLCJ0b1N0cmluZyQxIiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSQxIiwiY2hhckF0JDEiLCJjaGFyQ29kZUF0Iiwic3RyaW5nU2xpY2UkMSIsImNyZWF0ZU1ldGhvZCIsIkNPTlZFUlRfVE9fU1RSSU5HIiwicG9zIiwicG9zaXRpb24iLCJzaXplIiwic2Vjb25kIiwic3RyaW5nTXVsdGlieXRlIiwiY29kZUF0IiwiYWR2YW5jZVN0cmluZ0luZGV4JDEiLCJjYWxsJDEiLCJhbk9iamVjdCQxIiwiaXNDYWxsYWJsZSIsImNsYXNzb2YiLCJyZWdleHBFeGVjJDEiLCIkVHlwZUVycm9yIiwicmVnZXhwRXhlY0Fic3RyYWN0IiwiUiIsInVuY3VycnlUaGlzIiwiZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMiLCJhbk9iamVjdCIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCJzcGVjaWVzQ29uc3RydWN0b3IiLCJhZHZhbmNlU3RyaW5nSW5kZXgiLCJ0b0xlbmd0aCIsImdldE1ldGhvZCIsImFycmF5U2xpY2UiLCJjYWxsUmVnRXhwRXhlYyIsInJlZ2V4cEV4ZWMiLCJzdGlja3lIZWxwZXJzIiwiZmFpbHMiLCJNQVhfVUlOVDMyIiwiJHB1c2giLCJzdHJpbmdTbGljZSIsIlNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyIsIm9yaWdpbmFsRXhlYyIsIlNQTElUIiwibmF0aXZlU3BsaXQiLCJtYXliZUNhbGxOYXRpdmUiLCJpbnRlcm5hbFNwbGl0Iiwic2VwYXJhdG9yIiwibGltaXQiLCJsaW0iLCJvdXRwdXQiLCJsYXN0TGFzdEluZGV4Iiwic2VwYXJhdG9yQ29weSIsImxhc3RMZW5ndGgiLCJzcGxpdHRlciIsInJ4IiwicmVzIiwidW5pY29kZU1hdGNoaW5nIiwicCIsInEiLCJ6IiwibW9kYWwkYiIsImNvbm5lY3RZb3VyV2FsbGV0Iiwid2hhdElzQVdhbGxldCIsInNlY3VyZUFuZE1hbmFnZSIsInNhZmVseVN0b3JlIiwibG9nSW5Ub0FueSIsIm5vTmVlZFRvQ3JlYXRlIiwiZ2V0QVdhbGxldCIsInVzZUFXYWxsZXQiLCJjb25uZWN0aW9uRmFpbGVkIiwiY29ubmVjdGlvblN1Y2Nlc3NmdWwiLCJjb25uZWN0ZWQiLCJjb25uZWN0aW5nVG8iLCJjb25uZWN0aW5nTWVzc2FnZSIsImluamVjdGVkIiwiaGFyZHdhcmUiLCJicmlkZ2UiLCJsZWRnZXIiLCJjb25uZWN0V2l0aExlZGdlciIsIm1ha2VTdXJlWW91ckxlZGdlciIsInNwZWNpZnlIRFBhdGgiLCJlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGgiLCJyZXRyeSIsImxlZGdlcklzTm90QXZhaWxhYmxlIiwiYWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2UiLCJub0FjY291bnRzRm91bmQiLCJzZWxlY3RZb3VyQWNjb3VudHMiLCJjb25uZWN0aW5nMUFjY291bnQiLCJjYW50RmluZEFueUFjY291bnQiLCJvckNvbm5lY3RBbkFub3RoZXJMZWRnZXIiLCJjb25uZWN0aW5nIiwib2ZBY2NvdW50cyIsImZhaWxlZFRvQXV0b21hdGljYWxseSIsIm92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZCIsImZpbmlzaCIsImluc3RhbGwiLCJ5b3VsbE5lZWRUb0luc3RhbGwiLCJ0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nIiwicmVmcmVzaFRoZVBhZ2UiLCJxciIsImNvcGllZFRvQ2xpcGJvYXJkIiwiZmFpbGVkVG9Db3B5Iiwic2NhbldpdGhZb3VyTW9iaWxlIiwiY29weVRvQ2xpcGJvYXJkIiwicHJlZmVyVGhlT2ZmaWNpYWwiLCJ3YWxsZXRUeXBlcyIsIm1vYmlsZSIsImV4cG9ydEFjY291bnRzIiwiY2hvb3NlQVdhbGxldCIsInRyYW5zZmVyWW91ckFjY291bnRzIiwic2VsZWN0QVdhbGxldCIsImFmdGVyRGVjaWRlIiwiZGlzY2xhaW1lciIsIndhcm5pbmciLCJzZWxlY3RBY2NvdW50cyIsInRpdGxlIiwiYnV0dG9uIiwiZGVzZWxlY3RBbGwiLCJzZWxlY3RBbGwiLCJ1bmF2YWlsYWJsZSIsIndhcm5pbmdMZWRnZXIiLCJub0JhbGFuY2UiLCJnZXRQYXNzcGhyYXNlIiwiZGVzYyIsInRyYW5zZmVyQnV0dG9uIiwibGFiZWwiLCJjaGVja0xhYmVsIiwiY29tcGxldGUiLCJkZXNjT25lIiwiZGVzY1R3byIsInN0YXJ0T3ZlckJ1dHRvbiIsImNvbXBvbmVudCQxIiwiY2xpY2tUb0NvcHkiLCJ0b29sdGlwIiwiZW4iLCJtb2RhbCIsImNvbXBvbmVudCIsIm1vZGFsJGEiLCJlcyIsIm1vZGFsJDkiLCJ6aCIsIm1vZGFsJDgiLCJiZyIsIm1vZGFsJDciLCJrbyIsIm1vZGFsJDYiLCJ2aSIsIm1vZGFsJDUiLCJoaSIsIm1vZGFsJDQiLCJhciIsIm1vZGFsJDMiLCJociIsIm1vZGFsJDIiLCJtayIsIm1vZGFsJDEiLCJzbCIsInNyIiwiZ2V0TGFuZ3VhZ2UiLCJjaG9zZW5MYW5nIiwiYWxsb3dPbmx5TGFuZ3VhZ2UiLCJsYW5nQ29kZSIsInNob3J0ZW5MYW5ndWFnZUNvZGUiLCJsYW5nIiwiZmluZE9iamVjdFByb3BCeVN0cmluZ1BhdGgiLCJwcm9wIiwiX2luZGV4IiwiY3VycmVudFByb3AiLCJzdWJzdHJpbmciLCJuZXh0UHJvcCIsInRyYW5zbGF0ZSIsInBhdGgiLCJicm93c2VyTGFuZyIsImxhbmd1YWdlcyIsImxhbmd1YWdlIiwic2VsZWN0ZWRMYW5ndWFnZSIsInRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/core/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/here-wallet/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/here-wallet/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupHereWallet: () => (/* binding */ setupHereWallet)\n/* harmony export */ });\n/* harmony import */ var _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @here-wallet/core */ \"(ssr)/./node_modules/@here-wallet/core/build/index.js\");\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar check = function(it) {\n    return it && it.Math == Math && it;\n};\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$a = // eslint-disable-next-line es-x/no-global-this -- safe\ncheck(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\ncheck(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback\nfunction() {\n    return this;\n}() || Function(\"return this\")();\nvar objectGetOwnPropertyDescriptor = {};\nvar fails$a = function(exec) {\n    try {\n        return !!exec();\n    } catch (error) {\n        return true;\n    }\n};\nvar fails$9 = fails$a;\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$9(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty({}, 1, {\n        get: function() {\n            return 7;\n        }\n    })[1] != 7;\n});\nvar fails$8 = fails$a;\nvar functionBindNative = !fails$8(function() {\n    // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n    var test = (function() {}).bind();\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$1 = functionBindNative;\nvar call$6 = Function.prototype.call;\nvar functionCall = NATIVE_BIND$1 ? call$6.bind(call$6) : function() {\n    return call$6.apply(call$6, arguments);\n};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({\n    1: 2\n}, 1);\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n    var descriptor = getOwnPropertyDescriptor$1(this, V);\n    return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar createPropertyDescriptor$2 = function(bitmap, value) {\n    return {\n        enumerable: !(bitmap & 1),\n        configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        value: value\n    };\n};\nvar NATIVE_BIND = functionBindNative;\nvar FunctionPrototype$1 = Function.prototype;\nvar bind = FunctionPrototype$1.bind;\nvar call$5 = FunctionPrototype$1.call;\nvar uncurryThis$a = NATIVE_BIND && bind.bind(call$5, call$5);\nvar functionUncurryThis = NATIVE_BIND ? function(fn) {\n    return fn && uncurryThis$a(fn);\n} : function(fn) {\n    return fn && function() {\n        return call$5.apply(fn, arguments);\n    };\n};\nvar uncurryThis$9 = functionUncurryThis;\nvar toString$2 = uncurryThis$9({}.toString);\nvar stringSlice = uncurryThis$9(\"\".slice);\nvar classofRaw$1 = function(it) {\n    return stringSlice(toString$2(it), 8, -1);\n};\nvar uncurryThis$8 = functionUncurryThis;\nvar fails$7 = fails$a;\nvar classof$2 = classofRaw$1;\nvar $Object$3 = Object;\nvar split = uncurryThis$8(\"\".split);\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$7(function() {\n    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return !$Object$3(\"z\").propertyIsEnumerable(0);\n}) ? function(it) {\n    return classof$2(it) == \"String\" ? split(it, \"\") : $Object$3(it);\n} : $Object$3;\nvar $TypeError$5 = TypeError;\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function(it) {\n    if (it == undefined) throw $TypeError$5(\"Can't call method on \" + it);\n    return it;\n};\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\nvar toIndexedObject$3 = function(it) {\n    return IndexedObject$1(requireObjectCoercible$1(it));\n};\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$b = function(argument) {\n    return typeof argument == \"function\";\n};\nvar isCallable$a = isCallable$b;\nvar isObject$5 = function(it) {\n    return typeof it == \"object\" ? it !== null : isCallable$a(it);\n};\nvar global$9 = global$a;\nvar isCallable$9 = isCallable$b;\nvar aFunction = function(argument) {\n    return isCallable$9(argument) ? argument : undefined;\n};\nvar getBuiltIn$3 = function(namespace, method) {\n    return arguments.length < 2 ? aFunction(global$9[namespace]) : global$9[namespace] && global$9[namespace][method];\n};\nvar uncurryThis$7 = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$7({}.isPrototypeOf);\nvar getBuiltIn$2 = getBuiltIn$3;\nvar engineUserAgent = getBuiltIn$2(\"navigator\", \"userAgent\") || \"\";\nvar global$8 = global$a;\nvar userAgent = engineUserAgent;\nvar process = global$8.process;\nvar Deno = global$8.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n    match = v8.split(\".\");\n    // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n    // but their correct versions are not interesting for us\n    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n    match = userAgent.match(/Edge\\/(\\d+)/);\n    if (!match || match[1] >= 74) {\n        match = userAgent.match(/Chrome\\/(\\d+)/);\n        if (match) version = +match[1];\n    }\n}\nvar engineV8Version = version;\n/* eslint-disable es-x/no-symbol -- required for testing */ var V8_VERSION = engineV8Version;\nvar fails$6 = fails$a;\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$6(function() {\n    var symbol = Symbol();\n    // Chrome 38 Symbol has incorrect toString conversion\n    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n/* eslint-disable es-x/no-symbol -- required for testing */ var NATIVE_SYMBOL$1 = nativeSymbol;\nvar useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar getBuiltIn$1 = getBuiltIn$3;\nvar isCallable$8 = isCallable$b;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar $Object$2 = Object;\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {\n    return typeof it == \"symbol\";\n} : function(it) {\n    var $Symbol = getBuiltIn$1(\"Symbol\");\n    return isCallable$8($Symbol) && isPrototypeOf$1($Symbol.prototype, $Object$2(it));\n};\nvar $String$2 = String;\nvar tryToString$1 = function(argument) {\n    try {\n        return $String$2(argument);\n    } catch (error) {\n        return \"Object\";\n    }\n};\nvar isCallable$7 = isCallable$b;\nvar tryToString = tryToString$1;\nvar $TypeError$4 = TypeError;\n// `Assert: IsCallable(argument) is true`\nvar aCallable$1 = function(argument) {\n    if (isCallable$7(argument)) return argument;\n    throw $TypeError$4(tryToString(argument) + \" is not a function\");\n};\nvar aCallable = aCallable$1;\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$1 = function(V, P) {\n    var func = V[P];\n    return func == null ? undefined : aCallable(func);\n};\nvar call$4 = functionCall;\nvar isCallable$6 = isCallable$b;\nvar isObject$4 = isObject$5;\nvar $TypeError$3 = TypeError;\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function(input, pref) {\n    var fn, val;\n    if (pref === \"string\" && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n    if (isCallable$6(fn = input.valueOf) && !isObject$4(val = call$4(fn, input))) return val;\n    if (pref !== \"string\" && isCallable$6(fn = input.toString) && !isObject$4(val = call$4(fn, input))) return val;\n    throw $TypeError$3(\"Can't convert object to primitive value\");\n};\nvar shared$3 = {\n    exports: {}\n};\nvar global$7 = global$a;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\nvar defineGlobalProperty$3 = function(key, value) {\n    try {\n        defineProperty$2(global$7, key, {\n            value: value,\n            configurable: true,\n            writable: true\n        });\n    } catch (error) {\n        global$7[key] = value;\n    }\n    return value;\n};\nvar global$6 = global$a;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\nvar SHARED = \"__core-js_shared__\";\nvar store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$3.exports = function(key, value) {\n    return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})(\"versions\", []).push({\n    version: \"3.23.3\",\n    mode: \"global\",\n    copyright: \"\\xa9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n});\nvar requireObjectCoercible = requireObjectCoercible$2;\nvar $Object$1 = Object;\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function(argument) {\n    return $Object$1(requireObjectCoercible(argument));\n};\nvar uncurryThis$6 = functionUncurryThis;\nvar toObject$1 = toObject$2;\nvar hasOwnProperty = uncurryThis$6({}.hasOwnProperty);\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n    return hasOwnProperty(toObject$1(it), key);\n};\nvar uncurryThis$5 = functionUncurryThis;\nvar id = 0;\nvar postfix = Math.random();\nvar toString$1 = uncurryThis$5(1.0.toString);\nvar uid$2 = function(key) {\n    return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString$1(++id + postfix, 36);\n};\nvar global$5 = global$a;\nvar shared$2 = shared$3.exports;\nvar hasOwn$7 = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$2(\"wks\");\nvar Symbol$1 = global$5.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1[\"for\"];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\nvar wellKnownSymbol$3 = function(name) {\n    if (!hasOwn$7(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n        var description = \"Symbol.\" + name;\n        if (NATIVE_SYMBOL && hasOwn$7(Symbol$1, name)) {\n            WellKnownSymbolsStore[name] = Symbol$1[name];\n        } else if (USE_SYMBOL_AS_UID && symbolFor) {\n            WellKnownSymbolsStore[name] = symbolFor(description);\n        } else {\n            WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n        }\n    }\n    return WellKnownSymbolsStore[name];\n};\nvar call$3 = functionCall;\nvar isObject$3 = isObject$5;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod = getMethod$1;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$2 = wellKnownSymbol$3;\nvar $TypeError$2 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$2(\"toPrimitive\");\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function(input, pref) {\n    if (!isObject$3(input) || isSymbol$1(input)) return input;\n    var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n    var result;\n    if (exoticToPrim) {\n        if (pref === undefined) pref = \"default\";\n        result = call$3(exoticToPrim, input, pref);\n        if (!isObject$3(result) || isSymbol$1(result)) return result;\n        throw $TypeError$2(\"Can't convert object to primitive value\");\n    }\n    if (pref === undefined) pref = \"number\";\n    return ordinaryToPrimitive(input, pref);\n};\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function(argument) {\n    var key = toPrimitive(argument, \"string\");\n    return isSymbol(key) ? key : key + \"\";\n};\nvar global$4 = global$a;\nvar isObject$2 = isObject$5;\nvar document = global$4.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$2(document) && isObject$2(document.createElement);\nvar documentCreateElement = function(it) {\n    return EXISTS$1 ? document.createElement(it) : {};\n};\nvar DESCRIPTORS$7 = descriptors;\nvar fails$5 = fails$a;\nvar createElement = documentCreateElement;\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$7 && !fails$5(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(createElement(\"div\"), \"a\", {\n        get: function() {\n            return 7;\n        }\n    }).a != 7;\n});\nvar DESCRIPTORS$6 = descriptors;\nvar call$2 = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$2;\nvar toIndexedObject$2 = toIndexedObject$3;\nvar toPropertyKey$1 = toPropertyKey$2;\nvar hasOwn$6 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n    O = toIndexedObject$2(O);\n    P = toPropertyKey$1(P);\n    if (IE8_DOM_DEFINE$1) try {\n        return $getOwnPropertyDescriptor$1(O, P);\n    } catch (error) {}\n    if (hasOwn$6(O, P)) return createPropertyDescriptor$1(!call$2(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\nvar objectDefineProperty = {};\nvar DESCRIPTORS$5 = descriptors;\nvar fails$4 = fails$a;\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$5 && fails$4(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(function() {}, \"prototype\", {\n        value: 42,\n        writable: false\n    }).prototype != 42;\n});\nvar isObject$1 = isObject$5;\nvar $String$1 = String;\nvar $TypeError$1 = TypeError;\n// `Assert: Type(argument) is Object`\nvar anObject$4 = function(argument) {\n    if (isObject$1(argument)) return argument;\n    throw $TypeError$1($String$1(argument) + \" is not an object\");\n};\nvar DESCRIPTORS$4 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar anObject$3 = anObject$4;\nvar toPropertyKey = toPropertyKey$2;\nvar $TypeError = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = \"enumerable\";\nvar CONFIGURABLE$1 = \"configurable\";\nvar WRITABLE = \"writable\";\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n    anObject$3(O);\n    P = toPropertyKey(P);\n    anObject$3(Attributes);\n    if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n        var current = $getOwnPropertyDescriptor(O, P);\n        if (current && current[WRITABLE]) {\n            O[P] = Attributes.value;\n            Attributes = {\n                configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                writable: false\n            };\n        }\n    }\n    return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n    anObject$3(O);\n    P = toPropertyKey(P);\n    anObject$3(Attributes);\n    if (IE8_DOM_DEFINE) try {\n        return $defineProperty(O, P, Attributes);\n    } catch (error) {}\n    if (\"get\" in Attributes || \"set\" in Attributes) throw $TypeError(\"Accessors not supported\");\n    if (\"value\" in Attributes) O[P] = Attributes.value;\n    return O;\n};\nvar DESCRIPTORS$3 = descriptors;\nvar definePropertyModule$2 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$2;\nvar createNonEnumerableProperty$2 = DESCRIPTORS$3 ? function(object, key, value) {\n    return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));\n} : function(object, key, value) {\n    object[key] = value;\n    return object;\n};\nvar makeBuiltIn$2 = {\n    exports: {}\n};\nvar DESCRIPTORS$2 = descriptors;\nvar hasOwn$5 = hasOwnProperty_1;\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$5(FunctionPrototype, \"name\");\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() {}).name === \"something\";\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$2 || DESCRIPTORS$2 && getDescriptor(FunctionPrototype, \"name\").configurable);\nvar functionName = {\n    EXISTS: EXISTS,\n    PROPER: PROPER,\n    CONFIGURABLE: CONFIGURABLE\n};\nvar uncurryThis$4 = functionUncurryThis;\nvar isCallable$5 = isCallable$b;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$4(Function.toString);\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$5(store$1.inspectSource)) {\n    store$1.inspectSource = function(it) {\n        return functionToString(it);\n    };\n}\nvar inspectSource$2 = store$1.inspectSource;\nvar global$3 = global$a;\nvar isCallable$4 = isCallable$b;\nvar inspectSource$1 = inspectSource$2;\nvar WeakMap$1 = global$3.WeakMap;\nvar nativeWeakMap = isCallable$4(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\nvar keys = shared$1(\"keys\");\nvar sharedKey$1 = function(key) {\n    return keys[key] || (keys[key] = uid(key));\n};\nvar hiddenKeys$3 = {};\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$2 = global$a;\nvar uncurryThis$3 = functionUncurryThis;\nvar isObject = isObject$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$2;\nvar hasOwn$4 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey = sharedKey$1;\nvar hiddenKeys$2 = hiddenKeys$3;\nvar OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\nvar TypeError$1 = global$2.TypeError;\nvar WeakMap = global$2.WeakMap;\nvar set, get, has;\nvar enforce = function(it) {\n    return has(it) ? get(it) : set(it, {});\n};\nvar getterFor = function(TYPE) {\n    return function(it) {\n        var state;\n        if (!isObject(it) || (state = get(it)).type !== TYPE) {\n            throw TypeError$1(\"Incompatible receiver, \" + TYPE + \" required\");\n        }\n        return state;\n    };\n};\nif (NATIVE_WEAK_MAP || shared.state) {\n    var store = shared.state || (shared.state = new WeakMap());\n    var wmget = uncurryThis$3(store.get);\n    var wmhas = uncurryThis$3(store.has);\n    var wmset = uncurryThis$3(store.set);\n    set = function(it, metadata) {\n        if (wmhas(store, it)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        wmset(store, it, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return wmget(store, it) || {};\n    };\n    has = function(it) {\n        return wmhas(store, it);\n    };\n} else {\n    var STATE = sharedKey(\"state\");\n    hiddenKeys$2[STATE] = true;\n    set = function(it, metadata) {\n        if (hasOwn$4(it, STATE)) throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        createNonEnumerableProperty$1(it, STATE, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return hasOwn$4(it, STATE) ? it[STATE] : {};\n    };\n    has = function(it) {\n        return hasOwn$4(it, STATE);\n    };\n}\nvar internalState = {\n    set: set,\n    get: get,\n    has: has,\n    enforce: enforce,\n    getterFor: getterFor\n};\nvar fails$3 = fails$a;\nvar isCallable$3 = isCallable$b;\nvar hasOwn$3 = hasOwnProperty_1;\nvar DESCRIPTORS$1 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\nvar inspectSource = inspectSource$2;\nvar InternalStateModule = internalState;\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$1 = Object.defineProperty;\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$1 && !fails$3(function() {\n    return defineProperty$1(function() {}, \"length\", {\n        value: 8\n    }).length !== 8;\n});\nvar TEMPLATE = String(String).split(\"String\");\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {\n    if (String(name).slice(0, 7) === \"Symbol(\") {\n        name = \"[\" + String(name).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n    }\n    if (options && options.getter) name = \"get \" + name;\n    if (options && options.setter) name = \"set \" + name;\n    if (!hasOwn$3(value, \"name\") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n        if (DESCRIPTORS$1) defineProperty$1(value, \"name\", {\n            value: name,\n            configurable: true\n        });\n        else value.name = name;\n    }\n    if (CONFIGURABLE_LENGTH && options && hasOwn$3(options, \"arity\") && value.length !== options.arity) {\n        defineProperty$1(value, \"length\", {\n            value: options.arity\n        });\n    }\n    try {\n        if (options && hasOwn$3(options, \"constructor\") && options.constructor) {\n            if (DESCRIPTORS$1) defineProperty$1(value, \"prototype\", {\n                writable: false\n            });\n        // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n        } else if (value.prototype) value.prototype = undefined;\n    } catch (error) {}\n    var state = enforceInternalState(value);\n    if (!hasOwn$3(state, \"source\")) {\n        state.source = TEMPLATE.join(typeof name == \"string\" ? name : \"\");\n    }\n    return value;\n};\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n    return isCallable$3(this) && getInternalState(this).source || inspectSource(this);\n}, \"toString\");\nvar isCallable$2 = isCallable$b;\nvar definePropertyModule$1 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\nvar defineBuiltIn$2 = function(O, key, value, options) {\n    if (!options) options = {};\n    var simple = options.enumerable;\n    var name = options.name !== undefined ? options.name : key;\n    if (isCallable$2(value)) makeBuiltIn(value, name, options);\n    if (options.global) {\n        if (simple) O[key] = value;\n        else defineGlobalProperty$1(key, value);\n    } else {\n        try {\n            if (!options.unsafe) delete O[key];\n            else if (O[key]) simple = true;\n        } catch (error) {}\n        if (simple) O[key] = value;\n        else definePropertyModule$1.f(O, key, {\n            value: value,\n            enumerable: false,\n            configurable: !options.nonConfigurable,\n            writable: !options.nonWritable\n        });\n    }\n    return O;\n};\nvar objectGetOwnPropertyNames = {};\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n    var n = +x;\n    return (n > 0 ? floor : ceil)(n);\n};\nvar trunc = mathTrunc;\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function(argument) {\n    var number = +argument;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number !== number || number === 0 ? 0 : trunc(number);\n};\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\nvar max = Math.max;\nvar min$1 = Math.min;\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function(index, length) {\n    var integer = toIntegerOrInfinity$1(index);\n    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\nvar min = Math.min;\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function(argument) {\n    return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\nvar toLength = toLength$1;\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$1 = function(obj) {\n    return toLength(obj.length);\n};\nvar toIndexedObject$1 = toIndexedObject$3;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike = lengthOfArrayLike$1;\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function(IS_INCLUDES) {\n    return function($this, el, fromIndex) {\n        var O = toIndexedObject$1($this);\n        var length = lengthOfArrayLike(O);\n        var index = toAbsoluteIndex(fromIndex, length);\n        var value;\n        // Array#includes uses SameValueZero equality algorithm\n        // eslint-disable-next-line no-self-compare -- NaN check\n        if (IS_INCLUDES && el != el) while(length > index){\n            value = O[index++];\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (value != value) return true;\n        // Array#indexOf ignores holes, Array#includes - not\n        }\n        else for(; length > index; index++){\n            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n        }\n        return !IS_INCLUDES && -1;\n    };\n};\nvar arrayIncludes = {\n    // `Array.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-array.prototype.includes\n    includes: createMethod(true),\n    // `Array.prototype.indexOf` method\n    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n    indexOf: createMethod(false)\n};\nvar uncurryThis$2 = functionUncurryThis;\nvar hasOwn$2 = hasOwnProperty_1;\nvar toIndexedObject = toIndexedObject$3;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$1 = hiddenKeys$3;\nvar push = uncurryThis$2([].push);\nvar objectKeysInternal = function(object, names) {\n    var O = toIndexedObject(object);\n    var i = 0;\n    var result = [];\n    var key;\n    for(key in O)!hasOwn$2(hiddenKeys$1, key) && hasOwn$2(O, key) && push(result, key);\n    // Don't enum bug & hidden keys\n    while(names.length > i)if (hasOwn$2(O, key = names[i++])) {\n        ~indexOf(result, key) || push(result, key);\n    }\n    return result;\n};\n// IE8- don't enum bug keys\nvar enumBugKeys$2 = [\n    \"constructor\",\n    \"hasOwnProperty\",\n    \"isPrototypeOf\",\n    \"propertyIsEnumerable\",\n    \"toLocaleString\",\n    \"toString\",\n    \"valueOf\"\n];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$2;\nvar hiddenKeys = enumBugKeys$1.concat(\"length\", \"prototype\");\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return internalObjectKeys$1(O, hiddenKeys);\n};\nvar objectGetOwnPropertySymbols = {};\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn = getBuiltIn$3;\nvar uncurryThis$1 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$2 = anObject$4;\nvar concat$1 = uncurryThis$1([].concat);\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n    var keys = getOwnPropertyNamesModule.f(anObject$2(it));\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n    return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\nvar hasOwn$1 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule = objectDefineProperty;\nvar copyConstructorProperties$1 = function(target, source, exceptions) {\n    var keys = ownKeys(source);\n    var defineProperty = definePropertyModule.f;\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        if (!hasOwn$1(target, key) && !(exceptions && hasOwn$1(exceptions, key))) {\n            defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n        }\n    }\n};\nvar fails$2 = fails$a;\nvar isCallable$1 = isCallable$b;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$1 = function(feature, detection) {\n    var value = data[normalize(feature)];\n    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$1(detection) ? fails$2(detection) : !!detection;\n};\nvar normalize = isForced$1.normalize = function(string) {\n    return String(string).replace(replacement, \".\").toLowerCase();\n};\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = \"N\";\nvar POLYFILL = isForced$1.POLYFILL = \"P\";\nvar isForced_1 = isForced$1;\nvar global$1 = global$a;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty = createNonEnumerableProperty$2;\nvar defineBuiltIn$1 = defineBuiltIn$2;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced = isForced_1;\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ var _export = function(options, source) {\n    var TARGET = options.target;\n    var GLOBAL = options.global;\n    var STATIC = options.stat;\n    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n    if (GLOBAL) {\n        target = global$1;\n    } else if (STATIC) {\n        target = global$1[TARGET] || defineGlobalProperty(TARGET, {});\n    } else {\n        target = (global$1[TARGET] || {}).prototype;\n    }\n    if (target) for(key in source){\n        sourceProperty = source[key];\n        if (options.dontCallGetSet) {\n            descriptor = getOwnPropertyDescriptor(target, key);\n            targetProperty = descriptor && descriptor.value;\n        } else targetProperty = target[key];\n        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n        // contained in target\n        if (!FORCED && targetProperty !== undefined) {\n            if (typeof sourceProperty == typeof targetProperty) continue;\n            copyConstructorProperties(sourceProperty, targetProperty);\n        }\n        // add a flag to not completely full polyfills\n        if (options.sham || targetProperty && targetProperty.sham) {\n            createNonEnumerableProperty(sourceProperty, \"sham\", true);\n        }\n        defineBuiltIn$1(target, key, sourceProperty, options);\n    }\n};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$2;\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n    return internalObjectKeys(O, enumBugKeys);\n};\nvar DESCRIPTORS = descriptors;\nvar uncurryThis = functionUncurryThis;\nvar call$1 = functionCall;\nvar fails$1 = fails$a;\nvar objectKeys = objectKeys$1;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject = toObject$2;\nvar IndexedObject = indexedObject;\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\nvar concat = uncurryThis([].concat);\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$1(function() {\n    // should have correct order of operations (Edge bug)\n    if (DESCRIPTORS && $assign({\n        b: 1\n    }, $assign(defineProperty({}, \"a\", {\n        enumerable: true,\n        get: function() {\n            defineProperty(this, \"b\", {\n                value: 3,\n                enumerable: false\n            });\n        }\n    }), {\n        b: 2\n    })).b !== 1) return true;\n    // should work with symbols and should have deterministic property order (V8 bug)\n    var A = {};\n    var B = {};\n    // eslint-disable-next-line es-x/no-symbol -- safe\n    var symbol = Symbol();\n    var alphabet = \"abcdefghijklmnopqrst\";\n    A[symbol] = 7;\n    alphabet.split(\"\").forEach(function(chr) {\n        B[chr] = chr;\n    });\n    return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\"\") != alphabet;\n}) ? function assign(target, source) {\n    var T = toObject(target);\n    var argumentsLength = arguments.length;\n    var index = 1;\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n    var propertyIsEnumerable = propertyIsEnumerableModule.f;\n    while(argumentsLength > index){\n        var S = IndexedObject(arguments[index++]);\n        var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n        var length = keys.length;\n        var j = 0;\n        var key;\n        while(length > j){\n            key = keys[j++];\n            if (!DESCRIPTORS || call$1(propertyIsEnumerable, S, key)) T[key] = S[key];\n        }\n    }\n    return T;\n} : $assign;\nvar $ = _export;\nvar assign = objectAssign;\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$({\n    target: \"Object\",\n    stat: true,\n    arity: 2,\n    forced: Object.assign !== assign\n}, {\n    assign: assign\n});\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar wellKnownSymbol$1 = wellKnownSymbol$3;\nvar TO_STRING_TAG$1 = wellKnownSymbol$1(\"toStringTag\");\nvar test = {};\ntest[TO_STRING_TAG$1] = \"z\";\nvar toStringTagSupport = String(test) === \"[object z]\";\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable = isCallable$b;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol = wellKnownSymbol$3;\nvar TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\nvar $Object = Object;\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function() {\n    return arguments;\n}()) == \"Arguments\";\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key) {\n    try {\n        return it[key];\n    } catch (error) {}\n};\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n    var O, tag, result;\n    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && isCallable(O.callee) ? \"Arguments\" : result;\n};\nvar classof = classof$1;\nvar $String = String;\nvar toString = function(argument) {\n    if (classof(argument) === \"Symbol\") throw TypeError(\"Cannot convert a Symbol value to a string\");\n    return $String(argument);\n};\nvar anObject$1 = anObject$4;\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function() {\n    var that = anObject$1(this);\n    var result = \"\";\n    if (that.hasIndices) result += \"d\";\n    if (that.global) result += \"g\";\n    if (that.ignoreCase) result += \"i\";\n    if (that.multiline) result += \"m\";\n    if (that.dotAll) result += \"s\";\n    if (that.unicode) result += \"u\";\n    if (that.unicodeSets) result += \"v\";\n    if (that.sticky) result += \"y\";\n    return result;\n};\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\nvar RegExpPrototype$1 = RegExp.prototype;\nvar regexpGetFlags = function(R) {\n    var flags = R.flags;\n    return flags === undefined && !(\"flags\" in RegExpPrototype$1) && !hasOwn(R, \"flags\") && isPrototypeOf(RegExpPrototype$1, R) ? call(regExpFlags, R) : flags;\n};\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$2;\nvar anObject = anObject$4;\nvar $toString = toString;\nvar fails = fails$a;\nvar getRegExpFlags = regexpGetFlags;\nvar TO_STRING = \"toString\";\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\nvar NOT_GENERIC = fails(function() {\n    return n$ToString.call({\n        source: \"a\",\n        flags: \"b\"\n    }) != \"/a/b\";\n});\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n    defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n        var R = anObject(this);\n        var pattern = $toString(R.source);\n        var flags = $toString(getRegExpFlags(R));\n        return \"/\" + pattern + \"/\" + flags;\n    }, {\n        unsafe: true\n    });\n}\nconst initHereWallet = (config)=>__awaiter(void 0, void 0, void 0, function*() {\n        const { store, logger, emitter, options, defaultProvider, defaultStrategy } = config;\n        const here = new _here_wallet_core__WEBPACK_IMPORTED_MODULE_0__.HereWallet({\n            networkId: options.network.networkId,\n            nodeUrl: options.network.nodeUrl,\n            defaultProvider,\n            defaultStrategy\n        });\n        function getAccounts() {\n            return __awaiter(this, void 0, void 0, function*() {\n                logger.log(\"HereWallet:getAccounts\");\n                const accountIds = yield here.getAccounts();\n                const accounts = [];\n                for(let i = 0; i < accountIds.length; i++){\n                    accounts.push({\n                        accountId: accountIds[i],\n                        publicKey: (yield here.signer.getPublicKey(accountIds[i], options.network.networkId)).toString()\n                    });\n                }\n                return accounts;\n            });\n        }\n        return {\n            get networkId () {\n                return here.networkId;\n            },\n            buildImportAccountsUrl () {\n                return `https://my.herewallet.app/import?network=${options.network.networkId}`;\n            },\n            account (id) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:account\");\n                    return yield here.account(id);\n                });\n            },\n            switchAccount (id) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:switchAccount\");\n                    yield here.switchAccount(id);\n                });\n            },\n            getAccountId () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:getAccountId\");\n                    return yield here.getAccountId();\n                });\n            },\n            isSignedIn () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:isSignedIn\");\n                    return yield here.isSignedIn();\n                });\n            },\n            signIn (data) {\n                var _a;\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:signIn\");\n                    const contractId = data.contractId !== \"\" ? data.contractId : undefined;\n                    yield here.signIn(Object.assign(Object.assign({}, data), {\n                        contractId: contractId\n                    }));\n                    emitter.emit(\"signedIn\", {\n                        contractId: data.contractId,\n                        methodNames: (_a = data.methodNames) !== null && _a !== void 0 ? _a : [],\n                        accounts: yield getAccounts()\n                    });\n                    return yield getAccounts();\n                });\n            },\n            getHereBalance () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:getHereBalance\");\n                    return yield here.getHereBalance();\n                });\n            },\n            getAvailableBalance () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:getAvailableBalance\");\n                    return yield here.getAvailableBalance();\n                });\n            },\n            signOut () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:signOut\");\n                    yield here.signOut();\n                });\n            },\n            getAccounts () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    return getAccounts();\n                });\n            },\n            signAndSendTransaction (data) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:signAndSendTransaction\", data);\n                    const { contract } = store.getState();\n                    if (!here.isSignedIn || !contract) {\n                        throw new Error(\"Wallet not signed in\");\n                    }\n                    return yield here.signAndSendTransaction(Object.assign({\n                        receiverId: contract.contractId\n                    }, data));\n                });\n            },\n            verifyOwner () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    throw Error(\"HereWallet:verifyOwner is deprecated, use signMessage method with implementation NEP0413 Standard\");\n                });\n            },\n            signMessage (data) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:signMessage\", data);\n                    return yield here.signMessage(data);\n                });\n            },\n            signAndSendTransactions (data) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"HereWallet:signAndSendTransactions\", data);\n                    return yield here.signAndSendTransactions(data);\n                });\n            }\n        };\n    });\nvar icon = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xOS43MzM1IDExLjY4MzFMMjEuNzA4OSA4TDI0LjI5ODMgMTYuNjc2NkwyMC40MTYgMTQuOTIxNUwxOS43MzM1IDExLjY4MzFaTTUuNzYzODggMTUuNTQwOUwzLjc1NTYyIDE5LjE2MjFMOS44OTYwNSAyMi4xNjYxTDE4LjM0NzMgMjEuNTgyOEw1Ljc2Mzg4IDE1LjU0MDlaTTQuNjQ0NjQgMjIuMzY5NEwyLjY0ODY1IDI1Ljk3MTNMMTQuOTA4MyAzMi4wNTc1TDM1LjMzODggMzAuODE3NEwzNy4zMzQ4IDI3LjIxNTRMMTYuOTA0MyAyOC40NTU3TDQuNjQ0NjQgMjIuMzY5NFoiIGZpbGw9IiMyQzMwMzQiLz4KPHBhdGggZD0iTTM3LjMzNTkgMjcuMjE1N0wxNi45MTEyIDI4LjQ1NjFMNC41NDYzMyAyMi4zNTU0TDE3LjkzNTggMjEuNTQ1M0w1Ljc2Mzg3IDE1LjU0MDlMMTEuNzQxIDEwLjQ3ODZMMjQuMTQwMSAxNi41NzYzTDIxLjcwOSA4TDMzLjU1NyAxMy44MUwzNy4zMzU5IDI3LjIxNTdaIiBmaWxsPSIjRkRCRjFDIi8+Cjwvc3ZnPgo=\";\nfunction setupHereWallet({ deprecated = false, iconUrl = icon, defaultStrategy, defaultProvider } = {}) {\n    return ()=>__awaiter(this, void 0, void 0, function*() {\n            return {\n                id: \"here-wallet\",\n                type: \"injected\",\n                metadata: {\n                    name: \"Here Wallet\",\n                    description: \"Mobile wallet for NEAR Protocol\",\n                    useUrlAccountImport: true,\n                    downloadUrl: \"https://herewallet.app\",\n                    iconUrl,\n                    deprecated,\n                    available: true\n                },\n                init: (config)=>initHereWallet(Object.assign(Object.assign({}, config), {\n                        defaultStrategy,\n                        defaultProvider\n                    }))\n            };\n        });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2hlcmUtd2FsbGV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDO0FBRS9DLElBQUlDLGlCQUFpQixPQUFPQyxlQUFlLGNBQWNBLGFBQWEsTUFBa0IsR0FBY0MsQ0FBTUEsR0FBRyxPQUFPQyxXQUFXLGNBQWNBLFNBQVMsT0FBT0MsU0FBUyxjQUFjQSxPQUFPLENBQUM7QUFFOUwsSUFBSUMsUUFBUSxTQUFVQyxFQUFFO0lBQ3RCLE9BQU9BLE1BQU1BLEdBQUdDLElBQUksSUFBSUEsUUFBUUQ7QUFDbEM7QUFFQSx1RUFBdUU7QUFDdkUsSUFBSUUsV0FDRix1REFBdUQ7QUFDdkRILE1BQU0sT0FBT0osY0FBYyxZQUFZQSxlQUN2Q0ksTUFBTSxNQUFpQixJQUFZSCxDQUFNQSxLQUN6Qyx5REFBeUQ7QUFDekRHLE1BQU0sT0FBT0QsUUFBUSxZQUFZQSxTQUNqQ0MsTUFBTSxPQUFPTCxrQkFBa0IsWUFBWUEsbUJBRTNDLG1EQURtRDtBQUNsRDtJQUFjLE9BQU8sSUFBSTtBQUFFLE9BQVFTLFNBQVM7QUFFL0MsSUFBSUMsaUNBQWlDLENBQUM7QUFFdEMsSUFBSUMsVUFBVSxTQUFVQyxJQUFJO0lBQzFCLElBQUk7UUFDRixPQUFPLENBQUMsQ0FBQ0E7SUFDWCxFQUFFLE9BQU9DLE9BQU87UUFDZCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLElBQUlDLFVBQVVIO0FBRWQsd0RBQXdEO0FBQ3hELElBQUlJLGNBQWMsQ0FBQ0QsUUFBUTtJQUN6QixpRkFBaUY7SUFDakYsT0FBT0UsT0FBT0MsY0FBYyxDQUFDLENBQUMsR0FBRyxHQUFHO1FBQUVDLEtBQUs7WUFBYyxPQUFPO1FBQUc7SUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJO0FBQ2hGO0FBRUEsSUFBSUMsVUFBVVI7QUFFZCxJQUFJUyxxQkFBcUIsQ0FBQ0QsUUFBUTtJQUNoQyxtRUFBbUU7SUFDbkUsSUFBSUUsT0FBTyxDQUFDLFlBQTBCLEdB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LEdBQUc7WUFDM0MsT0FBTztnQkFDTG5SLElBQUk7Z0JBQ0oySCxNQUFNO2dCQUNOSyxVQUFVO29CQUNSL0csTUFBTTtvQkFDTkMsYUFBYTtvQkFDYjBXLHFCQUFxQjtvQkFDckJDLGFBQWE7b0JBQ2JGO29CQUNBRDtvQkFDQUksV0FBVztnQkFDYjtnQkFDQUMsTUFBTTVDLENBQUFBLFNBQVVELGVBQWVoZSxPQUFPb1osTUFBTSxDQUFDcFosT0FBT29aLE1BQU0sQ0FBQyxDQUFDLEdBQUc2RSxTQUFTO3dCQUN0RUk7d0JBQ0FEO29CQUNGO1lBQ0Y7UUFDRjtBQUNGO0FBRTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaS1hbS1uZWFyYnkvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2hlcmUtd2FsbGV0L2luZGV4LmpzP2VkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGVyZVdhbGxldCB9IGZyb20gJ0BoZXJlLXdhbGxldC9jb3JlJztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkYSA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRhID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyQ5ID0gZmFpbHMkYTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyQ5KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxudmFyIGZhaWxzJDggPSBmYWlscyRhO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJDYgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDEgPyBjYWxsJDYuYmluZChjYWxsJDYpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCQ2LmFwcGx5KGNhbGwkNiwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBOQVRJVkVfQklORCA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCA9IEZ1bmN0aW9uUHJvdG90eXBlJDEuYmluZDtcbnZhciBjYWxsJDUgPSBGdW5jdGlvblByb3RvdHlwZSQxLmNhbGw7XG52YXIgdW5jdXJyeVRoaXMkYSA9IE5BVElWRV9CSU5EICYmIGJpbmQuYmluZChjYWxsJDUsIGNhbGwkNSk7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQgPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzJGEoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJDUuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyQyID0gdW5jdXJyeVRoaXMkOSh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyQ5KCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmckMihpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQ3ID0gZmFpbHMkYTtcbnZhciBjbGFzc29mJDIgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDMgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyQ4KCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQzKCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiQyKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDMoaXQpO1xufSA6ICRPYmplY3QkMztcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkNShcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMSA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoaXQpKTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkYiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRiO1xuXG52YXIgaXNPYmplY3QkNSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGEoaXQpO1xufTtcblxudmFyIGdsb2JhbCQ5ID0gZ2xvYmFsJGE7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRiO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJDkoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkOVtuYW1lc3BhY2VdKSA6IGdsb2JhbCQ5W25hbWVzcGFjZV0gJiYgZ2xvYmFsJDlbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJDcoe30uaXNQcm90b3R5cGVPZik7XG5cbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDM7XG5cbnZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluJDIoJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJGE7XG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbCQ4LnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbCQ4LkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkNiA9IGZhaWxzJGE7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJDYoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDEgPSBuYXRpdmVTeW1ib2w7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMVxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kMztcbnZhciBpc0NhbGxhYmxlJDggPSBpc0NhbGxhYmxlJGI7XG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQyID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4kMSgnU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlJDgoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZiQxKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0JDIoaXQpKTtcbn07XG5cbnZhciAkU3RyaW5nJDIgPSBTdHJpbmc7XG5cbnZhciB0cnlUb1N0cmluZyQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmckMihhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG52YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRiO1xudmFyIHRyeVRvU3RyaW5nID0gdHJ5VG9TdHJpbmckMTtcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSQ3KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQxO1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG52YXIgZ2V0TWV0aG9kJDEgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuXG52YXIgY2FsbCQ0ID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkYjtcbnZhciBpc09iamVjdCQ0ID0gaXNPYmplY3QkNTtcblxudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSQ2KGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ0KHZhbCA9IGNhbGwkNChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkNihmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCQ0KHZhbCA9IGNhbGwkNChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkNihmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJDQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkMyhcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBzaGFyZWQkMyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkNyA9IGdsb2JhbCRhO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQyKGdsb2JhbCQ3LCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCQ3W2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkYTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkNltTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkMy5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyO1xuXG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkNiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDI7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJDYoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JDEoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDEgPSB1bmN1cnJ5VGhpcyQ1KDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQxKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkYTtcbnZhciBzaGFyZWQkMiA9IHNoYXJlZCQzLmV4cG9ydHM7XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHVpZCQxID0gdWlkJDI7XG52YXIgTkFUSVZFX1NZTUJPTCA9IG5hdGl2ZVN5bWJvbDtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkJDIoJ3drcycpO1xudmFyIFN5bWJvbCQxID0gZ2xvYmFsJDUuU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCQxICYmIFN5bWJvbCQxWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQkMTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kNyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzT3duJDcoU3ltYm9sJDEsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG5cbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkMyA9IGlzT2JqZWN0JDU7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDI7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDE7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCQzO1xuXG52YXIgJFR5cGVFcnJvciQyID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCQyKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQzKGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsJDMoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdCQzKHJlc3VsdCkgfHwgaXNTeW1ib2wkMShyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93ICRUeXBlRXJyb3IkMihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHRvUHJpbWl0aXZlJDE7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQyO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkYTtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkNTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsJDQuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JDIoZG9jdW1lbnQpICYmIGlzT2JqZWN0JDIoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkNSA9IGZhaWxzJGE7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudDtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJDcgJiYgIWZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMjtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCQzO1xudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkMjtcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJDYgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDIoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDEoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biQ2KE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEoIWNhbGwkMihwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJDQgPSBmYWlscyRhO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJDUgJiYgZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JDU7XG5cbnZhciAkU3RyaW5nJDEgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG52YXIgYW5PYmplY3QkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QkMShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQxKCRTdHJpbmckMShhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkNDtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQyO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDQgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkMyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0JDMoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JDMoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdCQzKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMjtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gREVTQ1JJUFRPUlMkMyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDIuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIG1ha2VCdWlsdEluJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkMiA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biQ1KEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyQyIHx8IChERVNDUklQVE9SUyQyICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGI7XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJDQoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkNShzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkMiA9IHN0b3JlJDEuaW5zcGVjdFNvdXJjZTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJGE7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRiO1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkMjtcblxudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCQzLldlYWtNYXA7XG5cbnZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZSQ0KFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UkMShXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQxID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMSgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDMgPSB7fTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkYTtcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCA9IGlzT2JqZWN0JDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMjtcbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgc2hhcmVkID0gc2hhcmVkU3RvcmU7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDE7XG52YXIgaGlkZGVuS2V5cyQyID0gaGlkZGVuS2V5cyQzO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDIuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkMi5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDEoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyQzKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJDMoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkMyhzdG9yZS5zZXQpO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkMShPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkMltTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ0KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMShPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDQoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDQoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgZmFpbHMkMyA9IGZhaWxzJGE7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRiO1xudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDI7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkMSAmJiAhZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQxKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQzKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUyQxKSBkZWZpbmVQcm9wZXJ0eSQxKHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duJDMob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ2xlbmd0aCcsIHsgdmFsdWU6IG9wdGlvbnMuYXJpdHkgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24kMyhvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMkMSkgZGVmaW5lUHJvcGVydHkkMSh2YWx1ZSwgJ3Byb3RvdHlwZScsIHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgaWYgKCFoYXNPd24kMyhzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZSAtLSByZXF1aXJlZFxuRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gbWFrZUJ1aWx0SW4kMShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkMyh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJDIgPSBpc0NhbGxhYmxlJGI7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJDIodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbWF0aC10cnVuYyAtLSBzYWZlXG52YXIgbWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciA6IGNlaWwpKG4pO1xufTtcblxudmFyIHRydW5jID0gbWF0aFRydW5jO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQyO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JDM7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDE7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQxO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkMSgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JDM7XG52YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDEgPSBoaWRkZW5LZXlzJDM7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMkMihbXS5wdXNoKTtcblxudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDIoaGlkZGVuS2V5cyQxLCBrZXkpICYmIGhhc093biQyKE8sIGtleSkgJiYgcHVzaChyZXN1bHQsIGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXNPd24kMihPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCBwdXNoKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMiA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMjtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cyQxLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBoaWRkZW5LZXlzKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBnZXRCdWlsdEluID0gZ2V0QnVpbHRJbiQzO1xudmFyIHVuY3VycnlUaGlzJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCQ0O1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyQxKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0JDIoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMShrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG52YXIgaGFzT3duJDEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIG93bktleXMgPSBvd25LZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24kMSh0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093biQxKGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFpbHMkMiA9IGZhaWxzJGE7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRiO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZSQxKGRldGVjdGlvbikgPyBmYWlscyQyKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDEubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQxLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQxLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDEuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMTtcblxudmFyIGdsb2JhbCQxID0gZ2xvYmFsJGE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDI7XG52YXIgZGVmaW5lQnVpbHRJbiQxID0gZGVmaW5lQnVpbHRJbiQyO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbCQxO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbCQxW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbCQxW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4kMSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMjtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbnZhciBvYmplY3RLZXlzJDEgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIGZhaWxzJDEgPSBmYWlscyRhO1xudmFyIG9iamVjdEtleXMgPSBvYmplY3RLZXlzJDE7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQyO1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KG9iamVjdEtleXMoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBjYWxsJDEocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyIGFzc2lnbiA9IG9iamVjdEFzc2lnbjtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgYXJpdHk6IDIsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduIH0sIHtcbiAgYXNzaWduOiBhc3NpZ25cbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDEgPSB3ZWxsS25vd25TeW1ib2wkMztcblxudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCQxKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHJDFdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkYjtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCQzO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxudmFyIGNsYXNzb2YkMSA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciBjbGFzc29mID0gY2xhc3NvZiQxO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCQ0O1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkMSh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciByZWdFeHBGbGFncyA9IHJlZ2V4cEZsYWdzO1xuXG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgcmVnZXhwR2V0RmxhZ3MgPSBmdW5jdGlvbiAoUikge1xuICB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuICByZXR1cm4gZmxhZ3MgPT09IHVuZGVmaW5lZCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlJDEpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUkMSwgUilcbiAgICA/IGNhbGwocmVnRXhwRmxhZ3MsIFIpIDogZmxhZ3M7XG59O1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDI7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCQ0O1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nO1xudmFyIGZhaWxzID0gZmFpbHMkYTtcbnZhciBnZXRSZWdFeHBGbGFncyA9IHJlZ2V4cEdldEZsYWdzO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG4kVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbiRUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBuJFRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICBkZWZpbmVCdWlsdEluKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICB2YXIgcGF0dGVybiA9ICR0b1N0cmluZyhSLnNvdXJjZSk7XG4gICAgdmFyIGZsYWdzID0gJHRvU3RyaW5nKGdldFJlZ0V4cEZsYWdzKFIpKTtcbiAgICByZXR1cm4gJy8nICsgcGF0dGVybiArICcvJyArIGZsYWdzO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuY29uc3QgaW5pdEhlcmVXYWxsZXQgPSBjb25maWcgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHtcbiAgICBzdG9yZSxcbiAgICBsb2dnZXIsXG4gICAgZW1pdHRlcixcbiAgICBvcHRpb25zLFxuICAgIGRlZmF1bHRQcm92aWRlcixcbiAgICBkZWZhdWx0U3RyYXRlZ3lcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgaGVyZSA9IG5ldyBIZXJlV2FsbGV0KHtcbiAgICBuZXR3b3JrSWQ6IG9wdGlvbnMubmV0d29yay5uZXR3b3JrSWQsXG4gICAgbm9kZVVybDogb3B0aW9ucy5uZXR3b3JrLm5vZGVVcmwsXG4gICAgZGVmYXVsdFByb3ZpZGVyLFxuICAgIGRlZmF1bHRTdHJhdGVneVxuICB9KTtcbiAgZnVuY3Rpb24gZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmdldEFjY291bnRzXCIpO1xuICAgICAgY29uc3QgYWNjb3VudElkcyA9IHlpZWxkIGhlcmUuZ2V0QWNjb3VudHMoKTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY291bnRJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgYWNjb3VudElkOiBhY2NvdW50SWRzW2ldLFxuICAgICAgICAgIHB1YmxpY0tleTogKHlpZWxkIGhlcmUuc2lnbmVyLmdldFB1YmxpY0tleShhY2NvdW50SWRzW2ldLCBvcHRpb25zLm5ldHdvcmsubmV0d29ya0lkKSkudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBuZXR3b3JrSWQoKSB7XG4gICAgICByZXR1cm4gaGVyZS5uZXR3b3JrSWQ7XG4gICAgfSxcbiAgICBidWlsZEltcG9ydEFjY291bnRzVXJsKCkge1xuICAgICAgcmV0dXJuIGBodHRwczovL215LmhlcmV3YWxsZXQuYXBwL2ltcG9ydD9uZXR3b3JrPSR7b3B0aW9ucy5uZXR3b3JrLm5ldHdvcmtJZH1gO1xuICAgIH0sXG4gICAgYWNjb3VudChpZCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6YWNjb3VudFwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuYWNjb3VudChpZCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHN3aXRjaEFjY291bnQoaWQpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OnN3aXRjaEFjY291bnRcIik7XG4gICAgICAgIHlpZWxkIGhlcmUuc3dpdGNoQWNjb3VudChpZCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEFjY291bnRJZCgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmdldEFjY291bnRJZFwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuZ2V0QWNjb3VudElkKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzU2lnbmVkSW4oKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDppc1NpZ25lZEluXCIpO1xuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5pc1NpZ25lZEluKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25JbihkYXRhKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDpzaWduSW5cIik7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0SWQgPSBkYXRhLmNvbnRyYWN0SWQgIT09IFwiXCIgPyBkYXRhLmNvbnRyYWN0SWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHlpZWxkIGhlcmUuc2lnbkluKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIHtcbiAgICAgICAgICBjb250cmFjdElkOiBjb250cmFjdElkXG4gICAgICAgIH0pKTtcbiAgICAgICAgZW1pdHRlci5lbWl0KFwic2lnbmVkSW5cIiwge1xuICAgICAgICAgIGNvbnRyYWN0SWQ6IGRhdGEuY29udHJhY3RJZCxcbiAgICAgICAgICBtZXRob2ROYW1lczogKF9hID0gZGF0YS5tZXRob2ROYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgYWNjb3VudHM6IHlpZWxkIGdldEFjY291bnRzKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBnZXRBY2NvdW50cygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRIZXJlQmFsYW5jZSgpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJIZXJlV2FsbGV0OmdldEhlcmVCYWxhbmNlXCIpO1xuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5nZXRIZXJlQmFsYW5jZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRBdmFpbGFibGVCYWxhbmNlKCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6Z2V0QXZhaWxhYmxlQmFsYW5jZVwiKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuZ2V0QXZhaWxhYmxlQmFsYW5jZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduT3V0KCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbk91dFwiKTtcbiAgICAgICAgeWllbGQgaGVyZS5zaWduT3V0KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEFjY291bnRzKCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEFjY291bnRzKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiLCBkYXRhKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRyYWN0XG4gICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWhlcmUuaXNTaWduZWRJbiB8fCAhY29udHJhY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IHNpZ25lZCBpblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWllbGQgaGVyZS5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHJlY2VpdmVySWQ6IGNvbnRyYWN0LmNvbnRyYWN0SWRcbiAgICAgICAgfSwgZGF0YSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB2ZXJpZnlPd25lcigpIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiSGVyZVdhbGxldDp2ZXJpZnlPd25lciBpcyBkZXByZWNhdGVkLCB1c2Ugc2lnbk1lc3NhZ2UgbWV0aG9kIHdpdGggaW1wbGVtZW50YXRpb24gTkVQMDQxMyBTdGFuZGFyZFwiKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbk1lc3NhZ2UoZGF0YSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkhlcmVXYWxsZXQ6c2lnbk1lc3NhZ2VcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBoZXJlLnNpZ25NZXNzYWdlKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9ucyhkYXRhKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsb2dnZXIubG9nKFwiSGVyZVdhbGxldDpzaWduQW5kU2VuZFRyYW5zYWN0aW9uc1wiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhlcmUuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcblxudmFyIGljb24gPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5EQWlJR2hsYVdkb2REMGlOREFpSUhacFpYZENiM2c5SWpBZ01DQTBNQ0EwTUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE9TNDNNek0xSURFeExqWTRNekZNTWpFdU56QTRPU0E0VERJMExqSTVPRE1nTVRZdU5qYzJOa3d5TUM0ME1UWWdNVFF1T1RJeE5Vd3hPUzQzTXpNMUlERXhMalk0TXpGYVRUVXVOell6T0RnZ01UVXVOVFF3T1V3ekxqYzFOVFl5SURFNUxqRTJNakZNT1M0NE9UWXdOU0F5TWk0eE5qWXhUREU0TGpNME56TWdNakV1TlRneU9FdzFMamMyTXpnNElERTFMalUwTURsYVRUUXVOalEwTmpRZ01qSXVNelk1TkV3eUxqWTBPRFkxSURJMUxqazNNVE5NTVRRdU9UQTRNeUF6TWk0d05UYzFURE0xTGpNek9EZ2dNekF1T0RFM05Fd3pOeTR6TXpRNElESTNMakl4TlRSTU1UWXVPVEEwTXlBeU9DNDBOVFUzVERRdU5qUTBOalFnTWpJdU16WTVORm9pSUdacGJHdzlJaU15UXpNd016UWlMejRLUEhCaGRHZ2daRDBpVFRNM0xqTXpOVGtnTWpjdU1qRTFOMHd4Tmk0NU1URXlJREk0TGpRMU5qRk1OQzQxTkRZek15QXlNaTR6TlRVMFRERTNMamt6TlRnZ01qRXVOVFExTTB3MUxqYzJNemczSURFMUxqVTBNRGxNTVRFdU56UXhJREV3TGpRM09EWk1NalF1TVRRd01TQXhOaTQxTnpZelRESXhMamN3T1NBNFRETXpMalUxTnlBeE15NDRNVXd6Tnk0ek16VTVJREkzTGpJeE5UZGFJaUJtYVd4c1BTSWpSa1JDUmpGRElpOCtDand2YzNablBnbz1cIjtcblxuZnVuY3Rpb24gc2V0dXBIZXJlV2FsbGV0KHtcbiAgZGVwcmVjYXRlZCA9IGZhbHNlLFxuICBpY29uVXJsID0gaWNvbixcbiAgZGVmYXVsdFN0cmF0ZWd5LFxuICBkZWZhdWx0UHJvdmlkZXJcbn0gPSB7fSkge1xuICByZXR1cm4gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogXCJoZXJlLXdhbGxldFwiLFxuICAgICAgdHlwZTogXCJpbmplY3RlZFwiLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgbmFtZTogXCJIZXJlIFdhbGxldFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJNb2JpbGUgd2FsbGV0IGZvciBORUFSIFByb3RvY29sXCIsXG4gICAgICAgIHVzZVVybEFjY291bnRJbXBvcnQ6IHRydWUsXG4gICAgICAgIGRvd25sb2FkVXJsOiBcImh0dHBzOi8vaGVyZXdhbGxldC5hcHBcIixcbiAgICAgICAgaWNvblVybCxcbiAgICAgICAgZGVwcmVjYXRlZCxcbiAgICAgICAgYXZhaWxhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgaW5pdDogY29uZmlnID0+IGluaXRIZXJlV2FsbGV0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwge1xuICAgICAgICBkZWZhdWx0U3RyYXRlZ3ksXG4gICAgICAgIGRlZmF1bHRQcm92aWRlclxuICAgICAgfSkpXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHNldHVwSGVyZVdhbGxldCB9O1xuIl0sIm5hbWVzIjpbIkhlcmVXYWxsZXQiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiY2hlY2siLCJpdCIsIk1hdGgiLCJnbG9iYWwkYSIsIkZ1bmN0aW9uIiwib2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZmFpbHMkYSIsImV4ZWMiLCJlcnJvciIsImZhaWxzJDkiLCJkZXNjcmlwdG9ycyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZmFpbHMkOCIsImZ1bmN0aW9uQmluZE5hdGl2ZSIsInRlc3QiLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJOQVRJVkVfQklORCQxIiwiY2FsbCQ2IiwicHJvdG90eXBlIiwiY2FsbCIsImZ1bmN0aW9uQ2FsbCIsImFwcGx5IiwiYXJndW1lbnRzIiwib2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiTkFTSE9STl9CVUciLCJmIiwiViIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIiLCJiaXRtYXAiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiTkFUSVZFX0JJTkQiLCJGdW5jdGlvblByb3RvdHlwZSQxIiwiY2FsbCQ1IiwidW5jdXJyeVRoaXMkYSIsImZ1bmN0aW9uVW5jdXJyeVRoaXMiLCJmbiIsInVuY3VycnlUaGlzJDkiLCJ0b1N0cmluZyQyIiwidG9TdHJpbmciLCJzdHJpbmdTbGljZSIsInNsaWNlIiwiY2xhc3NvZlJhdyQxIiwidW5jdXJyeVRoaXMkOCIsImZhaWxzJDciLCJjbGFzc29mJDIiLCIkT2JqZWN0JDMiLCJzcGxpdCIsImluZGV4ZWRPYmplY3QiLCIkVHlwZUVycm9yJDUiLCJUeXBlRXJyb3IiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIiLCJ1bmRlZmluZWQiLCJJbmRleGVkT2JqZWN0JDEiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEiLCJ0b0luZGV4ZWRPYmplY3QkMyIsImlzQ2FsbGFibGUkYiIsImFyZ3VtZW50IiwiaXNDYWxsYWJsZSRhIiwiaXNPYmplY3QkNSIsImdsb2JhbCQ5IiwiaXNDYWxsYWJsZSQ5IiwiYUZ1bmN0aW9uIiwiZ2V0QnVpbHRJbiQzIiwibmFtZXNwYWNlIiwibWV0aG9kIiwibGVuZ3RoIiwidW5jdXJyeVRoaXMkNyIsIm9iamVjdElzUHJvdG90eXBlT2YiLCJpc1Byb3RvdHlwZU9mIiwiZ2V0QnVpbHRJbiQyIiwiZW5naW5lVXNlckFnZW50IiwiZ2xvYmFsJDgiLCJ1c2VyQWdlbnQiLCJwcm9jZXNzIiwiRGVubyIsInZlcnNpb25zIiwidmVyc2lvbiIsInY4IiwibWF0Y2giLCJlbmdpbmVWOFZlcnNpb24iLCJWOF9WRVJTSU9OIiwiZmFpbHMkNiIsIm5hdGl2ZVN5bWJvbCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbCIsIlN5bWJvbCIsIlN0cmluZyIsInNoYW0iLCJOQVRJVkVfU1lNQk9MJDEiLCJ1c2VTeW1ib2xBc1VpZCIsIml0ZXJhdG9yIiwiZ2V0QnVpbHRJbiQxIiwiaXNDYWxsYWJsZSQ4IiwiaXNQcm90b3R5cGVPZiQxIiwiVVNFX1NZTUJPTF9BU19VSUQkMSIsIiRPYmplY3QkMiIsImlzU3ltYm9sJDIiLCIkU3ltYm9sIiwiJFN0cmluZyQyIiwidHJ5VG9TdHJpbmckMSIsImlzQ2FsbGFibGUkNyIsInRyeVRvU3RyaW5nIiwiJFR5cGVFcnJvciQ0IiwiYUNhbGxhYmxlJDEiLCJhQ2FsbGFibGUiLCJnZXRNZXRob2QkMSIsIlAiLCJmdW5jIiwiY2FsbCQ0IiwiaXNDYWxsYWJsZSQ2IiwiaXNPYmplY3QkNCIsIiRUeXBlRXJyb3IkMyIsIm9yZGluYXJ5VG9QcmltaXRpdmUkMSIsImlucHV0IiwicHJlZiIsInZhbCIsInZhbHVlT2YiLCJzaGFyZWQkMyIsImV4cG9ydHMiLCJnbG9iYWwkNyIsImRlZmluZVByb3BlcnR5JDIiLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzIiwia2V5IiwiZ2xvYmFsJDYiLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyIiwiU0hBUkVEIiwic3RvcmUkMyIsInNoYXJlZFN0b3JlIiwic3RvcmUkMiIsInB1c2giLCJtb2RlIiwiY29weXJpZ2h0IiwibGljZW5zZSIsInNvdXJjZSIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCIkT2JqZWN0JDEiLCJ0b09iamVjdCQyIiwidW5jdXJyeVRoaXMkNiIsInRvT2JqZWN0JDEiLCJoYXNPd25Qcm9wZXJ0eV8xIiwiaGFzT3duIiwidW5jdXJyeVRoaXMkNSIsImlkIiwicG9zdGZpeCIsInJhbmRvbSIsInRvU3RyaW5nJDEiLCJ1aWQkMiIsImdsb2JhbCQ1Iiwic2hhcmVkJDIiLCJoYXNPd24kNyIsInVpZCQxIiwiTkFUSVZFX1NZTUJPTCIsIlVTRV9TWU1CT0xfQVNfVUlEIiwiV2VsbEtub3duU3ltYm9sc1N0b3JlIiwiU3ltYm9sJDEiLCJzeW1ib2xGb3IiLCJjcmVhdGVXZWxsS25vd25TeW1ib2wiLCJ3aXRob3V0U2V0dGVyIiwid2VsbEtub3duU3ltYm9sJDMiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJjYWxsJDMiLCJpc09iamVjdCQzIiwiaXNTeW1ib2wkMSIsImdldE1ldGhvZCIsIm9yZGluYXJ5VG9QcmltaXRpdmUiLCJ3ZWxsS25vd25TeW1ib2wkMiIsIiRUeXBlRXJyb3IkMiIsIlRPX1BSSU1JVElWRSIsInRvUHJpbWl0aXZlJDEiLCJleG90aWNUb1ByaW0iLCJyZXN1bHQiLCJ0b1ByaW1pdGl2ZSIsImlzU3ltYm9sIiwidG9Qcm9wZXJ0eUtleSQyIiwiZ2xvYmFsJDQiLCJpc09iamVjdCQyIiwiZG9jdW1lbnQiLCJFWElTVFMkMSIsImNyZWF0ZUVsZW1lbnQiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJERVNDUklQVE9SUyQ3IiwiZmFpbHMkNSIsImllOERvbURlZmluZSIsImEiLCJERVNDUklQVE9SUyQ2IiwiY2FsbCQyIiwicHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUkMSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxIiwidG9JbmRleGVkT2JqZWN0JDIiLCJ0b1Byb3BlcnR5S2V5JDEiLCJoYXNPd24kNiIsIklFOF9ET01fREVGSU5FJDEiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJPIiwib2JqZWN0RGVmaW5lUHJvcGVydHkiLCJERVNDUklQVE9SUyQ1IiwiZmFpbHMkNCIsInY4UHJvdG90eXBlRGVmaW5lQnVnIiwiaXNPYmplY3QkMSIsIiRTdHJpbmckMSIsIiRUeXBlRXJyb3IkMSIsImFuT2JqZWN0JDQiLCJERVNDUklQVE9SUyQ0IiwiSUU4X0RPTV9ERUZJTkUiLCJWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyIsImFuT2JqZWN0JDMiLCJ0b1Byb3BlcnR5S2V5IiwiJFR5cGVFcnJvciIsIiRkZWZpbmVQcm9wZXJ0eSIsIiRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJFTlVNRVJBQkxFIiwiQ09ORklHVVJBQkxFJDEiLCJXUklUQUJMRSIsIkF0dHJpYnV0ZXMiLCJjdXJyZW50IiwiREVTQ1JJUFRPUlMkMyIsImRlZmluZVByb3BlcnR5TW9kdWxlJDIiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiIsIm9iamVjdCIsIm1ha2VCdWlsdEluJDIiLCJERVNDUklQVE9SUyQyIiwiaGFzT3duJDUiLCJGdW5jdGlvblByb3RvdHlwZSIsImdldERlc2NyaXB0b3IiLCJFWElTVFMiLCJQUk9QRVIiLCJzb21ldGhpbmciLCJDT05GSUdVUkFCTEUiLCJmdW5jdGlvbk5hbWUiLCJ1bmN1cnJ5VGhpcyQ0IiwiaXNDYWxsYWJsZSQ1Iiwic3RvcmUkMSIsImZ1bmN0aW9uVG9TdHJpbmciLCJpbnNwZWN0U291cmNlIiwiaW5zcGVjdFNvdXJjZSQyIiwiZ2xvYmFsJDMiLCJpc0NhbGxhYmxlJDQiLCJpbnNwZWN0U291cmNlJDEiLCJXZWFrTWFwJDEiLCJXZWFrTWFwIiwibmF0aXZlV2Vha01hcCIsInNoYXJlZCQxIiwidWlkIiwia2V5cyIsInNoYXJlZEtleSQxIiwiaGlkZGVuS2V5cyQzIiwiTkFUSVZFX1dFQUtfTUFQIiwiZ2xvYmFsJDIiLCJ1bmN1cnJ5VGhpcyQzIiwiaXNPYmplY3QiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSIsImhhc093biQ0Iiwic2hhcmVkIiwic2hhcmVkS2V5IiwiaGlkZGVuS2V5cyQyIiwiT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQiLCJUeXBlRXJyb3IkMSIsInNldCIsImhhcyIsImVuZm9yY2UiLCJnZXR0ZXJGb3IiLCJUWVBFIiwic3RhdGUiLCJ0eXBlIiwic3RvcmUiLCJ3bWdldCIsIndtaGFzIiwid21zZXQiLCJtZXRhZGF0YSIsImZhY2FkZSIsIlNUQVRFIiwiaW50ZXJuYWxTdGF0ZSIsImZhaWxzJDMiLCJpc0NhbGxhYmxlJDMiLCJoYXNPd24kMyIsIkRFU0NSSVBUT1JTJDEiLCJDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSIsIkludGVybmFsU3RhdGVNb2R1bGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsImdldEludGVybmFsU3RhdGUiLCJkZWZpbmVQcm9wZXJ0eSQxIiwiQ09ORklHVVJBQkxFX0xFTkdUSCIsIlRFTVBMQVRFIiwibWFrZUJ1aWx0SW4kMSIsIm9wdGlvbnMiLCJyZXBsYWNlIiwiZ2V0dGVyIiwic2V0dGVyIiwiYXJpdHkiLCJjb25zdHJ1Y3RvciIsImpvaW4iLCJpc0NhbGxhYmxlJDIiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxIiwibWFrZUJ1aWx0SW4iLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxIiwiZGVmaW5lQnVpbHRJbiQyIiwic2ltcGxlIiwidW5zYWZlIiwibm9uQ29uZmlndXJhYmxlIiwibm9uV3JpdGFibGUiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY2VpbCIsImZsb29yIiwibWF0aFRydW5jIiwidHJ1bmMiLCJ4IiwibiIsInRvSW50ZWdlck9ySW5maW5pdHkkMiIsIm51bWJlciIsInRvSW50ZWdlck9ySW5maW5pdHkkMSIsIm1heCIsIm1pbiQxIiwibWluIiwidG9BYnNvbHV0ZUluZGV4JDEiLCJpbmRleCIsImludGVnZXIiLCJ0b0ludGVnZXJPckluZmluaXR5IiwidG9MZW5ndGgkMSIsInRvTGVuZ3RoIiwibGVuZ3RoT2ZBcnJheUxpa2UkMSIsIm9iaiIsInRvSW5kZXhlZE9iamVjdCQxIiwidG9BYnNvbHV0ZUluZGV4IiwibGVuZ3RoT2ZBcnJheUxpa2UiLCJjcmVhdGVNZXRob2QiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZWwiLCJmcm9tSW5kZXgiLCJhcnJheUluY2x1ZGVzIiwiaW5jbHVkZXMiLCJpbmRleE9mIiwidW5jdXJyeVRoaXMkMiIsImhhc093biQyIiwidG9JbmRleGVkT2JqZWN0IiwiaGlkZGVuS2V5cyQxIiwib2JqZWN0S2V5c0ludGVybmFsIiwibmFtZXMiLCJpIiwiZW51bUJ1Z0tleXMkMiIsImludGVybmFsT2JqZWN0S2V5cyQxIiwiZW51bUJ1Z0tleXMkMSIsImhpZGRlbktleXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0QnVpbHRJbiIsInVuY3VycnlUaGlzJDEiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEiLCJhbk9iamVjdCQyIiwiY29uY2F0JDEiLCJvd25LZXlzJDEiLCJvd25LZXlzIiwiaGFzT3duJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSIsInRhcmdldCIsImV4Y2VwdGlvbnMiLCJmYWlscyQyIiwiaXNDYWxsYWJsZSQxIiwicmVwbGFjZW1lbnQiLCJpc0ZvcmNlZCQxIiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInN0cmluZyIsInRvTG93ZXJDYXNlIiwiaXNGb3JjZWRfMSIsImdsb2JhbCQxIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5IiwiZGVmaW5lQnVpbHRJbiQxIiwiZGVmaW5lR2xvYmFsUHJvcGVydHkiLCJjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzIiwiaXNGb3JjZWQiLCJfZXhwb3J0IiwiVEFSR0VUIiwiR0xPQkFMIiwiU1RBVElDIiwic3RhdCIsIkZPUkNFRCIsInRhcmdldFByb3BlcnR5Iiwic291cmNlUHJvcGVydHkiLCJkb250Q2FsbEdldFNldCIsImZvcmNlZCIsImludGVybmFsT2JqZWN0S2V5cyIsImVudW1CdWdLZXlzIiwib2JqZWN0S2V5cyQxIiwiREVTQ1JJUFRPUlMiLCJ1bmN1cnJ5VGhpcyIsImNhbGwkMSIsImZhaWxzJDEiLCJvYmplY3RLZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlIiwicHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUiLCJ0b09iamVjdCIsIkluZGV4ZWRPYmplY3QiLCIkYXNzaWduIiwiYXNzaWduIiwib2JqZWN0QXNzaWduIiwiYiIsIkEiLCJCIiwiYWxwaGFiZXQiLCJmb3JFYWNoIiwiY2hyIiwiVCIsImFyZ3VtZW50c0xlbmd0aCIsIlMiLCJqIiwiJCIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwiZG9uZSIsInRoZW4iLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwid2VsbEtub3duU3ltYm9sJDEiLCJUT19TVFJJTkdfVEFHJDEiLCJ0b1N0cmluZ1RhZ1N1cHBvcnQiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJpc0NhbGxhYmxlIiwiY2xhc3NvZlJhdyIsIndlbGxLbm93blN5bWJvbCIsIlRPX1NUUklOR19UQUciLCIkT2JqZWN0IiwiQ09SUkVDVF9BUkdVTUVOVFMiLCJ0cnlHZXQiLCJjbGFzc29mJDEiLCJ0YWciLCJjYWxsZWUiLCJjbGFzc29mIiwiJFN0cmluZyIsImFuT2JqZWN0JDEiLCJyZWdleHBGbGFncyIsInRoYXQiLCJoYXNJbmRpY2VzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImRvdEFsbCIsInVuaWNvZGUiLCJ1bmljb2RlU2V0cyIsInN0aWNreSIsInJlZ0V4cEZsYWdzIiwiUmVnRXhwUHJvdG90eXBlJDEiLCJSZWdFeHAiLCJyZWdleHBHZXRGbGFncyIsIlIiLCJmbGFncyIsIlBST1BFUl9GVU5DVElPTl9OQU1FIiwiZGVmaW5lQnVpbHRJbiIsImFuT2JqZWN0IiwiJHRvU3RyaW5nIiwiZmFpbHMiLCJnZXRSZWdFeHBGbGFncyIsIlRPX1NUUklORyIsIlJlZ0V4cFByb3RvdHlwZSIsIm4kVG9TdHJpbmciLCJOT1RfR0VORVJJQyIsIklOQ09SUkVDVF9OQU1FIiwicGF0dGVybiIsImluaXRIZXJlV2FsbGV0IiwiY29uZmlnIiwibG9nZ2VyIiwiZW1pdHRlciIsImRlZmF1bHRQcm92aWRlciIsImRlZmF1bHRTdHJhdGVneSIsImhlcmUiLCJuZXR3b3JrSWQiLCJuZXR3b3JrIiwibm9kZVVybCIsImdldEFjY291bnRzIiwibG9nIiwiYWNjb3VudElkcyIsImFjY291bnRzIiwiYWNjb3VudElkIiwicHVibGljS2V5Iiwic2lnbmVyIiwiZ2V0UHVibGljS2V5IiwiYnVpbGRJbXBvcnRBY2NvdW50c1VybCIsImFjY291bnQiLCJzd2l0Y2hBY2NvdW50IiwiZ2V0QWNjb3VudElkIiwiaXNTaWduZWRJbiIsInNpZ25JbiIsIl9hIiwiY29udHJhY3RJZCIsImVtaXQiLCJtZXRob2ROYW1lcyIsImdldEhlcmVCYWxhbmNlIiwiZ2V0QXZhaWxhYmxlQmFsYW5jZSIsInNpZ25PdXQiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwiY29udHJhY3QiLCJnZXRTdGF0ZSIsInJlY2VpdmVySWQiLCJ2ZXJpZnlPd25lciIsInNpZ25NZXNzYWdlIiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMiLCJpY29uIiwic2V0dXBIZXJlV2FsbGV0IiwiZGVwcmVjYXRlZCIsImljb25VcmwiLCJ1c2VVcmxBY2NvdW50SW1wb3J0IiwiZG93bmxvYWRVcmwiLCJhdmFpbGFibGUiLCJpbml0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/here-wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/modal-ui/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/modal-ui/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupModal: () => (/* binding */ setupModal)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/client.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @near-wallet-selector/core */ \"(ssr)/./node_modules/@near-wallet-selector/core/index.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! qrcode */ \"(ssr)/./node_modules/qrcode/lib/index.js\");\n/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! copy-to-clipboard */ \"(ssr)/./node_modules/copy-to-clipboard/index.js\");\n\n\n\n\n\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar fails$h = function(exec) {\n    try {\n        return !!exec();\n    } catch (error) {\n        return true;\n    }\n};\nvar fails$g = fails$h;\nvar functionBindNative = !fails$g(function() {\n    // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n    var test = (function() {}).bind();\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$3 = functionBindNative;\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$5 = FunctionPrototype$2.bind;\nvar call$f = FunctionPrototype$2.call;\nvar uncurryThis$h = NATIVE_BIND$3 && bind$5.bind(call$f, call$f);\nvar functionUncurryThis = NATIVE_BIND$3 ? function(fn) {\n    return fn && uncurryThis$h(fn);\n} : function(fn) {\n    return fn && function() {\n        return call$f.apply(fn, arguments);\n    };\n};\nvar uncurryThis$g = functionUncurryThis;\nvar toString$5 = uncurryThis$g({}.toString);\nvar stringSlice$1 = uncurryThis$g(\"\".slice);\nvar classofRaw$1 = function(it) {\n    return stringSlice$1(toString$5(it), 8, -1);\n};\nvar uncurryThis$f = functionUncurryThis;\nvar fails$f = fails$h;\nvar classof$6 = classofRaw$1;\nvar $Object$4 = Object;\nvar split = uncurryThis$f(\"\".split);\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$f(function() {\n    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return !$Object$4(\"z\").propertyIsEnumerable(0);\n}) ? function(it) {\n    return classof$6(it) == \"String\" ? split(it, \"\") : $Object$4(it);\n} : $Object$4;\nvar $TypeError$e = TypeError;\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$3 = function(it) {\n    if (it == undefined) throw $TypeError$e(\"Can't call method on \" + it);\n    return it;\n};\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$2 = indexedObject;\nvar requireObjectCoercible$2 = requireObjectCoercible$3;\nvar toIndexedObject$5 = function(it) {\n    return IndexedObject$2(requireObjectCoercible$2(it));\n};\nvar check = function(it) {\n    return it && it.Math == Math && it;\n};\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$k = // eslint-disable-next-line es-x/no-global-this -- safe\ncheck(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\ncheck(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback\nfunction() {\n    return this;\n}() || Function(\"return this\")();\nvar shared$3 = {\n    exports: {}\n};\nvar global$j = global$k;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\nvar defineGlobalProperty$3 = function(key, value) {\n    try {\n        defineProperty$6(global$j, key, {\n            value: value,\n            configurable: true,\n            writable: true\n        });\n    } catch (error) {\n        global$j[key] = value;\n    }\n    return value;\n};\nvar global$i = global$k;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\nvar SHARED = \"__core-js_shared__\";\nvar store$3 = global$i[SHARED] || defineGlobalProperty$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$3.exports = function(key, value) {\n    return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})(\"versions\", []).push({\n    version: \"3.23.3\",\n    mode: \"global\",\n    copyright: \"\\xa9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n});\nvar requireObjectCoercible$1 = requireObjectCoercible$3;\nvar $Object$3 = Object;\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$5 = function(argument) {\n    return $Object$3(requireObjectCoercible$1(argument));\n};\nvar uncurryThis$e = functionUncurryThis;\nvar toObject$4 = toObject$5;\nvar hasOwnProperty = uncurryThis$e({}.hasOwnProperty);\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n    return hasOwnProperty(toObject$4(it), key);\n};\nvar uncurryThis$d = functionUncurryThis;\nvar id = 0;\nvar postfix = Math.random();\nvar toString$4 = uncurryThis$d(1.0.toString);\nvar uid$2 = function(key) {\n    return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString$4(++id + postfix, 36);\n};\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$l = function(argument) {\n    return typeof argument == \"function\";\n};\nvar global$h = global$k;\nvar isCallable$k = isCallable$l;\nvar aFunction = function(argument) {\n    return isCallable$k(argument) ? argument : undefined;\n};\nvar getBuiltIn$8 = function(namespace, method) {\n    return arguments.length < 2 ? aFunction(global$h[namespace]) : global$h[namespace] && global$h[namespace][method];\n};\nvar getBuiltIn$7 = getBuiltIn$8;\nvar engineUserAgent = getBuiltIn$7(\"navigator\", \"userAgent\") || \"\";\nvar global$g = global$k;\nvar userAgent$5 = engineUserAgent;\nvar process$3 = global$g.process;\nvar Deno$1 = global$g.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n    match = v8.split(\".\");\n    // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n    // but their correct versions are not interesting for us\n    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n    match = userAgent$5.match(/Edge\\/(\\d+)/);\n    if (!match || match[1] >= 74) {\n        match = userAgent$5.match(/Chrome\\/(\\d+)/);\n        if (match) version = +match[1];\n    }\n}\nvar engineV8Version = version;\n/* eslint-disable es-x/no-symbol -- required for testing */ var V8_VERSION$1 = engineV8Version;\nvar fails$e = fails$h;\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$e(function() {\n    var symbol = Symbol();\n    // Chrome 38 Symbol has incorrect toString conversion\n    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n/* eslint-disable es-x/no-symbol -- required for testing */ var NATIVE_SYMBOL$2 = nativeSymbol;\nvar useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar global$f = global$k;\nvar shared$2 = shared$3.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL$1 = nativeSymbol;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$2(\"wks\");\nvar Symbol$1 = global$f.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1[\"for\"];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\nvar wellKnownSymbol$g = function(name) {\n    if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore[name] == \"string\")) {\n        var description = \"Symbol.\" + name;\n        if (NATIVE_SYMBOL$1 && hasOwn$b(Symbol$1, name)) {\n            WellKnownSymbolsStore[name] = Symbol$1[name];\n        } else if (USE_SYMBOL_AS_UID$1 && symbolFor) {\n            WellKnownSymbolsStore[name] = symbolFor(description);\n        } else {\n            WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n        }\n    }\n    return WellKnownSymbolsStore[name];\n};\nvar isCallable$j = isCallable$l;\nvar isObject$8 = function(it) {\n    return typeof it == \"object\" ? it !== null : isCallable$j(it);\n};\nvar isObject$7 = isObject$8;\nvar $String$3 = String;\nvar $TypeError$d = TypeError;\n// `Assert: Type(argument) is Object`\nvar anObject$c = function(argument) {\n    if (isObject$7(argument)) return argument;\n    throw $TypeError$d($String$3(argument) + \" is not an object\");\n};\nvar objectDefineProperties = {};\nvar fails$d = fails$h;\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$d(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty({}, 1, {\n        get: function() {\n            return 7;\n        }\n    })[1] != 7;\n});\nvar DESCRIPTORS$b = descriptors;\nvar fails$c = fails$h;\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$c(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(function() {}, \"prototype\", {\n        value: 42,\n        writable: false\n    }).prototype != 42;\n});\nvar objectDefineProperty = {};\nvar global$e = global$k;\nvar isObject$6 = isObject$8;\nvar document$3 = global$e.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$6(document$3) && isObject$6(document$3.createElement);\nvar documentCreateElement$2 = function(it) {\n    return EXISTS$1 ? document$3.createElement(it) : {};\n};\nvar DESCRIPTORS$a = descriptors;\nvar fails$b = fails$h;\nvar createElement$1 = documentCreateElement$2;\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$a && !fails$b(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(createElement$1(\"div\"), \"a\", {\n        get: function() {\n            return 7;\n        }\n    }).a != 7;\n});\nvar NATIVE_BIND$2 = functionBindNative;\nvar call$e = Function.prototype.call;\nvar functionCall = NATIVE_BIND$2 ? call$e.bind(call$e) : function() {\n    return call$e.apply(call$e, arguments);\n};\nvar uncurryThis$c = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$c({}.isPrototypeOf);\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$i = isCallable$l;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar $Object$2 = Object;\nvar isSymbol$2 = USE_SYMBOL_AS_UID ? function(it) {\n    return typeof it == \"symbol\";\n} : function(it) {\n    var $Symbol = getBuiltIn$6(\"Symbol\");\n    return isCallable$i($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$2(it));\n};\nvar $String$2 = String;\nvar tryToString$5 = function(argument) {\n    try {\n        return $String$2(argument);\n    } catch (error) {\n        return \"Object\";\n    }\n};\nvar isCallable$h = isCallable$l;\nvar tryToString$4 = tryToString$5;\nvar $TypeError$c = TypeError;\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function(argument) {\n    if (isCallable$h(argument)) return argument;\n    throw $TypeError$c(tryToString$4(argument) + \" is not a function\");\n};\nvar aCallable$8 = aCallable$9;\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function(V, P) {\n    var func = V[P];\n    return func == null ? undefined : aCallable$8(func);\n};\nvar call$d = functionCall;\nvar isCallable$g = isCallable$l;\nvar isObject$5 = isObject$8;\nvar $TypeError$b = TypeError;\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function(input, pref) {\n    var fn, val;\n    if (pref === \"string\" && isCallable$g(fn = input.toString) && !isObject$5(val = call$d(fn, input))) return val;\n    if (isCallable$g(fn = input.valueOf) && !isObject$5(val = call$d(fn, input))) return val;\n    if (pref !== \"string\" && isCallable$g(fn = input.toString) && !isObject$5(val = call$d(fn, input))) return val;\n    throw $TypeError$b(\"Can't convert object to primitive value\");\n};\nvar call$c = functionCall;\nvar isObject$4 = isObject$8;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$f = wellKnownSymbol$g;\nvar $TypeError$a = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$f(\"toPrimitive\");\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function(input, pref) {\n    if (!isObject$4(input) || isSymbol$1(input)) return input;\n    var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n    var result;\n    if (exoticToPrim) {\n        if (pref === undefined) pref = \"default\";\n        result = call$c(exoticToPrim, input, pref);\n        if (!isObject$4(result) || isSymbol$1(result)) return result;\n        throw $TypeError$a(\"Can't convert object to primitive value\");\n    }\n    if (pref === undefined) pref = \"number\";\n    return ordinaryToPrimitive(input, pref);\n};\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$3 = function(argument) {\n    var key = toPrimitive(argument, \"string\");\n    return isSymbol(key) ? key : key + \"\";\n};\nvar DESCRIPTORS$9 = descriptors;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$b = anObject$c;\nvar toPropertyKey$2 = toPropertyKey$3;\nvar $TypeError$9 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = \"enumerable\";\nvar CONFIGURABLE$1 = \"configurable\";\nvar WRITABLE = \"writable\";\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$9 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n    anObject$b(O);\n    P = toPropertyKey$2(P);\n    anObject$b(Attributes);\n    if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n        var current = $getOwnPropertyDescriptor$1(O, P);\n        if (current && current[WRITABLE]) {\n            O[P] = Attributes.value;\n            Attributes = {\n                configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                writable: false\n            };\n        }\n    }\n    return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n    anObject$b(O);\n    P = toPropertyKey$2(P);\n    anObject$b(Attributes);\n    if (IE8_DOM_DEFINE$1) try {\n        return $defineProperty(O, P, Attributes);\n    } catch (error) {}\n    if (\"get\" in Attributes || \"set\" in Attributes) throw $TypeError$9(\"Accessors not supported\");\n    if (\"value\" in Attributes) O[P] = Attributes.value;\n    return O;\n};\nvar ceil = Math.ceil;\nvar floor$1 = Math.floor;\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n    var n = +x;\n    return (n > 0 ? floor$1 : ceil)(n);\n};\nvar trunc = mathTrunc;\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function(argument) {\n    var number = +argument;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number !== number || number === 0 ? 0 : trunc(number);\n};\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\nvar max$1 = Math.max;\nvar min$1 = Math.min;\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$2 = function(index, length) {\n    var integer = toIntegerOrInfinity$1(index);\n    return integer < 0 ? max$1(integer + length, 0) : min$1(integer, length);\n};\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\nvar min = Math.min;\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function(argument) {\n    return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\nvar toLength = toLength$1;\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$5 = function(obj) {\n    return toLength(obj.length);\n};\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$2;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$5;\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function(IS_INCLUDES) {\n    return function($this, el, fromIndex) {\n        var O = toIndexedObject$4($this);\n        var length = lengthOfArrayLike$4(O);\n        var index = toAbsoluteIndex$1(fromIndex, length);\n        var value;\n        // Array#includes uses SameValueZero equality algorithm\n        // eslint-disable-next-line no-self-compare -- NaN check\n        if (IS_INCLUDES && el != el) while(length > index){\n            value = O[index++];\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (value != value) return true;\n        // Array#indexOf ignores holes, Array#includes - not\n        }\n        else for(; length > index; index++){\n            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n        }\n        return !IS_INCLUDES && -1;\n    };\n};\nvar arrayIncludes = {\n    // `Array.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-array.prototype.includes\n    includes: createMethod$1(true),\n    // `Array.prototype.indexOf` method\n    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n    indexOf: createMethod$1(false)\n};\nvar hiddenKeys$4 = {};\nvar uncurryThis$b = functionUncurryThis;\nvar hasOwn$a = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$5;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$3 = hiddenKeys$4;\nvar push$1 = uncurryThis$b([].push);\nvar objectKeysInternal = function(object, names) {\n    var O = toIndexedObject$3(object);\n    var i = 0;\n    var result = [];\n    var key;\n    for(key in O)!hasOwn$a(hiddenKeys$3, key) && hasOwn$a(O, key) && push$1(result, key);\n    // Don't enum bug & hidden keys\n    while(names.length > i)if (hasOwn$a(O, key = names[i++])) {\n        ~indexOf(result, key) || push$1(result, key);\n    }\n    return result;\n};\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n    \"constructor\",\n    \"hasOwnProperty\",\n    \"isPrototypeOf\",\n    \"propertyIsEnumerable\",\n    \"toLocaleString\",\n    \"toString\",\n    \"valueOf\"\n];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n    return internalObjectKeys$1(O, enumBugKeys$2);\n};\nvar DESCRIPTORS$8 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$5 = objectDefineProperty;\nvar anObject$a = anObject$c;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar objectKeys$1 = objectKeys$2;\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$8 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n    anObject$a(O);\n    var props = toIndexedObject$2(Properties);\n    var keys = objectKeys$1(Properties);\n    var length = keys.length;\n    var index = 0;\n    var key;\n    while(length > index)definePropertyModule$5.f(O, key = keys[index++], props[key]);\n    return O;\n};\nvar getBuiltIn$5 = getBuiltIn$8;\nvar html$2 = getBuiltIn$5(\"document\", \"documentElement\");\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\nvar keys = shared$1(\"keys\");\nvar sharedKey$3 = function(key) {\n    return keys[key] || (keys[key] = uid(key));\n};\n/* global ActiveXObject -- old IE, WSH */ var anObject$9 = anObject$c;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$2 = sharedKey$3;\nvar GT = \">\";\nvar LT = \"<\";\nvar PROTOTYPE = \"prototype\";\nvar SCRIPT = \"script\";\nvar IE_PROTO$1 = sharedKey$2(\"IE_PROTO\");\nvar EmptyConstructor = function() {};\nvar scriptTag = function(content) {\n    return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n};\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function(activeXDocument) {\n    activeXDocument.write(scriptTag(\"\"));\n    activeXDocument.close();\n    var temp = activeXDocument.parentWindow.Object;\n    activeXDocument = null; // avoid memory leak\n    return temp;\n};\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function() {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = documentCreateElement$1(\"iframe\");\n    var JS = \"java\" + SCRIPT + \":\";\n    var iframeDocument;\n    iframe.style.display = \"none\";\n    html$1.appendChild(iframe);\n    // https://github.com/zloirock/core-js/issues/475\n    iframe.src = String(JS);\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(scriptTag(\"document.F=Object\"));\n    iframeDocument.close();\n    return iframeDocument.F;\n};\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function() {\n    try {\n        activeXDocument = new ActiveXObject(\"htmlfile\");\n    } catch (error) {}\n    NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n     : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n    var length = enumBugKeys$1.length;\n    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];\n    return NullProtoObject();\n};\nhiddenKeys$2[IE_PROTO$1] = true;\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n    var result;\n    if (O !== null) {\n        EmptyConstructor[PROTOTYPE] = anObject$9(O);\n        result = new EmptyConstructor();\n        EmptyConstructor[PROTOTYPE] = null;\n        // add \"__proto__\" for Object.getPrototypeOf polyfill\n        result[IE_PROTO$1] = O;\n    } else result = NullProtoObject();\n    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\nvar wellKnownSymbol$e = wellKnownSymbol$g;\nvar create$1 = objectCreate;\nvar defineProperty$5 = objectDefineProperty.f;\nvar UNSCOPABLES = wellKnownSymbol$e(\"unscopables\");\nvar ArrayPrototype$1 = Array.prototype;\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n    defineProperty$5(ArrayPrototype$1, UNSCOPABLES, {\n        configurable: true,\n        value: create$1(null)\n    });\n}\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function(key) {\n    ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\nvar iterators = {};\nvar uncurryThis$a = functionUncurryThis;\nvar isCallable$f = isCallable$l;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$a(Function.toString);\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$f(store$1.inspectSource)) {\n    store$1.inspectSource = function(it) {\n        return functionToString(it);\n    };\n}\nvar inspectSource$4 = store$1.inspectSource;\nvar global$d = global$k;\nvar isCallable$e = isCallable$l;\nvar inspectSource$3 = inspectSource$4;\nvar WeakMap$1 = global$d.WeakMap;\nvar nativeWeakMap = isCallable$e(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\nvar createPropertyDescriptor$4 = function(bitmap, value) {\n    return {\n        enumerable: !(bitmap & 1),\n        configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        value: value\n    };\n};\nvar DESCRIPTORS$7 = descriptors;\nvar definePropertyModule$4 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$4;\nvar createNonEnumerableProperty$4 = DESCRIPTORS$7 ? function(object, key, value) {\n    return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));\n} : function(object, key, value) {\n    object[key] = value;\n    return object;\n};\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$c = global$k;\nvar uncurryThis$9 = functionUncurryThis;\nvar isObject$3 = isObject$8;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$4;\nvar hasOwn$9 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$3;\nvar hiddenKeys$1 = hiddenKeys$4;\nvar OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\nvar TypeError$2 = global$c.TypeError;\nvar WeakMap = global$c.WeakMap;\nvar set$1, get, has;\nvar enforce = function(it) {\n    return has(it) ? get(it) : set$1(it, {});\n};\nvar getterFor = function(TYPE) {\n    return function(it) {\n        var state;\n        if (!isObject$3(it) || (state = get(it)).type !== TYPE) {\n            throw TypeError$2(\"Incompatible receiver, \" + TYPE + \" required\");\n        }\n        return state;\n    };\n};\nif (NATIVE_WEAK_MAP || shared.state) {\n    var store = shared.state || (shared.state = new WeakMap());\n    var wmget = uncurryThis$9(store.get);\n    var wmhas = uncurryThis$9(store.has);\n    var wmset = uncurryThis$9(store.set);\n    set$1 = function(it, metadata) {\n        if (wmhas(store, it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        wmset(store, it, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return wmget(store, it) || {};\n    };\n    has = function(it) {\n        return wmhas(store, it);\n    };\n} else {\n    var STATE = sharedKey$1(\"state\");\n    hiddenKeys$1[STATE] = true;\n    set$1 = function(it, metadata) {\n        if (hasOwn$9(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        createNonEnumerableProperty$3(it, STATE, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return hasOwn$9(it, STATE) ? it[STATE] : {};\n    };\n    has = function(it) {\n        return hasOwn$9(it, STATE);\n    };\n}\nvar internalState = {\n    set: set$1,\n    get: get,\n    has: has,\n    enforce: enforce,\n    getterFor: getterFor\n};\nvar objectGetOwnPropertyDescriptor = {};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({\n    1: 2\n}, 1);\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n    var descriptor = getOwnPropertyDescriptor$2(this, V);\n    return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar DESCRIPTORS$6 = descriptors;\nvar call$b = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$4;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar toPropertyKey$1 = toPropertyKey$3;\nvar hasOwn$8 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE = ie8DomDefine;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n    O = toIndexedObject$1(O);\n    P = toPropertyKey$1(P);\n    if (IE8_DOM_DEFINE) try {\n        return $getOwnPropertyDescriptor(O, P);\n    } catch (error) {}\n    if (hasOwn$8(O, P)) return createPropertyDescriptor$2(!call$b(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\nvar makeBuiltIn$2 = {\n    exports: {}\n};\nvar DESCRIPTORS$5 = descriptors;\nvar hasOwn$7 = hasOwnProperty_1;\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$5 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$7(FunctionPrototype$1, \"name\");\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() {}).name === \"something\";\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$5 || DESCRIPTORS$5 && getDescriptor(FunctionPrototype$1, \"name\").configurable);\nvar functionName = {\n    EXISTS: EXISTS,\n    PROPER: PROPER,\n    CONFIGURABLE: CONFIGURABLE\n};\nvar fails$a = fails$h;\nvar isCallable$d = isCallable$l;\nvar hasOwn$6 = hasOwnProperty_1;\nvar DESCRIPTORS$4 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$2 = internalState;\nvar enforceInternalState = InternalStateModule$2.enforce;\nvar getInternalState$1 = InternalStateModule$2.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$4 = Object.defineProperty;\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$4 && !fails$a(function() {\n    return defineProperty$4(function() {}, \"length\", {\n        value: 8\n    }).length !== 8;\n});\nvar TEMPLATE = String(String).split(\"String\");\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {\n    if (String(name).slice(0, 7) === \"Symbol(\") {\n        name = \"[\" + String(name).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n    }\n    if (options && options.getter) name = \"get \" + name;\n    if (options && options.setter) name = \"set \" + name;\n    if (!hasOwn$6(value, \"name\") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {\n        if (DESCRIPTORS$4) defineProperty$4(value, \"name\", {\n            value: name,\n            configurable: true\n        });\n        else value.name = name;\n    }\n    if (CONFIGURABLE_LENGTH && options && hasOwn$6(options, \"arity\") && value.length !== options.arity) {\n        defineProperty$4(value, \"length\", {\n            value: options.arity\n        });\n    }\n    try {\n        if (options && hasOwn$6(options, \"constructor\") && options.constructor) {\n            if (DESCRIPTORS$4) defineProperty$4(value, \"prototype\", {\n                writable: false\n            });\n        // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n        } else if (value.prototype) value.prototype = undefined;\n    } catch (error) {}\n    var state = enforceInternalState(value);\n    if (!hasOwn$6(state, \"source\")) {\n        state.source = TEMPLATE.join(typeof name == \"string\" ? name : \"\");\n    }\n    return value;\n};\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n    return isCallable$d(this) && getInternalState$1(this).source || inspectSource$2(this);\n}, \"toString\");\nvar isCallable$c = isCallable$l;\nvar definePropertyModule$3 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\nvar defineBuiltIn$6 = function(O, key, value, options) {\n    if (!options) options = {};\n    var simple = options.enumerable;\n    var name = options.name !== undefined ? options.name : key;\n    if (isCallable$c(value)) makeBuiltIn(value, name, options);\n    if (options.global) {\n        if (simple) O[key] = value;\n        else defineGlobalProperty$1(key, value);\n    } else {\n        try {\n            if (!options.unsafe) delete O[key];\n            else if (O[key]) simple = true;\n        } catch (error) {}\n        if (simple) O[key] = value;\n        else definePropertyModule$3.f(O, key, {\n            value: value,\n            enumerable: false,\n            configurable: !options.nonConfigurable,\n            writable: !options.nonWritable\n        });\n    }\n    return O;\n};\nvar objectGetOwnPropertyNames = {};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return internalObjectKeys(O, hiddenKeys);\n};\nvar objectGetOwnPropertySymbols = {};\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn$4 = getBuiltIn$8;\nvar uncurryThis$8 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$8 = anObject$c;\nvar concat$1 = uncurryThis$8([].concat);\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$4(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n    var keys = getOwnPropertyNamesModule.f(anObject$8(it));\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n    return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$2 = objectDefineProperty;\nvar copyConstructorProperties$2 = function(target, source, exceptions) {\n    var keys = ownKeys(source);\n    var defineProperty = definePropertyModule$2.f;\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n            defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n        }\n    }\n};\nvar fails$9 = fails$h;\nvar isCallable$b = isCallable$l;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$2 = function(feature, detection) {\n    var value = data[normalize(feature)];\n    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$b(detection) ? fails$9(detection) : !!detection;\n};\nvar normalize = isForced$2.normalize = function(string) {\n    return String(string).replace(replacement, \".\").toLowerCase();\n};\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = \"N\";\nvar POLYFILL = isForced$2.POLYFILL = \"P\";\nvar isForced_1 = isForced$2;\nvar global$b = global$k;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$4;\nvar defineBuiltIn$5 = defineBuiltIn$6;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties$1 = copyConstructorProperties$2;\nvar isForced$1 = isForced_1;\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ var _export = function(options, source) {\n    var TARGET = options.target;\n    var GLOBAL = options.global;\n    var STATIC = options.stat;\n    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n    if (GLOBAL) {\n        target = global$b;\n    } else if (STATIC) {\n        target = global$b[TARGET] || defineGlobalProperty(TARGET, {});\n    } else {\n        target = (global$b[TARGET] || {}).prototype;\n    }\n    if (target) for(key in source){\n        sourceProperty = source[key];\n        if (options.dontCallGetSet) {\n            descriptor = getOwnPropertyDescriptor$1(target, key);\n            targetProperty = descriptor && descriptor.value;\n        } else targetProperty = target[key];\n        FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n        // contained in target\n        if (!FORCED && targetProperty !== undefined) {\n            if (typeof sourceProperty == typeof targetProperty) continue;\n            copyConstructorProperties$1(sourceProperty, targetProperty);\n        }\n        // add a flag to not completely full polyfills\n        if (options.sham || targetProperty && targetProperty.sham) {\n            createNonEnumerableProperty$2(sourceProperty, \"sham\", true);\n        }\n        defineBuiltIn$5(target, key, sourceProperty, options);\n    }\n};\nvar fails$8 = fails$h;\nvar correctPrototypeGetter = !fails$8(function() {\n    function F() {}\n    F.prototype.constructor = null;\n    // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n    return Object.getPrototypeOf(new F()) !== F.prototype;\n});\nvar hasOwn$4 = hasOwnProperty_1;\nvar isCallable$a = isCallable$l;\nvar toObject$3 = toObject$5;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\nvar IE_PROTO = sharedKey(\"IE_PROTO\");\nvar $Object$1 = Object;\nvar ObjectPrototype = $Object$1.prototype;\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function(O) {\n    var object = toObject$3(O);\n    if (hasOwn$4(object, IE_PROTO)) return object[IE_PROTO];\n    var constructor = object.constructor;\n    if (isCallable$a(constructor) && object instanceof constructor) {\n        return constructor.prototype;\n    }\n    return object instanceof $Object$1 ? ObjectPrototype : null;\n};\nvar fails$7 = fails$h;\nvar isCallable$9 = isCallable$l;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$6;\nvar wellKnownSymbol$d = wellKnownSymbol$g;\nvar ITERATOR$5 = wellKnownSymbol$d(\"iterator\");\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n/* eslint-disable es-x/no-array-prototype-keys -- safe */ if ([].keys) {\n    arrayIterator = [].keys();\n    // Safari 8 has buggy iterators w/o `next`\n    if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n    else {\n        PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n    }\n}\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$7(function() {\n    var test = {};\n    // FF44- legacy iterators case\n    return IteratorPrototype$2[ITERATOR$5].call(test) !== test;\n});\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$9(IteratorPrototype$2[ITERATOR$5])) {\n    defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function() {\n        return this;\n    });\n}\nvar iteratorsCore = {\n    IteratorPrototype: IteratorPrototype$2,\n    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\nvar defineProperty$3 = objectDefineProperty.f;\nvar hasOwn$3 = hasOwnProperty_1;\nvar wellKnownSymbol$c = wellKnownSymbol$g;\nvar TO_STRING_TAG$3 = wellKnownSymbol$c(\"toStringTag\");\nvar setToStringTag$3 = function(target, TAG, STATIC) {\n    if (target && !STATIC) target = target.prototype;\n    if (target && !hasOwn$3(target, TO_STRING_TAG$3)) {\n        defineProperty$3(target, TO_STRING_TAG$3, {\n            configurable: true,\n            value: TAG\n        });\n    }\n};\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create = objectCreate;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$4;\nvar setToStringTag$2 = setToStringTag$3;\nvar Iterators$4 = iterators;\nvar returnThis$1 = function() {\n    return this;\n};\nvar createIteratorConstructor$1 = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    IteratorConstructor.prototype = create(IteratorPrototype$1, {\n        next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next)\n    });\n    setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n    Iterators$4[TO_STRING_TAG] = returnThis$1;\n    return IteratorConstructor;\n};\nvar isCallable$8 = isCallable$l;\nvar $String$1 = String;\nvar $TypeError$8 = TypeError;\nvar aPossiblePrototype$1 = function(argument) {\n    if (typeof argument == \"object\" || isCallable$8(argument)) return argument;\n    throw $TypeError$8(\"Can't set \" + $String$1(argument) + \" as a prototype\");\n};\n/* eslint-disable no-proto -- safe */ var uncurryThis$7 = functionUncurryThis;\nvar anObject$7 = anObject$c;\nvar aPossiblePrototype = aPossiblePrototype$1;\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n    var CORRECT_SETTER = false;\n    var test = {};\n    var setter;\n    try {\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        setter = uncurryThis$7(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set);\n        setter(test, []);\n        CORRECT_SETTER = test instanceof Array;\n    } catch (error) {}\n    return function setPrototypeOf(O, proto) {\n        anObject$7(O);\n        aPossiblePrototype(proto);\n        if (CORRECT_SETTER) setter(O, proto);\n        else O.__proto__ = proto;\n        return O;\n    };\n}() : undefined);\nvar $$c = _export;\nvar call$a = functionCall;\nvar FunctionName = functionName;\nvar isCallable$7 = isCallable$l;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$3;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$4;\nvar defineBuiltIn$3 = defineBuiltIn$6;\nvar wellKnownSymbol$b = wellKnownSymbol$g;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\nvar PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$4 = wellKnownSymbol$b(\"iterator\");\nvar KEYS = \"keys\";\nvar VALUES = \"values\";\nvar ENTRIES = \"entries\";\nvar returnThis = function() {\n    return this;\n};\nvar defineIterator$1 = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n    createIteratorConstructor(IteratorConstructor, NAME, next);\n    var getIterationMethod = function(KIND) {\n        if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n        switch(KIND){\n            case KEYS:\n                return function keys() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case VALUES:\n                return function values() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case ENTRIES:\n                return function entries() {\n                    return new IteratorConstructor(this, KIND);\n                };\n        }\n        return function() {\n            return new IteratorConstructor(this);\n        };\n    };\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    var INCORRECT_VALUES_NAME = false;\n    var IterablePrototype = Iterable.prototype;\n    var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n    var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n    var CurrentIteratorPrototype, methods, KEY;\n    // fix native\n    if (anyNativeIterator) {\n        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n            if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n                if (setPrototypeOf$1) {\n                    setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n                } else if (!isCallable$7(CurrentIteratorPrototype[ITERATOR$4])) {\n                    defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);\n                }\n            }\n            // Set @@toStringTag to native iterators\n            setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n        }\n    }\n    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n    if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n        if (CONFIGURABLE_FUNCTION_NAME) {\n            createNonEnumerableProperty$1(IterablePrototype, \"name\", VALUES);\n        } else {\n            INCORRECT_VALUES_NAME = true;\n            defaultIterator = function values() {\n                return call$a(nativeIterator, this);\n            };\n        }\n    }\n    // export additional methods\n    if (DEFAULT) {\n        methods = {\n            values: getIterationMethod(VALUES),\n            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n            entries: getIterationMethod(ENTRIES)\n        };\n        if (FORCED) for(KEY in methods){\n            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n                defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n            }\n        }\n        else $$c({\n            target: NAME,\n            proto: true,\n            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n        }, methods);\n    }\n    // define iterator\n    if (IterablePrototype[ITERATOR$4] !== defaultIterator) {\n        defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, {\n            name: DEFAULT\n        });\n    }\n    Iterators$3[NAME] = defaultIterator;\n    return methods;\n};\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators$2 = iterators;\nvar InternalStateModule$1 = internalState;\nvar defineProperty$2 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$3 = descriptors;\nvar ARRAY_ITERATOR = \"Array Iterator\";\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalState = InternalStateModule$1.getterFor(ARRAY_ITERATOR);\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, \"Array\", function(iterated, kind) {\n    setInternalState$1(this, {\n        type: ARRAY_ITERATOR,\n        target: toIndexedObject(iterated),\n        index: 0,\n        kind: kind // kind\n    });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function() {\n    var state = getInternalState(this);\n    var target = state.target;\n    var kind = state.kind;\n    var index = state.index++;\n    if (!target || index >= target.length) {\n        state.target = undefined;\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    if (kind == \"keys\") return {\n        value: index,\n        done: false\n    };\n    if (kind == \"values\") return {\n        value: target[index],\n        done: false\n    };\n    return {\n        value: [\n            index,\n            target[index]\n        ],\n        done: false\n    };\n}, \"values\");\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1(\"keys\");\naddToUnscopables$1(\"values\");\naddToUnscopables$1(\"entries\");\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$3 && values.name !== \"values\") try {\n    defineProperty$2(values, \"name\", {\n        value: \"values\"\n    });\n} catch (error) {}\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n};\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\nvar classList = documentCreateElement(\"span\").classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\nvar global$a = global$k;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty = createNonEnumerableProperty$4;\nvar wellKnownSymbol$a = wellKnownSymbol$g;\nvar ITERATOR$3 = wellKnownSymbol$a(\"iterator\");\nvar TO_STRING_TAG$2 = wellKnownSymbol$a(\"toStringTag\");\nvar ArrayValues = ArrayIteratorMethods.values;\nvar handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {\n    if (CollectionPrototype) {\n        // some Chrome versions have non-configurable methods on DOMTokenList\n        if (CollectionPrototype[ITERATOR$3] !== ArrayValues) try {\n            createNonEnumerableProperty(CollectionPrototype, ITERATOR$3, ArrayValues);\n        } catch (error) {\n            CollectionPrototype[ITERATOR$3] = ArrayValues;\n        }\n        if (!CollectionPrototype[TO_STRING_TAG$2]) {\n            createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);\n        }\n        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){\n            // some Chrome versions have non-configurable methods on DOMTokenList\n            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n            } catch (error) {\n                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n            }\n        }\n    }\n};\nfor(var COLLECTION_NAME in DOMIterables){\n    handlePrototype(global$a[COLLECTION_NAME] && global$a[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\nhandlePrototype(DOMTokenListPrototype, \"DOMTokenList\");\nvar DESCRIPTORS$2 = descriptors;\nvar uncurryThis$6 = functionUncurryThis;\nvar call$9 = functionCall;\nvar fails$6 = fails$h;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$2 = toObject$5;\nvar IndexedObject$1 = indexedObject;\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$1 = Object.defineProperty;\nvar concat = uncurryThis$6([].concat);\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$6(function() {\n    // should have correct order of operations (Edge bug)\n    if (DESCRIPTORS$2 && $assign({\n        b: 1\n    }, $assign(defineProperty$1({}, \"a\", {\n        enumerable: true,\n        get: function() {\n            defineProperty$1(this, \"b\", {\n                value: 3,\n                enumerable: false\n            });\n        }\n    }), {\n        b: 2\n    })).b !== 1) return true;\n    // should work with symbols and should have deterministic property order (V8 bug)\n    var A = {};\n    var B = {};\n    // eslint-disable-next-line es-x/no-symbol -- safe\n    var symbol = Symbol();\n    var alphabet = \"abcdefghijklmnopqrst\";\n    A[symbol] = 7;\n    alphabet.split(\"\").forEach(function(chr) {\n        B[chr] = chr;\n    });\n    return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\"\") != alphabet;\n}) ? function assign(target, source) {\n    var T = toObject$2(target);\n    var argumentsLength = arguments.length;\n    var index = 1;\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n    var propertyIsEnumerable = propertyIsEnumerableModule.f;\n    while(argumentsLength > index){\n        var S = IndexedObject$1(arguments[index++]);\n        var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n        var length = keys.length;\n        var j = 0;\n        var key;\n        while(length > j){\n            key = keys[j++];\n            if (!DESCRIPTORS$2 || call$9(propertyIsEnumerable, S, key)) T[key] = S[key];\n        }\n    }\n    return T;\n} : $assign;\nvar $$b = _export;\nvar assign = objectAssign;\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$b({\n    target: \"Object\",\n    stat: true,\n    arity: 2,\n    forced: Object.assign !== assign\n}, {\n    assign: assign\n});\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst CloseIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        fill: \"#C1C1C1\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M0 0h24v24H0z\",\n                fill: \"none\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"\n            })\n        ]\n    }));\n};\nconst CloseButton = ({ onClick })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        onClick: onClick,\n        className: \"close-button\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseIcon, {})\n    }));\n};\nconst ModalHeader = ({ title, onCloseModal })=>{\n    const additionalClasses = title === \"Get a Wallet\" ? \" -open\" : \"\";\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"nws-modal-header\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n                className: `middleTitle ${additionalClasses}`\n            }, {\n                children: title\n            })),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseButton, {\n                onClick: onCloseModal\n            })\n        ]\n    }));\n};\nconst BackArrowIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        width: \"8\",\n        height: \"14\",\n        viewBox: \"0 0 8 14\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M7 13L1 7L7 1\",\n            stroke: \"#6494EE\",\n            strokeWidth: \"1.5\",\n            strokeLinecap: \"round\",\n            strokeLinejoin: \"round\"\n        })\n    }));\n};\nconst BackArrow = ({ onClick })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n        onClick: onClick,\n        className: \"back-button\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrowIcon, {})\n    }));\n};\nconst WalletNetworkChanged = ({ selector, onBack, onCloseModal })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"nws-modal-header-wrapper\"\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n                        onClick: onBack\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n                        title: \"You Must Change the Network\",\n                        onCloseModal: onCloseModal\n                    })\n                ]\n            })),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                className: \"switch-network-message-wrapper\"\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                    className: \"content\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                            children: [\n                                \"We've detected that you need to change your wallet's network to\",\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", Object.assign({\n                                    className: \"network-id\"\n                                }, {\n                                    children: ` ${selector.options.network.networkId}`\n                                })),\n                                \" \",\n                                \"for this dApp.\"\n                            ]\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                            children: \"Some wallets may not support changing networks. If you can not change networks you may consider switching to another wallet.\"\n                        })\n                    ]\n                }))\n            }))\n        ]\n    });\n};\nvar tryToString$3 = tryToString$5;\nvar $TypeError$7 = TypeError;\nvar deletePropertyOrThrow$1 = function(O, P) {\n    if (!delete O[P]) throw $TypeError$7(\"Cannot delete property \" + tryToString$3(P) + \" of \" + tryToString$3(O));\n};\nvar wellKnownSymbol$9 = wellKnownSymbol$g;\nvar TO_STRING_TAG$1 = wellKnownSymbol$9(\"toStringTag\");\nvar test$1 = {};\ntest$1[TO_STRING_TAG$1] = \"z\";\nvar toStringTagSupport = String(test$1) === \"[object z]\";\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$6 = isCallable$l;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$8 = wellKnownSymbol$g;\nvar TO_STRING_TAG = wellKnownSymbol$8(\"toStringTag\");\nvar $Object = Object;\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function() {\n    return arguments;\n}()) == \"Arguments\";\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key) {\n    try {\n        return it[key];\n    } catch (error) {}\n};\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$5 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n    var O, tag, result;\n    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && isCallable$6(O.callee) ? \"Arguments\" : result;\n};\nvar classof$4 = classof$5;\nvar $String = String;\nvar toString$3 = function(argument) {\n    if (classof$4(argument) === \"Symbol\") throw TypeError(\"Cannot convert a Symbol value to a string\");\n    return $String(argument);\n};\nvar toPropertyKey = toPropertyKey$3;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$4;\nvar createProperty$1 = function(object, key, value) {\n    var propertyKey = toPropertyKey(key);\n    if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor(0, value));\n    else object[propertyKey] = value;\n};\nvar toAbsoluteIndex = toAbsoluteIndex$2;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$5;\nvar createProperty = createProperty$1;\nvar $Array = Array;\nvar max = Math.max;\nvar arraySliceSimple = function(O, start, end) {\n    var length = lengthOfArrayLike$3(O);\n    var k = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    var result = $Array(max(fin - k, 0));\n    for(var n = 0; k < fin; k++, n++)createProperty(result, n, O[k]);\n    result.length = n;\n    return result;\n};\nvar arraySlice$2 = arraySliceSimple;\nvar floor = Math.floor;\nvar mergeSort = function(array, comparefn) {\n    var length = array.length;\n    var middle = floor(length / 2);\n    return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice$2(array, 0, middle), comparefn), mergeSort(arraySlice$2(array, middle), comparefn), comparefn);\n};\nvar insertionSort = function(array, comparefn) {\n    var length = array.length;\n    var i = 1;\n    var element, j;\n    while(i < length){\n        j = i;\n        element = array[i];\n        while(j && comparefn(array[j - 1], element) > 0){\n            array[j] = array[--j];\n        }\n        if (j !== i++) array[j] = element;\n    }\n    return array;\n};\nvar merge = function(array, left, right, comparefn) {\n    var llength = left.length;\n    var rlength = right.length;\n    var lindex = 0;\n    var rindex = 0;\n    while(lindex < llength || rindex < rlength){\n        array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];\n    }\n    return array;\n};\nvar arraySort = mergeSort;\nvar fails$5 = fails$h;\nvar arrayMethodIsStrict$2 = function(METHOD_NAME, argument) {\n    var method = [][METHOD_NAME];\n    return !!method && fails$5(function() {\n        // eslint-disable-next-line no-useless-call -- required for testing\n        method.call(null, argument || function() {\n            return 1;\n        }, 1);\n    });\n};\nvar userAgent$4 = engineUserAgent;\nvar firefox = userAgent$4.match(/firefox\\/(\\d+)/i);\nvar engineFfVersion = !!firefox && +firefox[1];\nvar UA = engineUserAgent;\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\nvar userAgent$3 = engineUserAgent;\nvar webkit = userAgent$3.match(/AppleWebKit\\/(\\d+)\\./);\nvar engineWebkitVersion = !!webkit && +webkit[1];\nvar $$a = _export;\nvar uncurryThis$5 = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar toObject$1 = toObject$5;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$5;\nvar deletePropertyOrThrow = deletePropertyOrThrow$1;\nvar toString$2 = toString$3;\nvar fails$4 = fails$h;\nvar internalSort = arraySort;\nvar arrayMethodIsStrict$1 = arrayMethodIsStrict$2;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\nvar test = [];\nvar un$Sort = uncurryThis$5(test.sort);\nvar push = uncurryThis$5(test.push);\n// IE8-\nvar FAILS_ON_UNDEFINED = fails$4(function() {\n    test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails$4(function() {\n    test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD$1 = arrayMethodIsStrict$1(\"sort\");\nvar STABLE_SORT = !fails$4(function() {\n    // feature detection can be too slow, so check engines versions\n    if (V8) return V8 < 70;\n    if (FF && FF > 3) return;\n    if (IE_OR_EDGE) return true;\n    if (WEBKIT) return WEBKIT < 603;\n    var result = \"\";\n    var code, chr, value, index;\n    // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n    for(code = 65; code < 76; code++){\n        chr = String.fromCharCode(code);\n        switch(code){\n            case 66:\n            case 69:\n            case 70:\n            case 72:\n                value = 3;\n                break;\n            case 68:\n            case 71:\n                value = 4;\n                break;\n            default:\n                value = 2;\n        }\n        for(index = 0; index < 47; index++){\n            test.push({\n                k: chr + index,\n                v: value\n            });\n        }\n    }\n    test.sort(function(a, b) {\n        return b.v - a.v;\n    });\n    for(index = 0; index < test.length; index++){\n        chr = test[index].k.charAt(0);\n        if (result.charAt(result.length - 1) !== chr) result += chr;\n    }\n    return result !== \"DGBEFHACIJK\";\n});\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;\nvar getSortCompare = function(comparefn) {\n    return function(x, y) {\n        if (y === undefined) return -1;\n        if (x === undefined) return 1;\n        if (comparefn !== undefined) return +comparefn(x, y) || 0;\n        return toString$2(x) > toString$2(y) ? 1 : -1;\n    };\n};\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$$a({\n    target: \"Array\",\n    proto: true,\n    forced: FORCED\n}, {\n    sort: function sort(comparefn) {\n        if (comparefn !== undefined) aCallable$7(comparefn);\n        var array = toObject$1(this);\n        if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n        var items = [];\n        var arrayLength = lengthOfArrayLike$2(array);\n        var itemsLength, index;\n        for(index = 0; index < arrayLength; index++){\n            if (index in array) push(items, array[index]);\n        }\n        internalSort(items, getSortCompare(comparefn));\n        itemsLength = items.length;\n        index = 0;\n        while(index < itemsLength)array[index] = items[index++];\n        while(index < arrayLength)deletePropertyOrThrow(array, index++);\n        return array;\n    }\n});\nvar $$9 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$3 = fails$h;\nvar addToUnscopables = addToUnscopables$2;\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$3(function() {\n    return !Array(1).includes();\n});\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$9({\n    target: \"Array\",\n    proto: true,\n    forced: BROKEN_ON_SPARSE\n}, {\n    includes: function includes(el /* , fromIndex = 0 */ ) {\n        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n    }\n});\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(\"includes\");\nvar isObject$2 = isObject$8;\nvar classof$3 = classofRaw$1;\nvar wellKnownSymbol$7 = wellKnownSymbol$g;\nvar MATCH$1 = wellKnownSymbol$7(\"match\");\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function(it) {\n    var isRegExp;\n    return isObject$2(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$3(it) == \"RegExp\");\n};\nvar isRegExp = isRegexp;\nvar $TypeError$6 = TypeError;\nvar notARegexp = function(it) {\n    if (isRegExp(it)) {\n        throw $TypeError$6(\"The method doesn't accept regular expressions\");\n    }\n    return it;\n};\nvar wellKnownSymbol$6 = wellKnownSymbol$g;\nvar MATCH = wellKnownSymbol$6(\"match\");\nvar correctIsRegexpLogic = function(METHOD_NAME) {\n    var regexp = /./;\n    try {\n        \"/./\"[METHOD_NAME](regexp);\n    } catch (error1) {\n        try {\n            regexp[MATCH] = false;\n            return \"/./\"[METHOD_NAME](regexp);\n        } catch (error2) {}\n    }\n    return false;\n};\nvar $$8 = _export;\nvar uncurryThis$4 = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible = requireObjectCoercible$3;\nvar toString$1 = toString$3;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\nvar stringIndexOf = uncurryThis$4(\"\".indexOf);\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$8({\n    target: \"String\",\n    proto: true,\n    forced: !correctIsRegExpLogic(\"includes\")\n}, {\n    includes: function includes(searchString /* , position = 0 */ ) {\n        return !!~stringIndexOf(toString$1(requireObjectCoercible(this)), toString$1(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);\n    }\n});\nvar aCallable$6 = aCallable$9;\nvar toObject = toObject$5;\nvar IndexedObject = indexedObject;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$5;\nvar $TypeError$5 = TypeError;\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function(IS_RIGHT) {\n    return function(that, callbackfn, argumentsLength, memo) {\n        aCallable$6(callbackfn);\n        var O = toObject(that);\n        var self1 = IndexedObject(O);\n        var length = lengthOfArrayLike$1(O);\n        var index = IS_RIGHT ? length - 1 : 0;\n        var i = IS_RIGHT ? -1 : 1;\n        if (argumentsLength < 2) while(true){\n            if (index in self1) {\n                memo = self1[index];\n                index += i;\n                break;\n            }\n            index += i;\n            if (IS_RIGHT ? index < 0 : length <= index) {\n                throw $TypeError$5(\"Reduce of empty array with no initial value\");\n            }\n        }\n        for(; IS_RIGHT ? index >= 0 : length > index; index += i)if (index in self1) {\n            memo = callbackfn(memo, self1[index], index, O);\n        }\n        return memo;\n    };\n};\nvar arrayReduce = {\n    // `Array.prototype.reduce` method\n    // https://tc39.es/ecma262/#sec-array.prototype.reduce\n    left: createMethod(false),\n    // `Array.prototype.reduceRight` method\n    // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n    right: createMethod(true)\n};\nvar classof$2 = classofRaw$1;\nvar global$9 = global$k;\nvar engineIsNode = classof$2(global$9.process) == \"process\";\nvar $$7 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$2;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE$3 = engineIsNode;\nvar STRICT_METHOD = arrayMethodIsStrict(\"reduce\");\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE$3 && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$7({\n    target: \"Array\",\n    proto: true,\n    forced: !STRICT_METHOD || CHROME_BUG\n}, {\n    reduce: function reduce(callbackfn /* , initialValue */ ) {\n        var length = arguments.length;\n        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n    }\n});\nvar $$6 = _export;\nvar DESCRIPTORS$1 = descriptors;\nvar global$8 = global$k;\nvar uncurryThis$3 = functionUncurryThis;\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$l;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar toString = toString$3;\nvar defineProperty = objectDefineProperty.f;\nvar copyConstructorProperties = copyConstructorProperties$2;\nvar NativeSymbol = global$8.Symbol;\nvar SymbolPrototype = NativeSymbol && NativeSymbol.prototype;\nif (DESCRIPTORS$1 && isCallable$5(NativeSymbol) && (!(\"description\" in SymbolPrototype) || // Safari 12 bug\nNativeSymbol().description !== undefined)) {\n    var EmptyStringDescriptionStore = {};\n    // wrap Symbol constructor for correct work with undefined description\n    var SymbolWrapper = function Symbol1() {\n        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);\n        var result = isPrototypeOf$3(SymbolPrototype, this) ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);\n        if (description === \"\") EmptyStringDescriptionStore[result] = true;\n        return result;\n    };\n    copyConstructorProperties(SymbolWrapper, NativeSymbol);\n    SymbolWrapper.prototype = SymbolPrototype;\n    SymbolPrototype.constructor = SymbolWrapper;\n    var NATIVE_SYMBOL = String(NativeSymbol(\"test\")) == \"Symbol(test)\";\n    var symbolToString = uncurryThis$3(SymbolPrototype.toString);\n    var symbolValueOf = uncurryThis$3(SymbolPrototype.valueOf);\n    var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n    var replace = uncurryThis$3(\"\".replace);\n    var stringSlice = uncurryThis$3(\"\".slice);\n    defineProperty(SymbolPrototype, \"description\", {\n        configurable: true,\n        get: function description() {\n            var symbol = symbolValueOf(this);\n            var string = symbolToString(symbol);\n            if (hasOwn$2(EmptyStringDescriptionStore, symbol)) return \"\";\n            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, \"$1\");\n            return desc === \"\" ? undefined : desc;\n        }\n    });\n    $$6({\n        global: true,\n        constructor: true,\n        forced: true\n    }, {\n        Symbol: SymbolWrapper\n    });\n}\nconst WarningIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: \"18\",\n        height: \"18\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M4.95215 16.3536L10.2152 5.85657C10.9531 4.38481 13.0538 4.38519 13.7912 5.85723L19.0494 16.3543C19.7156 17.6841 18.7486 19.25 17.2612 19.25H6.74001C5.25228 19.25 4.28535 17.6835 4.95215 16.3536Z\",\n                stroke: \"#E6B73E\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M12 10V12\",\n                stroke: \"#E6B73E\",\n                strokeWidth: \"2\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M12.5 16C12.5 16.2761 12.2761 16.5 12 16.5C11.7239 16.5 11.5 16.2761 11.5 16C11.5 15.7239 11.7239 15.5 12 15.5C12.2761 15.5 12.5 15.7239 12.5 16Z\",\n                stroke: \"#E6B73E\"\n            })\n        ]\n    }));\n};\nconst WalletOptions = ({ selector, handleWalletClick })=>{\n    const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [recentModules, setRecentModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [moreModules, setMoreModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [activeWalletId, setActiveWalletId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const subscription = selector.store.observable.subscribe((state)=>{\n            const { selectedWalletId } = selector.store.getState();\n            if (selectedWalletId) {\n                setActiveWalletId(selectedWalletId);\n            }\n            const wallets = state.modules.filter((module)=>!(module.type === \"instant-link\" && selectedWalletId !== module.id));\n            if (selector.options.optimizeWalletOrder) {\n                state.modules.sort((current, next)=>{\n                    if (current.metadata.deprecated === next.metadata.deprecated) {\n                        return 0;\n                    }\n                    return current.metadata.deprecated ? 1 : -1;\n                });\n                state.modules.sort((current, next)=>{\n                    if (next.metadata.available === current.metadata.available) {\n                        return 0;\n                    }\n                    return next.metadata.available ? 1 : -1;\n                });\n                const moreWallets = [];\n                const recentlySignedInWallets = [];\n                wallets.forEach((module)=>{\n                    if (selector.store.getState().recentlySignedInWallets.includes(module.id)) {\n                        recentlySignedInWallets.push(module);\n                    } else {\n                        moreWallets.push(module);\n                    }\n                });\n                setRecentModules(recentlySignedInWallets);\n                setMoreModules(moreWallets);\n            }\n            if (selector.options.randomizeWalletOrder) {\n                setModules(wallets.sort(()=>Math.random() - 0.5));\n            } else {\n                setModules(wallets);\n            }\n        });\n        return ()=>subscription.unsubscribe();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    function renderOptionsList(modulesToRender) {\n        return modulesToRender.reduce((result, module, index)=>{\n            const { selectedWalletId } = selector.store.getState();\n            const { name, description, iconUrl, deprecated } = module.metadata;\n            const selected = module.id === selectedWalletId;\n            result.push((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"li\", Object.assign({\n                tabIndex: 0,\n                className: `single-wallet ${activeWalletId === module.id ? \"selected-wallet\" : \"\"} ${selected ? \"connected-wallet\" : \"\"} ${deprecated ? \"deprecated-wallet\" : \"\"} sidebar ${module.id}`,\n                onClick: ()=>{\n                    if (module.id === modulesToRender[index].id) {\n                        setActiveWalletId(module.id);\n                    }\n                    return handleWalletClick(module);\n                }\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                        className: \"icon\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                            src: iconUrl,\n                            alt: name\n                        })\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"content\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"title\"\n                            }, {\n                                children: name\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"description\"\n                            }, {\n                                children: description\n                            }))\n                        ]\n                    })),\n                    deprecated && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                        className: \"warning-triangle\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WarningIcon, {})\n                    }))\n                ]\n            }), module.id));\n            return result;\n        }, []);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        children: selector.options.optimizeWalletOrder && selector.store.getState().recentlySignedInWallets.length > 0 ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"wallet-options-wrapper\"\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                    className: \"options-list-section\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"options-list-section-header\"\n                        }, {\n                            children: \"Recent\"\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"options-list more-options-list-content\"\n                        }, {\n                            children: renderOptionsList(recentModules)\n                        }))\n                    ]\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                    className: \"options-list-section\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"options-list-section-header\"\n                        }, {\n                            children: \"More\"\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"options-list more-options-list-content\"\n                        }, {\n                            children: renderOptionsList(moreModules)\n                        }))\n                    ]\n                }))\n            ]\n        })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"wallet-options-wrapper\"\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                className: \"options-list\"\n            }, {\n                children: renderOptionsList(modules)\n            }))\n        }))\n    });\n};\nconst ConnectionErrorIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: \"21\",\n        height: \"20\",\n        viewBox: \"0 0 21 20\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M10.5001 18.3333C15.1025 18.3333 18.8334 14.6023 18.8334 9.99996C18.8334 5.39759 15.1025 1.66663 10.5001 1.66663C5.89771 1.66663 2.16675 5.39759 2.16675 9.99996C2.16675 14.6023 5.89771 18.3333 10.5001 18.3333Z\",\n                stroke: \"#CE5A6F\",\n                strokeWidth: \"2\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M13 7.5L8 12.5\",\n                stroke: \"#CE5A6F\",\n                strokeWidth: \"2\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M8 7.5L13 12.5\",\n                stroke: \"#CE5A6F\",\n                strokeWidth: \"2\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            })\n        ]\n    }));\n};\nconst ConnectionSuccessIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: \"21\",\n        height: \"20\",\n        viewBox: \"0 0 21 20\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M18.8333 9.2333V9.99997C18.8323 11.797 18.2504 13.5455 17.1744 14.9848C16.0984 16.4241 14.586 17.477 12.8628 17.9866C11.1395 18.4961 9.29768 18.4349 7.61202 17.8121C5.92636 17.1894 4.48717 16.0384 3.50909 14.5309C2.53101 13.0233 2.06645 11.24 2.18469 9.4469C2.30293 7.65377 2.99763 5.94691 4.16519 4.58086C5.33275 3.21482 6.91061 2.26279 8.66345 1.86676C10.4163 1.47073 12.2502 1.65192 13.8916 2.3833\",\n                stroke: \"#4FD98F\",\n                strokeWidth: \"2\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M18.8333 3.33337L10.5 11.675L8 9.17504\",\n                stroke: \"#4FD98F\",\n                strokeWidth: \"2\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            })\n        ]\n    }));\n};\nconst ConnectionResult = ({ module, message, err, onRetry })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        className: \"connection connecting-details\"\n    }, {\n        children: err ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"error-wrapper\"\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                    className: \"error\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionErrorIcon, {}),\n                        (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionFailed\")\n                    ]\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                    children: message\n                }),\n                (module === null || module === void 0 ? void 0 : module.metadata.available) && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                    onClick: onRetry\n                }, {\n                    children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.retry\")\n                }))\n            ]\n        })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            className: \"success\"\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionSuccessIcon, {}),\n                (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionSuccessful\")\n            ]\n        }))\n    }));\n};\nconst AlertMessage = ({ message, module, onBack, onCloseModal })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n                title: \"\",\n                onCloseModal: onCloseModal\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                className: \"alert-message connecting-wrapper connecting-wrapper-err\"\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                    className: \"content\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"icon\"\n                        }, {\n                            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                src: module === null || module === void 0 ? void 0 : module.metadata.iconUrl,\n                                alt: module === null || module === void 0 ? void 0 : module.metadata.name\n                            })\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n                            className: \"connecting-name\"\n                        }, {\n                            children: module === null || module === void 0 ? void 0 : module.metadata.name\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionResult, {\n                            module: module,\n                            message: message,\n                            err: message !== null,\n                            onRetry: ()=>{\n                                onBack(true);\n                            }\n                        })\n                    ]\n                }))\n            }))\n        ]\n    });\n};\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule = objectDefineProperty;\nvar wellKnownSymbol$5 = wellKnownSymbol$g;\nvar DESCRIPTORS = descriptors;\nvar SPECIES$2 = wellKnownSymbol$5(\"species\");\nvar setSpecies$1 = function(CONSTRUCTOR_NAME) {\n    var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n    var defineProperty = definePropertyModule.f;\n    if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {\n        defineProperty(Constructor, SPECIES$2, {\n            configurable: true,\n            get: function() {\n                return this;\n            }\n        });\n    }\n};\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar $TypeError$4 = TypeError;\nvar anInstance$1 = function(it, Prototype) {\n    if (isPrototypeOf$2(Prototype, it)) return it;\n    throw $TypeError$4(\"Incorrect invocation\");\n};\nvar uncurryThis$2 = functionUncurryThis;\nvar fails$2 = fails$h;\nvar isCallable$4 = isCallable$l;\nvar classof$1 = classof$5;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\nvar noop = function() {};\nvar empty = [];\nvar construct = getBuiltIn$2(\"Reflect\", \"construct\");\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$2(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\nvar isConstructorModern = function isConstructor(argument) {\n    if (!isCallable$4(argument)) return false;\n    try {\n        construct(noop, empty, argument);\n        return true;\n    } catch (error) {\n        return false;\n    }\n};\nvar isConstructorLegacy = function isConstructor(argument) {\n    if (!isCallable$4(argument)) return false;\n    switch(classof$1(argument)){\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n            return false;\n    }\n    try {\n        // we can't check .prototype since constructors produced by .bind haven't it\n        // `Function#toString` throws on some built-it function in some legacy engines\n        // (for example, `DOMQuad` and similar in FF41-)\n        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));\n    } catch (error) {\n        return true;\n    }\n};\nisConstructorLegacy.sham = true;\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails$2(function() {\n    var called;\n    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {\n        called = true;\n    }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar isConstructor = isConstructor$1;\nvar tryToString$2 = tryToString$5;\nvar $TypeError$3 = TypeError;\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function(argument) {\n    if (isConstructor(argument)) return argument;\n    throw $TypeError$3(tryToString$2(argument) + \" is not a constructor\");\n};\nvar anObject$6 = anObject$c;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$g;\nvar SPECIES$1 = wellKnownSymbol$4(\"species\");\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function(O, defaultConstructor) {\n    var C = anObject$6(O).constructor;\n    var S;\n    return C === undefined || (S = anObject$6(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);\n};\nvar NATIVE_BIND$1 = functionBindNative;\nvar FunctionPrototype = Function.prototype;\nvar apply$1 = FunctionPrototype.apply;\nvar call$8 = FunctionPrototype.call;\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND$1 ? call$8.bind(apply$1) : function() {\n    return call$8.apply(apply$1, arguments);\n});\nvar uncurryThis$1 = functionUncurryThis;\nvar aCallable$5 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\nvar bind$4 = uncurryThis$1(uncurryThis$1.bind);\n// optional / simple context binding\nvar functionBindContext = function(fn, that) {\n    aCallable$5(fn);\n    return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function() {\n        return fn.apply(that, arguments);\n    };\n};\nvar uncurryThis = functionUncurryThis;\nvar arraySlice$1 = uncurryThis([].slice);\nvar $TypeError$2 = TypeError;\nvar validateArgumentsLength$1 = function(passed, required) {\n    if (passed < required) throw $TypeError$2(\"Not enough arguments\");\n    return passed;\n};\nvar userAgent$2 = engineUserAgent;\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\nvar global$7 = global$k;\nvar apply = functionApply;\nvar bind$3 = functionBindContext;\nvar isCallable$3 = isCallable$l;\nvar hasOwn$1 = hasOwnProperty_1;\nvar fails$1 = fails$h;\nvar html = html$2;\nvar arraySlice = arraySlice$1;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\nvar set = global$7.setImmediate;\nvar clear = global$7.clearImmediate;\nvar process$2 = global$7.process;\nvar Dispatch = global$7.Dispatch;\nvar Function$1 = global$7.Function;\nvar MessageChannel = global$7.MessageChannel;\nvar String$1 = global$7.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = \"onreadystatechange\";\nvar location, defer, channel, port;\ntry {\n    // Deno throws a ReferenceError on `location` access without `--location` flag\n    location = global$7.location;\n} catch (error) {}\nvar run = function(id) {\n    if (hasOwn$1(queue$1, id)) {\n        var fn = queue$1[id];\n        delete queue$1[id];\n        fn();\n    }\n};\nvar runner = function(id) {\n    return function() {\n        run(id);\n    };\n};\nvar listener = function(event) {\n    run(event.data);\n};\nvar post = function(id) {\n    // old engines have not location.origin\n    global$7.postMessage(String$1(id), location.protocol + \"//\" + location.host);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n    set = function setImmediate(handler) {\n        validateArgumentsLength(arguments.length, 1);\n        var fn = isCallable$3(handler) ? handler : Function$1(handler);\n        var args = arraySlice(arguments, 1);\n        queue$1[++counter] = function() {\n            apply(fn, undefined, args);\n        };\n        defer(counter);\n        return counter;\n    };\n    clear = function clearImmediate(id) {\n        delete queue$1[id];\n    };\n    // Node.js 0.8-\n    if (IS_NODE$2) {\n        defer = function(id) {\n            process$2.nextTick(runner(id));\n        };\n    // Sphere (JS game engine) Dispatch API\n    } else if (Dispatch && Dispatch.now) {\n        defer = function(id) {\n            Dispatch.now(runner(id));\n        };\n    // Browsers with MessageChannel, includes WebWorkers\n    // except iOS - https://github.com/zloirock/core-js/issues/624\n    } else if (MessageChannel && !IS_IOS$1) {\n        channel = new MessageChannel();\n        port = channel.port2;\n        channel.port1.onmessage = listener;\n        defer = bind$3(port.postMessage, port);\n    // Browsers with postMessage, skip WebWorkers\n    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n    } else if (global$7.addEventListener && isCallable$3(global$7.postMessage) && !global$7.importScripts && location && location.protocol !== \"file:\" && !fails$1(post)) {\n        defer = post;\n        global$7.addEventListener(\"message\", listener, false);\n    // IE8-\n    } else if (ONREADYSTATECHANGE in createElement(\"script\")) {\n        defer = function(id) {\n            html.appendChild(createElement(\"script\"))[ONREADYSTATECHANGE] = function() {\n                html.removeChild(this);\n                run(id);\n            };\n        };\n    // Rest old browsers\n    } else {\n        defer = function(id) {\n            setTimeout(runner(id), 0);\n        };\n    }\n}\nvar task$1 = {\n    set: set,\n    clear: clear\n};\nvar userAgent$1 = engineUserAgent;\nvar global$6 = global$k;\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$6.Pebble !== undefined;\nvar userAgent = engineUserAgent;\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\nvar global$5 = global$k;\nvar bind$2 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\nvar MutationObserver = global$5.MutationObserver || global$5.WebKitMutationObserver;\nvar document$2 = global$5.document;\nvar process$1 = global$5.process;\nvar Promise$1 = global$5.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$5, \"queueMicrotask\");\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\nvar flush, head, last, notify$1, toggle, node, promise, then;\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n    flush = function() {\n        var parent, fn;\n        if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n        while(head){\n            fn = head.fn;\n            head = head.next;\n            try {\n                fn();\n            } catch (error) {\n                if (head) notify$1();\n                else last = undefined;\n                throw error;\n            }\n        }\n        last = undefined;\n        if (parent) parent.enter();\n    };\n    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n    if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n        toggle = true;\n        node = document$2.createTextNode(\"\");\n        new MutationObserver(flush).observe(node, {\n            characterData: true\n        });\n        notify$1 = function() {\n            node.data = toggle = !toggle;\n        };\n    // environments with maybe non-completely correct, but existent Promise\n    } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n        // Promise.resolve without an argument throws an error in LG WebOS 2\n        promise = Promise$1.resolve(undefined);\n        // workaround of WebKit ~ iOS Safari 10.1 bug\n        promise.constructor = Promise$1;\n        then = bind$2(promise.then, promise);\n        notify$1 = function() {\n            then(flush);\n        };\n    // Node.js without promises\n    } else if (IS_NODE$1) {\n        notify$1 = function() {\n            process$1.nextTick(flush);\n        };\n    // for other environments - macrotask based on:\n    // - setImmediate\n    // - MessageChannel\n    // - window.postMessage\n    // - onreadystatechange\n    // - setTimeout\n    } else {\n        // strange IE + webpack dev server bug - use .bind(global)\n        macrotask = bind$2(macrotask, global$5);\n        notify$1 = function() {\n            macrotask(flush);\n        };\n    }\n}\nvar microtask$1 = queueMicrotask || function(fn) {\n    var task = {\n        fn: fn,\n        next: undefined\n    };\n    if (last) last.next = task;\n    if (!head) {\n        head = task;\n        notify$1();\n    }\n    last = task;\n};\nvar global$4 = global$k;\nvar hostReportErrors$1 = function(a, b) {\n    var console = global$4.console;\n    if (console && console.error) {\n        arguments.length == 1 ? console.error(a) : console.error(a, b);\n    }\n};\nvar perform$3 = function(exec) {\n    try {\n        return {\n            error: false,\n            value: exec()\n        };\n    } catch (error) {\n        return {\n            error: true,\n            value: error\n        };\n    }\n};\nvar Queue$1 = function() {\n    this.head = null;\n    this.tail = null;\n};\nQueue$1.prototype = {\n    add: function(item) {\n        var entry = {\n            item: item,\n            next: null\n        };\n        if (this.head) this.tail.next = entry;\n        else this.head = entry;\n        this.tail = entry;\n    },\n    get: function() {\n        var entry = this.head;\n        if (entry) {\n            this.head = entry.next;\n            if (this.tail === entry) this.tail = null;\n            return entry.item;\n        }\n    }\n};\nvar queue = Queue$1;\nvar global$3 = global$k;\nvar promiseNativeConstructor = global$3.Promise;\nvar engineIsBrowser =  false && 0;\nvar global$2 = global$k;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$2 = isCallable$l;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$3 = wellKnownSymbol$g;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES = wellKnownSymbol$3(\"species\");\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(global$2.PromiseRejectionEvent);\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced(\"Promise\", function() {\n    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n    // We can't detect it synchronously, so just check versions\n    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n    // We can't use @@species feature detection in V8 since it causes\n    // deoptimization and performance degradation\n    // https://github.com/zloirock/core-js/issues/679\n    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n    // Detect correctness of subclassing with @@species support\n    var promise = new NativePromiseConstructor$3(function(resolve) {\n        resolve(1);\n    });\n    var FakePromise = function(exec) {\n        exec(function() {}, function() {});\n    };\n    var constructor = promise.constructor = {};\n    constructor[SPECIES] = FakePromise;\n    SUBCLASSING = promise.then(function() {}) instanceof FakePromise;\n    if (!SUBCLASSING) return true;\n    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\nvar promiseConstructorDetection = {\n    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n    SUBCLASSING: SUBCLASSING\n};\nvar newPromiseCapability$2 = {};\nvar aCallable$4 = aCallable$9;\nvar PromiseCapability = function(C) {\n    var resolve, reject;\n    this.promise = new C(function($$resolve, $$reject) {\n        if (resolve !== undefined || reject !== undefined) throw TypeError(\"Bad Promise constructor\");\n        resolve = $$resolve;\n        reject = $$reject;\n    });\n    this.resolve = aCallable$4(resolve);\n    this.reject = aCallable$4(reject);\n};\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function(C) {\n    return new PromiseCapability(C);\n};\nvar $$5 = _export;\nvar IS_NODE = engineIsNode;\nvar global$1 = global$k;\nvar call$7 = functionCall;\nvar defineBuiltIn$2 = defineBuiltIn$6;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag = setToStringTag$3;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$9;\nvar isCallable$1 = isCallable$l;\nvar isObject$1 = isObject$8;\nvar anInstance = anInstance$1;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\nvar PROMISE = \"Promise\";\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar setInternalState = InternalStateModule.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$1 = global$1.TypeError;\nvar document$1 = global$1.document;\nvar process = global$1.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);\nvar UNHANDLED_REJECTION = \"unhandledrejection\";\nvar REJECTION_HANDLED = \"rejectionhandled\";\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n// helpers\nvar isThenable = function(it) {\n    var then;\n    return isObject$1(it) && isCallable$1(then = it.then) ? then : false;\n};\nvar callReaction = function(reaction, state) {\n    var value = state.value;\n    var ok = state.state == FULFILLED;\n    var handler = ok ? reaction.ok : reaction.fail;\n    var resolve = reaction.resolve;\n    var reject = reaction.reject;\n    var domain = reaction.domain;\n    var result, then, exited;\n    try {\n        if (handler) {\n            if (!ok) {\n                if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n                state.rejection = HANDLED;\n            }\n            if (handler === true) result = value;\n            else {\n                if (domain) domain.enter();\n                result = handler(value); // can throw\n                if (domain) {\n                    domain.exit();\n                    exited = true;\n                }\n            }\n            if (result === reaction.promise) {\n                reject(TypeError$1(\"Promise-chain cycle\"));\n            } else if (then = isThenable(result)) {\n                call$7(then, result, resolve, reject);\n            } else resolve(result);\n        } else reject(value);\n    } catch (error) {\n        if (domain && !exited) domain.exit();\n        reject(error);\n    }\n};\nvar notify = function(state, isReject) {\n    if (state.notified) return;\n    state.notified = true;\n    microtask(function() {\n        var reactions = state.reactions;\n        var reaction;\n        while(reaction = reactions.get()){\n            callReaction(reaction, state);\n        }\n        state.notified = false;\n        if (isReject && !state.rejection) onUnhandled(state);\n    });\n};\nvar dispatchEvent = function(name, promise, reason) {\n    var event, handler;\n    if (DISPATCH_EVENT) {\n        event = document$1.createEvent(\"Event\");\n        event.promise = promise;\n        event.reason = reason;\n        event.initEvent(name, false, true);\n        global$1.dispatchEvent(event);\n    } else event = {\n        promise: promise,\n        reason: reason\n    };\n    if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$1[\"on\" + name])) handler(event);\n    else if (name === UNHANDLED_REJECTION) hostReportErrors(\"Unhandled promise rejection\", reason);\n};\nvar onUnhandled = function(state) {\n    call$7(task, global$1, function() {\n        var promise = state.facade;\n        var value = state.value;\n        var IS_UNHANDLED = isUnhandled(state);\n        var result;\n        if (IS_UNHANDLED) {\n            result = perform$2(function() {\n                if (IS_NODE) {\n                    process.emit(\"unhandledRejection\", value, promise);\n                } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n            });\n            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n            if (result.error) throw result.value;\n        }\n    });\n};\nvar isUnhandled = function(state) {\n    return state.rejection !== HANDLED && !state.parent;\n};\nvar onHandleUnhandled = function(state) {\n    call$7(task, global$1, function() {\n        var promise = state.facade;\n        if (IS_NODE) {\n            process.emit(\"rejectionHandled\", promise);\n        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n    });\n};\nvar bind$1 = function(fn, state, unwrap) {\n    return function(value) {\n        fn(state, value, unwrap);\n    };\n};\nvar internalReject = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    state.value = value;\n    state.state = REJECTED;\n    notify(state, true);\n};\nvar internalResolve = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    try {\n        if (state.facade === value) throw TypeError$1(\"Promise can't be resolved itself\");\n        var then = isThenable(value);\n        if (then) {\n            microtask(function() {\n                var wrapper = {\n                    done: false\n                };\n                try {\n                    call$7(then, value, bind$1(internalResolve, wrapper, state), bind$1(internalReject, wrapper, state));\n                } catch (error) {\n                    internalReject(wrapper, error, state);\n                }\n            });\n        } else {\n            state.value = value;\n            state.state = FULFILLED;\n            notify(state, false);\n        }\n    } catch (error) {\n        internalReject({\n            done: false\n        }, error, state);\n    }\n};\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n    // 25.4.3.1 Promise(executor)\n    PromiseConstructor = function Promise1(executor) {\n        anInstance(this, PromisePrototype);\n        aCallable$3(executor);\n        call$7(Internal, this);\n        var state = getInternalPromiseState(this);\n        try {\n            executor(bind$1(internalResolve, state), bind$1(internalReject, state));\n        } catch (error) {\n            internalReject(state, error);\n        }\n    };\n    PromisePrototype = PromiseConstructor.prototype;\n    // eslint-disable-next-line no-unused-vars -- required for `.length`\n    Internal = function Promise1(executor) {\n        setInternalState(this, {\n            type: PROMISE,\n            done: false,\n            notified: false,\n            parent: false,\n            reactions: new Queue(),\n            rejection: false,\n            state: PENDING,\n            value: undefined\n        });\n    };\n    // `Promise.prototype.then` method\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\n    Internal.prototype = defineBuiltIn$2(PromisePrototype, \"then\", function then(onFulfilled, onRejected) {\n        var state = getInternalPromiseState(this);\n        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n        state.parent = true;\n        reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;\n        reaction.fail = isCallable$1(onRejected) && onRejected;\n        reaction.domain = IS_NODE ? process.domain : undefined;\n        if (state.state == PENDING) state.reactions.add(reaction);\n        else microtask(function() {\n            callReaction(reaction, state);\n        });\n        return reaction.promise;\n    });\n    OwnPromiseCapability = function() {\n        var promise = new Internal();\n        var state = getInternalPromiseState(promise);\n        this.promise = promise;\n        this.resolve = bind$1(internalResolve, state);\n        this.reject = bind$1(internalReject, state);\n    };\n    newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function(C) {\n        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n    };\n    if (isCallable$1(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n        nativeThen = NativePromisePrototype$1.then;\n        if (!NATIVE_PROMISE_SUBCLASSING) {\n            // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n            defineBuiltIn$2(NativePromisePrototype$1, \"then\", function then(onFulfilled, onRejected) {\n                var that = this;\n                return new PromiseConstructor(function(resolve, reject) {\n                    call$7(nativeThen, that, resolve, reject);\n                }).then(onFulfilled, onRejected);\n            // https://github.com/zloirock/core-js/issues/640\n            }, {\n                unsafe: true\n            });\n        }\n        // make `.constructor === Promise` work for native promise-based APIs\n        try {\n            delete NativePromisePrototype$1.constructor;\n        } catch (error) {}\n        // make `instanceof Promise` work for native promise-based APIs\n        if (setPrototypeOf) {\n            setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n        }\n    }\n}\n$$5({\n    global: true,\n    constructor: true,\n    wrap: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$4\n}, {\n    Promise: PromiseConstructor\n});\nsetToStringTag(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\nvar wellKnownSymbol$2 = wellKnownSymbol$g;\nvar Iterators$1 = iterators;\nvar ITERATOR$2 = wellKnownSymbol$2(\"iterator\");\nvar ArrayPrototype = Array.prototype;\n// check on default Array iterator\nvar isArrayIteratorMethod$1 = function(it) {\n    return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);\n};\nvar classof = classof$5;\nvar getMethod$1 = getMethod$3;\nvar Iterators = iterators;\nvar wellKnownSymbol$1 = wellKnownSymbol$g;\nvar ITERATOR$1 = wellKnownSymbol$1(\"iterator\");\nvar getIteratorMethod$2 = function(it) {\n    if (it != undefined) return getMethod$1(it, ITERATOR$1) || getMethod$1(it, \"@@iterator\") || Iterators[classof(it)];\n};\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$9;\nvar anObject$5 = anObject$c;\nvar tryToString$1 = tryToString$5;\nvar getIteratorMethod$1 = getIteratorMethod$2;\nvar $TypeError$1 = TypeError;\nvar getIterator$1 = function(argument, usingIterator) {\n    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;\n    if (aCallable$2(iteratorMethod)) return anObject$5(call$6(iteratorMethod, argument));\n    throw $TypeError$1(tryToString$1(argument) + \" is not iterable\");\n};\nvar call$5 = functionCall;\nvar anObject$4 = anObject$c;\nvar getMethod = getMethod$3;\nvar iteratorClose$1 = function(iterator, kind, value) {\n    var innerResult, innerError;\n    anObject$4(iterator);\n    try {\n        innerResult = getMethod(iterator, \"return\");\n        if (!innerResult) {\n            if (kind === \"throw\") throw value;\n            return value;\n        }\n        innerResult = call$5(innerResult, iterator);\n    } catch (error) {\n        innerError = true;\n        innerResult = error;\n    }\n    if (kind === \"throw\") throw value;\n    if (innerError) throw innerResult;\n    anObject$4(innerResult);\n    return value;\n};\nvar bind = functionBindContext;\nvar call$4 = functionCall;\nvar anObject$3 = anObject$c;\nvar tryToString = tryToString$5;\nvar isArrayIteratorMethod = isArrayIteratorMethod$1;\nvar lengthOfArrayLike = lengthOfArrayLike$5;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getIterator = getIterator$1;\nvar getIteratorMethod = getIteratorMethod$2;\nvar iteratorClose = iteratorClose$1;\nvar $TypeError = TypeError;\nvar Result = function(stopped, result) {\n    this.stopped = stopped;\n    this.result = result;\n};\nvar ResultPrototype = Result.prototype;\nvar iterate$2 = function(iterable, unboundFunction, options) {\n    var that = options && options.that;\n    var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n    var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n    var INTERRUPTED = !!(options && options.INTERRUPTED);\n    var fn = bind(unboundFunction, that);\n    var iterator, iterFn, index, length, result, next, step;\n    var stop = function(condition) {\n        if (iterator) iteratorClose(iterator, \"normal\", condition);\n        return new Result(true, condition);\n    };\n    var callFn = function(value) {\n        if (AS_ENTRIES) {\n            anObject$3(value);\n            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n        }\n        return INTERRUPTED ? fn(value, stop) : fn(value);\n    };\n    if (IS_ITERATOR) {\n        iterator = iterable;\n    } else {\n        iterFn = getIteratorMethod(iterable);\n        if (!iterFn) throw $TypeError(tryToString(iterable) + \" is not iterable\");\n        // optimisation for array iterators\n        if (isArrayIteratorMethod(iterFn)) {\n            for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){\n                result = callFn(iterable[index]);\n                if (result && isPrototypeOf$1(ResultPrototype, result)) return result;\n            }\n            return new Result(false);\n        }\n        iterator = getIterator(iterable, iterFn);\n    }\n    next = iterator.next;\n    while(!(step = call$4(next, iterator)).done){\n        try {\n            result = callFn(step.value);\n        } catch (error) {\n            iteratorClose(iterator, \"throw\", error);\n        }\n        if (typeof result == \"object\" && result && isPrototypeOf$1(ResultPrototype, result)) return result;\n    }\n    return new Result(false);\n};\nvar wellKnownSymbol = wellKnownSymbol$g;\nvar ITERATOR = wellKnownSymbol(\"iterator\");\nvar SAFE_CLOSING = false;\ntry {\n    var called = 0;\n    var iteratorWithReturn = {\n        next: function() {\n            return {\n                done: !!called++\n            };\n        },\n        \"return\": function() {\n            SAFE_CLOSING = true;\n        }\n    };\n    iteratorWithReturn[ITERATOR] = function() {\n        return this;\n    };\n    // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n    Array.from(iteratorWithReturn, function() {\n        throw 2;\n    });\n} catch (error) {}\nvar checkCorrectnessOfIteration$1 = function(exec, SKIP_CLOSING) {\n    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n    var ITERATION_SUPPORT = false;\n    try {\n        var object = {};\n        object[ITERATOR] = function() {\n            return {\n                next: function() {\n                    return {\n                        done: ITERATION_SUPPORT = true\n                    };\n                }\n            };\n        };\n        exec(object);\n    } catch (error) {}\n    return ITERATION_SUPPORT;\n};\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function(iterable) {\n    NativePromiseConstructor$1.all(iterable).then(undefined, function() {});\n});\nvar $$4 = _export;\nvar call$3 = functionCall;\nvar aCallable$1 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$4({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION$1\n}, {\n    all: function all(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$2.f(C);\n        var resolve = capability.resolve;\n        var reject = capability.reject;\n        var result = perform$1(function() {\n            var $promiseResolve = aCallable$1(C.resolve);\n            var values = [];\n            var counter = 0;\n            var remaining = 1;\n            iterate$1(iterable, function(promise) {\n                var index = counter++;\n                var alreadyCalled = false;\n                remaining++;\n                call$3($promiseResolve, C, promise).then(function(value) {\n                    if (alreadyCalled) return;\n                    alreadyCalled = true;\n                    values[index] = value;\n                    --remaining || resolve(values);\n                }, reject);\n            });\n            --remaining || resolve(values);\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$3 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable = isCallable$l;\nvar defineBuiltIn$1 = defineBuiltIn$6;\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$3({\n    target: \"Promise\",\n    proto: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$2,\n    real: true\n}, {\n    \"catch\": function(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n});\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable(NativePromiseConstructor)) {\n    var method = getBuiltIn$1(\"Promise\").prototype[\"catch\"];\n    if (NativePromisePrototype[\"catch\"] !== method) {\n        defineBuiltIn$1(NativePromisePrototype, \"catch\", method, {\n            unsafe: true\n        });\n    }\n}\nvar $$2 = _export;\nvar call$2 = functionCall;\nvar aCallable = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$2({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION\n}, {\n    race: function race(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$1.f(C);\n        var reject = capability.reject;\n        var result = perform(function() {\n            var $promiseResolve = aCallable(C.resolve);\n            iterate(iterable, function(promise) {\n                call$2($promiseResolve, C, promise).then(capability.resolve, reject);\n            });\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$1 = _export;\nvar call$1 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$1({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$1\n}, {\n    reject: function reject(r) {\n        var capability = newPromiseCapabilityModule.f(this);\n        call$1(capability.reject, undefined, r);\n        return capability.promise;\n    }\n});\nvar anObject$2 = anObject$c;\nvar isObject = isObject$8;\nvar newPromiseCapability = newPromiseCapability$2;\nvar promiseResolve$1 = function(C, x) {\n    anObject$2(C);\n    if (isObject(x) && x.constructor === C) return x;\n    var promiseCapability = newPromiseCapability.f(C);\n    var resolve = promiseCapability.resolve;\n    resolve(x);\n    return promiseCapability.promise;\n};\nvar $ = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\ngetBuiltIn(\"Promise\");\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR\n}, {\n    resolve: function resolve(x) {\n        return promiseResolve(this, x);\n    }\n});\nconst HardwareWalletAccountsForm = ({ accounts, onSelectedChanged, onSubmit, onChangeRoute })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"choose-ledger-account-form-wrapper\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                children: [\n                    \"We found \",\n                    accounts.length,\n                    \" accounts on your device. Select the account(s) you wish to connect.\"\n                ]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                className: \"button-wrapper\"\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                    onClick: ()=>{\n                        onChangeRoute(\"SpecifyHDPath\");\n                    }\n                }, {\n                    children: \"HD.../0\"\n                }))\n            })),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"form\", Object.assign({\n                className: \"form\",\n                onSubmit: (e)=>{\n                    onSubmit(accounts, e);\n                }\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"nws-form-control\"\n                        }, {\n                            children: accounts.map((account, index)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                    className: \"account\"\n                                }, {\n                                    children: [\n                                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n                                            onChange: (e)=>{\n                                                onSelectedChanged(index, e.target.checked);\n                                            },\n                                            checked: account.selected,\n                                            type: \"checkbox\",\n                                            id: account.accountId,\n                                            name: account.accountId,\n                                            value: account.accountId\n                                        }),\n                                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"label\", Object.assign({\n                                            htmlFor: account.accountId\n                                        }, {\n                                            children: [\n                                                \" \",\n                                                account.accountId\n                                            ]\n                                        })),\n                                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {})\n                                    ]\n                                }), index))\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"action-buttons\"\n                        }, {\n                            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                className: \"middleButton\",\n                                type: \"submit\",\n                                disabled: !accounts.some((x)=>x.selected)\n                            }, {\n                                children: \"Connect\"\n                            }))\n                        }))\n                    ]\n                })\n            }))\n        ]\n    }));\n};\nvar img = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAR3SURBVHgBpVZ9aJVVGH+e55z33bi7zY9hMz+yMAeNoEIq6A9ZRKQWEsQNFIIpsf5Y9E+GsD9iBEEDMUkDa6ShRKKZYIWiRkaKaUGUGCKOTGMF84PNO99773vOefq9720yK5ZzD/dwPt/nd37P17lEk5Qnuz9roUkKT7T5bNe+QjTNLCHv24h1Xgh+OmtwQYPH2jUXwlnW9NRooqePfLS6MmmQ59cdeEGJlkJZA5MGVecoAwghBYZTVY9ftuaDSy8x8w9fbFl95JZAXuw9dmelkvRAyXxS7wMFryG4bIyWZiqzPgMhaFfGfn3NY3AZG9sPf/Dy8HidZvxkZc/h1pqnPlKey6yspMqUd9jVAEYY6RCGDQTwjGDwGTgAlbwRijV1C9vanz577tT+6r+YrOz5rlXFrQ/qZ+FbDxCfXS5oOgxln4v473f3rbgwdn7FK5/MCaH2eAg6X8g3K2iBMTiBkNJVKbod+ze9mgPZsY/UaicYzCE1HgpZc558olCTjTvWLxv9p1n3bV45iO7T5zq3TU9j9xTOLwQ5D9t48aEYrtGj2P/2BpNS78nZJoRdlDsYd8vphz273lqyhW5Rnlnz3hOe6SEwghvxPUMTVfYe2rpuUOqOkZeIxdSbsSJ8eTIAmXy5tftrMPkzi0C4B2ZDNHp+INvLQURkhYiJ6gDGko376DbEJ8k3mcnYBSeSM2ptL/XGsurNnxfnDIQNwCKADO1845Ef6Tbk0M51g4joMgncDyBmkrtsNEMQovcDxGYsGL2yDNAUxPv0VySs4yxhfeYbabJg0Awg+ILylEB6nKMpSOp0WCR1+QSuD4ELljNDEfyRrdXPCU1BTEgD7pyOzVmC2iBm0KgYAMCEeXovoClIjdKiVdQ3FYbzmatxWRqMPcNsDHyfNWskWk5TkJhNEwVyxA6hLL5clLJsW7voFxa6LiR5CCOeWzo3XFxKtyEdy3tnp7VahAoDp6PEVGvJye09l3P7K9k9WQijXBv4B6WG+0pvD0ybFEBHZ6OPh+/OGaBsIvNRAGp/ZHv1jJeon+omszBkFsr3FhsLB7rev3JLQKVSyfjmaW2BJSavDlqR7c5VrR+4AbLttbkXMehH7gjA8gZiD/tq+Or/ABZ3dUW/J62LcPUGcrW8pKSVFAg6cHz3O0l25qZHa/XGwWPg9aAwwzdZAaDX+7tbNsMYf5+bpaUS0dDQEF8rtsUxCbI5e5KRzGhBMiqNxllKju7d8NOYXjseRBytQngcVDL3wD9H+7vf3YS7mnnzqrZpwSxrwkh04cpM5NTMyJdHbIgaESyxJ6tZ5cDbw3qd0tqVCp25Se/4yYdr5/zm/ehjwvpxZHgN0Wlub0/Yt7awdykqRYFHy6NUQVrBd4o6p6ngrVL2Bo8ksuJqoXzq9Ln9m6rj9U74b6Wjo8OeP082aY5NUxRsYzwDkeFsU+MdUU3U4PG0QtbahqhadDMuHTy4fvS/9EwIUpdeuW/ZiShOipFxURRbNdWETFMRZrCFlEZGkuPHdycTafgLExNiI6YfUpcAAAAASUVORK5CYII=\";\nconst WalletConnecting = ({ wallet, onCloseModal })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n                title: \"\",\n                onCloseModal: onCloseModal\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                className: \"connecting-wrapper\"\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                    className: \"content\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"icon\"\n                        }, {\n                            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                src: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.iconUrl,\n                                alt: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name\n                            })\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n                            className: \"connecting-name\"\n                        }, {\n                            children: wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                            className: \"connecting-details\"\n                        }, {\n                            children: [\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                    className: \"spinner\"\n                                }, {\n                                    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                        src: img,\n                                        alt: \"loading-icon\"\n                                    })\n                                })),\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", {\n                                    children: [\n                                        (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectingTo\"),\n                                        \" \",\n                                        wallet === null || wallet === void 0 ? void 0 : wallet.metadata.name,\n                                        \"...\"\n                                    ]\n                                })\n                            ]\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                            className: \"connecting-message\"\n                        }, {\n                            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(`modal.wallet.connectingMessage.${wallet === null || wallet === void 0 ? void 0 : wallet.type}`)\n                            })\n                        }))\n                    ]\n                }))\n            }))\n        ]\n    });\n};\nconst LedgerDeviceIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: \"317\",\n        height: \"157\",\n        viewBox: \"0 0 317 157\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M249.99 16.0994C270.063 -0.864155 289.788 1.58873 301.497 10.7365C307.402 15.3499 311.278 21.6575 312.267 28.1258C313.247 34.5412 311.413 41.2233 305.692 46.8044C297.366 54.9273 286.343 55.3362 273.015 51.5109C261.654 48.25 249.058 42.0377 235.726 35.4627L235.726 35.4626L235.717 35.458C233.367 34.2992 230.995 33.129 228.602 31.9618C212.742 24.2253 196.067 16.6575 179.842 13.8595C163.538 11.0479 147.552 13.0313 133.266 24.522C128.032 28.732 123.478 35.2086 121.716 44.8205C119.961 54.3947 120.992 66.9771 126.703 83.4311C135.432 108.583 132.899 126.677 123.575 138.063C114.217 149.491 97.5614 154.733 76.7887 153.121C55.0043 151.43 29.0621 142.206 3.29867 125.227L0.887817 127.942C27.2472 145.405 53.9251 154.952 76.5105 156.705C97.9028 158.365 115.96 153.035 126.356 140.341C136.785 127.606 139.045 108.029 130.099 82.2524C124.521 66.1801 123.642 54.2493 125.252 45.4687C126.854 36.7258 130.94 31.006 135.519 27.3232C148.794 16.6458 163.649 14.715 179.231 17.4021C194.891 20.1027 211.146 27.4463 227.026 35.1928C229.381 36.3415 231.729 37.5001 234.066 38.6531L234.073 38.6568C247.382 45.223 260.324 51.608 272.024 54.9662C285.819 58.9258 298.493 58.8501 308.202 49.3776C314.764 42.9759 316.974 35.1288 315.82 27.5826C314.675 20.0893 310.237 13.0029 303.71 7.90363C290.555 -2.37382 268.938 -4.62038 247.67 13.3537L249.99 16.0994Z\",\n                fill: \"url(#paint0_linear_3_672)\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M260.264 17.8767L177.605 89.4649L157.679 73.9664L239.23 3.85423L260.264 17.8767Z\",\n                fill: \"#6A7075\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M205.939 54.4577L199.764 50.2636L233.316 20.9053L239.907 25.8395L205.939 54.4577Z\",\n                fill: \"#494E52\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M260.264 17.8757L177.605 89.4639L182.033 98.3202L264.323 26.363L260.264 17.8757Z\",\n                fill: \"#494E52\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M177.236 89.4646L181.295 98.3209L165.059 85.7745L170.963 85.0365L177.236 89.4646Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M93.4708 99.6384L91.9948 110.13L174.653 92.894L164.69 85.7749L93.4708 99.6384Z\",\n                fill: \"#DCDADA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M93.1157 104.323L94.314 100.129L165.613 86.3483L169.208 89.344L93.1157 104.323Z\",\n                fill: \"#C1C1C1\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M94.2086 99.7963L86.0903 101.272L92.3635 110.129L94.2086 99.7963Z\",\n                fill: \"#B3AAAA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M86.0903 100.907L89.0027 74.1304L178.455 55.2416C184.695 53.9962 195.766 54.7675 197.177 63.7058C198.284 70.717 195.506 73.9943 191.628 77.3592C188.495 80.0671 180.152 82.4646 178.343 82.8944C178.293 82.9064 178.241 82.9188 178.186 82.9319C177.38 83.1245 176.007 83.4525 170.644 84.5088C169.085 84.8158 167.382 85.1501 165.557 85.5078L164.933 85.63C146.312 89.2764 115.528 95.2297 93.9844 99.3849C91.1808 99.9257 88.5337 100.436 86.0903 100.907ZM185.076 75.554C190.748 73.3535 193.99 68.0745 192.318 63.7631C190.645 59.4517 184.691 57.7405 179.019 59.941C173.347 62.1416 170.105 67.4206 171.778 71.732C173.45 76.0434 179.404 77.7546 185.076 75.554Z\",\n                fill: \"#F4F1E8\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M199.764 50.3994L196.768 48.3043L232.194 18.0454L233.316 21.6403L199.764 50.3994Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M239.968 25.9943L232.588 20.4592V17.5071L241.813 24.5183L239.968 25.9943Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n                cx: \"182.084\",\n                cy: \"68.0811\",\n                rx: \"10.242\",\n                ry: \"7.46772\",\n                transform: \"rotate(-23.7949 182.084 68.0811)\",\n                fill: \"#494E52\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n                cx: \"182.084\",\n                cy: \"68.0816\",\n                rx: \"6.68462\",\n                ry: \"4.87394\",\n                transform: \"rotate(-23.7949 182.084 68.0816)\",\n                fill: \"#494E52\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M238.725 2.93094L260.368 17.2564L264.865 26.4556L181.615 99.0341L175.16 94.311L92.0028 110.947L85.3267 101.399L88.3269 73.8157L178.118 54.8553L238.725 2.93094ZM178.599 56.2622L89.6786 75.0388L86.9321 100.29C89.0979 99.8725 91.4124 99.4263 93.8446 98.9572C115.388 94.8019 146.171 88.8488 164.791 85.2026L165.415 85.0804C167.24 84.7228 168.943 84.3885 170.501 84.0816C175.853 83.0275 177.219 82.701 178.015 82.5107C178.07 82.4976 178.122 82.4852 178.173 82.4732C179.048 82.2652 181.558 81.5669 184.235 80.5851C186.742 79.6655 189.286 78.5354 190.802 77.3758L191.151 77.0922L191.644 76.6595C193.341 75.147 194.723 73.6739 195.61 71.871C196.571 69.916 196.982 67.5029 196.448 64.1178C195.8 60.0131 192.959 57.7574 189.408 56.6566C185.833 55.5483 181.637 55.6566 178.603 56.2615C178.601 56.2617 178.6 56.262 178.599 56.2622ZM192.631 77.7565L259.555 18.9531L263.042 26.0869L181.808 96.9078L178.132 89.5713L191.724 78.529C191.859 78.4249 191.988 78.32 192.11 78.2144L192.111 78.2136C192.286 78.0617 192.46 77.9094 192.631 77.7565ZM185.491 81.6908C185.24 81.7868 184.99 81.8802 184.743 81.9709C182.013 82.9723 179.447 83.6875 178.514 83.9093C178.463 83.9213 178.411 83.9338 178.356 83.9468C177.635 84.1192 176.472 84.3971 172.491 85.1919L177.172 88.4492L185.491 81.6908ZM176.631 89.8707L170.479 85.5903C169.306 85.8213 168.054 86.0673 166.731 86.3265L175.769 92.9276L179.548 95.6924L176.631 89.8707ZM164.758 86.7132C146.252 90.3362 116.027 96.1817 94.6324 100.308L93.2258 109.197L173.543 93.1293L164.758 86.7132ZM91.888 108.207L93.0909 100.606C91.0848 100.993 89.1642 101.363 87.3471 101.713L91.888 108.207ZM258.581 17.8436L197.306 71.6841C198.142 69.5779 198.41 67.0795 197.906 63.8876C197.143 59.0539 193.743 56.4549 189.845 55.2467C186.921 54.3402 183.662 54.1916 180.861 54.449L238.84 4.77668L258.581 17.8436ZM232.505 16.82L243.089 24.5643L205.915 56.5106L196.042 48.0665L232.505 16.82ZM232.118 19.096L198.312 48.0654L199.744 49.29L232.584 20.9424L232.118 19.096ZM233.456 22.1396L200.878 50.2604L205.913 54.5664L239.041 26.0969L233.456 22.1396ZM240.195 25.1054L240.717 24.6571L233.759 19.5663L234.06 20.7586L240.195 25.1054Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M190.194 69.9744C191.32 68.1409 191.576 66.2271 190.942 64.5937C190.308 62.9603 188.829 61.7198 186.761 61.1254C184.691 60.5307 182.116 60.6196 179.553 61.6139C176.991 62.6081 175.029 64.2794 173.902 66.1141C172.776 67.9477 172.52 69.8614 173.154 71.4948C173.788 73.1282 175.267 74.3687 177.335 74.9631C179.405 75.5578 181.98 75.4689 184.543 74.4746C187.105 73.4804 189.067 71.8091 190.194 69.9744ZM185.077 75.8508C190.749 73.6502 193.991 68.3712 192.318 64.0598C190.645 59.7484 184.691 58.0372 179.019 60.2378C173.347 62.4383 170.105 67.7173 171.778 72.0287C173.451 76.3401 179.405 78.0513 185.077 75.8508Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M187.391 69.169C188.127 67.9713 188.266 66.7721 187.881 65.7812C187.497 64.7903 186.586 63.9984 185.235 63.6102C183.883 63.2216 182.173 63.2741 180.456 63.9404C178.738 64.6068 177.441 65.7208 176.705 66.9196C175.969 68.1172 175.83 69.3165 176.215 70.3074C176.599 71.2983 177.511 72.0901 178.861 72.4783C180.214 72.8669 181.923 72.8144 183.64 72.1481C185.358 71.4818 186.655 70.3678 187.391 69.169ZM184.174 73.5242C188.156 71.9795 190.432 68.2738 189.257 65.2473C188.083 62.2208 183.904 61.0196 179.922 62.5643C175.94 64.1091 173.665 67.8148 174.839 70.8412C176.013 73.8677 180.193 75.0689 184.174 73.5242Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M240.499 41.2441C239.744 40.3649 239.844 39.04 240.724 38.285L249.781 30.5067C250.66 29.7516 251.985 29.8523 252.74 30.7315V30.7315C253.495 31.6108 253.395 32.9356 252.516 33.6907L243.458 41.469C242.579 42.224 241.254 42.1234 240.499 41.2441V41.2441Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M250.743 31.6265L241.685 39.4048C241.424 39.6287 241.395 40.0217 241.619 40.2825C241.842 40.5433 242.235 40.5731 242.496 40.3492L251.554 32.5709C251.815 32.3469 251.845 31.954 251.621 31.6932C251.397 31.4324 251.004 31.4025 250.743 31.6265ZM240.724 38.285C239.844 39.04 239.744 40.3649 240.499 41.2441C241.254 42.1234 242.579 42.224 243.458 41.469L252.516 33.6907C253.395 32.9356 253.495 31.6108 252.74 30.7315C251.985 29.8523 250.66 29.7516 249.781 30.5067L240.724 38.285Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M205.779 71.4647C205.005 70.5642 205.108 69.2073 206.009 68.4339L214.989 60.7218C215.89 59.9485 217.247 60.0516 218.02 60.9521V60.9521C218.793 61.8526 218.69 63.2095 217.79 63.9829L208.809 71.695C207.909 72.4683 206.552 72.3652 205.779 71.4647V71.4647Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M215.951 61.8416L206.97 69.5537C206.688 69.796 206.656 70.221 206.898 70.5031C207.141 70.7851 207.566 70.8174 207.848 70.5752L216.828 62.863C217.11 62.6208 217.143 62.1958 216.9 61.9137C216.658 61.6317 216.233 61.5994 215.951 61.8416ZM206.009 68.4339C205.108 69.2073 205.005 70.5642 205.779 71.4647C206.552 72.3652 207.909 72.4683 208.809 71.695L217.79 63.9829C218.69 63.2095 218.793 61.8526 218.02 60.9521C217.247 60.0516 215.89 59.9485 214.989 60.7218L206.009 68.4339Z\",\n                fill: \"black\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                cx: \"141.356\",\n                cy: \"19.525\",\n                r: \"10.1855\",\n                fill: \"#FE89B4\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n                cx: \"139.062\",\n                cy: \"14.7094\",\n                rx: \"2.42519\",\n                ry: \"1.94015\",\n                transform: \"rotate(-34.544 139.062 14.7094)\",\n                fill: \"#FDF7FF\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                cx: \"252.489\",\n                cy: \"79.7577\",\n                r: \"7.78893\",\n                fill: \"#EC5236\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ellipse\", {\n                cx: \"250.434\",\n                cy: \"76.3701\",\n                rx: \"2.61272\",\n                ry: \"2.09018\",\n                transform: \"rotate(-34.544 250.434 76.3701)\",\n                fill: \"#EDB69D\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M100.436 79.9254C100.461 79.6567 100.732 79.3897 101.042 79.329L106.657 78.2299C107.587 78.0478 108.281 78.5536 108.207 79.3596L107.759 84.2243C107.734 84.493 107.463 84.76 107.153 84.8207L100.416 86.1396C100.106 86.2003 99.8742 86.0317 99.899 85.7631L100.436 79.9254Z\",\n                fill: \"#B3AAAA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M95.8553 81.7775C95.9294 80.9715 96.7437 80.1704 97.6739 79.9883L98.7968 79.7685C99.1069 79.7078 99.3382 79.8764 99.3135 80.1451L99.1344 82.091C99.1096 82.3597 98.8382 82.6267 98.5282 82.6874L96.2824 83.127C95.9723 83.1877 95.741 83.0191 95.7657 82.7505L95.8553 81.7775Z\",\n                fill: \"#B3AAAA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M95.5865 84.6965C95.6112 84.4278 95.8826 84.1608 96.1927 84.1001L98.4385 83.6605C98.7486 83.5998 98.9799 83.7684 98.9552 84.037L98.7761 85.9829C98.7513 86.2516 98.4799 86.5186 98.1699 86.5793L95.9241 87.019C95.614 87.0797 95.3827 86.9111 95.4074 86.6424L95.5865 84.6965Z\",\n                fill: \"#B3AAAA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M95.2282 88.5884C95.2529 88.3197 95.5244 88.0527 95.8344 87.992L98.0802 87.5524C98.3903 87.4917 98.6216 87.6603 98.5969 87.929L98.4178 89.8749C98.3931 90.1435 98.1216 90.4105 97.8116 90.4712L96.6887 90.6911C95.7584 90.8732 95.0645 90.3674 95.1387 89.5614L95.2282 88.5884Z\",\n                fill: \"#B3AAAA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M99.7197 87.709C99.7444 87.4403 100.016 87.1733 100.326 87.1126L102.572 86.673C102.882 86.6123 103.113 86.7809 103.088 87.0496L102.909 88.9955C102.885 89.2641 102.613 89.5312 102.303 89.5919L100.057 90.0315C99.7472 90.0922 99.5159 89.9236 99.5406 89.6549L99.7197 87.709Z\",\n                fill: \"#B3AAAA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                fillRule: \"evenodd\",\n                clipRule: \"evenodd\",\n                d: \"M104.211 86.8298C104.236 86.5611 104.507 86.2941 104.817 86.2334L107.063 85.7938C107.373 85.7331 107.605 85.9017 107.58 86.1704L107.49 87.1433C107.416 87.9493 106.602 88.7504 105.672 88.9325L104.549 89.1523C104.239 89.213 104.007 89.0444 104.032 88.7757L104.211 86.8298Z\",\n                fill: \"#B3AAAA\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"linearGradient\", Object.assign({\n                    id: \"paint0_linear_3_672\",\n                    x1: \"-44.5195\",\n                    y1: \"122.42\",\n                    x2: \"263.357\",\n                    y2: \"-8.65023\",\n                    gradientUnits: \"userSpaceOnUse\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"stop\", {\n                            offset: \"0.110697\",\n                            stopColor: \"#232323\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"stop\", {\n                            offset: \"1\",\n                            stopColor: \"#3D3D3D\"\n                        })\n                    ]\n                }))\n            })\n        ]\n    }));\n};\nconst UpArrowIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        width: \"10\",\n        height: \"7\",\n        viewBox: \"0 0 10 7\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M9 5.4762L5 1.4762L1 5.4762\",\n            stroke: \"#4F7CD1\",\n            strokeWidth: \"1.5\",\n            strokeLinecap: \"round\",\n            strokeLinejoin: \"round\"\n        })\n    }));\n};\nconst DownArrowIcon = ()=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        width: \"10\",\n        height: \"7\",\n        viewBox: \"0 0 10 7\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M1 1.52382L5 5.52382L9 1.52382\",\n            stroke: \"#4F7CD1\",\n            strokeWidth: \"1.5\",\n            strokeLinecap: \"round\",\n            strokeLinejoin: \"round\"\n        })\n    }));\n};\nconst DEFAULT_DERIVATION_PATH = \"44'/397'/0'/0'/1'\";\nconst DerivationPath = ({ selector, options, onBack, onConnected, params, onError, onCloseModal })=>{\n    const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"EnterDerivationPath\");\n    const [derivationPath, setDerivationPath] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(DEFAULT_DERIVATION_PATH);\n    const [customDerivationPath, setCustomDerivationPath] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(1);\n    const [accounts, setAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [selectedAccounts, setSelectedAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [hardwareWallet, setHardwareWallet] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    const [customAccountId, setCustomAccountId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [connecting, setConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const initalHeaderTitle = (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connectWithLedger\");\n    const [headerTitle, setHeaderTitle] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(initalHeaderTitle);\n    const getAccountIds = (publicKey)=>__awaiter(void 0, void 0, void 0, function*() {\n            const response = yield fetch(`${selector.options.network.indexerUrl}/publicKey/ed25519:${publicKey}/accounts`);\n            if (!response.ok) {\n                throw new Error(\"Failed to get account id from public key\");\n            }\n            const accountIds = yield response.json();\n            if (!Array.isArray(accountIds) || !accountIds.length) {\n                return [];\n            }\n            return accountIds;\n        });\n    const resolveAccounts = (wallet)=>__awaiter(void 0, void 0, void 0, function*() {\n            const publicKey = yield wallet.getPublicKey(derivationPath);\n            try {\n                const accountIds = yield getAccountIds(publicKey);\n                return accountIds.map((accountId, index)=>{\n                    return {\n                        derivationPath,\n                        publicKey,\n                        accountId,\n                        selected: index === 0\n                    };\n                });\n            } catch (e) {\n                return null;\n            }\n        });\n    const handleValidateAccount = ()=>__awaiter(void 0, void 0, void 0, function*() {\n            const wallet = yield selector.wallet(params.walletId);\n            if (wallet.type !== \"hardware\") {\n                return;\n            }\n            setConnecting(true);\n            setHardwareWallet(wallet);\n            try {\n                const resolvedAccounts = yield resolveAccounts(wallet);\n                if (!resolvedAccounts) {\n                    setRoute(\"AddCustomAccountId\");\n                    return;\n                }\n                const noAccounts = resolvedAccounts.length === 0;\n                const multipleAccounts = resolvedAccounts.length > 1;\n                if (noAccounts) {\n                    setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.noAccountsFound\"));\n                    setRoute(\"NoAccountsFound\");\n                    return;\n                }\n                setAccounts(resolvedAccounts);\n                if (!multipleAccounts) {\n                    setSelectedAccounts(resolvedAccounts);\n                    setRoute(\"OverviewAccounts\");\n                } else {\n                    setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.selectYourAccounts\"));\n                    setRoute(\"ChooseAccount\");\n                }\n            } catch (err) {\n                setConnecting(false);\n                const message = err instanceof Error ? err.message : \"Something went wrong\";\n                onError(message, wallet);\n            } finally{\n                setConnecting(false);\n            }\n        });\n    const handleAddCustomAccountId = ()=>__awaiter(void 0, void 0, void 0, function*() {\n            try {\n                setConnecting(true);\n                const publicKey = yield hardwareWallet.getPublicKey(derivationPath);\n                const accountList = [\n                    {\n                        derivationPath: derivationPath,\n                        publicKey,\n                        accountId: customAccountId,\n                        selected: true\n                    }\n                ];\n                setAccounts(accountList);\n                setSelectedAccounts(accountList);\n                setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connecting1Account\"));\n                setRoute(\"OverviewAccounts\");\n            } catch (err) {\n                setConnecting(false);\n                const message = err instanceof Error ? err.message : \"Something went wrong\";\n                onError(message, hardwareWallet);\n            } finally{\n                setConnecting(false);\n            }\n        });\n    const handleSignIn = ()=>{\n        const mapAccounts = selectedAccounts.map((account)=>{\n            return {\n                derivationPath: account.derivationPath,\n                publicKey: account.publicKey,\n                accountId: account.accountId\n            };\n        });\n        return hardwareWallet.signIn({\n            contractId: options.contractId,\n            methodNames: options.methodNames,\n            accounts: mapAccounts\n        }).then(()=>onConnected()).catch((err)=>{\n            onError(`Error: ${err.message}`, hardwareWallet);\n        });\n    };\n    const handleOnBackButtonClick = ()=>{\n        if (route === \"SpecifyHDPath\" || route === \"NoAccountsFound\" || route === \"ChooseAccount\") {\n            setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connectWithLedger\"));\n            setRoute(\"EnterDerivationPath\");\n        }\n        if (route === \"OverviewAccounts\") {\n            setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.selectYourAccounts\"));\n            setRoute(\"ChooseAccount\");\n        }\n    };\n    if (connecting) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            className: \"derivation-path-wrapper\"\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnecting, {\n                wallet: hardwareWallet,\n                onBack: ()=>{\n                    setConnecting(false);\n                },\n                onCloseModal: onCloseModal\n            })\n        }));\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"nws-modal-header-wrapper\"\n            }, {\n                children: [\n                    (route === \"SpecifyHDPath\" || route === \"NoAccountsFound\" || route === \"ChooseAccount\" || route === \"OverviewAccounts\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n                        onClick: handleOnBackButtonClick\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n                        title: headerTitle,\n                        onCloseModal: onCloseModal\n                    })\n                ]\n            })),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"derivation-path-wrapper\"\n            }, {\n                children: [\n                    route === \"EnterDerivationPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"enter-derivation-path\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"ledger-image\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LedgerDeviceIcon, {})\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                className: \"ledger-description\"\n                            }, {\n                                children: [\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                                        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.makeSureYourLedger\")\n                                    }),\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n                                        className: \"specify-path\",\n                                        onClick: ()=>{\n                                            setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\"));\n                                            setRoute(\"SpecifyHDPath\");\n                                        }\n                                    }, {\n                                        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\")\n                                    }))\n                                ]\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"action-buttons\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                    className: \"middleButton\",\n                                    onClick: handleValidateAccount\n                                }, {\n                                    children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.continue\")\n                                }))\n                            }))\n                        ]\n                    })),\n                    route === \"SpecifyHDPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"specify-path-wrapper\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                className: \"change-path-wrapper\"\n                            }, {\n                                children: [\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                        className: \"display-path\"\n                                    }, {\n                                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                                            children: derivationPath.slice(0, -2)\n                                        })\n                                    })),\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                        className: \"change-path\"\n                                    }, {\n                                        children: [\n                                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                                className: \"path-value\"\n                                            }, {\n                                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                                                    children: customDerivationPath\n                                                })\n                                            })),\n                                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                                className: \"buttons-wrapper\"\n                                            }, {\n                                                children: [\n                                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                                        onClick: ()=>{\n                                                            const newValue = customDerivationPath + 1;\n                                                            const path = derivationPath.slice(0, -2);\n                                                            setDerivationPath(`${path}${newValue}'`);\n                                                            setCustomDerivationPath(newValue);\n                                                        }\n                                                    }, {\n                                                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UpArrowIcon, {})\n                                                    })),\n                                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                                        onClick: ()=>{\n                                                            const newValue = customDerivationPath - 1;\n                                                            if (newValue < 0) {\n                                                                return;\n                                                            }\n                                                            const path = derivationPath.slice(0, -2);\n                                                            setDerivationPath(`${path}${newValue}'`);\n                                                            setCustomDerivationPath(newValue);\n                                                        }\n                                                    }, {\n                                                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DownArrowIcon, {})\n                                                    }))\n                                                ]\n                                            }))\n                                        ]\n                                    }))\n                                ]\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n                                className: \"path-description\"\n                            }, {\n                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.enterYourPreferredHDPath\")\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", Object.assign({\n                                className: \"what-link\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", Object.assign({\n                                    href: \"https://www.ledger.com/academy/crypto/what-are-hierarchical-deterministic-hd-wallets\",\n                                    target: \"_blank\"\n                                }, {\n                                    children: \"What's this?\"\n                                }))\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"action-buttons\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                    className: \"middleButton\",\n                                    onClick: handleValidateAccount\n                                }, {\n                                    children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.scan\")\n                                }))\n                            }))\n                        ]\n                    })),\n                    route === \"NoAccountsFound\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                        className: \"no-accounts-found-wrapper\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                            children: [\n                                (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.cantFindAnyAccount\"),\n                                \" \",\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", Object.assign({\n                                    href: `https://${selector.options.network.networkId === \"testnet\" ? \"testnet\" : \"app\"}.mynearwallet.com/create`,\n                                    target: \"_blank\"\n                                }, {\n                                    children: \"MyNearWallet\"\n                                })),\n                                \" \",\n                                (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.orConnectAnAnotherLedger\")\n                            ]\n                        })\n                    })),\n                    route === \"ChooseAccount\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardwareWalletAccountsForm, {\n                        accounts: accounts,\n                        onSelectedChanged: (index, selected)=>{\n                            setAccounts((prevAccounts)=>{\n                                const updateAccounts = prevAccounts.map((account, idx)=>{\n                                    const selectedValue = index === idx ? selected : account.selected;\n                                    return Object.assign(Object.assign({}, account), {\n                                        selected: selectedValue\n                                    });\n                                });\n                                return [\n                                    ...updateAccounts\n                                ];\n                            });\n                        },\n                        onSubmit: (acc, e)=>{\n                            e.preventDefault();\n                            const selectedAcc = acc.filter((account)=>account.selected);\n                            setSelectedAccounts(selectedAcc);\n                            const numberOfAccounts = selectedAcc.length;\n                            setHeaderTitle(`${(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.connecting\")} ${numberOfAccounts} ${(0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.ofAccounts\")}`);\n                            setRoute(\"OverviewAccounts\");\n                        },\n                        onChangeRoute: (newRoute)=>{\n                            if (newRoute === \"SpecifyHDPath\") {\n                                setHeaderTitle((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.specifyHDPath\"));\n                            }\n                            setRoute(newRoute);\n                        }\n                    }),\n                    route === \"AddCustomAccountId\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"enter-custom-account\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.failedToAutomatically\")\n                            }),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"input-wrapper\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n                                    type: \"text\",\n                                    placeholder: \"Account ID\",\n                                    value: customAccountId,\n                                    onChange: (e)=>{\n                                        setCustomAccountId(e.target.value);\n                                    }\n                                })\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"action-buttons\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                    className: \"middleButton\",\n                                    onClick: handleAddCustomAccountId\n                                }, {\n                                    children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"ledger.Continue\")\n                                }))\n                            }))\n                        ]\n                    })),\n                    route === \"OverviewAccounts\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"overview-wrapper\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.overviewTheListOfAuthorized\")\n                            }),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"accounts\"\n                            }, {\n                                children: selectedAccounts.map((account, index)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                            className: \"account\"\n                                        }, {\n                                            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                                                children: account.accountId\n                                            })\n                                        }))\n                                    }, account.accountId))\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"action-buttons\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                    className: \"middleButton\",\n                                    onClick: handleSignIn,\n                                    disabled: accounts.length === 0\n                                }, {\n                                    children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.ledger.finish\")\n                                }))\n                            }))\n                        ]\n                    }))\n                ]\n            }))\n        ]\n    });\n};\nconst WalletNotInstalled = ({ module, onBack, onCloseModal })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"nws-modal-header-wrapper\"\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n                        onClick: onBack\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n                        title: \"\",\n                        onCloseModal: onCloseModal\n                    })\n                ]\n            })),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"wallet-not-installed-wrapper\"\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"wallet-data\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: `wallet-icon-box ${module.id}`\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                    src: module.metadata.iconUrl,\n                                    alt: module.metadata.name\n                                })\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                                children: module.metadata.name\n                            })\n                        ]\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                        children: [\n                            (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.youllNeedToInstall\"),\n                            \" \",\n                            module.metadata.name,\n                            \" \",\n                            (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.toContinueAfterInstalling\"),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", Object.assign({\n                                className: \"refresh-link\",\n                                onClick: ()=>window.location.reload()\n                            }, {\n                                children: [\n                                    \" \",\n                                    (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.refreshThePage\")\n                                ]\n                            }))\n                        ]\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                        className: \"action-buttons\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"button\", Object.assign({\n                            className: \"middleButton\",\n                            onClick: ()=>{\n                                if (module.type !== \"injected\") {\n                                    return;\n                                }\n                                window.open(module.metadata.downloadUrl, \"_blank\");\n                            }\n                        }, {\n                            children: [\n                                (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.install.open\"),\n                                \" \",\n                                module.metadata.name\n                            ]\n                        }))\n                    }))\n                ]\n            }))\n        ]\n    });\n};\nconst QRIcon = ()=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: \"18\",\n        height: \"16\",\n        viewBox: \"0 0 18 16\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M7.22224 1.33334H1.44446V6.66668H7.22224V1.33334Z\",\n                stroke: \"currentColor\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M15.8889 1.33334H10.1111V6.66668H15.8889V1.33334Z\",\n                stroke: \"currentColor\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M7.22224 9.33334H1.44446V14.6667H7.22224V9.33334Z\",\n                stroke: \"currentColor\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M10.1111 13.1429V14.6667H15.8889M10.1111 9.33334V10.8572H12.5873V9.33334H15.8889V12.381\",\n                stroke: \"#4C5155\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"3.61108\",\n                y: \"3.33334\",\n                width: \"1.44444\",\n                height: \"1.33333\",\n                fill: \"#4C5155\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"3.61108\",\n                y: \"11.3333\",\n                width: \"1.44444\",\n                height: \"1.33333\",\n                fill: \"#4C5155\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"12.2778\",\n                y: \"3.33334\",\n                width: \"1.44445\",\n                height: \"1.33333\",\n                fill: \"#4C5155\"\n            })\n        ]\n    }));\nconst LinkIcon = ()=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: \"18\",\n        height: \"16\",\n        viewBox: \"0 0 18 16\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M13 8.66667V12.6667C13 13.0203 12.8478 13.3594 12.577 13.6095C12.3061 13.8595 11.9387 14 11.5556 14H3.61113C3.22804 14 2.86064 13.8595 2.58975 13.6095C2.31887 13.3594 2.16669 13.0203 2.16669 12.6667V5.33333C2.16669 4.97971 2.31887 4.64057 2.58975 4.39052C2.86064 4.14048 3.22804 4 3.61113 4H7.94447\",\n                stroke: \"currentColor\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M10.8333 2H15.1666V6\",\n                stroke: \"currentColor\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M7.22223 9.33333L15.1667 2\",\n                stroke: \"currentColor\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            })\n        ]\n    }));\nconst KeyIcon = ()=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        width: \"40\",\n        height: \"40\",\n        viewBox: \"0 0 40 40\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M33.5 1.83325L30.1666 5.16658M17.4818 17.8514C19.1406 19.5103 20.1666 21.8019 20.1666 24.3333C20.1666 29.3959 16.0626 33.4999 11 33.4999C5.93735 33.4999 1.8333 29.3959 1.8333 24.3333C1.8333 19.2706 5.93735 15.1666 11 15.1666C13.5313 15.1666 15.8229 16.1926 17.4818 17.8514ZM17.4818 17.8514L24.3333 10.9999M24.3333 10.9999L29.3333 15.9999L35.1666 10.1666L30.1666 5.16658M24.3333 10.9999L30.1666 5.16658\",\n            stroke: \"currentColor\",\n            strokeWidth: \"3\",\n            strokeLinecap: \"round\",\n            strokeLinejoin: \"round\"\n        })\n    }));\nconst FolderIcon = ()=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: \"40\",\n        height: \"41\",\n        viewBox: \"0 0 40 41\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                cx: \"28.3333\",\n                cy: \"23.8333\",\n                r: \"1.66667\",\n                fill: \"currentColor\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M35 12.1667H7C5.89543 12.1667 5 11.2712 5 10.1667V7.5C5 6.39543 5.89543 5.5 7 5.5H31.6667\",\n                stroke: \"currentColor\",\n                strokeWidth: \"3\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M35 12.1667V35.5H7C5.89543 35.5 5 34.6046 5 33.5V8.83334\",\n                stroke: \"currentColor\",\n                strokeWidth: \"3\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            })\n        ]\n    }));\nconst WalletHome = ({ selector, onCloseModal })=>{\n    const [modules, setModules] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"WalletInfo\");\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const subscription = selector.store.observable.subscribe((state)=>{\n            const filterByType = (item)=>{\n                return item.type !== \"bridge\" && item.type !== \"hardware\" && item.type !== \"instant-link\";\n            };\n            const filteredModules = state.modules.filter(filterByType);\n            setModules(filteredModules);\n        });\n        return ()=>subscription.unsubscribe();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    const getWalletUrl = (module)=>{\n        let url = \"\";\n        if (module.type === \"injected\") {\n            url = module.metadata.downloadUrl;\n        }\n        if (module.type === \"browser\") {\n            url = module.metadata.walletUrl;\n        }\n        return url;\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: \"wallet-home-wrapper\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"nws-modal-header-wrapper\"\n            }, {\n                children: [\n                    route === \"GetWallets\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BackArrow, {\n                        onClick: ()=>{\n                            setRoute(\"WalletInfo\");\n                        }\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n                        title: route === \"GetWallets\" ? (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\") : (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.whatIsAWallet\"),\n                        onCloseModal: onCloseModal\n                    })\n                ]\n            })),\n            route === \"GetWallets\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                className: \"get-wallet-wrapper\"\n            }, {\n                children: modules.map((module)=>{\n                    const { iconUrl, name } = module.metadata;\n                    const qrIcon = [\n                        \"nearfi\",\n                        \"here-wallet\"\n                    ].includes(module.id);\n                    const hereWalletType = module.id === \"here-wallet\" ? \"mobile\" : \"\";\n                    const walletUrl = getWalletUrl(module);\n                    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        tabIndex: 0,\n                        className: `single-wallet-get ${module.id}`,\n                        onClick: ()=>{\n                            if (walletUrl) {\n                                window.open(walletUrl, \"_blank\");\n                            }\n                        }\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                className: \"small-icon\"\n                            }, {\n                                children: [\n                                    qrIcon && walletUrl && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(QRIcon, {}),\n                                    !qrIcon && walletUrl && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinkIcon, {})\n                                ]\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"icon\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                    src: iconUrl,\n                                    alt: name\n                                })\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                className: \"content\"\n                            }, {\n                                children: [\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                        className: \"title\"\n                                    }, {\n                                        children: name\n                                    })),\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                        className: \"type\"\n                                    }, {\n                                        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(`modal.walletTypes.${hereWalletType || module.type}`)\n                                    }))\n                                ]\n                            }))\n                        ]\n                    }), module.id);\n                })\n            })),\n            route === \"WalletInfo\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"wallet-info-wrapper what-wallet-hide\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                className: \"wallet-what\"\n                            }, {\n                                children: [\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                        className: \"icon-side\"\n                                    }, {\n                                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(KeyIcon, {})\n                                    })),\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                        className: \"content-side\"\n                                    }, {\n                                        children: [\n                                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n                                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.secureAndManage\")\n                                            }),\n                                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.safelyStore\")\n                                            })\n                                        ]\n                                    }))\n                                ]\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                className: \"wallet-what\"\n                            }, {\n                                children: [\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                        className: \"icon-side\"\n                                    }, {\n                                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FolderIcon, {})\n                                    })),\n                                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                                        className: \"content-side\"\n                                    }, {\n                                        children: [\n                                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n                                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.logInToAny\")\n                                            }),\n                                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.noNeedToCreate\")\n                                            })\n                                        ]\n                                    }))\n                                ]\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                className: \"button-spacing\"\n                            }),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                className: \"middleButton\",\n                                onClick: ()=>{\n                                    setRoute(\"GetWallets\");\n                                }\n                            }, {\n                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\")\n                            }))\n                        ]\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"what-wallet-mobile\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.useAWallet\")\n                            }),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                                className: \"middleButton\",\n                                onClick: ()=>{\n                                    setRoute(\"GetWallets\");\n                                }\n                            }, {\n                                children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.getAWallet\")\n                            }))\n                        ]\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                        className: \"lang-selector-wrapper\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"select\", Object.assign({\n                            className: \"lang-selector\",\n                            name: \"lang\"\n                        }, {\n                            children: [\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", Object.assign({\n                                    value: \"en\"\n                                }, {\n                                    children: \"English\"\n                                })),\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"option\", Object.assign({\n                                    value: \"es\"\n                                }, {\n                                    children: \"Spanish\"\n                                }))\n                            ]\n                        }))\n                    }))\n                ]\n            })\n        ]\n    }));\n};\nconst WalletConnected = ({ module, onCloseModal })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"nws-modal-header\"\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n                        className: \"middleTitle\"\n                    }, {\n                        children: ``\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CloseButton, {\n                        onClick: onCloseModal\n                    })\n                ]\n            })),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                className: \"connecting-wrapper\"\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                    className: \"content\"\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                            className: \"icon\"\n                        }, {\n                            children: [\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                    className: \"green-dot\"\n                                }),\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                    src: module === null || module === void 0 ? void 0 : module.metadata.iconUrl,\n                                    alt: module === null || module === void 0 ? void 0 : module.metadata.name\n                                })\n                            ]\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", Object.assign({\n                            className: \"connecting-name\"\n                        }, {\n                            children: module === null || module === void 0 ? void 0 : module.metadata.name\n                        })),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                            className: \"wallet-connected-success\"\n                        }, {\n                            children: [\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionSuccessIcon, {}),\n                                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                                    children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectionSuccessful\")\n                                })\n                            ]\n                        }))\n                    ]\n                }))\n            }))\n        ]\n    });\n};\nvar anObject$1 = anObject$c;\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function() {\n    var that = anObject$1(this);\n    var result = \"\";\n    if (that.hasIndices) result += \"d\";\n    if (that.global) result += \"g\";\n    if (that.ignoreCase) result += \"i\";\n    if (that.multiline) result += \"m\";\n    if (that.dotAll) result += \"s\";\n    if (that.unicode) result += \"u\";\n    if (that.unicodeSets) result += \"v\";\n    if (that.sticky) result += \"y\";\n    return result;\n};\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\nvar RegExpPrototype$1 = RegExp.prototype;\nvar regexpGetFlags = function(R) {\n    var flags = R.flags;\n    return flags === undefined && !(\"flags\" in RegExpPrototype$1) && !hasOwn(R, \"flags\") && isPrototypeOf(RegExpPrototype$1, R) ? call(regExpFlags, R) : flags;\n};\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$6;\nvar anObject = anObject$c;\nvar $toString = toString$3;\nvar fails = fails$h;\nvar getRegExpFlags = regexpGetFlags;\nvar TO_STRING = \"toString\";\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\nvar NOT_GENERIC = fails(function() {\n    return n$ToString.call({\n        source: \"a\",\n        flags: \"b\"\n    }) != \"/a/b\";\n});\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n    defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n        var R = anObject(this);\n        var pattern = $toString(R.source);\n        var flags = $toString(getRegExpFlags(R));\n        return \"/\" + pattern + \"/\" + flags;\n    }, {\n        unsafe: true\n    });\n}\nconst CopyIcon = ()=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", Object.assign({\n        width: 24,\n        height: 24,\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M6.5 15.25a1.75 1.75 0 0 1-1.75-1.75V6.75a2 2 0 0 1 2-2h6.75c.966 0 1.75.784 1.75 1.75\",\n                stroke: \"#4F7CD1\",\n                strokeWidth: 1.5,\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: \"M8.75 10.75a2 2 0 0 1 2-2h6.5a2 2 0 0 1 2 2v6.5a2 2 0 0 1-2 2h-6.5a2 2 0 0 1-2-2v-6.5Z\",\n                stroke: \"#4F7CD1\",\n                strokeWidth: 1.5,\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            })\n        ]\n    }));\nfunction formatQRCodeImage(data) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield qrcode__WEBPACK_IMPORTED_MODULE_4__.toString(data, {\n            margin: 0,\n            type: \"svg\"\n        });\n    });\n}\nconst ScanQRCode = ({ wallet, uri, onCloseModal, handleOpenDefaultModal })=>{\n    const [notification, setNotification] = react__WEBPACK_IMPORTED_MODULE_2__.useState(\"\");\n    const [svg, setSvg] = react__WEBPACK_IMPORTED_MODULE_2__.useState(\"\");\n    const copyToClipboard = ()=>{\n        if (!uri) {\n            return;\n        }\n        const success = copy_to_clipboard__WEBPACK_IMPORTED_MODULE_5__(uri);\n        if (success) {\n            setNotification((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.copiedToClipboard\"));\n            setTimeout(()=>setNotification(\"\"), 1200);\n        } else {\n            setNotification((0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.failedToCopy\"));\n            setTimeout(()=>setNotification(\"\"), 1200);\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(()=>{\n        (()=>__awaiter(void 0, void 0, void 0, function*() {\n                if (uri) {\n                    setSvg((yield formatQRCodeImage(uri)));\n                }\n            }))();\n    }, [\n        uri\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"section\", Object.assign({\n        className: \"scan-qr-code\"\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ModalHeader, {\n                title: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.scanWithYourMobile\"),\n                onCloseModal: onCloseModal\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"section\", Object.assign({\n                className: \"qr-code\"\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                        dangerouslySetInnerHTML: {\n                            __html: svg\n                        }\n                    }),\n                    notification ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                        className: \"notification\"\n                    }, {\n                        children: notification\n                    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"copy-btn\",\n                        onClick: copyToClipboard\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CopyIcon, {}),\n                            (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.copyToClipboard\")\n                        ]\n                    }))\n                ]\n            })),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"footer\", Object.assign({\n                className: \"footer\"\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                        children: [\n                            (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.preferTheOfficial\"),\n                            \" \",\n                            wallet.metadata.name,\n                            \"?\"\n                        ]\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", Object.assign({\n                        className: \"btn\",\n                        onClick: handleOpenDefaultModal\n                    }, {\n                        children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.qr.open\")\n                    }))\n                ]\n            }))\n        ]\n    }));\n};\nconst getThemeClass = (theme)=>{\n    switch(theme){\n        case \"dark\":\n            return \"dark-theme\";\n        case \"light\":\n            return \"light-theme\";\n        default:\n            return \"\";\n    }\n};\nconst Modal = ({ selector, options, visible, hide, emitter })=>{\n    var _a, _b, _c;\n    const [route, setRoute] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        name: \"WalletHome\"\n    });\n    const [alertMessage, setAlertMessage] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [selectedWallet, setSelectedWallet] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    const [bridgeWalletUri, setBridgeWalletUri] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        setRoute({\n            name: \"WalletHome\"\n        });\n        (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.allowOnlyLanguage)(selector.options.languageCode);\n        const { selectedWalletId, modules } = selector.store.getState();\n        if (selectedWalletId) {\n            const module = modules.find((m)=>m.id === selectedWalletId);\n            setSelectedWallet(module);\n            setRoute({\n                name: \"WalletConnected\",\n                params: {\n                    module\n                }\n            });\n        }\n        setBridgeWalletUri(\"\");\n    // eslint-disable-next-line\n    }, [\n        visible\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const subscription = selector.on(\"networkChanged\", ({ networkId })=>{\n            // Switched back to the correct network.\n            if (networkId === selector.options.network.networkId) {\n                return handleDismissClick({});\n            }\n            setRoute({\n                name: \"WalletNetworkChanged\"\n            });\n        });\n        return ()=>subscription.remove();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    const handleDismissClick = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(({ hideReason })=>{\n        setAlertMessage(null);\n        setRoute({\n            name: \"WalletHome\"\n        });\n        if (hideReason === \"user-triggered\") {\n            emitter.emit(\"onHide\", {\n                hideReason\n            });\n        }\n        if (hideReason === \"wallet-navigation\") {\n            emitter.emit(\"onHide\", {\n                hideReason\n            });\n        }\n        hide();\n    }, [\n        hide,\n        emitter\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const close = (e)=>{\n            if (e.key === \"Escape\") {\n                handleDismissClick({\n                    hideReason: \"user-triggered\"\n                });\n            }\n        };\n        window.addEventListener(\"keydown\", close);\n        return ()=>window.removeEventListener(\"keydown\", close);\n    }, [\n        handleDismissClick\n    ]);\n    const handleWalletClick = (module, qrCodeModal)=>__awaiter(void 0, void 0, void 0, function*() {\n            setSelectedWallet(module);\n            const { selectedWalletId } = selector.store.getState();\n            if (selectedWalletId === module.id) {\n                setRoute({\n                    name: \"WalletConnected\",\n                    params: {\n                        module\n                    }\n                });\n                return;\n            }\n            try {\n                const { deprecated, available } = module.metadata;\n                if (module.type === \"injected\" && !available) {\n                    setRoute({\n                        name: \"WalletNotInstalled\",\n                        params: {\n                            module: module\n                        }\n                    });\n                    return;\n                }\n                const wallet = yield module.wallet();\n                if (deprecated) {\n                    setAlertMessage(`${module.metadata.name} is deprecated. Please select another wallet.`);\n                    setRoute({\n                        name: \"AlertMessage\",\n                        params: {\n                            module: module\n                        }\n                    });\n                    return;\n                }\n                if (wallet.type === \"hardware\") {\n                    setRoute({\n                        name: \"DerivationPath\",\n                        params: {\n                            walletId: wallet.id || \"ledger\"\n                        }\n                    });\n                    return;\n                }\n                setRoute({\n                    name: \"WalletConnecting\",\n                    params: {\n                        wallet: wallet\n                    }\n                });\n                if (wallet.type === \"bridge\") {\n                    const subscription = selector.on(\"uriChanged\", ({ uri })=>{\n                        setBridgeWalletUri(uri);\n                        setRoute({\n                            name: \"ScanQRCode\",\n                            params: {\n                                uri,\n                                wallet\n                            }\n                        });\n                    });\n                    yield wallet.signIn({\n                        contractId: options.contractId,\n                        methodNames: options.methodNames,\n                        qrCodeModal\n                    });\n                    subscription.remove();\n                    handleDismissClick({\n                        hideReason: \"wallet-navigation\"\n                    });\n                    return;\n                }\n                if (wallet.type === \"browser\") {\n                    yield wallet.signIn({\n                        contractId: options.contractId,\n                        methodNames: options.methodNames,\n                        successUrl: wallet.metadata.successUrl,\n                        failureUrl: wallet.metadata.failureUrl\n                    });\n                    handleDismissClick({\n                        hideReason: \"wallet-navigation\"\n                    });\n                    return;\n                }\n                yield wallet.signIn({\n                    contractId: options.contractId,\n                    methodNames: options.methodNames\n                });\n                handleDismissClick({\n                    hideReason: \"wallet-navigation\"\n                });\n            } catch (err) {\n                const { name } = module.metadata;\n                const message = err instanceof Error ? err.message : \"Something went wrong\";\n                setAlertMessage(`Failed to sign in with ${name}: ${message}`);\n                setRoute({\n                    name: \"AlertMessage\",\n                    params: {\n                        module: module\n                    }\n                });\n            }\n        });\n    if (!visible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        className: `nws-modal-wrapper ${getThemeClass(options === null || options === void 0 ? void 0 : options.theme)} ${visible ? \"open\" : \"\"}`\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                className: \"nws-modal-overlay\",\n                onClick: ()=>{\n                    handleDismissClick({\n                        hideReason: \"user-triggered\"\n                    });\n                }\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                className: \"nws-modal\"\n            }, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                        className: \"modal-left\"\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                                className: \"modal-left-title\"\n                            }, {\n                                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n                                    children: (0,_near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.translate)(\"modal.wallet.connectYourWallet\")\n                                })\n                            })),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletOptions, {\n                                handleWalletClick: (module)=>{\n                                    handleWalletClick(module, false);\n                                },\n                                selector: selector\n                            })\n                        ]\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                        className: \"modal-right\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n                            className: \"nws-modal-body\"\n                        }, {\n                            children: [\n                                route.name === \"AlertMessage\" && alertMessage && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AlertMessage, {\n                                    message: alertMessage,\n                                    module: (_a = route.params) === null || _a === void 0 ? void 0 : _a.module,\n                                    onBack: (retry)=>{\n                                        if (retry) {\n                                            handleWalletClick(selectedWallet, false);\n                                        }\n                                        setAlertMessage(null);\n                                        setRoute({\n                                            name: \"WalletHome\"\n                                        });\n                                    },\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        })\n                                }),\n                                route.name === \"DerivationPath\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DerivationPath, {\n                                    selector: selector,\n                                    options: options,\n                                    onConnected: ()=>{\n                                        handleDismissClick({\n                                            hideReason: \"wallet-navigation\"\n                                        });\n                                    },\n                                    params: route.params,\n                                    onBack: ()=>setRoute({\n                                            name: \"WalletHome\"\n                                        }),\n                                    onError: (message, wallet)=>{\n                                        const { modules } = selector.store.getState();\n                                        const findModule = modules.find((module)=>module.id === wallet.id);\n                                        setAlertMessage(message);\n                                        setRoute({\n                                            name: \"AlertMessage\",\n                                            params: {\n                                                module: findModule\n                                            }\n                                        });\n                                    },\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        })\n                                }),\n                                route.name === \"WalletNetworkChanged\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletNetworkChanged, {\n                                    selector: selector,\n                                    onBack: ()=>setRoute({\n                                            name: \"WalletHome\"\n                                        }),\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        })\n                                }),\n                                route.name === \"WalletNotInstalled\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletNotInstalled, {\n                                    module: (_b = route.params) === null || _b === void 0 ? void 0 : _b.module,\n                                    onBack: ()=>{\n                                        setRoute({\n                                            name: \"WalletHome\"\n                                        });\n                                    },\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        })\n                                }),\n                                route.name === \"WalletConnecting\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnecting, {\n                                    wallet: (_c = route.params) === null || _c === void 0 ? void 0 : _c.wallet,\n                                    onBack: ()=>{\n                                        setRoute({\n                                            name: \"WalletHome\"\n                                        });\n                                    },\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        })\n                                }),\n                                route.name === \"WalletHome\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletHome, {\n                                    selector: selector,\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        })\n                                }),\n                                route.name === \"WalletConnected\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WalletConnected, {\n                                    module: selectedWallet,\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        })\n                                }),\n                                route.name === \"ScanQRCode\" && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ScanQRCode, {\n                                    handleOpenDefaultModal: ()=>{\n                                        handleWalletClick(selectedWallet, true);\n                                    },\n                                    onCloseModal: ()=>handleDismissClick({\n                                            hideReason: \"user-triggered\"\n                                        }),\n                                    uri: bridgeWalletUri,\n                                    wallet: selectedWallet\n                                })\n                            ]\n                        }))\n                    }))\n                ]\n            }))\n        ]\n    }));\n};\nconst MODAL_ELEMENT_ID = \"near-wallet-selector-modal\";\nlet modalInstance = null;\nlet root = null;\n/**\r\n * Initiates a modal instance\r\n * @param {WalletSelector} selector Selector\r\n * @param {ModalOptions} options Modal options\r\n * @returns {WalletSelectorModal} Returns a WalletSelectorModal object\r\n */ const setupModal = (selector, options)=>{\n    if (!root) {\n        const body = document.body;\n        const container = document.createElement(\"div\");\n        container.id = MODAL_ELEMENT_ID;\n        body.appendChild(container);\n        root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot)(container);\n    }\n    const emitter = new _near_wallet_selector_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();\n    const render = (visible = false)=>{\n        root.render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Modal, {\n            selector: selector,\n            options: options,\n            visible: visible,\n            hide: ()=>render(false),\n            emitter: emitter\n        }));\n    };\n    if (!modalInstance) {\n        modalInstance = {\n            show: ()=>{\n                render(true);\n            },\n            hide: ()=>{\n                render(false);\n            },\n            on: (eventName, callback)=>{\n                return emitter.on(eventName, callback);\n            },\n            off: (eventName, callback)=>{\n                emitter.off(eventName, callback);\n            }\n        };\n    }\n    return modalInstance;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL21vZGFsLXVpL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0U7QUFDeEI7QUFDNEI7QUFDYztBQUM1RDtBQUNTO0FBRXJDLElBQUljLGlCQUFpQixPQUFPQyxlQUFlLGNBQWNBLGFBQWEsTUFBa0IsR0FBY0MsQ0FBTUEsR0FBRyxPQUFPQyxXQUFXLGNBQWNBLFNBQVMsT0FBT0MsU0FBUyxjQUFjQSxPQUFPLENBQUM7QUFFOUwsSUFBSUMsVUFBVSxTQUFVQyxJQUFJO0lBQzFCLElBQUk7UUFDRixPQUFPLENBQUMsQ0FBQ0E7SUFDWCxFQUFFLE9BQU9DLE9BQU87UUFDZCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLElBQUlDLFVBQVVIO0FBRWQsSUFBSUkscUJBQXFCLENBQUNELFFBQVE7SUFDaEMsbUVBQW1FO0lBQ25FLElBQUlFLE9BQU8sQ0FBQyxZQUEwQixHQUFHQyxJQUFJO0lBQzdDLHlEQUF5RDtJQUN6RCxPQUFPLE9BQU9ELFFBQVEsY0FBY0EsS0FBS0UsY0FBYyxDQUFDO0FBQzFEO0FBRUEsSUFBSUMsZ0JBQWdCSjtBQUVwQixJQUFJSyxzQkFBc0JDLFNBQVNDLFNBQVM7QUFDNUMsSUFBSUMsU0FBU0gsb0JBQW9CSCxJQUFJO0FBQ3JDLElBQUlPLFNBQVNKLG9CQUFvQkssSUFBSTtBQUNyQyxJQUFJQyxnQkFBZ0JQLGlCQUFpQkksT0FBT04sSUFBSSxDQUFDTyxRQUFRQTtBQUV6RCxJQUFJRyxzQkFBc0JSLGdCQUFnQixTQUFVUyxFQUFFO0lBQ3BELE9BQU9BLE1BQU1GLGNBQWNFO0FBQzdCLElBQUksU0FBVUEsRUFBRTtJQUNkLE9BQU9BLE1BQU07UUFDWCxPQUFPSixPQUFPSyxLQUFLLENBQUNELElBQUlFO0lBQzFCO0FBQ0Y7QUFFQSxJQUFJQyxnQkFBZ0JKO0FBRXBCLElBQUlLLGFBQWFELGNBQWMsQ0FBQyxFQUFFRSxRQUFRO0FBQzFDLElBQUlDLGdCQUFnQkgs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WUFDQWhCLElBQUksQ0FBQ2tCLFdBQVdDO2dCQUNkLE9BQU9oQyxRQUFRYSxFQUFFLENBQUNrQixXQUFXQztZQUMvQjtZQUNBQyxLQUFLLENBQUNGLFdBQVdDO2dCQUNmaEMsUUFBUWlDLEdBQUcsQ0FBQ0YsV0FBV0M7WUFDekI7UUFDRjtJQUNGO0lBQ0EsT0FBT1I7QUFDVDtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ktYW0tbmVhcmJ5Ly4vbm9kZV9tb2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci9tb2RhbC11aS9pbmRleC5qcz9mMjA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeHMsIGpzeCwgRnJhZ21lbnQgYXMgRnJhZ21lbnQkMSB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IGNyZWF0ZVJvb3QgfSBmcm9tICdyZWFjdC1kb20vY2xpZW50JztcbmltcG9ydCBSZWFjdCwgeyBGcmFnbWVudCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGFsbG93T25seUxhbmd1YWdlLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAbmVhci13YWxsZXQtc2VsZWN0b3IvY29yZSc7XG5pbXBvcnQgUVJDb2RlIGZyb20gJ3FyY29kZSc7XG5pbXBvcnQgY29weSBmcm9tICdjb3B5LXRvLWNsaXBib2FyZCc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgZmFpbHMkaCA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkZyA9IGZhaWxzJGg7XG5cbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMyA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYmluZCQ1ID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5iaW5kO1xudmFyIGNhbGwkZiA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuY2FsbDtcbnZhciB1bmN1cnJ5VGhpcyRoID0gTkFUSVZFX0JJTkQkMyAmJiBiaW5kJDUuYmluZChjYWxsJGYsIGNhbGwkZik7XG5cbnZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQkMyA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgdW5jdXJyeVRoaXMkaChmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwkZi5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIHRvU3RyaW5nJDUgPSB1bmN1cnJ5VGhpcyRnKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkZygnJy5zbGljZSk7XG5cbnZhciBjbGFzc29mUmF3JDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlJDEodG9TdHJpbmckNShpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRmID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRmID0gZmFpbHMkaDtcbnZhciBjbGFzc29mJDYgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDQgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyRmKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkZihmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQ0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiQ2KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDQoaXQpO1xufSA6ICRPYmplY3QkNDtcblxudmFyICRUeXBlRXJyb3IkZSA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkZShcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMihyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoaXQpKTtcbn07XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkayA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgc2hhcmVkJDMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ2xvYmFsJGogPSBnbG9iYWwkaztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNihnbG9iYWwkaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWwkaltrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdsb2JhbCRpID0gZ2xvYmFsJGs7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMiA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSQzID0gZ2xvYmFsJGlbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyKFNIQVJFRCwge30pO1xuXG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG52YXIgc3RvcmUkMiA9IHNoYXJlZFN0b3JlO1xuXG4oc2hhcmVkJDMuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMjMuMycsXG4gIG1vZGU6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMy4zL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQxID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoYXJndW1lbnQpKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b09iamVjdCQ0ID0gdG9PYmplY3QkNTtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMkZSh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbnZhciBoYXNPd25Qcm9wZXJ0eV8xID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QkNChpdCksIGtleSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmckNCA9IHVuY3VycnlUaGlzJGQoMS4wLnRvU3RyaW5nKTtcblxudmFyIHVpZCQyID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nJDQoKytpZCArIHBvc3RmaXgsIDM2KTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkbCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkaztcbnZhciBpc0NhbGxhYmxlJGsgPSBpc0NhbGxhYmxlJGw7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkayhhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDggPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCRoW25hbWVzcGFjZV0pIDogZ2xvYmFsJGhbbmFtZXNwYWNlXSAmJiBnbG9iYWwkaFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ3ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbiQ3KCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBnbG9iYWwkZyA9IGdsb2JhbCRrO1xudmFyIHVzZXJBZ2VudCQ1ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgcHJvY2VzcyQzID0gZ2xvYmFsJGcucHJvY2VzcztcbnZhciBEZW5vJDEgPSBnbG9iYWwkZy5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQzICYmIHByb2Nlc3MkMy52ZXJzaW9ucyB8fCBEZW5vJDEgJiYgRGVubyQxLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCQ1KSB7XG4gIG1hdGNoID0gdXNlckFnZW50JDUubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50JDUubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIFY4X1ZFUlNJT04kMSA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBmYWlscyRlID0gZmFpbHMkaDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiQxICYmIFY4X1ZFUlNJT04kMSA8IDQxO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBOQVRJVkVfU1lNQk9MJDIgPSBuYXRpdmVTeW1ib2w7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IE5BVElWRV9TWU1CT0wkMlxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJGs7XG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkMy5leHBvcnRzO1xudmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMSA9IHVpZCQyO1xudmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCQxID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQkMignd2tzJyk7XG52YXIgU3ltYm9sJDEgPSBnbG9iYWwkZi5TeW1ib2w7XG52YXIgc3ltYm9sRm9yID0gU3ltYm9sJDEgJiYgU3ltYm9sJDFbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDE7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGIoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wkMSB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wkMSAmJiBoYXNPd24kYihTeW1ib2wkMSwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuICAgIH0gZWxzZSBpZiAoVVNFX1NZTUJPTF9BU19VSUQkMSAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgaXNDYWxsYWJsZSRqID0gaXNDYWxsYWJsZSRsO1xuXG52YXIgaXNPYmplY3QkOCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGooaXQpO1xufTtcblxudmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCQ4O1xuXG52YXIgJFN0cmluZyQzID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkZCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxudmFyIGFuT2JqZWN0JGMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0JDcoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkZCgkU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgZmFpbHMkZCA9IGZhaWxzJGg7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG52YXIgZGVzY3JpcHRvcnMgPSAhZmFpbHMkZChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyRiID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkYyA9IGZhaWxzJGg7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkYiAmJiBmYWlscyRjKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgZ2xvYmFsJGUgPSBnbG9iYWwkaztcbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkODtcblxudmFyIGRvY3VtZW50JDMgPSBnbG9iYWwkZS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkNihkb2N1bWVudCQzKSAmJiBpc09iamVjdCQ2KGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkYSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJGIgPSBmYWlscyRoO1xudmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbnZhciBpZThEb21EZWZpbmUgPSAhREVTQ1JJUFRPUlMkYSAmJiAhZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQkMSgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDIgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGUgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDIgPyBjYWxsJGUuYmluZChjYWxsJGUpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRlLmFwcGx5KGNhbGwkZSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSB1bmN1cnJ5VGhpcyRjKHt9LmlzUHJvdG90eXBlT2YpO1xuXG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkaSA9IGlzQ2FsbGFibGUkbDtcbnZhciBpc1Byb3RvdHlwZU9mJDQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gdXNlU3ltYm9sQXNVaWQ7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbnZhciBpc1N5bWJvbCQyID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDYoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSRpKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkNCgkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdCQyKGl0KSk7XG59O1xuXG52YXIgJFN0cmluZyQyID0gU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDIoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGlzQ2FsbGFibGUkaCA9IGlzQ2FsbGFibGUkbDtcbnZhciB0cnlUb1N0cmluZyQ0ID0gdHJ5VG9TdHJpbmckNTtcblxudmFyICRUeXBlRXJyb3IkYyA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkOSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSRoKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGModHJ5VG9TdHJpbmckNChhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDggPSBhQ2FsbGFibGUkOTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDgoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRkID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkZyA9IGlzQ2FsbGFibGUkbDtcbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkODtcblxudmFyICRUeXBlRXJyb3IkYiA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRnKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCQ1KHZhbCA9IGNhbGwkZChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkZyhmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCQ1KHZhbCA9IGNhbGwkZChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZyhmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNSh2YWwgPSBjYWxsJGQoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkYihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBjYWxsJGMgPSBmdW5jdGlvbkNhbGw7XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JDg7XG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sJDI7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkMztcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gb3JkaW5hcnlUb1ByaW1pdGl2ZSQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sJGYoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG52YXIgdG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0JDQoaW5wdXQpIHx8IGlzU3ltYm9sJDEoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QkMihpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbCRjKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QkNChyZXN1bHQpIHx8IGlzU3ltYm9sJDEocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yJGEoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUgPSB0b1ByaW1pdGl2ZSQxO1xudmFyIGlzU3ltYm9sID0gaXNTeW1ib2wkMjtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCRiID0gYW5PYmplY3QkYztcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSB0b1Byb3BlcnR5S2V5JDM7XG5cbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDkgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRiKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQyKFApO1xuICBhbk9iamVjdCRiKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGIoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGIoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvciQ5KCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDEgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtYXgkMSA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDEoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMShpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbnZhciB0b0xlbmd0aCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIHRvTGVuZ3RoID0gdG9MZW5ndGgkMTtcblxuLy8gYExlbmd0aE9mQXJyYXlMaWtlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2VcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ1ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdG9MZW5ndGgob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDQgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNChPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMShmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDEodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDEoZmFsc2UpXG59O1xuXG52YXIgaGlkZGVuS2V5cyQ0ID0ge307XG5cbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kYSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBpbmRleE9mID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMyA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkMSA9IHVuY3VycnlUaGlzJGIoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQzKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJGEoaGlkZGVuS2V5cyQzLCBrZXkpICYmIGhhc093biRhKE8sIGtleSkgJiYgcHVzaCQxKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biRhKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gkMShyZXN1bHQsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIGVudW1CdWdLZXlzJDMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMkMiA9IGVudW1CdWdLZXlzJDM7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG52YXIgb2JqZWN0S2V5cyQyID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMkMShPLCBlbnVtQnVnS2V5cyQyKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgYW5PYmplY3QkYSA9IGFuT2JqZWN0JGM7XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciBvYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzJDI7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5vYmplY3REZWZpbmVQcm9wZXJ0aWVzLmYgPSBERVNDUklQVE9SUyQ4ICYmICFWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JGEoTyk7XG4gIHZhciBwcm9wcyA9IHRvSW5kZXhlZE9iamVjdCQyKFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMkMShQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgaHRtbCQyID0gZ2V0QnVpbHRJbiQ1KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxudmFyIHNoYXJlZCQxID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMSgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkYztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDQ7XG52YXIgaHRtbCQxID0gaHRtbCQyO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkMztcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMignSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbCQxLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzJDEubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5cyQxW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzJDJbSUVfUFJPVE8kMV0gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdCQ5KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkZztcbnZhciBjcmVhdGUkMSA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sJGUoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGUkMVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5JDUoQXJyYXlQcm90b3R5cGUkMSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZSQxKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgYWRkVG9VbnNjb3BhYmxlcyQyID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZSQxW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIHVuY3VycnlUaGlzJGEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkbDtcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkYShGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRmKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQ0ID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJGQgPSBnbG9iYWwkaztcbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJGw7XG52YXIgaW5zcGVjdFNvdXJjZSQzID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJGQuV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJGUoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQzKFdlYWtNYXAkMSkpO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNDtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gREVTQ1JJUFRPUlMkNyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbnZhciBnbG9iYWwkYyA9IGdsb2JhbCRrO1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCQ4O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQxID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJGMuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkYy5XZWFrTWFwO1xudmFyIHNldCQxLCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0JDEoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkMyhpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDIoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyQ5KHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJDkoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkOShzdG9yZS5zZXQpO1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQyKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQxKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDFbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ5KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDEsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkYiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNDtcbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkMztcbnZhciBoYXNPd24kOCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3Jcbm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkNiA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDEoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDEoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJDgoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMighY2FsbCRiKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIG1ha2VCdWlsdEluJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkNSA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkNSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJDcoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkNSB8fCAoREVTQ1JJUFRPUlMkNSAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciBmYWlscyRhID0gZmFpbHMkaDtcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGw7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQyID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQ0ICYmICFmYWlscyRhKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDQoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4kMSA9IG1ha2VCdWlsdEluJDIuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoU3RyaW5nKG5hbWUpLnNsaWNlKDAsIDcpID09PSAnU3ltYm9sKCcpIHtcbiAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duJDYodmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkNCkgZGVmaW5lUHJvcGVydHkkNCh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093biQ2KG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5JDQodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDYob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTJDQpIGRlZmluZVByb3BlcnR5JDQodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duJDYoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDEoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGQodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDIodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkbDtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4gPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHM7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkkMSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG5cbnZhciBkZWZpbmVCdWlsdEluJDYgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUkYyh2YWx1ZSkpIG1ha2VCdWlsdEluKHZhbHVlLCBuYW1lLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxKGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlJDMuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQzO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJDggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JDggPSBhbk9iamVjdCRjO1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyQ4KFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDQoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkOChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQyID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24kNSh0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093biQ1KGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFpbHMkOSA9IGZhaWxzJGg7XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRsO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMiA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZSRiKGRldGVjdGlvbikgPyBmYWlscyQ5KGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDIubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQyLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQyLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDIuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMjtcblxudmFyIGdsb2JhbCRiID0gZ2xvYmFsJGs7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0O1xudmFyIGRlZmluZUJ1aWx0SW4kNSA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQyO1xudmFyIGlzRm9yY2VkJDEgPSBpc0ZvcmNlZF8xO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGI7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGJbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsJGJbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZCQxKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMShzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGZhaWxzJDggPSBmYWlscyRoO1xuXG52YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkbDtcbnZhciB0b09iamVjdCQzID0gdG9PYmplY3QkNTtcbnZhciBzaGFyZWRLZXkgPSBzaGFyZWRLZXkkMztcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBjb3JyZWN0UHJvdG90eXBlR2V0dGVyO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSA9ICRPYmplY3QkMS5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0JDEuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QkMyhPKTtcbiAgaWYgKGhhc093biQ0KG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZSRhKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QkMSA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG52YXIgZmFpbHMkNyA9IGZhaWxzJGg7XG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRsO1xudmFyIGdldFByb3RvdHlwZU9mJDEgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBkZWZpbmVCdWlsdEluJDQgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgd2VsbEtub3duU3ltYm9sJGQgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkZCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQxKGdldFByb3RvdHlwZU9mJDEoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQyID09IHVuZGVmaW5lZCB8fCBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDVdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlJDkoSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQ1XSkpIHtcbiAgZGVmaW5lQnVpbHRJbiQ0KEl0ZXJhdG9yUHJvdG90eXBlJDIsIElURVJBVE9SJDUsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMixcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaGFzT3duJDMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHdlbGxLbm93blN5bWJvbCRjID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkYygndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093biQzKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQzKSkge1xuICAgIGRlZmluZVByb3BlcnR5JDModGFyZ2V0LCBUT19TVFJJTkdfVEFHJDMsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDM7XG52YXIgSXRlcmF0b3JzJDQgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUkMSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnJDIoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UpO1xuICBJdGVyYXRvcnMkNFtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRsO1xuXG52YXIgJFN0cmluZyQxID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkOCA9IFR5cGVFcnJvcjtcblxudmFyIGFQb3NzaWJsZVByb3RvdHlwZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ29iamVjdCcgfHwgaXNDYWxsYWJsZSQ4KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDgoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nJDEoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGM7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gYVBvc3NpYmxlUHJvdG90eXBlJDE7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHNldHRlciA9IHVuY3VycnlUaGlzJDcoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0JDcoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxudmFyICQkYyA9IF9leHBvcnQ7XG52YXIgY2FsbCRhID0gZnVuY3Rpb25DYWxsO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGw7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mJDEgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckMztcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0O1xudmFyIGRlZmluZUJ1aWx0SW4kMyA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciB3ZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbCRnO1xudmFyIEl0ZXJhdG9ycyQzID0gaXRlcmF0b3JzO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSBpdGVyYXRvcnNDb3JlO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SJDQgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGRlZmluZUl0ZXJhdG9yJDEgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNF1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZiQxKSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YkMShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZSQ3KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUiQ0XSkpIHtcbiAgICAgICAgICBkZWZpbmVCdWlsdEluJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiQ0LCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWckMShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FJDEgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbCRhKG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgZGVmaW5lQnVpbHRJbiQzKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQkYyh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDQsIGRlZmF1bHRJdGVyYXRvciwgeyBuYW1lOiBERUZBVUxUIH0pO1xuICB9XG4gIEl0ZXJhdG9ycyQzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIHJldHVybiBtZXRob2RzO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIGFkZFRvVW5zY29wYWJsZXMkMSA9IGFkZFRvVW5zY29wYWJsZXMkMjtcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IkMTtcbnZhciBERVNDUklQVE9SUyQzID0gZGVzY3JpcHRvcnM7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxudmFyIGVzX2FycmF5X2l0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycyQyLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycyQyLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzJDEoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMkMSgndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzJDEoJ2VudHJpZXMnKTtcblxuLy8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xuaWYgKERFU0NSSVBUT1JTJDMgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSQyKHZhbHVlcywgJ25hbWUnLCB7IHZhbHVlOiAndmFsdWVzJyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG52YXIgZG9tSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxuLy8gaW4gb2xkIFdlYktpdCB2ZXJzaW9ucywgYGVsZW1lbnQuY2xhc3NMaXN0YCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgZ2xvYmFsIGBET01Ub2tlbkxpc3RgXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbnZhciBjbGFzc0xpc3QgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ3NwYW4nKS5jbGFzc0xpc3Q7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPSBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBkb21Ub2tlbkxpc3RQcm90b3R5cGUgPSBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHVuZGVmaW5lZCA6IERPTVRva2VuTGlzdFByb3RvdHlwZSQxO1xuXG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkaztcbnZhciBET01JdGVyYWJsZXMgPSBkb21JdGVyYWJsZXM7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlID0gZG9tVG9rZW5MaXN0UHJvdG90eXBlO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gZXNfYXJyYXlfaXRlcmF0b3I7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJGEgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2wkYSgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2wkYSgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxudmFyIGhhbmRsZVByb3RvdHlwZSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpIHtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQzXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IkMywgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SJDNdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHJDJdKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRyQyLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgaGFuZGxlUHJvdG90eXBlKGdsb2JhbCRhW0NPTExFQ1RJT05fTkFNRV0gJiYgZ2xvYmFsJGFbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSk7XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUsICdET01Ub2tlbkxpc3QnKTtcblxudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgZmFpbHMkNiA9IGZhaWxzJGg7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMjtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciB0b09iamVjdCQyID0gdG9PYmplY3QkNTtcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0ID0gdW5jdXJyeVRoaXMkNihbXS5jb25jYXQpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbnZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyQ2KGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKERFU0NSSVBUT1JTJDIgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSQxKHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkkMSh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdmFyIFQgPSB0b09iamVjdCQyKHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdCQxKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQob2JqZWN0S2V5cyhTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJDIgfHwgY2FsbCQ5KHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbnZhciAkJGIgPSBfZXhwb3J0O1xudmFyIGFzc2lnbiA9IG9iamVjdEFzc2lnbjtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kJGIoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbmNvbnN0IENsb3NlSWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgZmlsbDogXCIjQzFDMUMxXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0wIDBoMjR2MjRIMHpcIixcbiAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyelwiXG4gICAgfSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IENsb3NlQnV0dG9uID0gKHtcbiAgb25DbGlja1xufSkgPT4ge1xuICByZXR1cm4ganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgY2xhc3NOYW1lOiBcImNsb3NlLWJ1dHRvblwiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjoganN4KENsb3NlSWNvbiwge30pXG4gIH0pKTtcbn07XG5cbmNvbnN0IE1vZGFsSGVhZGVyID0gKHtcbiAgdGl0bGUsXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICBjb25zdCBhZGRpdGlvbmFsQ2xhc3NlcyA9IHRpdGxlID09PSBcIkdldCBhIFdhbGxldFwiID8gXCIgLW9wZW5cIiA6IFwiXCI7XG4gIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJud3MtbW9kYWwtaGVhZGVyXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwiaDNcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IGBtaWRkbGVUaXRsZSAke2FkZGl0aW9uYWxDbGFzc2VzfWBcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogdGl0bGVcbiAgICB9KSksIGpzeChDbG9zZUJ1dHRvbiwge1xuICAgICAgb25DbGljazogb25DbG9zZU1vZGFsXG4gICAgfSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IEJhY2tBcnJvd0ljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiOFwiLFxuICAgIGhlaWdodDogXCIxNFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDggMTRcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk03IDEzTDEgN0w3IDFcIixcbiAgICAgIHN0cm9rZTogXCIjNjQ5NEVFXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KVxuICB9KSk7XG59O1xuXG5jb25zdCBCYWNrQXJyb3cgPSAoe1xuICBvbkNsaWNrXG59KSA9PiB7XG4gIHJldHVybiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgb25DbGljazogb25DbGljayxcbiAgICBjbGFzc05hbWU6IFwiYmFjay1idXR0b25cIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IGpzeChCYWNrQXJyb3dJY29uLCB7fSlcbiAgfSkpO1xufTtcblxuY29uc3QgV2FsbGV0TmV0d29ya0NoYW5nZWQgPSAoe1xuICBzZWxlY3RvcixcbiAgb25CYWNrLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgcmV0dXJuIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwibndzLW1vZGFsLWhlYWRlci13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeChCYWNrQXJyb3csIHtcbiAgICAgICAgb25DbGljazogb25CYWNrXG4gICAgICB9KSwganN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICAgIHRpdGxlOiBcIllvdSBNdXN0IENoYW5nZSB0aGUgTmV0d29ya1wiLFxuICAgICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgICAgfSldXG4gICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwic3dpdGNoLW5ldHdvcmstbWVzc2FnZS13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeHMoXCJwXCIsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1wiV2UndmUgZGV0ZWN0ZWQgdGhhdCB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB3YWxsZXQncyBuZXR3b3JrIHRvXCIsIGpzeChcInN0cm9uZ1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJuZXR3b3JrLWlkXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogYCAke3NlbGVjdG9yLm9wdGlvbnMubmV0d29yay5uZXR3b3JrSWR9YFxuICAgICAgICAgIH0pKSwgXCIgXCIsIFwiZm9yIHRoaXMgZEFwcC5cIl1cbiAgICAgICAgfSksIGpzeChcInBcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlNvbWUgd2FsbGV0cyBtYXkgbm90IHN1cHBvcnQgY2hhbmdpbmcgbmV0d29ya3MuIElmIHlvdSBjYW4gbm90IGNoYW5nZSBuZXR3b3JrcyB5b3UgbWF5IGNvbnNpZGVyIHN3aXRjaGluZyB0byBhbm90aGVyIHdhbGxldC5cIlxuICAgICAgICB9KV1cbiAgICAgIH0pKVxuICAgIH0pKV1cbiAgfSk7XG59O1xuXG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDU7XG5cbnZhciAkVHlwZUVycm9yJDcgPSBUeXBlRXJyb3I7XG5cbnZhciBkZWxldGVQcm9wZXJ0eU9yVGhyb3ckMSA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIGlmICghZGVsZXRlIE9bUF0pIHRocm93ICRUeXBlRXJyb3IkNygnQ2Fubm90IGRlbGV0ZSBwcm9wZXJ0eSAnICsgdHJ5VG9TdHJpbmckMyhQKSArICcgb2YgJyArIHRyeVRvU3RyaW5nJDMoTykpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2wkOSgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0JDEgPSB7fTtcblxudGVzdCQxW1RPX1NUUklOR19UQUckMV0gPSAneic7XG5cbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCQxKSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkbDtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sJDgoJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDUgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkNihPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciBjbGFzc29mJDQgPSBjbGFzc29mJDU7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckMyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiQ0KGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ0O1xuXG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkMTtcblxudmFyICRBcnJheSA9IEFycmF5O1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG52YXIgYXJyYXlTbGljZVNpbXBsZSA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQzKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheShtYXgoZmluIC0gaywgMCkpO1xuICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gIHJlc3VsdC5sZW5ndGggPSBuO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2VTaW1wbGU7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKFxuICAgIGFycmF5LFxuICAgIG1lcmdlU29ydChhcnJheVNsaWNlJDIoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMihhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBjb21wYXJlZm5cbiAgKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aClcbiAgICAgID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdXG4gICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlTb3J0ID0gbWVyZ2VTb3J0O1xuXG52YXIgZmFpbHMkNSA9IGZhaWxzJGg7XG5cbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDIgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcblxudmFyIHVzZXJBZ2VudCQ0ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudCQ0Lm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xuXG52YXIgZW5naW5lRmZWZXJzaW9uID0gISFmaXJlZm94ICYmICtmaXJlZm94WzFdO1xuXG52YXIgVUEgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0llT3JFZGdlID0gL01TSUV8VHJpZGVudC8udGVzdChVQSk7XG5cbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xuXG52YXIgZW5naW5lV2Via2l0VmVyc2lvbiA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFDYWxsYWJsZSQ3ID0gYUNhbGxhYmxlJDk7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJDU7XG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93ID0gZGVsZXRlUHJvcGVydHlPclRocm93JDE7XG52YXIgdG9TdHJpbmckMiA9IHRvU3RyaW5nJDM7XG52YXIgZmFpbHMkNCA9IGZhaWxzJGg7XG52YXIgaW50ZXJuYWxTb3J0ID0gYXJyYXlTb3J0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMjtcbnZhciBGRiA9IGVuZ2luZUZmVmVyc2lvbjtcbnZhciBJRV9PUl9FREdFID0gZW5naW5lSXNJZU9yRWRnZTtcbnZhciBWOCA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBXRUJLSVQgPSBlbmdpbmVXZWJraXRWZXJzaW9uO1xuXG52YXIgdGVzdCA9IFtdO1xudmFyIHVuJFNvcnQgPSB1bmN1cnJ5VGhpcyQ1KHRlc3Quc29ydCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzJDUodGVzdC5wdXNoKTtcblxuLy8gSUU4LVxudmFyIEZBSUxTX09OX1VOREVGSU5FRCA9IGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pO1xuLy8gVjggYnVnXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTVFJJQ1RfTUVUSE9EJDEgPSBhcnJheU1ldGhvZElzU3RyaWN0JDEoJ3NvcnQnKTtcblxudmFyIFNUQUJMRV9TT1JUID0gIWZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG4gIGZvciAoY29kZSA9IDY1OyBjb2RlIDwgNzY7IGNvZGUrKykge1xuICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNjY6IGNhc2UgNjk6IGNhc2UgNzA6IGNhc2UgNzI6IHZhbHVlID0gMzsgYnJlYWs7XG4gICAgICBjYXNlIDY4OiBjYXNlIDcxOiB2YWx1ZSA9IDQ7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdmFsdWUgPSAyO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICB0ZXN0LnB1c2goeyBrOiBjaHIgKyBpbmRleCwgdjogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnYgLSBhLnY7IH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xufSk7XG5cbnZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QkMSB8fCAhU1RBQkxFX1NPUlQ7XG5cbnZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDtcbiAgICByZXR1cm4gdG9TdHJpbmckMih4KSA+IHRvU3RyaW5nJDIoeSkgPyAxIDogLTE7XG4gIH07XG59O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29ydFxuJCRhKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlJDcoY29tcGFyZWZuKTtcblxuICAgIHZhciBhcnJheSA9IHRvT2JqZWN0JDEodGhpcyk7XG5cbiAgICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/IHVuJFNvcnQoYXJyYXkpIDogdW4kU29ydChhcnJheSwgY29tcGFyZWZuKTtcblxuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBhcnJheUxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoYXJyYXkpO1xuICAgIHZhciBpdGVtc0xlbmd0aCwgaW5kZXg7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGluZGV4IGluIGFycmF5KSBwdXNoKGl0ZW1zLCBhcnJheVtpbmRleF0pO1xuICAgIH1cblxuICAgIGludGVybmFsU29ydChpdGVtcywgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG5cbiAgICBpdGVtc0xlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcbiAgICBpbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBpdGVtc0xlbmd0aCkgYXJyYXlbaW5kZXhdID0gaXRlbXNbaW5kZXgrK107XG4gICAgd2hpbGUgKGluZGV4IDwgYXJyYXlMZW5ndGgpIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyhhcnJheSwgaW5kZXgrKyk7XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn0pO1xuXG52YXIgJCQ5ID0gX2V4cG9ydDtcbnZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xudmFyIGZhaWxzJDMgPSBmYWlscyRoO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFBcnJheSgxKS5pbmNsdWRlcygpO1xufSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiQkOSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogQlJPS0VOX09OX1NQQVJTRSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuXG52YXIgaXNPYmplY3QkMiA9IGlzT2JqZWN0JDg7XG52YXIgY2xhc3NvZiQzID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sJDcoJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG52YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QkMihpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIJDFdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YkMyhpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxudmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG5cbnZhciAkVHlwZUVycm9yJDYgPSBUeXBlRXJyb3I7XG5cbnZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyAkVHlwZUVycm9yJDYoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGc7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQ2KCdtYXRjaCcpO1xuXG52YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDM7XG52YXIgdG9TdHJpbmckMSA9IHRvU3RyaW5nJDM7XG52YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSBjb3JyZWN0SXNSZWdleHBMb2dpYztcblxudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcyQ0KCcnLmluZGV4T2YpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQkOCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZihcbiAgICAgIHRvU3RyaW5nJDEocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSksXG4gICAgICB0b1N0cmluZyQxKG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKSksXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cbn0pO1xuXG52YXIgYUNhbGxhYmxlJDYgPSBhQ2FsbGFibGUkOTtcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JDU7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJDU7XG5cbnZhciAkVHlwZUVycm9yJDUgPSBUeXBlRXJyb3I7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhQ2FsbGFibGUkNihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMShPKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyAkVHlwZUVycm9yJDUoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbnZhciBhcnJheVJlZHVjZSA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbnZhciBjbGFzc29mJDIgPSBjbGFzc29mUmF3JDE7XG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkaztcblxudmFyIGVuZ2luZUlzTm9kZSA9IGNsYXNzb2YkMihnbG9iYWwkOS5wcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbnZhciAkJDcgPSBfZXhwb3J0O1xudmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBhcnJheU1ldGhvZElzU3RyaWN0JDI7XG52YXIgQ0hST01FX1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG52YXIgSVNfTk9ERSQzID0gZW5naW5lSXNOb2RlO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3JlZHVjZScpO1xuLy8gQ2hyb21lIDgwLTgyIGhhcyBhIGNyaXRpY2FsIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA0OTk4MlxudmFyIENIUk9NRV9CVUcgPSAhSVNfTk9ERSQzICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MztcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4kJDcoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EIHx8IENIUk9NRV9CVUcgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgbGVuZ3RoLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBnbG9iYWwkOCA9IGdsb2JhbCRrO1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGw7XG52YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciB0b1N0cmluZyA9IHRvU3RyaW5nJDM7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDI7XG5cbnZhciBOYXRpdmVTeW1ib2wgPSBnbG9iYWwkOC5TeW1ib2w7XG52YXIgU3ltYm9sUHJvdG90eXBlID0gTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG5cbmlmIChERVNDUklQVE9SUyQxICYmIGlzQ2FsbGFibGUkNShOYXRpdmVTeW1ib2wpICYmICghKCdkZXNjcmlwdGlvbicgaW4gU3ltYm9sUHJvdG90eXBlKSB8fFxuICAvLyBTYWZhcmkgMTIgYnVnXG4gIE5hdGl2ZVN5bWJvbCgpLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWRcbikpIHtcbiAgdmFyIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSA9IHt9O1xuICAvLyB3cmFwIFN5bWJvbCBjb25zdHJ1Y3RvciBmb3IgY29ycmVjdCB3b3JrIHdpdGggdW5kZWZpbmVkIGRlc2NyaXB0aW9uXG4gIHZhciBTeW1ib2xXcmFwcGVyID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gaXNQcm90b3R5cGVPZiQzKFN5bWJvbFByb3RvdHlwZSwgdGhpcylcbiAgICAgID8gbmV3IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbilcbiAgICAgIC8vIGluIEVkZ2UgMTMsIFN0cmluZyhTeW1ib2wodW5kZWZpbmVkKSkgPT09ICdTeW1ib2wodW5kZWZpbmVkKSdcbiAgICAgIDogZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IE5hdGl2ZVN5bWJvbCgpIDogTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoZGVzY3JpcHRpb24gPT09ICcnKSBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmVbcmVzdWx0XSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFN5bWJvbFdyYXBwZXIsIE5hdGl2ZVN5bWJvbCk7XG4gIFN5bWJvbFdyYXBwZXIucHJvdG90eXBlID0gU3ltYm9sUHJvdG90eXBlO1xuICBTeW1ib2xQcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW1ib2xXcmFwcGVyO1xuXG4gIHZhciBOQVRJVkVfU1lNQk9MID0gU3RyaW5nKE5hdGl2ZVN5bWJvbCgndGVzdCcpKSA9PSAnU3ltYm9sKHRlc3QpJztcbiAgdmFyIHN5bWJvbFRvU3RyaW5nID0gdW5jdXJyeVRoaXMkMyhTeW1ib2xQcm90b3R5cGUudG9TdHJpbmcpO1xuICB2YXIgc3ltYm9sVmFsdWVPZiA9IHVuY3VycnlUaGlzJDMoU3ltYm9sUHJvdG90eXBlLnZhbHVlT2YpO1xuICB2YXIgcmVnZXhwID0gL15TeW1ib2xcXCgoLiopXFwpW14pXSskLztcbiAgdmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcyQzKCcnLnJlcGxhY2UpO1xuICB2YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyQzKCcnLnNsaWNlKTtcblxuICBkZWZpbmVQcm9wZXJ0eShTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xWYWx1ZU9mKHRoaXMpO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nKHN5bWJvbCk7XG4gICAgICBpZiAoaGFzT3duJDIoRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IE5BVElWRV9TWU1CT0wgPyBzdHJpbmdTbGljZShzdHJpbmcsIDcsIC0xKSA6IHJlcGxhY2Uoc3RyaW5nLCByZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gICQkNih7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgU3ltYm9sOiBTeW1ib2xXcmFwcGVyXG4gIH0pO1xufVxuXG5jb25zdCBXYXJuaW5nSWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeHMoXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgd2lkdGg6IFwiMThcIixcbiAgICBoZWlnaHQ6IFwiMThcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk00Ljk1MjE1IDE2LjM1MzZMMTAuMjE1MiA1Ljg1NjU3QzEwLjk1MzEgNC4zODQ4MSAxMy4wNTM4IDQuMzg1MTkgMTMuNzkxMiA1Ljg1NzIzTDE5LjA0OTQgMTYuMzU0M0MxOS43MTU2IDE3LjY4NDEgMTguNzQ4NiAxOS4yNSAxNy4yNjEyIDE5LjI1SDYuNzQwMDFDNS4yNTIyOCAxOS4yNSA0LjI4NTM1IDE3LjY4MzUgNC45NTIxNSAxNi4zNTM2WlwiLFxuICAgICAgc3Ryb2tlOiBcIiNFNkI3M0VcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEyIDEwVjEyXCIsXG4gICAgICBzdHJva2U6IFwiI0U2QjczRVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEyLjUgMTZDMTIuNSAxNi4yNzYxIDEyLjI3NjEgMTYuNSAxMiAxNi41QzExLjcyMzkgMTYuNSAxMS41IDE2LjI3NjEgMTEuNSAxNkMxMS41IDE1LjcyMzkgMTEuNzIzOSAxNS41IDEyIDE1LjVDMTIuMjc2MSAxNS41IDEyLjUgMTUuNzIzOSAxMi41IDE2WlwiLFxuICAgICAgc3Ryb2tlOiBcIiNFNkI3M0VcIlxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBXYWxsZXRPcHRpb25zID0gKHtcbiAgc2VsZWN0b3IsXG4gIGhhbmRsZVdhbGxldENsaWNrXG59KSA9PiB7XG4gIGNvbnN0IFttb2R1bGVzLCBzZXRNb2R1bGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3JlY2VudE1vZHVsZXMsIHNldFJlY2VudE1vZHVsZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbbW9yZU1vZHVsZXMsIHNldE1vcmVNb2R1bGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2FjdGl2ZVdhbGxldElkLCBzZXRBY3RpdmVXYWxsZXRJZF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzZWxlY3Rvci5zdG9yZS5vYnNlcnZhYmxlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHNlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgc2V0QWN0aXZlV2FsbGV0SWQoc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxsZXRzID0gc3RhdGUubW9kdWxlcy5maWx0ZXIobW9kdWxlID0+ICEobW9kdWxlLnR5cGUgPT09IFwiaW5zdGFudC1saW5rXCIgJiYgc2VsZWN0ZWRXYWxsZXRJZCAhPT0gbW9kdWxlLmlkKSk7XG4gICAgICBpZiAoc2VsZWN0b3Iub3B0aW9ucy5vcHRpbWl6ZVdhbGxldE9yZGVyKSB7XG4gICAgICAgIHN0YXRlLm1vZHVsZXMuc29ydCgoY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICAgIGlmIChjdXJyZW50Lm1ldGFkYXRhLmRlcHJlY2F0ZWQgPT09IG5leHQubWV0YWRhdGEuZGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdXJyZW50Lm1ldGFkYXRhLmRlcHJlY2F0ZWQgPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5tb2R1bGVzLnNvcnQoKGN1cnJlbnQsIG5leHQpID0+IHtcbiAgICAgICAgICBpZiAobmV4dC5tZXRhZGF0YS5hdmFpbGFibGUgPT09IGN1cnJlbnQubWV0YWRhdGEuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5leHQubWV0YWRhdGEuYXZhaWxhYmxlID8gMSA6IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbW9yZVdhbGxldHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVjZW50bHlTaWduZWRJbldhbGxldHMgPSBbXTtcbiAgICAgICAgd2FsbGV0cy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yLnN0b3JlLmdldFN0YXRlKCkucmVjZW50bHlTaWduZWRJbldhbGxldHMuaW5jbHVkZXMobW9kdWxlLmlkKSkge1xuICAgICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHMucHVzaChtb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3JlV2FsbGV0cy5wdXNoKG1vZHVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0UmVjZW50TW9kdWxlcyhyZWNlbnRseVNpZ25lZEluV2FsbGV0cyk7XG4gICAgICAgIHNldE1vcmVNb2R1bGVzKG1vcmVXYWxsZXRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rvci5vcHRpb25zLnJhbmRvbWl6ZVdhbGxldE9yZGVyKSB7XG4gICAgICAgIHNldE1vZHVsZXMod2FsbGV0cy5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1vZHVsZXMod2FsbGV0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBmdW5jdGlvbiByZW5kZXJPcHRpb25zTGlzdChtb2R1bGVzVG9SZW5kZXIpIHtcbiAgICByZXR1cm4gbW9kdWxlc1RvUmVuZGVyLnJlZHVjZSgocmVzdWx0LCBtb2R1bGUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgaWNvblVybCxcbiAgICAgICAgZGVwcmVjYXRlZFxuICAgICAgfSA9IG1vZHVsZS5tZXRhZGF0YTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gbW9kdWxlLmlkID09PSBzZWxlY3RlZFdhbGxldElkO1xuICAgICAgcmVzdWx0LnB1c2goanN4cyhcImxpXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgY2xhc3NOYW1lOiBgc2luZ2xlLXdhbGxldCAke2FjdGl2ZVdhbGxldElkID09PSBtb2R1bGUuaWQgPyBcInNlbGVjdGVkLXdhbGxldFwiIDogXCJcIn0gJHtzZWxlY3RlZCA/IFwiY29ubmVjdGVkLXdhbGxldFwiIDogXCJcIn0gJHtkZXByZWNhdGVkID8gXCJkZXByZWNhdGVkLXdhbGxldFwiIDogXCJcIn0gc2lkZWJhciAke21vZHVsZS5pZH1gLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKG1vZHVsZS5pZCA9PT0gbW9kdWxlc1RvUmVuZGVyW2luZGV4XS5pZCkge1xuICAgICAgICAgICAgc2V0QWN0aXZlV2FsbGV0SWQobW9kdWxlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVdhbGxldENsaWNrKG1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImljb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICBzcmM6IGljb25VcmwsXG4gICAgICAgICAgICBhbHQ6IG5hbWVcbiAgICAgICAgICB9KVxuICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwidGl0bGVcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuYW1lXG4gICAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiZGVzY3JpcHRpb25cIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBkZXNjcmlwdGlvblxuICAgICAgICAgIH0pKV1cbiAgICAgICAgfSkpLCBkZXByZWNhdGVkICYmIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwid2FybmluZy10cmlhbmdsZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFdhcm5pbmdJY29uLCB7fSlcbiAgICAgICAgfSkpXVxuICAgICAgfSksIG1vZHVsZS5pZCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IHNlbGVjdG9yLm9wdGlvbnMub3B0aW1pemVXYWxsZXRPcmRlciAmJiBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpLnJlY2VudGx5U2lnbmVkSW5XYWxsZXRzLmxlbmd0aCA+IDAgPyBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC1vcHRpb25zLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uLWhlYWRlclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJSZWNlbnRcIlxuICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwib3B0aW9ucy1saXN0IG1vcmUtb3B0aW9ucy1saXN0LWNvbnRlbnRcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHJlbmRlck9wdGlvbnNMaXN0KHJlY2VudE1vZHVsZXMpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdC1zZWN0aW9uLWhlYWRlclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJNb3JlXCJcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm9wdGlvbnMtbGlzdCBtb3JlLW9wdGlvbnMtbGlzdC1jb250ZW50XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiByZW5kZXJPcHRpb25zTGlzdChtb3JlTW9kdWxlcylcbiAgICAgICAgfSkpXVxuICAgICAgfSkpXVxuICAgIH0pKSA6IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJ3YWxsZXQtb3B0aW9ucy13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwib3B0aW9ucy1saXN0XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IHJlbmRlck9wdGlvbnNMaXN0KG1vZHVsZXMpXG4gICAgICB9KSlcbiAgICB9KSlcbiAgfSk7XG59O1xuXG5jb25zdCBDb25uZWN0aW9uRXJyb3JJY29uID0gKCkgPT4ge1xuICByZXR1cm4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIyMVwiLFxuICAgIGhlaWdodDogXCIyMFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDIxIDIwXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCB7XG4gICAgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEwLjUwMDEgMTguMzMzM0MxNS4xMDI1IDE4LjMzMzMgMTguODMzNCAxNC42MDIzIDE4LjgzMzQgOS45OTk5NkMxOC44MzM0IDUuMzk3NTkgMTUuMTAyNSAxLjY2NjYzIDEwLjUwMDEgMS42NjY2M0M1Ljg5NzcxIDEuNjY2NjMgMi4xNjY3NSA1LjM5NzU5IDIuMTY2NzUgOS45OTk5NkMyLjE2Njc1IDE0LjYwMjMgNS44OTc3MSAxOC4zMzMzIDEwLjUwMDEgMTguMzMzM1pcIixcbiAgICAgIHN0cm9rZTogXCIjQ0U1QTZGXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIyXCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTMgNy41TDggMTIuNVwiLFxuICAgICAgc3Ryb2tlOiBcIiNDRTVBNkZcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk04IDcuNUwxMyAxMi41XCIsXG4gICAgICBzdHJva2U6IFwiI0NFNUE2RlwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBDb25uZWN0aW9uU3VjY2Vzc0ljb24gPSAoKSA9PiB7XG4gIHJldHVybiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHdpZHRoOiBcIjIxXCIsXG4gICAgaGVpZ2h0OiBcIjIwXCIsXG4gICAgdmlld0JveDogXCIwIDAgMjEgMjBcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTguODMzMyA5LjIzMzNWOS45OTk5N0MxOC44MzIzIDExLjc5NyAxOC4yNTA0IDEzLjU0NTUgMTcuMTc0NCAxNC45ODQ4QzE2LjA5ODQgMTYuNDI0MSAxNC41ODYgMTcuNDc3IDEyLjg2MjggMTcuOTg2NkMxMS4xMzk1IDE4LjQ5NjEgOS4yOTc2OCAxOC40MzQ5IDcuNjEyMDIgMTcuODEyMUM1LjkyNjM2IDE3LjE4OTQgNC40ODcxNyAxNi4wMzg0IDMuNTA5MDkgMTQuNTMwOUMyLjUzMTAxIDEzLjAyMzMgMi4wNjY0NSAxMS4yNCAyLjE4NDY5IDkuNDQ2OUMyLjMwMjkzIDcuNjUzNzcgMi45OTc2MyA1Ljk0NjkxIDQuMTY1MTkgNC41ODA4NkM1LjMzMjc1IDMuMjE0ODIgNi45MTA2MSAyLjI2Mjc5IDguNjYzNDUgMS44NjY3NkMxMC40MTYzIDEuNDcwNzMgMTIuMjUwMiAxLjY1MTkyIDEzLjg5MTYgMi4zODMzXCIsXG4gICAgICBzdHJva2U6IFwiIzRGRDk4RlwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE4LjgzMzMgMy4zMzMzN0wxMC41IDExLjY3NUw4IDkuMTc1MDRcIixcbiAgICAgIHN0cm9rZTogXCIjNEZEOThGXCIsXG4gICAgICBzdHJva2VXaWR0aDogXCIyXCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IENvbm5lY3Rpb25SZXN1bHQgPSAoe1xuICBtb2R1bGUsXG4gIG1lc3NhZ2UsXG4gIGVycixcbiAgb25SZXRyeVxufSkgPT4ge1xuICByZXR1cm4ganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW9uIGNvbm5lY3RpbmctZGV0YWlsc1wiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogZXJyID8ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJlcnJvci13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJlcnJvclwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KENvbm5lY3Rpb25FcnJvckljb24sIHt9KSwgdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmNvbm5lY3Rpb25GYWlsZWRcIildXG4gICAgICB9KSksIGpzeChcInBcIiwge1xuICAgICAgICBjaGlsZHJlbjogbWVzc2FnZVxuICAgICAgfSksIChtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEuYXZhaWxhYmxlKSAmJiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG9uQ2xpY2s6IG9uUmV0cnlcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5yZXRyeVwiKVxuICAgICAgfSkpXVxuICAgIH0pKSA6IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwic3VjY2Vzc1wiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3goQ29ubmVjdGlvblN1Y2Nlc3NJY29uLCB7fSksIHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5jb25uZWN0aW9uU3VjY2Vzc2Z1bFwiKV1cbiAgICB9KSlcbiAgfSkpO1xufTtcblxuY29uc3QgQWxlcnRNZXNzYWdlID0gKHtcbiAgbWVzc2FnZSxcbiAgbW9kdWxlLFxuICBvbkJhY2ssXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICByZXR1cm4ganN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbanN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICB0aXRsZTogXCJcIixcbiAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgfSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogXCJhbGVydC1tZXNzYWdlIGNvbm5lY3Rpbmctd3JhcHBlciBjb25uZWN0aW5nLXdyYXBwZXItZXJyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNvbnRlbnRcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaWNvblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiaW1nXCIsIHtcbiAgICAgICAgICAgIHNyYzogbW9kdWxlID09PSBudWxsIHx8IG1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kdWxlLm1ldGFkYXRhLmljb25VcmwsXG4gICAgICAgICAgICBhbHQ6IG1vZHVsZSA9PT0gbnVsbCB8fCBtb2R1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZHVsZS5tZXRhZGF0YS5uYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpLCBqc3goXCJoM1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiY29ubmVjdGluZy1uYW1lXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEubmFtZVxuICAgICAgICB9KSksIGpzeChDb25uZWN0aW9uUmVzdWx0LCB7XG4gICAgICAgICAgbW9kdWxlOiBtb2R1bGUsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBlcnI6IG1lc3NhZ2UgIT09IG51bGwsXG4gICAgICAgICAgb25SZXRyeTogKCkgPT4ge1xuICAgICAgICAgICAgb25CYWNrKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSldXG4gICAgICB9KSlcbiAgICB9KSldXG4gIH0pO1xufTtcblxudmFyIGdldEJ1aWx0SW4kMyA9IGdldEJ1aWx0SW4kODtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgREVTQ1JJUFRPUlMgPSBkZXNjcmlwdG9ycztcblxudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCQ1KCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzJDEgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluJDMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTJDJdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMkMiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuXG52YXIgJFR5cGVFcnJvciQ0ID0gVHlwZUVycm9yO1xuXG52YXIgYW5JbnN0YW5jZSQxID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YkMihQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyAkVHlwZUVycm9yJDQoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkMiA9IGZhaWxzJGg7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRsO1xudmFyIGNsYXNzb2YkMSA9IGNsYXNzb2YkNTtcbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzJDIoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiQxKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZSQxKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxudmFyIGlzQ29uc3RydWN0b3IkMSA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQxO1xudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ1O1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDModHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGM7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQ0KCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdCQ2KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0JDYoQylbU1BFQ0lFUyQxXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQxID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCQ4ID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJDguYmluZChhcHBseSQxKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkOC5hcHBseShhcHBseSQxLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ5O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ0ID0gdW5jdXJyeVRoaXMkMSh1bmN1cnJ5VGhpcyQxLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDEgPSB1bmN1cnJ5VGhpcyhbXS5zbGljZSk7XG5cbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyAkVHlwZUVycm9yJDIoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0lvcyA9IC8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCQyKTtcblxudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJGs7XG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRsO1xudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBmYWlscyQxID0gZmFpbHMkaDtcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlJDE7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcbnZhciBJU19JT1MkMSA9IGVuZ2luZUlzSW9zO1xudmFyIElTX05PREUkMiA9IGVuZ2luZUlzTm9kZTtcblxudmFyIHNldCA9IGdsb2JhbCQ3LnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbCQ3LmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MkMiA9IGdsb2JhbCQ3LnByb2Nlc3M7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwkNy5EaXNwYXRjaDtcbnZhciBGdW5jdGlvbiQxID0gZ2xvYmFsJDcuRnVuY3Rpb247XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwkNy5NZXNzYWdlQ2hhbm5lbDtcbnZhciBTdHJpbmckMSA9IGdsb2JhbCQ3LlN0cmluZztcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSQxID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgbG9jYXRpb24sIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG50cnkge1xuICAvLyBEZW5vIHRocm93cyBhIFJlZmVyZW5jZUVycm9yIG9uIGBsb2NhdGlvbmAgYWNjZXNzIHdpdGhvdXQgYC0tbG9jYXRpb25gIGZsYWdcbiAgbG9jYXRpb24gPSBnbG9iYWwkNy5sb2NhdGlvbjtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaGFzT3duJDEocXVldWUkMSwgaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWUkMVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBydW5uZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBydW4oaWQpO1xuICB9O1xufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwkNy5wb3N0TWVzc2FnZShTdHJpbmckMShpZCksIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQgfHwgIWNsZWFyKSB7XG4gIHNldCA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShoYW5kbGVyKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQzKGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcXVldWUkMVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFJDIpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MkMSkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZCQzKHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwkNy5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZSQzKGdsb2JhbCQ3LnBvc3RNZXNzYWdlKSAmJlxuICAgICFnbG9iYWwkNy5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMkMShwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsJDcuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciB0YXNrJDEgPSB7XG4gIHNldDogc2V0LFxuICBjbGVhcjogY2xlYXJcbn07XG5cbnZhciB1c2VyQWdlbnQkMSA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRrO1xuXG52YXIgZW5naW5lSXNJb3NQZWJibGUgPSAvaXBhZHxpcGhvbmV8aXBvZC9pLnRlc3QodXNlckFnZW50JDEpICYmIGdsb2JhbCQ2LlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNXZWJvc1dlYmtpdCA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50KTtcblxudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJGs7XG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBtYWNyb3Rhc2sgPSB0YXNrJDEuc2V0O1xudmFyIElTX0lPUyA9IGVuZ2luZUlzSW9zO1xudmFyIElTX0lPU19QRUJCTEUgPSBlbmdpbmVJc0lvc1BlYmJsZTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSBlbmdpbmVJc1dlYm9zV2Via2l0O1xudmFyIElTX05PREUkMSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwkNS5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbCQ1LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQkMiA9IGdsb2JhbCQ1LmRvY3VtZW50O1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbCQ1LnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsJDUuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsJDUsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnkkMSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSQxICYmIChwYXJlbnQgPSBwcm9jZXNzJDEuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5JDEoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICAvLyBhbHNvIGV4Y2VwdCBXZWJPUyBXZWJraXQgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg5OFxuICBpZiAoIUlTX0lPUyAmJiAhSVNfTk9ERSQxICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCQyKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQkMi5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKCFJU19JT1NfUEVCQkxFICYmIFByb21pc2UkMSAmJiBQcm9taXNlJDEucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgLy8gd29ya2Fyb3VuZCBvZiBXZWJLaXQgfiBpT1MgU2FmYXJpIDEwLjEgYnVnXG4gICAgcHJvbWlzZS5jb25zdHJ1Y3RvciA9IFByb21pc2UkMTtcbiAgICB0aGVuID0gYmluZCQyKHByb21pc2UudGhlbiwgcHJvbWlzZSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBOb2RlLmpzIHdpdGhvdXQgcHJvbWlzZXNcbiAgfSBlbHNlIGlmIChJU19OT0RFJDEpIHtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnZVxuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuYmluZChnbG9iYWwpXG4gICAgbWFjcm90YXNrID0gYmluZCQyKG1hY3JvdGFzaywgZ2xvYmFsJDUpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFjcm90YXNrKGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtaWNyb3Rhc2skMSA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSQxKCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuXG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkaztcblxudmFyIGhvc3RSZXBvcnRFcnJvcnMkMSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsJDQuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuXG52YXIgcGVyZm9ybSQzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cbnZhciBRdWV1ZSQxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuUXVldWUkMS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZW50cnkgPSB7IGl0ZW06IGl0ZW0sIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAodGhpcy50YWlsID09PSBlbnRyeSkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlID0gUXVldWUkMTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJGs7XG5cbnZhciBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkMy5Qcm9taXNlO1xuXG52YXIgZW5naW5lSXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgRGVubyAhPSAnb2JqZWN0JztcblxudmFyIGdsb2JhbCQyID0gZ2xvYmFsJGs7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRsO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgSVNfQlJPV1NFUiA9IGVuZ2luZUlzQnJvd3NlcjtcbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xuXG5OYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMy5wcm90b3R5cGU7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCQzKCdzcGVjaWVzJyk7XG52YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSA9IGlzQ2FsbGFibGUkMihnbG9iYWwkMi5Qcm9taXNlUmVqZWN0aW9uRXZlbnQpO1xuXG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IG5ldyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyhmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IEZha2VQcm9taXNlO1xuICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIGlmICghU1VCQ0xBU1NJTkcpIHJldHVybiB0cnVlO1xuICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMTtcbn0pO1xuXG52YXIgcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0ge1xuICBDT05TVFJVQ1RPUjogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSxcbiAgUkVKRUNUSU9OX0VWRU5UOiBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMiA9IHt9O1xuXG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkOTtcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFDYWxsYWJsZSQ0KHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZSQ0KHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubmV3UHJvbWlzZUNhcGFiaWxpdHkkMi5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkaztcbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkOTtcbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGw7XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JDg7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBzcGVjaWVzQ29uc3RydWN0b3IkMTtcbnZhciB0YXNrID0gdGFzayQxLnNldDtcbnZhciBtaWNyb3Rhc2sgPSBtaWNyb3Rhc2skMTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gaG9zdFJlcG9ydEVycm9ycyQxO1xudmFyIHBlcmZvcm0kMiA9IHBlcmZvcm0kMztcbnZhciBRdWV1ZSA9IHF1ZXVlO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMjtcbnZhciBQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDEuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkMS5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJDEucHJvY2VzcztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDEgJiYgZG9jdW1lbnQkMS5jcmVhdGVFdmVudCAmJiBnbG9iYWwkMS5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcblxudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QkMShpdCkgJiYgaXNDYWxsYWJsZSQxKHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQxKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwkNyh0aGVuLCByZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFjdGlvbnMgPSBzdGF0ZS5yZWFjdGlvbnM7XG4gICAgdmFyIHJlYWN0aW9uO1xuICAgIHdoaWxlIChyZWFjdGlvbiA9IHJlYWN0aW9ucy5nZXQoKSkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsJDEuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWwkMVsnb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJDcodGFzaywgZ2xvYmFsJDEsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybSQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkNyh0YXNrLCBnbG9iYWwkMSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kJDEgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUuZmFjYWRlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDEoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsJDcodGhlbiwgdmFsdWUsXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkMyhleGVjdXRvcik7XG4gICAgY2FsbCQ3KEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogbmV3IFF1ZXVlKCksXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYFByb21pc2UucHJvdG90eXBlLnRoZW5gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgSW50ZXJuYWwucHJvdG90eXBlID0gZGVmaW5lQnVpbHRJbiQyKFByb21pc2VQcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgcmVhY3Rpb24ub2sgPSBpc0NhbGxhYmxlJDEob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgIHJlYWN0aW9uLmZhaWwgPSBpc0NhbGxhYmxlJDEob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDtcbiAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZCQxKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlJDEoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4kMihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjYWxsJDcobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIHNldFByb3RvdHlwZU9mKE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbiQkNSh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGc7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDIoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDEuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SJDJdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiA9IGNsYXNzb2YkNTtcbnZhciBnZXRNZXRob2QkMSA9IGdldE1ldGhvZCQzO1xudmFyIEl0ZXJhdG9ycyA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRnO1xuXG52YXIgSVRFUkFUT1IkMSA9IHdlbGxLbm93blN5bWJvbCQxKCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kJDEoaXQsIElURVJBVE9SJDEpXG4gICAgfHwgZ2V0TWV0aG9kJDEoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxudmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMiA9IGFDYWxsYWJsZSQ5O1xudmFyIGFuT2JqZWN0JDUgPSBhbk9iamVjdCRjO1xudmFyIHRyeVRvU3RyaW5nJDEgPSB0cnlUb1N0cmluZyQ1O1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQyO1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG52YXIgZ2V0SXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kJDEoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcbiAgaWYgKGFDYWxsYWJsZSQyKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0JDUoY2FsbCQ2KGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuICB0aHJvdyAkVHlwZUVycm9yJDEodHJ5VG9TdHJpbmckMShhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xufTtcblxudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkYztcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkMztcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsJDUoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xuICB9XG4gIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuICBhbk9iamVjdCQ0KGlubmVyUmVzdWx0KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkYztcbnZhciB0cnlUb1N0cmluZyA9IHRyeVRvU3RyaW5nJDU7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDE7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQ1O1xudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IgPSBnZXRJdGVyYXRvciQxO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcbnZhciBpdGVyYXRvckNsb3NlID0gaXRlcmF0b3JDbG9zZSQxO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxudmFyIGl0ZXJhdGUkMiA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkMyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAoIWl0ZXJGbikgdGhyb3cgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoaXRlcmFibGUpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBjYWxsRm4oaXRlcmFibGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDEoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkNChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDEoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkZztcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWFycmF5LWZyb20sIG5vLXRocm93LWxpdGVyYWwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMSA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMS5hbGwoaXRlcmFibGUpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciAkJDQgPSBfZXhwb3J0O1xudmFyIGNhbGwkMyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ5O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0kMSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFsbFxuJCQ0KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSB9LCB7XG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMi5mKEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUkMShDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlJDEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIGNhbGwkMygkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRsO1xudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kNjtcblxudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hcbiQkMyh7IHRhcmdldDogJ1Byb21pc2UnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyLCByZWFsOiB0cnVlIH0sIHtcbiAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbn0pO1xuXG4vLyBtYWtlcyBzdXJlIHRoYXQgbmF0aXZlIHByb21pc2UtYmFzZWQgQVBJcyBgUHJvbWlzZSNjYXRjaGAgcHJvcGVybHkgd29ya3Mgd2l0aCBwYXRjaGVkIGBQcm9taXNlI3RoZW5gXG5pZiAoaXNDYWxsYWJsZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluJDEoJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2NhdGNoJ107XG4gIGlmIChOYXRpdmVQcm9taXNlUHJvdG90eXBlWydjYXRjaCddICE9PSBtZXRob2QpIHtcbiAgICBkZWZpbmVCdWlsdEluJDEoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgJ2NhdGNoJywgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG52YXIgJCQyID0gX2V4cG9ydDtcbnZhciBjYWxsJDIgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlID0gYUNhbGxhYmxlJDk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgcGVyZm9ybSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OID0gcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb247XG5cbi8vIGBQcm9taXNlLnJhY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJhY2VcbiQkMih7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEuZihDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZShDLnJlc29sdmUpO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgY2FsbCQyKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyICQkMSA9IF9leHBvcnQ7XG52YXIgY2FsbCQxID0gZnVuY3Rpb25DYWxsO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQxID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xuXG4vLyBgUHJvbWlzZS5yZWplY3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlamVjdFxuJCQxKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSB9LCB7XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYodGhpcyk7XG4gICAgY2FsbCQxKGNhcGFiaWxpdHkucmVqZWN0LCB1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGM7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCQ4O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQyKEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG52YXIgJCA9IF9leHBvcnQ7XG52YXIgZ2V0QnVpbHRJbiA9IGdldEJ1aWx0SW4kODtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHByb21pc2VSZXNvbHZlJDE7XG5cbmdldEJ1aWx0SW4oJ1Byb21pc2UnKTtcblxuLy8gYFByb21pc2UucmVzb2x2ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmVzb2x2ZVxuJCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxuY29uc3QgSGFyZHdhcmVXYWxsZXRBY2NvdW50c0Zvcm0gPSAoe1xuICBhY2NvdW50cyxcbiAgb25TZWxlY3RlZENoYW5nZWQsXG4gIG9uU3VibWl0LFxuICBvbkNoYW5nZVJvdXRlXG59KSA9PiB7XG4gIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogXCJjaG9vc2UtbGVkZ2VyLWFjY291bnQtZm9ybS13cmFwcGVyXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4cyhcInBcIiwge1xuICAgICAgY2hpbGRyZW46IFtcIldlIGZvdW5kIFwiLCBhY2NvdW50cy5sZW5ndGgsIFwiIGFjY291bnRzIG9uIHlvdXIgZGV2aWNlLiBTZWxlY3QgdGhlIGFjY291bnQocykgeW91IHdpc2ggdG8gY29ubmVjdC5cIl1cbiAgICB9KSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImJ1dHRvbi13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjoganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2VSb3V0ZShcIlNwZWNpZnlIRFBhdGhcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFwiSEQuLi4vMFwiXG4gICAgICB9KSlcbiAgICB9KSksIGpzeChcImZvcm1cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiZm9ybVwiLFxuICAgICAgb25TdWJtaXQ6IGUgPT4ge1xuICAgICAgICBvblN1Ym1pdChhY2NvdW50cywgZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibndzLWZvcm0tY29udHJvbFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogYWNjb3VudHMubWFwKChhY2NvdW50LCBpbmRleCkgPT4ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJhY2NvdW50XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2U6IGUgPT4ge1xuICAgICAgICAgICAgICAgIG9uU2VsZWN0ZWRDaGFuZ2VkKGluZGV4LCBlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2hlY2tlZDogYWNjb3VudC5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICBpZDogYWNjb3VudC5hY2NvdW50SWQsXG4gICAgICAgICAgICAgIG5hbWU6IGFjY291bnQuYWNjb3VudElkLFxuICAgICAgICAgICAgICB2YWx1ZTogYWNjb3VudC5hY2NvdW50SWRcbiAgICAgICAgICAgIH0pLCBqc3hzKFwibGFiZWxcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGh0bWxGb3I6IGFjY291bnQuYWNjb3VudElkXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXCIgXCIsIGFjY291bnQuYWNjb3VudElkXVxuICAgICAgICAgICAgfSkpLCBqc3goXCJiclwiLCB7fSldXG4gICAgICAgICAgfSksIGluZGV4KSlcbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFjdGlvbi1idXR0b25zXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgICB0eXBlOiBcInN1Ym1pdFwiLFxuICAgICAgICAgICAgZGlzYWJsZWQ6ICFhY2NvdW50cy5zb21lKHggPT4geC5zZWxlY3RlZClcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJDb25uZWN0XCJcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpXVxuICAgICAgfSlcbiAgICB9KSldXG4gIH0pKTtcbn07XG5cbnZhciBpbWcgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkNBWUFBQURFNllWakFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFSM1NVUkJWSGdCcFZaOWFKVlZHSCtlNTV6MzNiaTd6WTloTXoreU1BZU5vRUlxNkE5WlJLUVdFc1FORklJcHNmNVk5RStHc0Q5aUJFRURNVWtEYTZTaFJLS1pZSVdpUmthS2FVR1VHQ0tPVEdNRjg0UE5POTk3NzN2T2VmcTk3MjB5SzVaekQvZHdQdC9uZDM3UDE3bEVrNVFudXo5cm9Va0tUN1Q1Yk5lK1FqVE5MQ0h2MjRoMVhnaCtPbXR3UVlQSDJqVVh3bG5XOU5Sb29xZVBmTFM2TW1tUTU5Y2RlRUdKbGtKWkE1TUdWZWNvQXdnaEJZWlRWWTlmdHVhRFN5OHg4dzlmYkZsOTVKWkFYdXc5ZG1lbGt2UkF5WHhTN3dNRnJ5RzRiSXlXWmlxelBnTWhhRmZHZm4zTlkzQVpHOXNQZi9EeThIaWRadnhrWmMvaDFwcW5QbEtleTZ5c3BNcVVkOWpWQUVZWTZSQ0dEUVR3akdEd0dUZ0FsYndSaWpWMUM5dmFuejU3N3RUKzZyK1lyT3o1cmxYRnJRL3FaK0ZiRHhDZlhTNW9PZ3hsbjR2NDczZjNyYmd3ZG43Rks1L01DYUgyZUFnNlg4ZzNLMmlCTVRpQmtOSlZLYm9kK3plOW1nUFpzWS9VYWljWXpDRTFIZ3BaYzU1OG9sQ1RqVHZXTHh2OXAxbjNiVjQ1aU83VDV6cTNUVTlqOXhUT0x3UTVEOXQ0OGFFWXJ0R2oyUC8yQnBOUzc4blpKb1JkbERzWWQ4dnBoejI3M2xxeWhXNVJubG56M2hPZTZTRXdnaHZ4UFVNVFZmWWUycnB1VU9xT2taZUl4ZFNic1NKOGVUSUFtWHk1dGZ0ck1Qa3ppMEM0QjJaRE5IcCtJTnZMUVVSa2hZaUo2Z0RHa28zNzZEYkVKOGszbWNuWUJTZVNNMnB0TC9YR3N1ck5ueGZuRElRTndDS0FETzE4NDVFZjZUYmswTTUxZzRqb01nbmNEeUJta3J0c05FTVFvdmNEeEdZc0dMMnlETkFVeFB2MFZ5U3M0eXhoZmVZYmFiSmcwQXdnK0lMeWxFQjZuS01wU09wMFdDUjErUVN1RDRFTGxqTkRFZnlScmRYUENVMUJURWdEN3B5T3pWbUMyaUJtMEtnWUFNQ0VlWG92b0NsSWpkS2lWZFEzRlliem1hdHhXUnFNUGNOc0RIeWZOV3NrV2s1VGtKaE5Fd1Z5eEE2aExMNWNsTEpzVzd2b0Z4YTZMaVI1Q0NPZVd6bzNYRnhLdHlFZHkzdG5wN1ZhaEFvRHA2UEVWR3ZKeWUwOWwzUDdLOWs5V1FpalhCdjRCNldHKzBwdkQweWJGRUJIWjZPUGgrL09HYUJzSXZOUkFHcC9aSHYxakplb24rb21zekJrRnNyM0Zoc0xCN3JldjNKTFFLVlN5ZmptYVcyQkpTYXZEbHFSN2M1VnJSKzRBYkx0dGJrWE1laEg3Z2pBOGdaaUQvdHErT3IvQUJaM2RVVy9KNjJMY1BVR2NyVzhwS1NWRkFnNmNIejNPMGwyNXFaSGEvWEd3V1BnOWFBd3d6ZFpBYURYKzd0Yk5zTVlmNSticGFVUzBkRFFFRjhydHNVeENiSTVlNUtSekdoQk1pcU54bGxLanU3ZDhOT1lYanNlUkJ5dFFuZ2NWREwzd0Q5SCs3dmYzWVM3bW5uenFyWnB3U3hyd2toMDRjcE01TlRNeUpkSGJJZ2FFU3l4SjZ0WjVjRGJ3M3FkMHRxVkNwMjVTZS80eVlkcjUvem0vZWhqd3ZweFpIZ04wV2x1YjAvWXQ3YXdkeWtxUllGSHk2TlVRVnJCZDRvNnA2bmdyVkwyQm84a3N1SnFvWHpxOUxuOW02cmo5VTc0YjZXam84T2VQMDgyYVk1TlV4UnNZendEa2VGc1UrTWRVVTNVNFBHMFF0YmFocWhhZERNdUhUeTRmdlMvOUV3SVVwZGV1Vy9aaVNoT2lwRnhVUlJiTmRXRVRGTVJackNGbEVaR2t1UEhkeWNUYWZnTEV4TmlJNllmVXBjQUFBQUFTVVZPUks1Q1lJST1cIjtcblxuY29uc3QgV2FsbGV0Q29ubmVjdGluZyA9ICh7XG4gIHdhbGxldCxcbiAgb25DbG9zZU1vZGFsXG59KSA9PiB7XG4gIHJldHVybiBqc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtqc3goTW9kYWxIZWFkZXIsIHtcbiAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICB9KSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3Rpbmctd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImljb25cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICBzcmM6IHdhbGxldCA9PT0gbnVsbCB8fCB3YWxsZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdhbGxldC5tZXRhZGF0YS5pY29uVXJsLFxuICAgICAgICAgICAgYWx0OiB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQubWV0YWRhdGEubmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwganN4KFwiaDNcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3RpbmctbmFtZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogd2FsbGV0ID09PSBudWxsIHx8IHdhbGxldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2FsbGV0Lm1ldGFkYXRhLm5hbWVcbiAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJjb25uZWN0aW5nLWRldGFpbHNcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic3Bpbm5lclwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICAgIHNyYzogaW1nLFxuICAgICAgICAgICAgICBhbHQ6IFwibG9hZGluZy1pY29uXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSkpLCBqc3hzKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW3RyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5jb25uZWN0aW5nVG9cIiksIFwiIFwiLCB3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQubWV0YWRhdGEubmFtZSwgXCIuLi5cIl1cbiAgICAgICAgICB9KV1cbiAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3RpbmctbWVzc2FnZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKGBtb2RhbC53YWxsZXQuY29ubmVjdGluZ01lc3NhZ2UuJHt3YWxsZXQgPT09IG51bGwgfHwgd2FsbGV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3YWxsZXQudHlwZX1gKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKVxuICAgIH0pKV1cbiAgfSk7XG59O1xuXG5jb25zdCBMZWRnZXJEZXZpY2VJY29uID0gKCkgPT4ge1xuICByZXR1cm4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIzMTdcIixcbiAgICBoZWlnaHQ6IFwiMTU3XCIsXG4gICAgdmlld0JveDogXCIwIDAgMzE3IDE1N1wiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0yNDkuOTkgMTYuMDk5NEMyNzAuMDYzIC0wLjg2NDE1NSAyODkuNzg4IDEuNTg4NzMgMzAxLjQ5NyAxMC43MzY1QzMwNy40MDIgMTUuMzQ5OSAzMTEuMjc4IDIxLjY1NzUgMzEyLjI2NyAyOC4xMjU4QzMxMy4yNDcgMzQuNTQxMiAzMTEuNDEzIDQxLjIyMzMgMzA1LjY5MiA0Ni44MDQ0QzI5Ny4zNjYgNTQuOTI3MyAyODYuMzQzIDU1LjMzNjIgMjczLjAxNSA1MS41MTA5QzI2MS42NTQgNDguMjUgMjQ5LjA1OCA0Mi4wMzc3IDIzNS43MjYgMzUuNDYyN0wyMzUuNzI2IDM1LjQ2MjZMMjM1LjcxNyAzNS40NThDMjMzLjM2NyAzNC4yOTkyIDIzMC45OTUgMzMuMTI5IDIyOC42MDIgMzEuOTYxOEMyMTIuNzQyIDI0LjIyNTMgMTk2LjA2NyAxNi42NTc1IDE3OS44NDIgMTMuODU5NUMxNjMuNTM4IDExLjA0NzkgMTQ3LjU1MiAxMy4wMzEzIDEzMy4yNjYgMjQuNTIyQzEyOC4wMzIgMjguNzMyIDEyMy40NzggMzUuMjA4NiAxMjEuNzE2IDQ0LjgyMDVDMTE5Ljk2MSA1NC4zOTQ3IDEyMC45OTIgNjYuOTc3MSAxMjYuNzAzIDgzLjQzMTFDMTM1LjQzMiAxMDguNTgzIDEzMi44OTkgMTI2LjY3NyAxMjMuNTc1IDEzOC4wNjNDMTE0LjIxNyAxNDkuNDkxIDk3LjU2MTQgMTU0LjczMyA3Ni43ODg3IDE1My4xMjFDNTUuMDA0MyAxNTEuNDMgMjkuMDYyMSAxNDIuMjA2IDMuMjk4NjcgMTI1LjIyN0wwLjg4NzgxNyAxMjcuOTQyQzI3LjI0NzIgMTQ1LjQwNSA1My45MjUxIDE1NC45NTIgNzYuNTEwNSAxNTYuNzA1Qzk3LjkwMjggMTU4LjM2NSAxMTUuOTYgMTUzLjAzNSAxMjYuMzU2IDE0MC4zNDFDMTM2Ljc4NSAxMjcuNjA2IDEzOS4wNDUgMTA4LjAyOSAxMzAuMDk5IDgyLjI1MjRDMTI0LjUyMSA2Ni4xODAxIDEyMy42NDIgNTQuMjQ5MyAxMjUuMjUyIDQ1LjQ2ODdDMTI2Ljg1NCAzNi43MjU4IDEzMC45NCAzMS4wMDYgMTM1LjUxOSAyNy4zMjMyQzE0OC43OTQgMTYuNjQ1OCAxNjMuNjQ5IDE0LjcxNSAxNzkuMjMxIDE3LjQwMjFDMTk0Ljg5MSAyMC4xMDI3IDIxMS4xNDYgMjcuNDQ2MyAyMjcuMDI2IDM1LjE5MjhDMjI5LjM4MSAzNi4zNDE1IDIzMS43MjkgMzcuNTAwMSAyMzQuMDY2IDM4LjY1MzFMMjM0LjA3MyAzOC42NTY4QzI0Ny4zODIgNDUuMjIzIDI2MC4zMjQgNTEuNjA4IDI3Mi4wMjQgNTQuOTY2MkMyODUuODE5IDU4LjkyNTggMjk4LjQ5MyA1OC44NTAxIDMwOC4yMDIgNDkuMzc3NkMzMTQuNzY0IDQyLjk3NTkgMzE2Ljk3NCAzNS4xMjg4IDMxNS44MiAyNy41ODI2QzMxNC42NzUgMjAuMDg5MyAzMTAuMjM3IDEzLjAwMjkgMzAzLjcxIDcuOTAzNjNDMjkwLjU1NSAtMi4zNzM4MiAyNjguOTM4IC00LjYyMDM4IDI0Ny42NyAxMy4zNTM3TDI0OS45OSAxNi4wOTk0WlwiLFxuICAgICAgZmlsbDogXCJ1cmwoI3BhaW50MF9saW5lYXJfM182NzIpXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0yNjAuMjY0IDE3Ljg3NjdMMTc3LjYwNSA4OS40NjQ5TDE1Ny42NzkgNzMuOTY2NEwyMzkuMjMgMy44NTQyM0wyNjAuMjY0IDE3Ljg3NjdaXCIsXG4gICAgICBmaWxsOiBcIiM2QTcwNzVcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTIwNS45MzkgNTQuNDU3N0wxOTkuNzY0IDUwLjI2MzZMMjMzLjMxNiAyMC45MDUzTDIzOS45MDcgMjUuODM5NUwyMDUuOTM5IDU0LjQ1NzdaXCIsXG4gICAgICBmaWxsOiBcIiM0OTRFNTJcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTI2MC4yNjQgMTcuODc1N0wxNzcuNjA1IDg5LjQ2MzlMMTgyLjAzMyA5OC4zMjAyTDI2NC4zMjMgMjYuMzYzTDI2MC4yNjQgMTcuODc1N1pcIixcbiAgICAgIGZpbGw6IFwiIzQ5NEU1MlwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTc3LjIzNiA4OS40NjQ2TDE4MS4yOTUgOTguMzIwOUwxNjUuMDU5IDg1Ljc3NDVMMTcwLjk2MyA4NS4wMzY1TDE3Ny4yMzYgODkuNDY0NlpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTkzLjQ3MDggOTkuNjM4NEw5MS45OTQ4IDExMC4xM0wxNzQuNjUzIDkyLjg5NEwxNjQuNjkgODUuNzc0OUw5My40NzA4IDk5LjYzODRaXCIsXG4gICAgICBmaWxsOiBcIiNEQ0RBREFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTkzLjExNTcgMTA0LjMyM0w5NC4zMTQgMTAwLjEyOUwxNjUuNjEzIDg2LjM0ODNMMTY5LjIwOCA4OS4zNDRMOTMuMTE1NyAxMDQuMzIzWlwiLFxuICAgICAgZmlsbDogXCIjQzFDMUMxXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk05NC4yMDg2IDk5Ljc5NjNMODYuMDkwMyAxMDEuMjcyTDkyLjM2MzUgMTEwLjEyOUw5NC4yMDg2IDk5Ljc5NjNaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTg2LjA5MDMgMTAwLjkwN0w4OS4wMDI3IDc0LjEzMDRMMTc4LjQ1NSA1NS4yNDE2QzE4NC42OTUgNTMuOTk2MiAxOTUuNzY2IDU0Ljc2NzUgMTk3LjE3NyA2My43MDU4QzE5OC4yODQgNzAuNzE3IDE5NS41MDYgNzMuOTk0MyAxOTEuNjI4IDc3LjM1OTJDMTg4LjQ5NSA4MC4wNjcxIDE4MC4xNTIgODIuNDY0NiAxNzguMzQzIDgyLjg5NDRDMTc4LjI5MyA4Mi45MDY0IDE3OC4yNDEgODIuOTE4OCAxNzguMTg2IDgyLjkzMTlDMTc3LjM4IDgzLjEyNDUgMTc2LjAwNyA4My40NTI1IDE3MC42NDQgODQuNTA4OEMxNjkuMDg1IDg0LjgxNTggMTY3LjM4MiA4NS4xNTAxIDE2NS41NTcgODUuNTA3OEwxNjQuOTMzIDg1LjYzQzE0Ni4zMTIgODkuMjc2NCAxMTUuNTI4IDk1LjIyOTcgOTMuOTg0NCA5OS4zODQ5QzkxLjE4MDggOTkuOTI1NyA4OC41MzM3IDEwMC40MzYgODYuMDkwMyAxMDAuOTA3Wk0xODUuMDc2IDc1LjU1NEMxOTAuNzQ4IDczLjM1MzUgMTkzLjk5IDY4LjA3NDUgMTkyLjMxOCA2My43NjMxQzE5MC42NDUgNTkuNDUxNyAxODQuNjkxIDU3Ljc0MDUgMTc5LjAxOSA1OS45NDFDMTczLjM0NyA2Mi4xNDE2IDE3MC4xMDUgNjcuNDIwNiAxNzEuNzc4IDcxLjczMkMxNzMuNDUgNzYuMDQzNCAxNzkuNDA0IDc3Ljc1NDYgMTg1LjA3NiA3NS41NTRaXCIsXG4gICAgICBmaWxsOiBcIiNGNEYxRThcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE5OS43NjQgNTAuMzk5NEwxOTYuNzY4IDQ4LjMwNDNMMjMyLjE5NCAxOC4wNDU0TDIzMy4zMTYgMjEuNjQwM0wxOTkuNzY0IDUwLjM5OTRaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0yMzkuOTY4IDI1Ljk5NDNMMjMyLjU4OCAyMC40NTkyVjE3LjUwNzFMMjQxLjgxMyAyNC41MTgzTDIzOS45NjggMjUuOTk0M1pcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJlbGxpcHNlXCIsIHtcbiAgICAgIGN4OiBcIjE4Mi4wODRcIixcbiAgICAgIGN5OiBcIjY4LjA4MTFcIixcbiAgICAgIHJ4OiBcIjEwLjI0MlwiLFxuICAgICAgcnk6IFwiNy40Njc3MlwiLFxuICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgtMjMuNzk0OSAxODIuMDg0IDY4LjA4MTEpXCIsXG4gICAgICBmaWxsOiBcIiM0OTRFNTJcIlxuICAgIH0pLCBqc3goXCJlbGxpcHNlXCIsIHtcbiAgICAgIGN4OiBcIjE4Mi4wODRcIixcbiAgICAgIGN5OiBcIjY4LjA4MTZcIixcbiAgICAgIHJ4OiBcIjYuNjg0NjJcIixcbiAgICAgIHJ5OiBcIjQuODczOTRcIixcbiAgICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoLTIzLjc5NDkgMTgyLjA4NCA2OC4wODE2KVwiLFxuICAgICAgZmlsbDogXCIjNDk0RTUyXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0yMzguNzI1IDIuOTMwOTRMMjYwLjM2OCAxNy4yNTY0TDI2NC44NjUgMjYuNDU1NkwxODEuNjE1IDk5LjAzNDFMMTc1LjE2IDk0LjMxMUw5Mi4wMDI4IDExMC45NDdMODUuMzI2NyAxMDEuMzk5TDg4LjMyNjkgNzMuODE1N0wxNzguMTE4IDU0Ljg1NTNMMjM4LjcyNSAyLjkzMDk0Wk0xNzguNTk5IDU2LjI2MjJMODkuNjc4NiA3NS4wMzg4TDg2LjkzMjEgMTAwLjI5Qzg5LjA5NzkgOTkuODcyNSA5MS40MTI0IDk5LjQyNjMgOTMuODQ0NiA5OC45NTcyQzExNS4zODggOTQuODAxOSAxNDYuMTcxIDg4Ljg0ODggMTY0Ljc5MSA4NS4yMDI2TDE2NS40MTUgODUuMDgwNEMxNjcuMjQgODQuNzIyOCAxNjguOTQzIDg0LjM4ODUgMTcwLjUwMSA4NC4wODE2QzE3NS44NTMgODMuMDI3NSAxNzcuMjE5IDgyLjcwMSAxNzguMDE1IDgyLjUxMDdDMTc4LjA3IDgyLjQ5NzYgMTc4LjEyMiA4Mi40ODUyIDE3OC4xNzMgODIuNDczMkMxNzkuMDQ4IDgyLjI2NTIgMTgxLjU1OCA4MS41NjY5IDE4NC4yMzUgODAuNTg1MUMxODYuNzQyIDc5LjY2NTUgMTg5LjI4NiA3OC41MzU0IDE5MC44MDIgNzcuMzc1OEwxOTEuMTUxIDc3LjA5MjJMMTkxLjY0NCA3Ni42NTk1QzE5My4zNDEgNzUuMTQ3IDE5NC43MjMgNzMuNjczOSAxOTUuNjEgNzEuODcxQzE5Ni41NzEgNjkuOTE2IDE5Ni45ODIgNjcuNTAyOSAxOTYuNDQ4IDY0LjExNzhDMTk1LjggNjAuMDEzMSAxOTIuOTU5IDU3Ljc1NzQgMTg5LjQwOCA1Ni42NTY2QzE4NS44MzMgNTUuNTQ4MyAxODEuNjM3IDU1LjY1NjYgMTc4LjYwMyA1Ni4yNjE1QzE3OC42MDEgNTYuMjYxNyAxNzguNiA1Ni4yNjIgMTc4LjU5OSA1Ni4yNjIyWk0xOTIuNjMxIDc3Ljc1NjVMMjU5LjU1NSAxOC45NTMxTDI2My4wNDIgMjYuMDg2OUwxODEuODA4IDk2LjkwNzhMMTc4LjEzMiA4OS41NzEzTDE5MS43MjQgNzguNTI5QzE5MS44NTkgNzguNDI0OSAxOTEuOTg4IDc4LjMyIDE5Mi4xMSA3OC4yMTQ0TDE5Mi4xMTEgNzguMjEzNkMxOTIuMjg2IDc4LjA2MTcgMTkyLjQ2IDc3LjkwOTQgMTkyLjYzMSA3Ny43NTY1Wk0xODUuNDkxIDgxLjY5MDhDMTg1LjI0IDgxLjc4NjggMTg0Ljk5IDgxLjg4MDIgMTg0Ljc0MyA4MS45NzA5QzE4Mi4wMTMgODIuOTcyMyAxNzkuNDQ3IDgzLjY4NzUgMTc4LjUxNCA4My45MDkzQzE3OC40NjMgODMuOTIxMyAxNzguNDExIDgzLjkzMzggMTc4LjM1NiA4My45NDY4QzE3Ny42MzUgODQuMTE5MiAxNzYuNDcyIDg0LjM5NzEgMTcyLjQ5MSA4NS4xOTE5TDE3Ny4xNzIgODguNDQ5MkwxODUuNDkxIDgxLjY5MDhaTTE3Ni42MzEgODkuODcwN0wxNzAuNDc5IDg1LjU5MDNDMTY5LjMwNiA4NS44MjEzIDE2OC4wNTQgODYuMDY3MyAxNjYuNzMxIDg2LjMyNjVMMTc1Ljc2OSA5Mi45Mjc2TDE3OS41NDggOTUuNjkyNEwxNzYuNjMxIDg5Ljg3MDdaTTE2NC43NTggODYuNzEzMkMxNDYuMjUyIDkwLjMzNjIgMTE2LjAyNyA5Ni4xODE3IDk0LjYzMjQgMTAwLjMwOEw5My4yMjU4IDEwOS4xOTdMMTczLjU0MyA5My4xMjkzTDE2NC43NTggODYuNzEzMlpNOTEuODg4IDEwOC4yMDdMOTMuMDkwOSAxMDAuNjA2QzkxLjA4NDggMTAwLjk5MyA4OS4xNjQyIDEwMS4zNjMgODcuMzQ3MSAxMDEuNzEzTDkxLjg4OCAxMDguMjA3Wk0yNTguNTgxIDE3Ljg0MzZMMTk3LjMwNiA3MS42ODQxQzE5OC4xNDIgNjkuNTc3OSAxOTguNDEgNjcuMDc5NSAxOTcuOTA2IDYzLjg4NzZDMTk3LjE0MyA1OS4wNTM5IDE5My43NDMgNTYuNDU0OSAxODkuODQ1IDU1LjI0NjdDMTg2LjkyMSA1NC4zNDAyIDE4My42NjIgNTQuMTkxNiAxODAuODYxIDU0LjQ0OUwyMzguODQgNC43NzY2OEwyNTguNTgxIDE3Ljg0MzZaTTIzMi41MDUgMTYuODJMMjQzLjA4OSAyNC41NjQzTDIwNS45MTUgNTYuNTEwNkwxOTYuMDQyIDQ4LjA2NjVMMjMyLjUwNSAxNi44MlpNMjMyLjExOCAxOS4wOTZMMTk4LjMxMiA0OC4wNjU0TDE5OS43NDQgNDkuMjlMMjMyLjU4NCAyMC45NDI0TDIzMi4xMTggMTkuMDk2Wk0yMzMuNDU2IDIyLjEzOTZMMjAwLjg3OCA1MC4yNjA0TDIwNS45MTMgNTQuNTY2NEwyMzkuMDQxIDI2LjA5NjlMMjMzLjQ1NiAyMi4xMzk2Wk0yNDAuMTk1IDI1LjEwNTRMMjQwLjcxNyAyNC42NTcxTDIzMy43NTkgMTkuNTY2M0wyMzQuMDYgMjAuNzU4NkwyNDAuMTk1IDI1LjEwNTRaXCIsXG4gICAgICBmaWxsOiBcImJsYWNrXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xOTAuMTk0IDY5Ljk3NDRDMTkxLjMyIDY4LjE0MDkgMTkxLjU3NiA2Ni4yMjcxIDE5MC45NDIgNjQuNTkzN0MxOTAuMzA4IDYyLjk2MDMgMTg4LjgyOSA2MS43MTk4IDE4Ni43NjEgNjEuMTI1NEMxODQuNjkxIDYwLjUzMDcgMTgyLjExNiA2MC42MTk2IDE3OS41NTMgNjEuNjEzOUMxNzYuOTkxIDYyLjYwODEgMTc1LjAyOSA2NC4yNzk0IDE3My45MDIgNjYuMTE0MUMxNzIuNzc2IDY3Ljk0NzcgMTcyLjUyIDY5Ljg2MTQgMTczLjE1NCA3MS40OTQ4QzE3My43ODggNzMuMTI4MiAxNzUuMjY3IDc0LjM2ODcgMTc3LjMzNSA3NC45NjMxQzE3OS40MDUgNzUuNTU3OCAxODEuOTggNzUuNDY4OSAxODQuNTQzIDc0LjQ3NDZDMTg3LjEwNSA3My40ODA0IDE4OS4wNjcgNzEuODA5MSAxOTAuMTk0IDY5Ljk3NDRaTTE4NS4wNzcgNzUuODUwOEMxOTAuNzQ5IDczLjY1MDIgMTkzLjk5MSA2OC4zNzEyIDE5Mi4zMTggNjQuMDU5OEMxOTAuNjQ1IDU5Ljc0ODQgMTg0LjY5MSA1OC4wMzcyIDE3OS4wMTkgNjAuMjM3OEMxNzMuMzQ3IDYyLjQzODMgMTcwLjEwNSA2Ny43MTczIDE3MS43NzggNzIuMDI4N0MxNzMuNDUxIDc2LjM0MDEgMTc5LjQwNSA3OC4wNTEzIDE4NS4wNzcgNzUuODUwOFpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTE4Ny4zOTEgNjkuMTY5QzE4OC4xMjcgNjcuOTcxMyAxODguMjY2IDY2Ljc3MjEgMTg3Ljg4MSA2NS43ODEyQzE4Ny40OTcgNjQuNzkwMyAxODYuNTg2IDYzLjk5ODQgMTg1LjIzNSA2My42MTAyQzE4My44ODMgNjMuMjIxNiAxODIuMTczIDYzLjI3NDEgMTgwLjQ1NiA2My45NDA0QzE3OC43MzggNjQuNjA2OCAxNzcuNDQxIDY1LjcyMDggMTc2LjcwNSA2Ni45MTk2QzE3NS45NjkgNjguMTE3MiAxNzUuODMgNjkuMzE2NSAxNzYuMjE1IDcwLjMwNzRDMTc2LjU5OSA3MS4yOTgzIDE3Ny41MTEgNzIuMDkwMSAxNzguODYxIDcyLjQ3ODNDMTgwLjIxNCA3Mi44NjY5IDE4MS45MjMgNzIuODE0NCAxODMuNjQgNzIuMTQ4MUMxODUuMzU4IDcxLjQ4MTggMTg2LjY1NSA3MC4zNjc4IDE4Ny4zOTEgNjkuMTY5Wk0xODQuMTc0IDczLjUyNDJDMTg4LjE1NiA3MS45Nzk1IDE5MC40MzIgNjguMjczOCAxODkuMjU3IDY1LjI0NzNDMTg4LjA4MyA2Mi4yMjA4IDE4My45MDQgNjEuMDE5NiAxNzkuOTIyIDYyLjU2NDNDMTc1Ljk0IDY0LjEwOTEgMTczLjY2NSA2Ny44MTQ4IDE3NC44MzkgNzAuODQxMkMxNzYuMDEzIDczLjg2NzcgMTgwLjE5MyA3NS4wNjg5IDE4NC4xNzQgNzMuNTI0MlpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTI0MC40OTkgNDEuMjQ0MUMyMzkuNzQ0IDQwLjM2NDkgMjM5Ljg0NCAzOS4wNCAyNDAuNzI0IDM4LjI4NUwyNDkuNzgxIDMwLjUwNjdDMjUwLjY2IDI5Ljc1MTYgMjUxLjk4NSAyOS44NTIzIDI1Mi43NCAzMC43MzE1VjMwLjczMTVDMjUzLjQ5NSAzMS42MTA4IDI1My4zOTUgMzIuOTM1NiAyNTIuNTE2IDMzLjY5MDdMMjQzLjQ1OCA0MS40NjlDMjQyLjU3OSA0Mi4yMjQgMjQxLjI1NCA0Mi4xMjM0IDI0MC40OTkgNDEuMjQ0MVY0MS4yNDQxWlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMjUwLjc0MyAzMS42MjY1TDI0MS42ODUgMzkuNDA0OEMyNDEuNDI0IDM5LjYyODcgMjQxLjM5NSA0MC4wMjE3IDI0MS42MTkgNDAuMjgyNUMyNDEuODQyIDQwLjU0MzMgMjQyLjIzNSA0MC41NzMxIDI0Mi40OTYgNDAuMzQ5MkwyNTEuNTU0IDMyLjU3MDlDMjUxLjgxNSAzMi4zNDY5IDI1MS44NDUgMzEuOTU0IDI1MS42MjEgMzEuNjkzMkMyNTEuMzk3IDMxLjQzMjQgMjUxLjAwNCAzMS40MDI1IDI1MC43NDMgMzEuNjI2NVpNMjQwLjcyNCAzOC4yODVDMjM5Ljg0NCAzOS4wNCAyMzkuNzQ0IDQwLjM2NDkgMjQwLjQ5OSA0MS4yNDQxQzI0MS4yNTQgNDIuMTIzNCAyNDIuNTc5IDQyLjIyNCAyNDMuNDU4IDQxLjQ2OUwyNTIuNTE2IDMzLjY5MDdDMjUzLjM5NSAzMi45MzU2IDI1My40OTUgMzEuNjEwOCAyNTIuNzQgMzAuNzMxNUMyNTEuOTg1IDI5Ljg1MjMgMjUwLjY2IDI5Ljc1MTYgMjQ5Ljc4MSAzMC41MDY3TDI0MC43MjQgMzguMjg1WlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMjA1Ljc3OSA3MS40NjQ3QzIwNS4wMDUgNzAuNTY0MiAyMDUuMTA4IDY5LjIwNzMgMjA2LjAwOSA2OC40MzM5TDIxNC45ODkgNjAuNzIxOEMyMTUuODkgNTkuOTQ4NSAyMTcuMjQ3IDYwLjA1MTYgMjE4LjAyIDYwLjk1MjFWNjAuOTUyMUMyMTguNzkzIDYxLjg1MjYgMjE4LjY5IDYzLjIwOTUgMjE3Ljc5IDYzLjk4MjlMMjA4LjgwOSA3MS42OTVDMjA3LjkwOSA3Mi40NjgzIDIwNi41NTIgNzIuMzY1MiAyMDUuNzc5IDcxLjQ2NDdWNzEuNDY0N1pcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTIxNS45NTEgNjEuODQxNkwyMDYuOTcgNjkuNTUzN0MyMDYuNjg4IDY5Ljc5NiAyMDYuNjU2IDcwLjIyMSAyMDYuODk4IDcwLjUwMzFDMjA3LjE0MSA3MC43ODUxIDIwNy41NjYgNzAuODE3NCAyMDcuODQ4IDcwLjU3NTJMMjE2LjgyOCA2Mi44NjNDMjE3LjExIDYyLjYyMDggMjE3LjE0MyA2Mi4xOTU4IDIxNi45IDYxLjkxMzdDMjE2LjY1OCA2MS42MzE3IDIxNi4yMzMgNjEuNTk5NCAyMTUuOTUxIDYxLjg0MTZaTTIwNi4wMDkgNjguNDMzOUMyMDUuMTA4IDY5LjIwNzMgMjA1LjAwNSA3MC41NjQyIDIwNS43NzkgNzEuNDY0N0MyMDYuNTUyIDcyLjM2NTIgMjA3LjkwOSA3Mi40NjgzIDIwOC44MDkgNzEuNjk1TDIxNy43OSA2My45ODI5QzIxOC42OSA2My4yMDk1IDIxOC43OTMgNjEuODUyNiAyMTguMDIgNjAuOTUyMUMyMTcuMjQ3IDYwLjA1MTYgMjE1Ljg5IDU5Ljk0ODUgMjE0Ljk4OSA2MC43MjE4TDIwNi4wMDkgNjguNDMzOVpcIixcbiAgICAgIGZpbGw6IFwiYmxhY2tcIlxuICAgIH0pLCBqc3goXCJjaXJjbGVcIiwge1xuICAgICAgY3g6IFwiMTQxLjM1NlwiLFxuICAgICAgY3k6IFwiMTkuNTI1XCIsXG4gICAgICByOiBcIjEwLjE4NTVcIixcbiAgICAgIGZpbGw6IFwiI0ZFODlCNFwiXG4gICAgfSksIGpzeChcImVsbGlwc2VcIiwge1xuICAgICAgY3g6IFwiMTM5LjA2MlwiLFxuICAgICAgY3k6IFwiMTQuNzA5NFwiLFxuICAgICAgcng6IFwiMi40MjUxOVwiLFxuICAgICAgcnk6IFwiMS45NDAxNVwiLFxuICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgtMzQuNTQ0IDEzOS4wNjIgMTQuNzA5NClcIixcbiAgICAgIGZpbGw6IFwiI0ZERjdGRlwiXG4gICAgfSksIGpzeChcImNpcmNsZVwiLCB7XG4gICAgICBjeDogXCIyNTIuNDg5XCIsXG4gICAgICBjeTogXCI3OS43NTc3XCIsXG4gICAgICByOiBcIjcuNzg4OTNcIixcbiAgICAgIGZpbGw6IFwiI0VDNTIzNlwiXG4gICAgfSksIGpzeChcImVsbGlwc2VcIiwge1xuICAgICAgY3g6IFwiMjUwLjQzNFwiLFxuICAgICAgY3k6IFwiNzYuMzcwMVwiLFxuICAgICAgcng6IFwiMi42MTI3MlwiLFxuICAgICAgcnk6IFwiMi4wOTAxOFwiLFxuICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgtMzQuNTQ0IDI1MC40MzQgNzYuMzcwMSlcIixcbiAgICAgIGZpbGw6IFwiI0VEQjY5RFwiXG4gICAgfSksIGpzeChcInBhdGhcIiwge1xuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMTAwLjQzNiA3OS45MjU0QzEwMC40NjEgNzkuNjU2NyAxMDAuNzMyIDc5LjM4OTcgMTAxLjA0MiA3OS4zMjlMMTA2LjY1NyA3OC4yMjk5QzEwNy41ODcgNzguMDQ3OCAxMDguMjgxIDc4LjU1MzYgMTA4LjIwNyA3OS4zNTk2TDEwNy43NTkgODQuMjI0M0MxMDcuNzM0IDg0LjQ5MyAxMDcuNDYzIDg0Ljc2IDEwNy4xNTMgODQuODIwN0wxMDAuNDE2IDg2LjEzOTZDMTAwLjEwNiA4Ni4yMDAzIDk5Ljg3NDIgODYuMDMxNyA5OS44OTkgODUuNzYzMUwxMDAuNDM2IDc5LjkyNTRaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTk1Ljg1NTMgODEuNzc3NUM5NS45Mjk0IDgwLjk3MTUgOTYuNzQzNyA4MC4xNzA0IDk3LjY3MzkgNzkuOTg4M0w5OC43OTY4IDc5Ljc2ODVDOTkuMTA2OSA3OS43MDc4IDk5LjMzODIgNzkuODc2NCA5OS4zMTM1IDgwLjE0NTFMOTkuMTM0NCA4Mi4wOTFDOTkuMTA5NiA4Mi4zNTk3IDk4LjgzODIgODIuNjI2NyA5OC41MjgyIDgyLjY4NzRMOTYuMjgyNCA4My4xMjdDOTUuOTcyMyA4My4xODc3IDk1Ljc0MSA4My4wMTkxIDk1Ljc2NTcgODIuNzUwNUw5NS44NTUzIDgxLjc3NzVaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTk1LjU4NjUgODQuNjk2NUM5NS42MTEyIDg0LjQyNzggOTUuODgyNiA4NC4xNjA4IDk2LjE5MjcgODQuMTAwMUw5OC40Mzg1IDgzLjY2MDVDOTguNzQ4NiA4My41OTk4IDk4Ljk3OTkgODMuNzY4NCA5OC45NTUyIDg0LjAzN0w5OC43NzYxIDg1Ljk4MjlDOTguNzUxMyA4Ni4yNTE2IDk4LjQ3OTkgODYuNTE4NiA5OC4xNjk5IDg2LjU3OTNMOTUuOTI0MSA4Ny4wMTlDOTUuNjE0IDg3LjA3OTcgOTUuMzgyNyA4Ni45MTExIDk1LjQwNzQgODYuNjQyNEw5NS41ODY1IDg0LjY5NjVaXCIsXG4gICAgICBmaWxsOiBcIiNCM0FBQUFcIlxuICAgIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTk1LjIyODIgODguNTg4NEM5NS4yNTI5IDg4LjMxOTcgOTUuNTI0NCA4OC4wNTI3IDk1LjgzNDQgODcuOTkyTDk4LjA4MDIgODcuNTUyNEM5OC4zOTAzIDg3LjQ5MTcgOTguNjIxNiA4Ny42NjAzIDk4LjU5NjkgODcuOTI5TDk4LjQxNzggODkuODc0OUM5OC4zOTMxIDkwLjE0MzUgOTguMTIxNiA5MC40MTA1IDk3LjgxMTYgOTAuNDcxMkw5Ni42ODg3IDkwLjY5MTFDOTUuNzU4NCA5MC44NzMyIDk1LjA2NDUgOTAuMzY3NCA5NS4xMzg3IDg5LjU2MTRMOTUuMjI4MiA4OC41ODg0WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk05OS43MTk3IDg3LjcwOUM5OS43NDQ0IDg3LjQ0MDMgMTAwLjAxNiA4Ny4xNzMzIDEwMC4zMjYgODcuMTEyNkwxMDIuNTcyIDg2LjY3M0MxMDIuODgyIDg2LjYxMjMgMTAzLjExMyA4Ni43ODA5IDEwMy4wODggODcuMDQ5NkwxMDIuOTA5IDg4Ljk5NTVDMTAyLjg4NSA4OS4yNjQxIDEwMi42MTMgODkuNTMxMiAxMDIuMzAzIDg5LjU5MTlMMTAwLjA1NyA5MC4wMzE1Qzk5Ljc0NzIgOTAuMDkyMiA5OS41MTU5IDg5LjkyMzYgOTkuNTQwNiA4OS42NTQ5TDk5LjcxOTcgODcuNzA5WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xMDQuMjExIDg2LjgyOThDMTA0LjIzNiA4Ni41NjExIDEwNC41MDcgODYuMjk0MSAxMDQuODE3IDg2LjIzMzRMMTA3LjA2MyA4NS43OTM4QzEwNy4zNzMgODUuNzMzMSAxMDcuNjA1IDg1LjkwMTcgMTA3LjU4IDg2LjE3MDRMMTA3LjQ5IDg3LjE0MzNDMTA3LjQxNiA4Ny45NDkzIDEwNi42MDIgODguNzUwNCAxMDUuNjcyIDg4LjkzMjVMMTA0LjU0OSA4OS4xNTIzQzEwNC4yMzkgODkuMjEzIDEwNC4wMDcgODkuMDQ0NCAxMDQuMDMyIDg4Ljc3NTdMMTA0LjIxMSA4Ni44Mjk4WlwiLFxuICAgICAgZmlsbDogXCIjQjNBQUFBXCJcbiAgICB9KSwganN4KFwiZGVmc1wiLCB7XG4gICAgICBjaGlsZHJlbjoganN4cyhcImxpbmVhckdyYWRpZW50XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBpZDogXCJwYWludDBfbGluZWFyXzNfNjcyXCIsXG4gICAgICAgIHgxOiBcIi00NC41MTk1XCIsXG4gICAgICAgIHkxOiBcIjEyMi40MlwiLFxuICAgICAgICB4MjogXCIyNjMuMzU3XCIsXG4gICAgICAgIHkyOiBcIi04LjY1MDIzXCIsXG4gICAgICAgIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcInN0b3BcIiwge1xuICAgICAgICAgIG9mZnNldDogXCIwLjExMDY5N1wiLFxuICAgICAgICAgIHN0b3BDb2xvcjogXCIjMjMyMzIzXCJcbiAgICAgICAgfSksIGpzeChcInN0b3BcIiwge1xuICAgICAgICAgIG9mZnNldDogXCIxXCIsXG4gICAgICAgICAgc3RvcENvbG9yOiBcIiMzRDNEM0RcIlxuICAgICAgICB9KV1cbiAgICAgIH0pKVxuICAgIH0pXVxuICB9KSk7XG59O1xuXG5jb25zdCBVcEFycm93SWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIxMFwiLFxuICAgIGhlaWdodDogXCI3XCIsXG4gICAgdmlld0JveDogXCIwIDAgMTAgN1wiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTkgNS40NzYyTDUgMS40NzYyTDEgNS40NzYyXCIsXG4gICAgICBzdHJva2U6IFwiIzRGN0NEMVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSlcbiAgfSkpO1xufTtcblxuY29uc3QgRG93bkFycm93SWNvbiA9ICgpID0+IHtcbiAgcmV0dXJuIGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB3aWR0aDogXCIxMFwiLFxuICAgIGhlaWdodDogXCI3XCIsXG4gICAgdmlld0JveDogXCIwIDAgMTAgN1wiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwge1xuICAgIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEgMS41MjM4Mkw1IDUuNTIzODJMOSAxLjUyMzgyXCIsXG4gICAgICBzdHJva2U6IFwiIzRGN0NEMVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSlcbiAgfSkpO1xufTtcblxuY29uc3QgREVGQVVMVF9ERVJJVkFUSU9OX1BBVEggPSBcIjQ0Jy8zOTcnLzAnLzAnLzEnXCI7XG5jb25zdCBEZXJpdmF0aW9uUGF0aCA9ICh7XG4gIHNlbGVjdG9yLFxuICBvcHRpb25zLFxuICBvbkJhY2ssXG4gIG9uQ29ubmVjdGVkLFxuICBwYXJhbXMsXG4gIG9uRXJyb3IsXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICBjb25zdCBbcm91dGUsIHNldFJvdXRlXSA9IHVzZVN0YXRlKFwiRW50ZXJEZXJpdmF0aW9uUGF0aFwiKTtcbiAgY29uc3QgW2Rlcml2YXRpb25QYXRoLCBzZXREZXJpdmF0aW9uUGF0aF0gPSB1c2VTdGF0ZShERUZBVUxUX0RFUklWQVRJT05fUEFUSCk7XG4gIGNvbnN0IFtjdXN0b21EZXJpdmF0aW9uUGF0aCwgc2V0Q3VzdG9tRGVyaXZhdGlvblBhdGhdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFthY2NvdW50cywgc2V0QWNjb3VudHNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbc2VsZWN0ZWRBY2NvdW50cywgc2V0U2VsZWN0ZWRBY2NvdW50c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtoYXJkd2FyZVdhbGxldCwgc2V0SGFyZHdhcmVXYWxsZXRdID0gdXNlU3RhdGUoKTtcbiAgY29uc3QgW2N1c3RvbUFjY291bnRJZCwgc2V0Q3VzdG9tQWNjb3VudElkXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbY29ubmVjdGluZywgc2V0Q29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGluaXRhbEhlYWRlclRpdGxlID0gdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNvbm5lY3RXaXRoTGVkZ2VyXCIpO1xuICBjb25zdCBbaGVhZGVyVGl0bGUsIHNldEhlYWRlclRpdGxlXSA9IHVzZVN0YXRlKGluaXRhbEhlYWRlclRpdGxlKTtcbiAgY29uc3QgZ2V0QWNjb3VudElkcyA9IHB1YmxpY0tleSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGAke3NlbGVjdG9yLm9wdGlvbnMubmV0d29yay5pbmRleGVyVXJsfS9wdWJsaWNLZXkvZWQyNTUxOToke3B1YmxpY0tleX0vYWNjb3VudHNgKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGFjY291bnQgaWQgZnJvbSBwdWJsaWMga2V5XCIpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50SWRzID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhY2NvdW50SWRzKSB8fCAhYWNjb3VudElkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRJZHM7XG4gIH0pO1xuICBjb25zdCByZXNvbHZlQWNjb3VudHMgPSB3YWxsZXQgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0geWllbGQgd2FsbGV0LmdldFB1YmxpY0tleShkZXJpdmF0aW9uUGF0aCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjY291bnRJZHMgPSB5aWVsZCBnZXRBY2NvdW50SWRzKHB1YmxpY0tleSk7XG4gICAgICByZXR1cm4gYWNjb3VudElkcy5tYXAoKGFjY291bnRJZCwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgIHNlbGVjdGVkOiBpbmRleCA9PT0gMFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFuZGxlVmFsaWRhdGVBY2NvdW50ID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3Qgd2FsbGV0ID0geWllbGQgc2VsZWN0b3Iud2FsbGV0KHBhcmFtcy53YWxsZXRJZCk7XG4gICAgaWYgKHdhbGxldC50eXBlICE9PSBcImhhcmR3YXJlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0Q29ubmVjdGluZyh0cnVlKTtcbiAgICBzZXRIYXJkd2FyZVdhbGxldCh3YWxsZXQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNvbHZlZEFjY291bnRzID0geWllbGQgcmVzb2x2ZUFjY291bnRzKHdhbGxldCk7XG4gICAgICBpZiAoIXJlc29sdmVkQWNjb3VudHMpIHtcbiAgICAgICAgc2V0Um91dGUoXCJBZGRDdXN0b21BY2NvdW50SWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vQWNjb3VudHMgPSByZXNvbHZlZEFjY291bnRzLmxlbmd0aCA9PT0gMDtcbiAgICAgIGNvbnN0IG11bHRpcGxlQWNjb3VudHMgPSByZXNvbHZlZEFjY291bnRzLmxlbmd0aCA+IDE7XG4gICAgICBpZiAobm9BY2NvdW50cykge1xuICAgICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIubm9BY2NvdW50c0ZvdW5kXCIpKTtcbiAgICAgICAgc2V0Um91dGUoXCJOb0FjY291bnRzRm91bmRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldEFjY291bnRzKHJlc29sdmVkQWNjb3VudHMpO1xuICAgICAgaWYgKCFtdWx0aXBsZUFjY291bnRzKSB7XG4gICAgICAgIHNldFNlbGVjdGVkQWNjb3VudHMocmVzb2x2ZWRBY2NvdW50cyk7XG4gICAgICAgIHNldFJvdXRlKFwiT3ZlcnZpZXdBY2NvdW50c1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEhlYWRlclRpdGxlKHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5zZWxlY3RZb3VyQWNjb3VudHNcIikpO1xuICAgICAgICBzZXRSb3V0ZShcIkNob29zZUFjY291bnRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJTb21ldGhpbmcgd2VudCB3cm9uZ1wiO1xuICAgICAgb25FcnJvcihtZXNzYWdlLCB3YWxsZXQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBoYW5kbGVBZGRDdXN0b21BY2NvdW50SWQgPSAoKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICB0cnkge1xuICAgICAgc2V0Q29ubmVjdGluZyh0cnVlKTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHlpZWxkIGhhcmR3YXJlV2FsbGV0LmdldFB1YmxpY0tleShkZXJpdmF0aW9uUGF0aCk7XG4gICAgICBjb25zdCBhY2NvdW50TGlzdCA9IFt7XG4gICAgICAgIGRlcml2YXRpb25QYXRoOiBkZXJpdmF0aW9uUGF0aCxcbiAgICAgICAgcHVibGljS2V5LFxuICAgICAgICBhY2NvdW50SWQ6IGN1c3RvbUFjY291bnRJZCxcbiAgICAgICAgc2VsZWN0ZWQ6IHRydWVcbiAgICAgIH1dO1xuICAgICAgc2V0QWNjb3VudHMoYWNjb3VudExpc3QpO1xuICAgICAgc2V0U2VsZWN0ZWRBY2NvdW50cyhhY2NvdW50TGlzdCk7XG4gICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuY29ubmVjdGluZzFBY2NvdW50XCIpKTtcbiAgICAgIHNldFJvdXRlKFwiT3ZlcnZpZXdBY2NvdW50c1wiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldENvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlNvbWV0aGluZyB3ZW50IHdyb25nXCI7XG4gICAgICBvbkVycm9yKG1lc3NhZ2UsIGhhcmR3YXJlV2FsbGV0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFuZGxlU2lnbkluID0gKCkgPT4ge1xuICAgIGNvbnN0IG1hcEFjY291bnRzID0gc2VsZWN0ZWRBY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXJpdmF0aW9uUGF0aDogYWNjb3VudC5kZXJpdmF0aW9uUGF0aCxcbiAgICAgICAgcHVibGljS2V5OiBhY2NvdW50LnB1YmxpY0tleSxcbiAgICAgICAgYWNjb3VudElkOiBhY2NvdW50LmFjY291bnRJZFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGFyZHdhcmVXYWxsZXQuc2lnbkluKHtcbiAgICAgIGNvbnRyYWN0SWQ6IG9wdGlvbnMuY29udHJhY3RJZCxcbiAgICAgIG1ldGhvZE5hbWVzOiBvcHRpb25zLm1ldGhvZE5hbWVzLFxuICAgICAgYWNjb3VudHM6IG1hcEFjY291bnRzXG4gICAgfSkudGhlbigoKSA9PiBvbkNvbm5lY3RlZCgpKS5jYXRjaChlcnIgPT4ge1xuICAgICAgb25FcnJvcihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCwgaGFyZHdhcmVXYWxsZXQpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBoYW5kbGVPbkJhY2tCdXR0b25DbGljayA9ICgpID0+IHtcbiAgICBpZiAocm91dGUgPT09IFwiU3BlY2lmeUhEUGF0aFwiIHx8IHJvdXRlID09PSBcIk5vQWNjb3VudHNGb3VuZFwiIHx8IHJvdXRlID09PSBcIkNob29zZUFjY291bnRcIikge1xuICAgICAgc2V0SGVhZGVyVGl0bGUodHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNvbm5lY3RXaXRoTGVkZ2VyXCIpKTtcbiAgICAgIHNldFJvdXRlKFwiRW50ZXJEZXJpdmF0aW9uUGF0aFwiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlID09PSBcIk92ZXJ2aWV3QWNjb3VudHNcIikge1xuICAgICAgc2V0SGVhZGVyVGl0bGUodHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLnNlbGVjdFlvdXJBY2NvdW50c1wiKSk7XG4gICAgICBzZXRSb3V0ZShcIkNob29zZUFjY291bnRcIik7XG4gICAgfVxuICB9O1xuICBpZiAoY29ubmVjdGluZykge1xuICAgIHJldHVybiBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiZGVyaXZhdGlvbi1wYXRoLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBqc3goV2FsbGV0Q29ubmVjdGluZywge1xuICAgICAgICB3YWxsZXQ6IGhhcmR3YXJlV2FsbGV0LFxuICAgICAgICBvbkJhY2s6ICgpID0+IHtcbiAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9zZU1vZGFsOiBvbkNsb3NlTW9kYWxcbiAgICAgIH0pXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiBqc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1oZWFkZXItd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFsocm91dGUgPT09IFwiU3BlY2lmeUhEUGF0aFwiIHx8IHJvdXRlID09PSBcIk5vQWNjb3VudHNGb3VuZFwiIHx8IHJvdXRlID09PSBcIkNob29zZUFjY291bnRcIiB8fCByb3V0ZSA9PT0gXCJPdmVydmlld0FjY291bnRzXCIpICYmIGpzeChCYWNrQXJyb3csIHtcbiAgICAgICAgb25DbGljazogaGFuZGxlT25CYWNrQnV0dG9uQ2xpY2tcbiAgICAgIH0pLCBqc3goTW9kYWxIZWFkZXIsIHtcbiAgICAgICAgdGl0bGU6IGhlYWRlclRpdGxlLFxuICAgICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgICAgfSldXG4gICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImRlcml2YXRpb24tcGF0aC13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW3JvdXRlID09PSBcIkVudGVyRGVyaXZhdGlvblBhdGhcIiAmJiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiZW50ZXItZGVyaXZhdGlvbi1wYXRoXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImxlZGdlci1pbWFnZVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KExlZGdlckRldmljZUljb24sIHt9KVxuICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImxlZGdlci1kZXNjcmlwdGlvblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeChcInBcIiwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5tYWtlU3VyZVlvdXJMZWRnZXJcIilcbiAgICAgICAgICB9KSwganN4KFwicFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzcGVjaWZ5LXBhdGhcIixcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgc2V0SGVhZGVyVGl0bGUodHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLnNwZWNpZnlIRFBhdGhcIikpO1xuICAgICAgICAgICAgICBzZXRSb3V0ZShcIlNwZWNpZnlIRFBhdGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5zcGVjaWZ5SERQYXRoXCIpXG4gICAgICAgICAgfSkpXVxuICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYWN0aW9uLWJ1dHRvbnNcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVCdXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IGhhbmRsZVZhbGlkYXRlQWNjb3VudFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuY29udGludWVcIilcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpXVxuICAgICAgfSkpLCByb3V0ZSA9PT0gXCJTcGVjaWZ5SERQYXRoXCIgJiYganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInNwZWNpZnktcGF0aC13cmFwcGVyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGFuZ2UtcGF0aC13cmFwcGVyXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImRpc3BsYXktcGF0aFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGpzeChcInNwYW5cIiwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogZGVyaXZhdGlvblBhdGguc2xpY2UoMCwgLTIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGFuZ2UtcGF0aFwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJwYXRoLXZhbHVlXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGpzeChcInNwYW5cIiwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjdXN0b21EZXJpdmF0aW9uUGF0aFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiYnV0dG9ucy13cmFwcGVyXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBjdXN0b21EZXJpdmF0aW9uUGF0aCArIDE7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVyaXZhdGlvblBhdGguc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgICAgc2V0RGVyaXZhdGlvblBhdGgoYCR7cGF0aH0ke25ld1ZhbHVlfSdgKTtcbiAgICAgICAgICAgICAgICAgIHNldEN1c3RvbURlcml2YXRpb25QYXRoKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjoganN4KFVwQXJyb3dJY29uLCB7fSlcbiAgICAgICAgICAgICAgfSkpLCBqc3goXCJidXR0b25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBjdXN0b21EZXJpdmF0aW9uUGF0aCAtIDE7XG4gICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZXJpdmF0aW9uUGF0aC5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICAgICAgICBzZXREZXJpdmF0aW9uUGF0aChgJHtwYXRofSR7bmV3VmFsdWV9J2ApO1xuICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tRGVyaXZhdGlvblBhdGgobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goRG93bkFycm93SWNvbiwge30pXG4gICAgICAgICAgICAgIH0pKV1cbiAgICAgICAgICAgIH0pKV1cbiAgICAgICAgICB9KSldXG4gICAgICAgIH0pKSwganN4KFwicFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwicGF0aC1kZXNjcmlwdGlvblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmVudGVyWW91clByZWZlcnJlZEhEUGF0aFwiKVxuICAgICAgICB9KSksIGpzeChcInBcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIndoYXQtbGlua1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiYVwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly93d3cubGVkZ2VyLmNvbS9hY2FkZW15L2NyeXB0by93aGF0LWFyZS1oaWVyYXJjaGljYWwtZGV0ZXJtaW5pc3RpYy1oZC13YWxsZXRzXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJXaGF0J3MgdGhpcz9cIlxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYWN0aW9uLWJ1dHRvbnNcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVCdXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IGhhbmRsZVZhbGlkYXRlQWNjb3VudFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuc2NhblwiKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSldXG4gICAgICB9KSksIHJvdXRlID09PSBcIk5vQWNjb3VudHNGb3VuZFwiICYmIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm5vLWFjY291bnRzLWZvdW5kLXdyYXBwZXJcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjoganN4cyhcInBcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNhbnRGaW5kQW55QWNjb3VudFwiKSwgXCIgXCIsIGpzeChcImFcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBocmVmOiBgaHR0cHM6Ly8ke3NlbGVjdG9yLm9wdGlvbnMubmV0d29yay5uZXR3b3JrSWQgPT09IFwidGVzdG5ldFwiID8gXCJ0ZXN0bmV0XCIgOiBcImFwcFwifS5teW5lYXJ3YWxsZXQuY29tL2NyZWF0ZWAsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJNeU5lYXJXYWxsZXRcIlxuICAgICAgICAgIH0pKSwgXCIgXCIsIHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5vckNvbm5lY3RBbkFub3RoZXJMZWRnZXJcIildXG4gICAgICAgIH0pXG4gICAgICB9KSksIHJvdXRlID09PSBcIkNob29zZUFjY291bnRcIiAmJiBqc3goSGFyZHdhcmVXYWxsZXRBY2NvdW50c0Zvcm0sIHtcbiAgICAgICAgYWNjb3VudHM6IGFjY291bnRzLFxuICAgICAgICBvblNlbGVjdGVkQ2hhbmdlZDogKGluZGV4LCBzZWxlY3RlZCkgPT4ge1xuICAgICAgICAgIHNldEFjY291bnRzKHByZXZBY2NvdW50cyA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVBY2NvdW50cyA9IHByZXZBY2NvdW50cy5tYXAoKGFjY291bnQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gaW5kZXggPT09IGlkeCA/IHNlbGVjdGVkIDogYWNjb3VudC5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi51cGRhdGVBY2NvdW50c107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3VibWl0OiAoYWNjLCBlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkQWNjID0gYWNjLmZpbHRlcihhY2NvdW50ID0+IGFjY291bnQuc2VsZWN0ZWQpO1xuICAgICAgICAgIHNldFNlbGVjdGVkQWNjb3VudHMoc2VsZWN0ZWRBY2MpO1xuICAgICAgICAgIGNvbnN0IG51bWJlck9mQWNjb3VudHMgPSBzZWxlY3RlZEFjYy5sZW5ndGg7XG4gICAgICAgICAgc2V0SGVhZGVyVGl0bGUoYCR7dHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmNvbm5lY3RpbmdcIil9ICR7bnVtYmVyT2ZBY2NvdW50c30gJHt0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIub2ZBY2NvdW50c1wiKX1gKTtcbiAgICAgICAgICBzZXRSb3V0ZShcIk92ZXJ2aWV3QWNjb3VudHNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlUm91dGU6IG5ld1JvdXRlID0+IHtcbiAgICAgICAgICBpZiAobmV3Um91dGUgPT09IFwiU3BlY2lmeUhEUGF0aFwiKSB7XG4gICAgICAgICAgICBzZXRIZWFkZXJUaXRsZSh0cmFuc2xhdGUoXCJtb2RhbC5sZWRnZXIuc3BlY2lmeUhEUGF0aFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFJvdXRlKG5ld1JvdXRlKTtcbiAgICAgICAgfVxuICAgICAgfSksIHJvdXRlID09PSBcIkFkZEN1c3RvbUFjY291bnRJZFwiICYmIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJlbnRlci1jdXN0b20tYWNjb3VudFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwicFwiLCB7XG4gICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5mYWlsZWRUb0F1dG9tYXRpY2FsbHlcIilcbiAgICAgICAgfSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaW5wdXQtd3JhcHBlclwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJBY2NvdW50IElEXCIsXG4gICAgICAgICAgICB2YWx1ZTogY3VzdG9tQWNjb3VudElkLFxuICAgICAgICAgICAgb25DaGFuZ2U6IGUgPT4ge1xuICAgICAgICAgICAgICBzZXRDdXN0b21BY2NvdW50SWQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJhY3Rpb24tYnV0dG9uc1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjoganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZUJ1dHRvblwiLFxuICAgICAgICAgICAgb25DbGljazogaGFuZGxlQWRkQ3VzdG9tQWNjb3VudElkXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcImxlZGdlci5Db250aW51ZVwiKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSldXG4gICAgICB9KSksIHJvdXRlID09PSBcIk92ZXJ2aWV3QWNjb3VudHNcIiAmJiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwib3ZlcnZpZXctd3JhcHBlclwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwicFwiLCB7XG4gICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLmxlZGdlci5vdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWRcIilcbiAgICAgICAgfSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYWNjb3VudHNcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHNlbGVjdGVkQWNjb3VudHMubWFwKChhY2NvdW50LCBpbmRleCkgPT4ganN4KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJhY2NvdW50XCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGpzeChcInNwYW5cIiwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBhY2NvdW50LmFjY291bnRJZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgfSwgYWNjb3VudC5hY2NvdW50SWQpKVxuICAgICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiYWN0aW9uLWJ1dHRvbnNcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVCdXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IGhhbmRsZVNpZ25JbixcbiAgICAgICAgICAgIGRpc2FibGVkOiBhY2NvdW50cy5sZW5ndGggPT09IDBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwubGVkZ2VyLmZpbmlzaFwiKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSldXG4gICAgICB9KSldXG4gICAgfSkpXVxuICB9KTtcbn07XG5cbmNvbnN0IFdhbGxldE5vdEluc3RhbGxlZCA9ICh7XG4gIG1vZHVsZSxcbiAgb25CYWNrLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgcmV0dXJuIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwibndzLW1vZGFsLWhlYWRlci13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW2pzeChCYWNrQXJyb3csIHtcbiAgICAgICAgb25DbGljazogb25CYWNrXG4gICAgICB9KSwganN4KE1vZGFsSGVhZGVyLCB7XG4gICAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgICBvbkNsb3NlTW9kYWw6IG9uQ2xvc2VNb2RhbFxuICAgICAgfSldXG4gICAgfSkpLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC1ub3QtaW5zdGFsbGVkLXdyYXBwZXJcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC1kYXRhXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBgd2FsbGV0LWljb24tYm94ICR7bW9kdWxlLmlkfWBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgc3JjOiBtb2R1bGUubWV0YWRhdGEuaWNvblVybCxcbiAgICAgICAgICAgIGFsdDogbW9kdWxlLm1ldGFkYXRhLm5hbWVcbiAgICAgICAgICB9KVxuICAgICAgICB9KSksIGpzeChcInBcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBtb2R1bGUubWV0YWRhdGEubmFtZVxuICAgICAgICB9KV1cbiAgICAgIH0pKSwganN4cyhcInBcIiwge1xuICAgICAgICBjaGlsZHJlbjogW3RyYW5zbGF0ZShcIm1vZGFsLmluc3RhbGwueW91bGxOZWVkVG9JbnN0YWxsXCIpLCBcIiBcIiwgbW9kdWxlLm1ldGFkYXRhLm5hbWUsIFwiIFwiLCB0cmFuc2xhdGUoXCJtb2RhbC5pbnN0YWxsLnRvQ29udGludWVBZnRlckluc3RhbGxpbmdcIiksIGpzeHMoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWZyZXNoLWxpbmtcIixcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXCIgXCIsIHRyYW5zbGF0ZShcIm1vZGFsLmluc3RhbGwucmVmcmVzaFRoZVBhZ2VcIildXG4gICAgICAgIH0pKV1cbiAgICAgIH0pLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJhY3Rpb24tYnV0dG9uc1wiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBqc3hzKFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVCdXR0b25cIixcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobW9kdWxlLnR5cGUgIT09IFwiaW5qZWN0ZWRcIikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cub3Blbihtb2R1bGUubWV0YWRhdGEuZG93bmxvYWRVcmwsIFwiX2JsYW5rXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbdHJhbnNsYXRlKFwibW9kYWwuaW5zdGFsbC5vcGVuXCIpLCBcIiBcIiwgbW9kdWxlLm1ldGFkYXRhLm5hbWVdXG4gICAgICAgIH0pKVxuICAgICAgfSkpXVxuICAgIH0pKV1cbiAgfSk7XG59O1xuXG5jb25zdCBRUkljb24gPSAoKSA9PiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICB3aWR0aDogXCIxOFwiLFxuICBoZWlnaHQ6IFwiMTZcIixcbiAgdmlld0JveDogXCIwIDAgMTggMTZcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbn0sIHtcbiAgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk03LjIyMjI0IDEuMzMzMzRIMS40NDQ0NlY2LjY2NjY4SDcuMjIyMjRWMS4zMzMzNFpcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTE1Ljg4ODkgMS4zMzMzNEgxMC4xMTExVjYuNjY2NjhIMTUuODg4OVYxLjMzMzM0WlwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNy4yMjIyNCA5LjMzMzM0SDEuNDQ0NDZWMTQuNjY2N0g3LjIyMjI0VjkuMzMzMzRaXCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMC4xMTExIDEzLjE0MjlWMTQuNjY2N0gxNS44ODg5TTEwLjExMTEgOS4zMzMzNFYxMC44NTcySDEyLjU4NzNWOS4zMzMzNEgxNS44ODg5VjEyLjM4MVwiLFxuICAgIHN0cm9rZTogXCIjNEM1MTU1XCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInJlY3RcIiwge1xuICAgIHg6IFwiMy42MTEwOFwiLFxuICAgIHk6IFwiMy4zMzMzNFwiLFxuICAgIHdpZHRoOiBcIjEuNDQ0NDRcIixcbiAgICBoZWlnaHQ6IFwiMS4zMzMzM1wiLFxuICAgIGZpbGw6IFwiIzRDNTE1NVwiXG4gIH0pLCBqc3goXCJyZWN0XCIsIHtcbiAgICB4OiBcIjMuNjExMDhcIixcbiAgICB5OiBcIjExLjMzMzNcIixcbiAgICB3aWR0aDogXCIxLjQ0NDQ0XCIsXG4gICAgaGVpZ2h0OiBcIjEuMzMzMzNcIixcbiAgICBmaWxsOiBcIiM0QzUxNTVcIlxuICB9KSwganN4KFwicmVjdFwiLCB7XG4gICAgeDogXCIxMi4yNzc4XCIsXG4gICAgeTogXCIzLjMzMzM0XCIsXG4gICAgd2lkdGg6IFwiMS40NDQ0NVwiLFxuICAgIGhlaWdodDogXCIxLjMzMzMzXCIsXG4gICAgZmlsbDogXCIjNEM1MTU1XCJcbiAgfSldXG59KSk7XG5cbmNvbnN0IExpbmtJY29uID0gKCkgPT4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgd2lkdGg6IFwiMThcIixcbiAgaGVpZ2h0OiBcIjE2XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE4IDE2XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCB7XG4gIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTMgOC42NjY2N1YxMi42NjY3QzEzIDEzLjAyMDMgMTIuODQ3OCAxMy4zNTk0IDEyLjU3NyAxMy42MDk1QzEyLjMwNjEgMTMuODU5NSAxMS45Mzg3IDE0IDExLjU1NTYgMTRIMy42MTExM0MzLjIyODA0IDE0IDIuODYwNjQgMTMuODU5NSAyLjU4OTc1IDEzLjYwOTVDMi4zMTg4NyAxMy4zNTk0IDIuMTY2NjkgMTMuMDIwMyAyLjE2NjY5IDEyLjY2NjdWNS4zMzMzM0MyLjE2NjY5IDQuOTc5NzEgMi4zMTg4NyA0LjY0MDU3IDIuNTg5NzUgNC4zOTA1MkMyLjg2MDY0IDQuMTQwNDggMy4yMjgwNCA0IDMuNjExMTMgNEg3Ljk0NDQ3XCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMC44MzMzIDJIMTUuMTY2NlY2XCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk03LjIyMjIzIDkuMzMzMzNMMTUuMTY2NyAyXCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pXVxufSkpO1xuXG5jb25zdCBLZXlJY29uID0gKCkgPT4ganN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICB3aWR0aDogXCI0MFwiLFxuICBoZWlnaHQ6IFwiNDBcIixcbiAgdmlld0JveDogXCIwIDAgNDAgNDBcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbn0sIHtcbiAgY2hpbGRyZW46IGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTMzLjUgMS44MzMyNUwzMC4xNjY2IDUuMTY2NThNMTcuNDgxOCAxNy44NTE0QzE5LjE0MDYgMTkuNTEwMyAyMC4xNjY2IDIxLjgwMTkgMjAuMTY2NiAyNC4zMzMzQzIwLjE2NjYgMjkuMzk1OSAxNi4wNjI2IDMzLjQ5OTkgMTEgMzMuNDk5OUM1LjkzNzM1IDMzLjQ5OTkgMS44MzMzIDI5LjM5NTkgMS44MzMzIDI0LjMzMzNDMS44MzMzIDE5LjI3MDYgNS45MzczNSAxNS4xNjY2IDExIDE1LjE2NjZDMTMuNTMxMyAxNS4xNjY2IDE1LjgyMjkgMTYuMTkyNiAxNy40ODE4IDE3Ljg1MTRaTTE3LjQ4MTggMTcuODUxNEwyNC4zMzMzIDEwLjk5OTlNMjQuMzMzMyAxMC45OTk5TDI5LjMzMzMgMTUuOTk5OUwzNS4xNjY2IDEwLjE2NjZMMzAuMTY2NiA1LjE2NjU4TTI0LjMzMzMgMTAuOTk5OUwzMC4xNjY2IDUuMTY2NThcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiM1wiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pXG59KSk7XG5cbmNvbnN0IEZvbGRlckljb24gPSAoKSA9PiBqc3hzKFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICB3aWR0aDogXCI0MFwiLFxuICBoZWlnaHQ6IFwiNDFcIixcbiAgdmlld0JveDogXCIwIDAgNDAgNDFcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbn0sIHtcbiAgY2hpbGRyZW46IFtqc3goXCJjaXJjbGVcIiwge1xuICAgIGN4OiBcIjI4LjMzMzNcIixcbiAgICBjeTogXCIyMy44MzMzXCIsXG4gICAgcjogXCIxLjY2NjY3XCIsXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIlxuICB9KSwganN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMzUgMTIuMTY2N0g3QzUuODk1NDMgMTIuMTY2NyA1IDExLjI3MTIgNSAxMC4xNjY3VjcuNUM1IDYuMzk1NDMgNS44OTU0MyA1LjUgNyA1LjVIMzEuNjY2N1wiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VXaWR0aDogXCIzXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTM1IDEyLjE2NjdWMzUuNUg3QzUuODk1NDMgMzUuNSA1IDM0LjYwNDYgNSAzMy41VjguODMzMzRcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiM1wiLFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gIH0pXVxufSkpO1xuXG5jb25zdCBXYWxsZXRIb21lID0gKHtcbiAgc2VsZWN0b3IsXG4gIG9uQ2xvc2VNb2RhbFxufSkgPT4ge1xuICBjb25zdCBbbW9kdWxlcywgc2V0TW9kdWxlc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtyb3V0ZSwgc2V0Um91dGVdID0gdXNlU3RhdGUoXCJXYWxsZXRJbmZvXCIpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNlbGVjdG9yLnN0b3JlLm9ic2VydmFibGUuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlckJ5VHlwZSA9IGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gaXRlbS50eXBlICE9PSBcImJyaWRnZVwiICYmIGl0ZW0udHlwZSAhPT0gXCJoYXJkd2FyZVwiICYmIGl0ZW0udHlwZSAhPT0gXCJpbnN0YW50LWxpbmtcIjtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaWx0ZXJlZE1vZHVsZXMgPSBzdGF0ZS5tb2R1bGVzLmZpbHRlcihmaWx0ZXJCeVR5cGUpO1xuICAgICAgc2V0TW9kdWxlcyhmaWx0ZXJlZE1vZHVsZXMpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0V2FsbGV0VXJsID0gbW9kdWxlID0+IHtcbiAgICBsZXQgdXJsID0gXCJcIjtcbiAgICBpZiAobW9kdWxlLnR5cGUgPT09IFwiaW5qZWN0ZWRcIikge1xuICAgICAgdXJsID0gbW9kdWxlLm1ldGFkYXRhLmRvd25sb2FkVXJsO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgICB1cmwgPSBtb2R1bGUubWV0YWRhdGEud2FsbGV0VXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9O1xuICByZXR1cm4ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICBjbGFzc05hbWU6IFwid2FsbGV0LWhvbWUtd3JhcHBlclwiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwibndzLW1vZGFsLWhlYWRlci13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogW3JvdXRlID09PSBcIkdldFdhbGxldHNcIiAmJiBqc3goQmFja0Fycm93LCB7XG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICBzZXRSb3V0ZShcIldhbGxldEluZm9cIik7XG4gICAgICAgIH1cbiAgICAgIH0pLCBqc3goTW9kYWxIZWFkZXIsIHtcbiAgICAgICAgdGl0bGU6IHJvdXRlID09PSBcIkdldFdhbGxldHNcIiA/IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5nZXRBV2FsbGV0XCIpIDogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LndoYXRJc0FXYWxsZXRcIiksXG4gICAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgICB9KV1cbiAgICB9KSksIHJvdXRlID09PSBcIkdldFdhbGxldHNcIiAmJiBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiZ2V0LXdhbGxldC13cmFwcGVyXCJcbiAgICB9LCB7XG4gICAgICBjaGlsZHJlbjogbW9kdWxlcy5tYXAobW9kdWxlID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGljb25VcmwsXG4gICAgICAgICAgbmFtZVxuICAgICAgICB9ID0gbW9kdWxlLm1ldGFkYXRhO1xuICAgICAgICBjb25zdCBxckljb24gPSBbXCJuZWFyZmlcIiwgXCJoZXJlLXdhbGxldFwiXS5pbmNsdWRlcyhtb2R1bGUuaWQpO1xuICAgICAgICBjb25zdCBoZXJlV2FsbGV0VHlwZSA9IG1vZHVsZS5pZCA9PT0gXCJoZXJlLXdhbGxldFwiID8gXCJtb2JpbGVcIiA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHdhbGxldFVybCA9IGdldFdhbGxldFVybChtb2R1bGUpO1xuICAgICAgICByZXR1cm4ganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICBjbGFzc05hbWU6IGBzaW5nbGUtd2FsbGV0LWdldCAke21vZHVsZS5pZH1gLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh3YWxsZXRVcmwpIHtcbiAgICAgICAgICAgICAgd2luZG93Lm9wZW4od2FsbGV0VXJsLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic21hbGwtaWNvblwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtxckljb24gJiYgd2FsbGV0VXJsICYmIGpzeChRUkljb24sIHt9KSwgIXFySWNvbiAmJiB3YWxsZXRVcmwgJiYganN4KExpbmtJY29uLCB7fSldXG4gICAgICAgICAgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiaWNvblwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICAgIHNyYzogaWNvblVybCxcbiAgICAgICAgICAgICAgYWx0OiBuYW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW2pzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInRpdGxlXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IG5hbWVcbiAgICAgICAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwidHlwZVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoYG1vZGFsLndhbGxldFR5cGVzLiR7aGVyZVdhbGxldFR5cGUgfHwgbW9kdWxlLnR5cGV9YClcbiAgICAgICAgICAgIH0pKV1cbiAgICAgICAgICB9KSldXG4gICAgICAgIH0pLCBtb2R1bGUuaWQpO1xuICAgICAgfSlcbiAgICB9KSksIHJvdXRlID09PSBcIldhbGxldEluZm9cIiAmJiBqc3hzKEZyYWdtZW50JDEsIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC1pbmZvLXdyYXBwZXIgd2hhdC13YWxsZXQtaGlkZVwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwid2FsbGV0LXdoYXRcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiaWNvbi1zaWRlXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjoganN4KEtleUljb24sIHt9KVxuICAgICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50LXNpZGVcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiaDNcIiwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LnNlY3VyZUFuZE1hbmFnZVwiKVxuICAgICAgICAgICAgfSksIGpzeChcInBcIiwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LnNhZmVseVN0b3JlXCIpXG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9KSldXG4gICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwid2FsbGV0LXdoYXRcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiaWNvbi1zaWRlXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjoganN4KEZvbGRlckljb24sIHt9KVxuICAgICAgICAgIH0pKSwganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50LXNpZGVcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiaDNcIiwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmxvZ0luVG9BbnlcIilcbiAgICAgICAgICAgIH0pLCBqc3goXCJwXCIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5ub05lZWRUb0NyZWF0ZVwiKVxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfSkpXVxuICAgICAgICB9KSksIGpzeChcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImJ1dHRvbi1zcGFjaW5nXCJcbiAgICAgICAgfSksIGpzeChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwibWlkZGxlQnV0dG9uXCIsXG4gICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgc2V0Um91dGUoXCJHZXRXYWxsZXRzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQuZ2V0QVdhbGxldFwiKVxuICAgICAgICB9KSldXG4gICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ3aGF0LXdhbGxldC1tb2JpbGVcIlxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChcInBcIiwge1xuICAgICAgICAgIGNoaWxkcmVuOiB0cmFuc2xhdGUoXCJtb2RhbC53YWxsZXQudXNlQVdhbGxldFwiKVxuICAgICAgICB9KSwganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJtaWRkbGVCdXR0b25cIixcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRSb3V0ZShcIkdldFdhbGxldHNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLndhbGxldC5nZXRBV2FsbGV0XCIpXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZy1zZWxlY3Rvci13cmFwcGVyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IGpzeHMoXCJzZWxlY3RcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImxhbmctc2VsZWN0b3JcIixcbiAgICAgICAgICBuYW1lOiBcImxhbmdcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtqc3goXCJvcHRpb25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB2YWx1ZTogXCJlblwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiRW5nbGlzaFwiXG4gICAgICAgICAgfSkpLCBqc3goXCJvcHRpb25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB2YWx1ZTogXCJlc1wiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiU3BhbmlzaFwiXG4gICAgICAgICAgfSkpXVxuICAgICAgICB9KSlcbiAgICAgIH0pKV1cbiAgICB9KV1cbiAgfSkpO1xufTtcblxuY29uc3QgV2FsbGV0Q29ubmVjdGVkID0gKHtcbiAgbW9kdWxlLFxuICBvbkNsb3NlTW9kYWxcbn0pID0+IHtcbiAgcmV0dXJuIGpzeHMoRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwibndzLW1vZGFsLWhlYWRlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3goXCJoM1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1pZGRsZVRpdGxlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IGBgXG4gICAgICB9KSksIGpzeChDbG9zZUJ1dHRvbiwge1xuICAgICAgICBvbkNsaWNrOiBvbkNsb3NlTW9kYWxcbiAgICAgIH0pXVxuICAgIH0pKSwganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImNvbm5lY3Rpbmctd3JhcHBlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJpY29uXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJncmVlbi1kb3RcIlxuICAgICAgICAgIH0pLCBqc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgc3JjOiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEuaWNvblVybCxcbiAgICAgICAgICAgIGFsdDogbW9kdWxlID09PSBudWxsIHx8IG1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kdWxlLm1ldGFkYXRhLm5hbWVcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSkpLCBqc3goXCJoM1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiY29ubmVjdGluZy1uYW1lXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUubWV0YWRhdGEubmFtZVxuICAgICAgICB9KSksIGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIndhbGxldC1jb25uZWN0ZWQtc3VjY2Vzc1wiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGlsZHJlbjogW2pzeChDb25uZWN0aW9uU3VjY2Vzc0ljb24sIHt9KSwganN4KFwic3BhblwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmNvbm5lY3Rpb25TdWNjZXNzZnVsXCIpXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pKV1cbiAgICAgIH0pKVxuICAgIH0pKV1cbiAgfSk7XG59O1xuXG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JGM7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciByZWdleHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCQxKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVnZXhwRmxhZ3M7XG5cbnZhciBSZWdFeHBQcm90b3R5cGUkMSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciByZWdleHBHZXRGbGFncyA9IGZ1bmN0aW9uIChSKSB7XG4gIHZhciBmbGFncyA9IFIuZmxhZ3M7XG4gIHJldHVybiBmbGFncyA9PT0gdW5kZWZpbmVkICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUkMSkgJiYgIWhhc093bihSLCAnZmxhZ3MnKSAmJiBpc1Byb3RvdHlwZU9mKFJlZ0V4cFByb3RvdHlwZSQxLCBSKVxuICAgID8gY2FsbChyZWdFeHBGbGFncywgUikgOiBmbGFncztcbn07XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IGZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgZGVmaW5lQnVpbHRJbiA9IGRlZmluZUJ1aWx0SW4kNjtcbnZhciBhbk9iamVjdCA9IGFuT2JqZWN0JGM7XG52YXIgJHRvU3RyaW5nID0gdG9TdHJpbmckMztcbnZhciBmYWlscyA9IGZhaWxzJGg7XG52YXIgZ2V0UmVnRXhwRmxhZ3MgPSByZWdleHBHZXRGbGFncztcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbnZhciBuJFRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlW1RPX1NUUklOR107XG5cbnZhciBOT1RfR0VORVJJQyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG4kVG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxudmFyIElOQ09SUkVDVF9OQU1FID0gUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgbiRUb1N0cmluZy5uYW1lICE9IFRPX1NUUklORztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcbiAgZGVmaW5lQnVpbHRJbihSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHBhdHRlcm4gPSAkdG9TdHJpbmcoUi5zb3VyY2UpO1xuICAgIHZhciBmbGFncyA9ICR0b1N0cmluZyhnZXRSZWdFeHBGbGFncyhSKSk7XG4gICAgcmV0dXJuICcvJyArIHBhdHRlcm4gKyAnLycgKyBmbGFncztcbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG59XG5cbmNvbnN0IENvcHlJY29uID0gKCkgPT4ganN4cyhcInN2Z1wiLCBPYmplY3QuYXNzaWduKHtcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwge1xuICBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTYuNSAxNS4yNWExLjc1IDEuNzUgMCAwIDEtMS43NS0xLjc1VjYuNzVhMiAyIDAgMCAxIDItMmg2Ljc1Yy45NjYgMCAxLjc1Ljc4NCAxLjc1IDEuNzVcIixcbiAgICBzdHJva2U6IFwiIzRGN0NEMVwiLFxuICAgIHN0cm9rZVdpZHRoOiAxLjUsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTguNzUgMTAuNzVhMiAyIDAgMCAxIDItMmg2LjVhMiAyIDAgMCAxIDIgMnY2LjVhMiAyIDAgMCAxLTIgMmgtNi41YTIgMiAwIDAgMS0yLTJ2LTYuNVpcIixcbiAgICBzdHJva2U6IFwiIzRGN0NEMVwiLFxuICAgIHN0cm9rZVdpZHRoOiAxLjUsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgfSldXG59KSk7XG5cbmZ1bmN0aW9uIGZvcm1hdFFSQ29kZUltYWdlKGRhdGEpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4geWllbGQgUVJDb2RlLnRvU3RyaW5nKGRhdGEsIHtcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHR5cGU6IFwic3ZnXCJcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBTY2FuUVJDb2RlID0gKHtcbiAgd2FsbGV0LFxuICB1cmksXG4gIG9uQ2xvc2VNb2RhbCxcbiAgaGFuZGxlT3BlbkRlZmF1bHRNb2RhbFxufSkgPT4ge1xuICBjb25zdCBbbm90aWZpY2F0aW9uLCBzZXROb3RpZmljYXRpb25dID0gUmVhY3QudXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtzdmcsIHNldFN2Z10gPSBSZWFjdC51c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgY29weVRvQ2xpcGJvYXJkID0gKCkgPT4ge1xuICAgIGlmICghdXJpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBjb3B5KHVyaSk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHNldE5vdGlmaWNhdGlvbih0cmFuc2xhdGUoXCJtb2RhbC5xci5jb3BpZWRUb0NsaXBib2FyZFwiKSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHNldE5vdGlmaWNhdGlvbihcIlwiKSwgMTIwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldE5vdGlmaWNhdGlvbih0cmFuc2xhdGUoXCJtb2RhbC5xci5mYWlsZWRUb0NvcHlcIikpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXROb3RpZmljYXRpb24oXCJcIiksIDEyMDApO1xuICAgIH1cbiAgfTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAoKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodXJpKSB7XG4gICAgICAgIHNldFN2Zyh5aWVsZCBmb3JtYXRRUkNvZGVJbWFnZSh1cmkpKTtcbiAgICAgIH1cbiAgICB9KSkoKTtcbiAgfSwgW3VyaV0pO1xuICByZXR1cm4ganN4cyhcInNlY3Rpb25cIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgY2xhc3NOYW1lOiBcInNjYW4tcXItY29kZVwiXG4gIH0sIHtcbiAgICBjaGlsZHJlbjogW2pzeChNb2RhbEhlYWRlciwge1xuICAgICAgdGl0bGU6IHRyYW5zbGF0ZShcIm1vZGFsLnFyLnNjYW5XaXRoWW91ck1vYmlsZVwiKSxcbiAgICAgIG9uQ2xvc2VNb2RhbDogb25DbG9zZU1vZGFsXG4gICAgfSksIGpzeHMoXCJzZWN0aW9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcInFyLWNvZGVcIlxuICAgIH0sIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHtcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICBfX2h0bWw6IHN2Z1xuICAgICAgICB9XG4gICAgICB9KSwgbm90aWZpY2F0aW9uID8ganN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwibm90aWZpY2F0aW9uXCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IG5vdGlmaWNhdGlvblxuICAgICAgfSkpIDoganN4cyhcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImNvcHktYnRuXCIsXG4gICAgICAgIG9uQ2xpY2s6IGNvcHlUb0NsaXBib2FyZFxuICAgICAgfSwge1xuICAgICAgICBjaGlsZHJlbjogW2pzeChDb3B5SWNvbiwge30pLCB0cmFuc2xhdGUoXCJtb2RhbC5xci5jb3B5VG9DbGlwYm9hcmRcIildXG4gICAgICB9KSldXG4gICAgfSkpLCBqc3hzKFwiZm9vdGVyXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcImZvb3RlclwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3hzKFwicFwiLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbdHJhbnNsYXRlKFwibW9kYWwucXIucHJlZmVyVGhlT2ZmaWNpYWxcIiksIFwiIFwiLCB3YWxsZXQubWV0YWRhdGEubmFtZSwgXCI/XCJdXG4gICAgICB9KSwganN4KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwiYnRuXCIsXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZU9wZW5EZWZhdWx0TW9kYWxcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IHRyYW5zbGF0ZShcIm1vZGFsLnFyLm9wZW5cIilcbiAgICAgIH0pKV1cbiAgICB9KSldXG4gIH0pKTtcbn07XG5cbmNvbnN0IGdldFRoZW1lQ2xhc3MgPSB0aGVtZSA9PiB7XG4gIHN3aXRjaCAodGhlbWUpIHtcbiAgICBjYXNlIFwiZGFya1wiOlxuICAgICAgcmV0dXJuIFwiZGFyay10aGVtZVwiO1xuICAgIGNhc2UgXCJsaWdodFwiOlxuICAgICAgcmV0dXJuIFwibGlnaHQtdGhlbWVcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH1cbn07XG5jb25zdCBNb2RhbCA9ICh7XG4gIHNlbGVjdG9yLFxuICBvcHRpb25zLFxuICB2aXNpYmxlLFxuICBoaWRlLFxuICBlbWl0dGVyXG59KSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBbcm91dGUsIHNldFJvdXRlXSA9IHVzZVN0YXRlKHtcbiAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICB9KTtcbiAgY29uc3QgW2FsZXJ0TWVzc2FnZSwgc2V0QWxlcnRNZXNzYWdlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbc2VsZWN0ZWRXYWxsZXQsIHNldFNlbGVjdGVkV2FsbGV0XSA9IHVzZVN0YXRlKCk7XG4gIGNvbnN0IFticmlkZ2VXYWxsZXRVcmksIHNldEJyaWRnZVdhbGxldFVyaV0gPSB1c2VTdGF0ZSgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFJvdXRlKHtcbiAgICAgIG5hbWU6IFwiV2FsbGV0SG9tZVwiXG4gICAgfSk7XG4gICAgYWxsb3dPbmx5TGFuZ3VhZ2Uoc2VsZWN0b3Iub3B0aW9ucy5sYW5ndWFnZUNvZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICBtb2R1bGVzXG4gICAgfSA9IHNlbGVjdG9yLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHNlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IG1vZHVsZXMuZmluZChtID0+IG0uaWQgPT09IHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgc2V0U2VsZWN0ZWRXYWxsZXQobW9kdWxlKTtcbiAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgbmFtZTogXCJXYWxsZXRDb25uZWN0ZWRcIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbW9kdWxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRCcmlkZ2VXYWxsZXRVcmkoXCJcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIH0sIFt2aXNpYmxlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc2VsZWN0b3Iub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCAoe1xuICAgICAgbmV0d29ya0lkXG4gICAgfSkgPT4ge1xuICAgICAgLy8gU3dpdGNoZWQgYmFjayB0byB0aGUgY29ycmVjdCBuZXR3b3JrLlxuICAgICAgaWYgKG5ldHdvcmtJZCA9PT0gc2VsZWN0b3Iub3B0aW9ucy5uZXR3b3JrLm5ldHdvcmtJZCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlRGlzbWlzc0NsaWNrKHt9KTtcbiAgICAgIH1cbiAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgbmFtZTogXCJXYWxsZXROZXR3b3JrQ2hhbmdlZFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaXB0aW9uLnJlbW92ZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBjb25zdCBoYW5kbGVEaXNtaXNzQ2xpY2sgPSB1c2VDYWxsYmFjaygoe1xuICAgIGhpZGVSZWFzb25cbiAgfSkgPT4ge1xuICAgIHNldEFsZXJ0TWVzc2FnZShudWxsKTtcbiAgICBzZXRSb3V0ZSh7XG4gICAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICAgIH0pO1xuICAgIGlmIChoaWRlUmVhc29uID09PSBcInVzZXItdHJpZ2dlcmVkXCIpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdChcIm9uSGlkZVwiLCB7XG4gICAgICAgIGhpZGVSZWFzb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGlkZVJlYXNvbiA9PT0gXCJ3YWxsZXQtbmF2aWdhdGlvblwiKSB7XG4gICAgICBlbWl0dGVyLmVtaXQoXCJvbkhpZGVcIiwge1xuICAgICAgICBoaWRlUmVhc29uXG4gICAgICB9KTtcbiAgICB9XG4gICAgaGlkZSgpO1xuICB9LCBbaGlkZSwgZW1pdHRlcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNsb3NlID0gZSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgY2xvc2UpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgY2xvc2UpO1xuICB9LCBbaGFuZGxlRGlzbWlzc0NsaWNrXSk7XG4gIGNvbnN0IGhhbmRsZVdhbGxldENsaWNrID0gKG1vZHVsZSwgcXJDb2RlTW9kYWwpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHNldFNlbGVjdGVkV2FsbGV0KG1vZHVsZSk7XG4gICAgY29uc3Qge1xuICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgIH0gPSBzZWxlY3Rvci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzZWxlY3RlZFdhbGxldElkID09PSBtb2R1bGUuaWQpIHtcbiAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgbmFtZTogXCJXYWxsZXRDb25uZWN0ZWRcIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbW9kdWxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXByZWNhdGVkLFxuICAgICAgICBhdmFpbGFibGVcbiAgICAgIH0gPSBtb2R1bGUubWV0YWRhdGE7XG4gICAgICBpZiAobW9kdWxlLnR5cGUgPT09IFwiaW5qZWN0ZWRcIiAmJiAhYXZhaWxhYmxlKSB7XG4gICAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgICBuYW1lOiBcIldhbGxldE5vdEluc3RhbGxlZFwiLFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCBtb2R1bGUud2FsbGV0KCk7XG4gICAgICBpZiAoZGVwcmVjYXRlZCkge1xuICAgICAgICBzZXRBbGVydE1lc3NhZ2UoYCR7bW9kdWxlLm1ldGFkYXRhLm5hbWV9IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBzZWxlY3QgYW5vdGhlciB3YWxsZXQuYCk7XG4gICAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgICBuYW1lOiBcIkFsZXJ0TWVzc2FnZVwiLFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAod2FsbGV0LnR5cGUgPT09IFwiaGFyZHdhcmVcIikge1xuICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgbmFtZTogXCJEZXJpdmF0aW9uUGF0aFwiLFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IHdhbGxldC5pZCB8fCBcImxlZGdlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0Um91dGUoe1xuICAgICAgICBuYW1lOiBcIldhbGxldENvbm5lY3RpbmdcIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgd2FsbGV0OiB3YWxsZXRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAod2FsbGV0LnR5cGUgPT09IFwiYnJpZGdlXCIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc2VsZWN0b3Iub24oXCJ1cmlDaGFuZ2VkXCIsICh7XG4gICAgICAgICAgdXJpXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICBzZXRCcmlkZ2VXYWxsZXRVcmkodXJpKTtcbiAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICBuYW1lOiBcIlNjYW5RUkNvZGVcIixcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICB1cmksXG4gICAgICAgICAgICAgIHdhbGxldFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgd2FsbGV0LnNpZ25Jbih7XG4gICAgICAgICAgY29udHJhY3RJZDogb3B0aW9ucy5jb250cmFjdElkLFxuICAgICAgICAgIG1ldGhvZE5hbWVzOiBvcHRpb25zLm1ldGhvZE5hbWVzLFxuICAgICAgICAgIHFyQ29kZU1vZGFsXG4gICAgICAgIH0pO1xuICAgICAgICBzdWJzY3JpcHRpb24ucmVtb3ZlKCk7XG4gICAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgaGlkZVJlYXNvbjogXCJ3YWxsZXQtbmF2aWdhdGlvblwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAod2FsbGV0LnR5cGUgPT09IFwiYnJvd3NlclwiKSB7XG4gICAgICAgIHlpZWxkIHdhbGxldC5zaWduSW4oe1xuICAgICAgICAgIGNvbnRyYWN0SWQ6IG9wdGlvbnMuY29udHJhY3RJZCxcbiAgICAgICAgICBtZXRob2ROYW1lczogb3B0aW9ucy5tZXRob2ROYW1lcyxcbiAgICAgICAgICBzdWNjZXNzVXJsOiB3YWxsZXQubWV0YWRhdGEuc3VjY2Vzc1VybCxcbiAgICAgICAgICBmYWlsdXJlVXJsOiB3YWxsZXQubWV0YWRhdGEuZmFpbHVyZVVybFxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlRGlzbWlzc0NsaWNrKHtcbiAgICAgICAgICBoaWRlUmVhc29uOiBcIndhbGxldC1uYXZpZ2F0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHdhbGxldC5zaWduSW4oe1xuICAgICAgICBjb250cmFjdElkOiBvcHRpb25zLmNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzOiBvcHRpb25zLm1ldGhvZE5hbWVzXG4gICAgICB9KTtcbiAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgIGhpZGVSZWFzb246IFwid2FsbGV0LW5hdmlnYXRpb25cIlxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBtb2R1bGUubWV0YWRhdGE7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiU29tZXRoaW5nIHdlbnQgd3JvbmdcIjtcbiAgICAgIHNldEFsZXJ0TWVzc2FnZShgRmFpbGVkIHRvIHNpZ24gaW4gd2l0aCAke25hbWV9OiAke21lc3NhZ2V9YCk7XG4gICAgICBzZXRSb3V0ZSh7XG4gICAgICAgIG5hbWU6IFwiQWxlcnRNZXNzYWdlXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG1vZHVsZTogbW9kdWxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGlmICghdmlzaWJsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGNsYXNzTmFtZTogYG53cy1tb2RhbC13cmFwcGVyICR7Z2V0VGhlbWVDbGFzcyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGhlbWUpfSAke3Zpc2libGUgPyBcIm9wZW5cIiA6IFwiXCJ9YFxuICB9LCB7XG4gICAgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1vdmVybGF5XCIsXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgaGlkZVJlYXNvbjogXCJ1c2VyLXRyaWdnZXJlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLCBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbFwiXG4gICAgfSwge1xuICAgICAgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjbGFzc05hbWU6IFwibW9kYWwtbGVmdFwiXG4gICAgICB9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJtb2RhbC1sZWZ0LXRpdGxlXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBqc3goXCJoMlwiLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJhbnNsYXRlKFwibW9kYWwud2FsbGV0LmNvbm5lY3RZb3VyV2FsbGV0XCIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpLCBqc3goV2FsbGV0T3B0aW9ucywge1xuICAgICAgICAgIGhhbmRsZVdhbGxldENsaWNrOiBtb2R1bGUgPT4ge1xuICAgICAgICAgICAgaGFuZGxlV2FsbGV0Q2xpY2sobW9kdWxlLCBmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICAgICAgfSldXG4gICAgICB9KSksIGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1vZGFsLXJpZ2h0XCJcbiAgICAgIH0sIHtcbiAgICAgICAgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm53cy1tb2RhbC1ib2R5XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbcm91dGUubmFtZSA9PT0gXCJBbGVydE1lc3NhZ2VcIiAmJiBhbGVydE1lc3NhZ2UgJiYganN4KEFsZXJ0TWVzc2FnZSwge1xuICAgICAgICAgICAgbWVzc2FnZTogYWxlcnRNZXNzYWdlLFxuICAgICAgICAgICAgbW9kdWxlOiAoX2EgPSByb3V0ZS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2R1bGUsXG4gICAgICAgICAgICBvbkJhY2s6IHJldHJ5ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJldHJ5KSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlV2FsbGV0Q2xpY2soc2VsZWN0ZWRXYWxsZXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRBbGVydE1lc3NhZ2UobnVsbCk7XG4gICAgICAgICAgICAgIHNldFJvdXRlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgcm91dGUubmFtZSA9PT0gXCJEZXJpdmF0aW9uUGF0aFwiICYmIGpzeChEZXJpdmF0aW9uUGF0aCwge1xuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgICAgaGlkZVJlYXNvbjogXCJ3YWxsZXQtbmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmFtczogcm91dGUucGFyYW1zLFxuICAgICAgICAgICAgb25CYWNrOiAoKSA9PiBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgIG5hbWU6IFwiV2FsbGV0SG9tZVwiXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChtZXNzYWdlLCB3YWxsZXQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIG1vZHVsZXNcbiAgICAgICAgICAgICAgfSA9IHNlbGVjdG9yLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbmRNb2R1bGUgPSBtb2R1bGVzLmZpbmQobW9kdWxlID0+IG1vZHVsZS5pZCA9PT0gd2FsbGV0LmlkKTtcbiAgICAgICAgICAgICAgc2V0QWxlcnRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJBbGVydE1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgIG1vZHVsZTogZmluZE1vZHVsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0TmV0d29ya0NoYW5nZWRcIiAmJiBqc3goV2FsbGV0TmV0d29ya0NoYW5nZWQsIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIG9uQmFjazogKCkgPT4gc2V0Um91dGUoe1xuICAgICAgICAgICAgICBuYW1lOiBcIldhbGxldEhvbWVcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgcm91dGUubmFtZSA9PT0gXCJXYWxsZXROb3RJbnN0YWxsZWRcIiAmJiBqc3goV2FsbGV0Tm90SW5zdGFsbGVkLCB7XG4gICAgICAgICAgICBtb2R1bGU6IChfYiA9IHJvdXRlLnBhcmFtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1vZHVsZSxcbiAgICAgICAgICAgIG9uQmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0Q29ubmVjdGluZ1wiICYmIGpzeChXYWxsZXRDb25uZWN0aW5nLCB7XG4gICAgICAgICAgICB3YWxsZXQ6IChfYyA9IHJvdXRlLnBhcmFtcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLndhbGxldCxcbiAgICAgICAgICAgIG9uQmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICBzZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJXYWxsZXRIb21lXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiV2FsbGV0SG9tZVwiICYmIGpzeChXYWxsZXRIb21lLCB7XG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSwgcm91dGUubmFtZSA9PT0gXCJXYWxsZXRDb25uZWN0ZWRcIiAmJiBqc3goV2FsbGV0Q29ubmVjdGVkLCB7XG4gICAgICAgICAgICBtb2R1bGU6IHNlbGVjdGVkV2FsbGV0LFxuICAgICAgICAgICAgb25DbG9zZU1vZGFsOiAoKSA9PiBoYW5kbGVEaXNtaXNzQ2xpY2soe1xuICAgICAgICAgICAgICBoaWRlUmVhc29uOiBcInVzZXItdHJpZ2dlcmVkXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIHJvdXRlLm5hbWUgPT09IFwiU2NhblFSQ29kZVwiICYmIGpzeChTY2FuUVJDb2RlLCB7XG4gICAgICAgICAgICBoYW5kbGVPcGVuRGVmYXVsdE1vZGFsOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZVdhbGxldENsaWNrKHNlbGVjdGVkV2FsbGV0LCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb3NlTW9kYWw6ICgpID0+IGhhbmRsZURpc21pc3NDbGljayh7XG4gICAgICAgICAgICAgIGhpZGVSZWFzb246IFwidXNlci10cmlnZ2VyZWRcIlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB1cmk6IGJyaWRnZVdhbGxldFVyaSxcbiAgICAgICAgICAgIHdhbGxldDogc2VsZWN0ZWRXYWxsZXRcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSkpXG4gICAgICB9KSldXG4gICAgfSkpXVxuICB9KSk7XG59O1xuXG5jb25zdCBNT0RBTF9FTEVNRU5UX0lEID0gXCJuZWFyLXdhbGxldC1zZWxlY3Rvci1tb2RhbFwiO1xubGV0IG1vZGFsSW5zdGFuY2UgPSBudWxsO1xubGV0IHJvb3QgPSBudWxsO1xuLyoqXHJcbiAqIEluaXRpYXRlcyBhIG1vZGFsIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7V2FsbGV0U2VsZWN0b3J9IHNlbGVjdG9yIFNlbGVjdG9yXHJcbiAqIEBwYXJhbSB7TW9kYWxPcHRpb25zfSBvcHRpb25zIE1vZGFsIG9wdGlvbnNcclxuICogQHJldHVybnMge1dhbGxldFNlbGVjdG9yTW9kYWx9IFJldHVybnMgYSBXYWxsZXRTZWxlY3Rvck1vZGFsIG9iamVjdFxyXG4gKi9cbmNvbnN0IHNldHVwTW9kYWwgPSAoc2VsZWN0b3IsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFyb290KSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXIuaWQgPSBNT0RBTF9FTEVNRU5UX0lEO1xuICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICByb290ID0gY3JlYXRlUm9vdChjb250YWluZXIpO1xuICB9XG4gIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIGNvbnN0IHJlbmRlciA9ICh2aXNpYmxlID0gZmFsc2UpID0+IHtcbiAgICByb290LnJlbmRlcihqc3goTW9kYWwsIHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlLFxuICAgICAgaGlkZTogKCkgPT4gcmVuZGVyKGZhbHNlKSxcbiAgICAgIGVtaXR0ZXI6IGVtaXR0ZXJcbiAgICB9KSk7XG4gIH07XG4gIGlmICghbW9kYWxJbnN0YW5jZSkge1xuICAgIG1vZGFsSW5zdGFuY2UgPSB7XG4gICAgICBzaG93OiAoKSA9PiB7XG4gICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgIHJlbmRlcihmYWxzZSk7XG4gICAgICB9LFxuICAgICAgb246IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJldHVybiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIG9mZjogKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgZW1pdHRlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gbW9kYWxJbnN0YW5jZTtcbn07XG5cbmV4cG9ydCB7IHNldHVwTW9kYWwgfTtcbiJdLCJuYW1lcyI6WyJqc3hzIiwianN4IiwiRnJhZ21lbnQiLCJGcmFnbWVudCQxIiwiY3JlYXRlUm9vdCIsIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInRyYW5zbGF0ZSIsImFsbG93T25seUxhbmd1YWdlIiwiRXZlbnRFbWl0dGVyIiwiUVJDb2RlIiwiY29weSIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJmYWlscyRoIiwiZXhlYyIsImVycm9yIiwiZmFpbHMkZyIsImZ1bmN0aW9uQmluZE5hdGl2ZSIsInRlc3QiLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJOQVRJVkVfQklORCQzIiwiRnVuY3Rpb25Qcm90b3R5cGUkMiIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYmluZCQ1IiwiY2FsbCRmIiwiY2FsbCIsInVuY3VycnlUaGlzJGgiLCJmdW5jdGlvblVuY3VycnlUaGlzIiwiZm4iLCJhcHBseSIsImFyZ3VtZW50cyIsInVuY3VycnlUaGlzJGciLCJ0b1N0cmluZyQ1IiwidG9TdHJpbmciLCJzdHJpbmdTbGljZSQxIiwic2xpY2UiLCJjbGFzc29mUmF3JDEiLCJpdCIsInVuY3VycnlUaGlzJGYiLCJmYWlscyRmIiwiY2xhc3NvZiQ2IiwiJE9iamVjdCQ0IiwiT2JqZWN0Iiwic3BsaXQiLCJpbmRleGVkT2JqZWN0IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCIkVHlwZUVycm9yJGUiLCJUeXBlRXJyb3IiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMiLCJ1bmRlZmluZWQiLCJJbmRleGVkT2JqZWN0JDIiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIiLCJ0b0luZGV4ZWRPYmplY3QkNSIsImNoZWNrIiwiTWF0aCIsImdsb2JhbCRrIiwic2hhcmVkJDMiLCJleHBvcnRzIiwiZ2xvYmFsJGoiLCJkZWZpbmVQcm9wZXJ0eSQ2IiwiZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzIiwia2V5IiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImdsb2JhbCRpIiwiZGVmaW5lR2xvYmFsUHJvcGVydHkkMiIsIlNIQVJFRCIsInN0b3JlJDMiLCJzaGFyZWRTdG9yZSIsInN0b3JlJDIiLCJwdXNoIiwidmVyc2lvbiIsIm1vZGUiLCJjb3B5cmlnaHQiLCJsaWNlbnNlIiwic291cmNlIiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSQxIiwiJE9iamVjdCQzIiwidG9PYmplY3QkNSIsImFyZ3VtZW50IiwidW5jdXJyeVRoaXMkZSIsInRvT2JqZWN0JDQiLCJoYXNPd25Qcm9wZXJ0eV8xIiwiaGFzT3duIiwidW5jdXJyeVRoaXMkZCIsImlkIiwicG9zdGZpeCIsInJhbmRvbSIsInRvU3RyaW5nJDQiLCJ1aWQkMiIsImlzQ2FsbGFibGUkbCIsImdsb2JhbCRoIiwiaXNDYWxsYWJsZSRrIiwiYUZ1bmN0aW9uIiwiZ2V0QnVpbHRJbiQ4IiwibmFtZXNwYWNlIiwibWV0aG9kIiwibGVuZ3RoIiwiZ2V0QnVpbHRJbiQ3IiwiZW5naW5lVXNlckFnZW50IiwiZ2xvYmFsJGciLCJ1c2VyQWdlbnQkNSIsInByb2Nlc3MkMyIsInByb2Nlc3MiLCJEZW5vJDEiLCJEZW5vIiwidmVyc2lvbnMiLCJ2OCIsIm1hdGNoIiwiZW5naW5lVjhWZXJzaW9uIiwiVjhfVkVSU0lPTiQxIiwiZmFpbHMkZSIsIm5hdGl2ZVN5bWJvbCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbCIsIlN5bWJvbCIsIlN0cmluZyIsInNoYW0iLCJOQVRJVkVfU1lNQk9MJDIiLCJ1c2VTeW1ib2xBc1VpZCIsIml0ZXJhdG9yIiwiZ2xvYmFsJGYiLCJzaGFyZWQkMiIsImhhc093biRiIiwidWlkJDEiLCJOQVRJVkVfU1lNQk9MJDEiLCJVU0VfU1lNQk9MX0FTX1VJRCQxIiwiV2VsbEtub3duU3ltYm9sc1N0b3JlIiwiU3ltYm9sJDEiLCJzeW1ib2xGb3IiLCJjcmVhdGVXZWxsS25vd25TeW1ib2wiLCJ3aXRob3V0U2V0dGVyIiwid2VsbEtub3duU3ltYm9sJGciLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJpc0NhbGxhYmxlJGoiLCJpc09iamVjdCQ4IiwiaXNPYmplY3QkNyIsIiRTdHJpbmckMyIsIiRUeXBlRXJyb3IkZCIsImFuT2JqZWN0JGMiLCJvYmplY3REZWZpbmVQcm9wZXJ0aWVzIiwiZmFpbHMkZCIsImRlc2NyaXB0b3JzIiwiZ2V0IiwiREVTQ1JJUFRPUlMkYiIsImZhaWxzJGMiLCJ2OFByb3RvdHlwZURlZmluZUJ1ZyIsIm9iamVjdERlZmluZVByb3BlcnR5IiwiZ2xvYmFsJGUiLCJpc09iamVjdCQ2IiwiZG9jdW1lbnQkMyIsImRvY3VtZW50IiwiRVhJU1RTJDEiLCJjcmVhdGVFbGVtZW50IiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIiLCJERVNDUklQVE9SUyRhIiwiZmFpbHMkYiIsImNyZWF0ZUVsZW1lbnQkMSIsImllOERvbURlZmluZSIsImEiLCJOQVRJVkVfQklORCQyIiwiY2FsbCRlIiwiZnVuY3Rpb25DYWxsIiwidW5jdXJyeVRoaXMkYyIsIm9iamVjdElzUHJvdG90eXBlT2YiLCJpc1Byb3RvdHlwZU9mIiwiZ2V0QnVpbHRJbiQ2IiwiaXNDYWxsYWJsZSRpIiwiaXNQcm90b3R5cGVPZiQ0IiwiVVNFX1NZTUJPTF9BU19VSUQiLCIkT2JqZWN0JDIiLCJpc1N5bWJvbCQyIiwiJFN5bWJvbCIsIiRTdHJpbmckMiIsInRyeVRvU3RyaW5nJDUiLCJpc0NhbGxhYmxlJGgiLCJ0cnlUb1N0cmluZyQ0IiwiJFR5cGVFcnJvciRjIiwiYUNhbGxhYmxlJDkiLCJhQ2FsbGFibGUkOCIsImdldE1ldGhvZCQzIiwiViIsIlAiLCJmdW5jIiwiY2FsbCRkIiwiaXNDYWxsYWJsZSRnIiwiaXNPYmplY3QkNSIsIiRUeXBlRXJyb3IkYiIsIm9yZGluYXJ5VG9QcmltaXRpdmUkMSIsImlucHV0IiwicHJlZiIsInZhbCIsInZhbHVlT2YiLCJjYWxsJGMiLCJpc09iamVjdCQ0IiwiaXNTeW1ib2wkMSIsImdldE1ldGhvZCQyIiwib3JkaW5hcnlUb1ByaW1pdGl2ZSIsIndlbGxLbm93blN5bWJvbCRmIiwiJFR5cGVFcnJvciRhIiwiVE9fUFJJTUlUSVZFIiwidG9QcmltaXRpdmUkMSIsImV4b3RpY1RvUHJpbSIsInJlc3VsdCIsInRvUHJpbWl0aXZlIiwiaXNTeW1ib2wiLCJ0b1Byb3BlcnR5S2V5JDMiLCJERVNDUklQVE9SUyQ5IiwiSUU4X0RPTV9ERUZJTkUkMSIsIlY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEiLCJhbk9iamVjdCRiIiwidG9Qcm9wZXJ0eUtleSQyIiwiJFR5cGVFcnJvciQ5IiwiJGRlZmluZVByb3BlcnR5IiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRU5VTUVSQUJMRSIsIkNPTkZJR1VSQUJMRSQxIiwiV1JJVEFCTEUiLCJmIiwiTyIsIkF0dHJpYnV0ZXMiLCJjdXJyZW50IiwiZW51bWVyYWJsZSIsImNlaWwiLCJmbG9vciQxIiwiZmxvb3IiLCJtYXRoVHJ1bmMiLCJ0cnVuYyIsIngiLCJuIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQyIiwibnVtYmVyIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQxIiwibWF4JDEiLCJtYXgiLCJtaW4kMSIsIm1pbiIsInRvQWJzb2x1dGVJbmRleCQyIiwiaW5kZXgiLCJpbnRlZ2VyIiwidG9JbnRlZ2VyT3JJbmZpbml0eSIsInRvTGVuZ3RoJDEiLCJ0b0xlbmd0aCIsImxlbmd0aE9mQXJyYXlMaWtlJDUiLCJvYmoiLCJ0b0luZGV4ZWRPYmplY3QkNCIsInRvQWJzb2x1dGVJbmRleCQxIiwibGVuZ3RoT2ZBcnJheUxpa2UkNCIsImNyZWF0ZU1ldGhvZCQxIiwiSVNfSU5DTFVERVMiLCIkdGhpcyIsImVsIiwiZnJvbUluZGV4IiwiYXJyYXlJbmNsdWRlcyIsImluY2x1ZGVzIiwiaW5kZXhPZiIsImhpZGRlbktleXMkNCIsInVuY3VycnlUaGlzJGIiLCJoYXNPd24kYSIsInRvSW5kZXhlZE9iamVjdCQzIiwiaGlkZGVuS2V5cyQzIiwicHVzaCQxIiwib2JqZWN0S2V5c0ludGVybmFsIiwib2JqZWN0IiwibmFtZXMiLCJpIiwiZW51bUJ1Z0tleXMkMyIsImludGVybmFsT2JqZWN0S2V5cyQxIiwiZW51bUJ1Z0tleXMkMiIsIm9iamVjdEtleXMkMiIsImtleXMiLCJERVNDUklQVE9SUyQ4IiwiVjhfUFJPVE9UWVBFX0RFRklORV9CVUciLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1IiwiYW5PYmplY3QkYSIsInRvSW5kZXhlZE9iamVjdCQyIiwib2JqZWN0S2V5cyQxIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJwcm9wcyIsImdldEJ1aWx0SW4kNSIsImh0bWwkMiIsInNoYXJlZCQxIiwidWlkIiwic2hhcmVkS2V5JDMiLCJhbk9iamVjdCQ5IiwiZGVmaW5lUHJvcGVydGllc01vZHVsZSIsImVudW1CdWdLZXlzJDEiLCJoaWRkZW5LZXlzJDIiLCJodG1sJDEiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSIsInNoYXJlZEtleSQyIiwiR1QiLCJMVCIsIlBST1RPVFlQRSIsIlNDUklQVCIsIklFX1BST1RPJDEiLCJFbXB0eUNvbnN0cnVjdG9yIiwic2NyaXB0VGFnIiwiY29udGVudCIsIk51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgiLCJhY3RpdmVYRG9jdW1lbnQiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwiRiIsIk51bGxQcm90b09iamVjdCIsIkFjdGl2ZVhPYmplY3QiLCJkb21haW4iLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJ3ZWxsS25vd25TeW1ib2wkZSIsImNyZWF0ZSQxIiwiZGVmaW5lUHJvcGVydHkkNSIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90b3R5cGUkMSIsIkFycmF5IiwiYWRkVG9VbnNjb3BhYmxlcyQyIiwiaXRlcmF0b3JzIiwidW5jdXJyeVRoaXMkYSIsImlzQ2FsbGFibGUkZiIsInN0b3JlJDEiLCJmdW5jdGlvblRvU3RyaW5nIiwiaW5zcGVjdFNvdXJjZSIsImluc3BlY3RTb3VyY2UkNCIsImdsb2JhbCRkIiwiaXNDYWxsYWJsZSRlIiwiaW5zcGVjdFNvdXJjZSQzIiwiV2Vha01hcCQxIiwiV2Vha01hcCIsIm5hdGl2ZVdlYWtNYXAiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCIsImJpdG1hcCIsIkRFU0NSSVBUT1JTJDciLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0IiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCIsIk5BVElWRV9XRUFLX01BUCIsImdsb2JhbCRjIiwidW5jdXJyeVRoaXMkOSIsImlzT2JqZWN0JDMiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyIsImhhc093biQ5Iiwic2hhcmVkIiwic2hhcmVkS2V5JDEiLCJoaWRkZW5LZXlzJDEiLCJPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCIsIlR5cGVFcnJvciQyIiwic2V0JDEiLCJoYXMiLCJlbmZvcmNlIiwiZ2V0dGVyRm9yIiwiVFlQRSIsInN0YXRlIiwidHlwZSIsInN0b3JlIiwid21nZXQiLCJ3bWhhcyIsIndtc2V0Iiwic2V0IiwibWV0YWRhdGEiLCJmYWNhZGUiLCJTVEFURSIsImludGVybmFsU3RhdGUiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciQyIiwiTkFTSE9STl9CVUciLCJkZXNjcmlwdG9yIiwiREVTQ1JJUFRPUlMkNiIsImNhbGwkYiIsInByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiIsInRvSW5kZXhlZE9iamVjdCQxIiwidG9Qcm9wZXJ0eUtleSQxIiwiaGFzT3duJDgiLCJJRThfRE9NX0RFRklORSIsIiRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJtYWtlQnVpbHRJbiQyIiwiREVTQ1JJUFRPUlMkNSIsImhhc093biQ3IiwiRnVuY3Rpb25Qcm90b3R5cGUkMSIsImdldERlc2NyaXB0b3IiLCJFWElTVFMiLCJQUk9QRVIiLCJzb21ldGhpbmciLCJDT05GSUdVUkFCTEUiLCJmdW5jdGlvbk5hbWUiLCJmYWlscyRhIiwiaXNDYWxsYWJsZSRkIiwiaGFzT3duJDYiLCJERVNDUklQVE9SUyQ0IiwiQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSIsImluc3BlY3RTb3VyY2UkMiIsIkludGVybmFsU3RhdGVNb2R1bGUkMiIsImVuZm9yY2VJbnRlcm5hbFN0YXRlIiwiZ2V0SW50ZXJuYWxTdGF0ZSQxIiwiZGVmaW5lUHJvcGVydHkkNCIsIkNPTkZJR1VSQUJMRV9MRU5HVEgiLCJURU1QTEFURSIsIm1ha2VCdWlsdEluJDEiLCJvcHRpb25zIiwicmVwbGFjZSIsImdldHRlciIsInNldHRlciIsImFyaXR5IiwiY29uc3RydWN0b3IiLCJqb2luIiwiaXNDYWxsYWJsZSRjIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkMyIsIm1ha2VCdWlsdEluIiwiZGVmaW5lR2xvYmFsUHJvcGVydHkkMSIsImRlZmluZUJ1aWx0SW4kNiIsInNpbXBsZSIsInVuc2FmZSIsIm5vbkNvbmZpZ3VyYWJsZSIsIm5vbldyaXRhYmxlIiwib2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyIsImludGVybmFsT2JqZWN0S2V5cyIsImVudW1CdWdLZXlzIiwiaGlkZGVuS2V5cyIsImNvbmNhdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRCdWlsdEluJDQiLCJ1bmN1cnJ5VGhpcyQ4IiwiZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSIsImdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxIiwiYW5PYmplY3QkOCIsImNvbmNhdCQxIiwib3duS2V5cyQxIiwib3duS2V5cyIsImhhc093biQ1IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkMiIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMiIsInRhcmdldCIsImV4Y2VwdGlvbnMiLCJmYWlscyQ5IiwiaXNDYWxsYWJsZSRiIiwicmVwbGFjZW1lbnQiLCJpc0ZvcmNlZCQyIiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInN0cmluZyIsInRvTG93ZXJDYXNlIiwiaXNGb3JjZWRfMSIsImdsb2JhbCRiIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiIsImRlZmluZUJ1aWx0SW4kNSIsImRlZmluZUdsb2JhbFByb3BlcnR5IiwiY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxIiwiaXNGb3JjZWQkMSIsIl9leHBvcnQiLCJUQVJHRVQiLCJHTE9CQUwiLCJTVEFUSUMiLCJzdGF0IiwiRk9SQ0VEIiwidGFyZ2V0UHJvcGVydHkiLCJzb3VyY2VQcm9wZXJ0eSIsImRvbnRDYWxsR2V0U2V0IiwiZm9yY2VkIiwiZmFpbHMkOCIsImNvcnJlY3RQcm90b3R5cGVHZXR0ZXIiLCJnZXRQcm90b3R5cGVPZiIsImhhc093biQ0IiwiaXNDYWxsYWJsZSRhIiwidG9PYmplY3QkMyIsInNoYXJlZEtleSIsIkNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiIsIklFX1BST1RPIiwiJE9iamVjdCQxIiwiT2JqZWN0UHJvdG90eXBlIiwib2JqZWN0R2V0UHJvdG90eXBlT2YiLCJmYWlscyQ3IiwiaXNDYWxsYWJsZSQ5IiwiZ2V0UHJvdG90eXBlT2YkMSIsImRlZmluZUJ1aWx0SW4kNCIsIndlbGxLbm93blN5bWJvbCRkIiwiSVRFUkFUT1IkNSIsIkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSIsIkl0ZXJhdG9yUHJvdG90eXBlJDIiLCJQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUiLCJhcnJheUl0ZXJhdG9yIiwiTkVXX0lURVJBVE9SX1BST1RPVFlQRSIsIml0ZXJhdG9yc0NvcmUiLCJJdGVyYXRvclByb3RvdHlwZSIsIkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMiLCJkZWZpbmVQcm9wZXJ0eSQzIiwiaGFzT3duJDMiLCJ3ZWxsS25vd25TeW1ib2wkYyIsIlRPX1NUUklOR19UQUckMyIsInNldFRvU3RyaW5nVGFnJDMiLCJUQUciLCJJdGVyYXRvclByb3RvdHlwZSQxIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJzZXRUb1N0cmluZ1RhZyQyIiwiSXRlcmF0b3JzJDQiLCJyZXR1cm5UaGlzJDEiLCJjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDEiLCJJdGVyYXRvckNvbnN0cnVjdG9yIiwiTkFNRSIsIm5leHQiLCJFTlVNRVJBQkxFX05FWFQiLCJUT19TVFJJTkdfVEFHIiwiaXNDYWxsYWJsZSQ4IiwiJFN0cmluZyQxIiwiJFR5cGVFcnJvciQ4IiwiYVBvc3NpYmxlUHJvdG90eXBlJDEiLCJ1bmN1cnJ5VGhpcyQ3IiwiYW5PYmplY3QkNyIsImFQb3NzaWJsZVByb3RvdHlwZSIsIm9iamVjdFNldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJDT1JSRUNUX1NFVFRFUiIsInByb3RvIiwiX19wcm90b19fIiwiJCRjIiwiY2FsbCRhIiwiRnVuY3Rpb25OYW1lIiwiaXNDYWxsYWJsZSQ3IiwiY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciIsInNldFByb3RvdHlwZU9mJDEiLCJzZXRUb1N0cmluZ1RhZyQxIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEiLCJkZWZpbmVCdWlsdEluJDMiLCJ3ZWxsS25vd25TeW1ib2wkYiIsIkl0ZXJhdG9ycyQzIiwiSXRlcmF0b3JzQ29yZSIsIlBST1BFUl9GVU5DVElPTl9OQU1FJDEiLCJDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSIsIklURVJBVE9SJDQiLCJLRVlTIiwiVkFMVUVTIiwiRU5UUklFUyIsInJldHVyblRoaXMiLCJkZWZpbmVJdGVyYXRvciQxIiwiSXRlcmFibGUiLCJERUZBVUxUIiwiSVNfU0VUIiwiZ2V0SXRlcmF0aW9uTWV0aG9kIiwiS0lORCIsImRlZmF1bHRJdGVyYXRvciIsIkl0ZXJhYmxlUHJvdG90eXBlIiwidmFsdWVzIiwiZW50cmllcyIsIklOQ09SUkVDVF9WQUxVRVNfTkFNRSIsIm5hdGl2ZUl0ZXJhdG9yIiwiYW55TmF0aXZlSXRlcmF0b3IiLCJDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUiLCJtZXRob2RzIiwiS0VZIiwidG9JbmRleGVkT2JqZWN0IiwiYWRkVG9VbnNjb3BhYmxlcyQxIiwiSXRlcmF0b3JzJDIiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDEiLCJkZWZpbmVQcm9wZXJ0eSQyIiwiZGVmaW5lSXRlcmF0b3IiLCJERVNDUklQVE9SUyQzIiwiQVJSQVlfSVRFUkFUT1IiLCJzZXRJbnRlcm5hbFN0YXRlJDEiLCJnZXRJbnRlcm5hbFN0YXRlIiwiZXNfYXJyYXlfaXRlcmF0b3IiLCJpdGVyYXRlZCIsImtpbmQiLCJkb25lIiwiQXJndW1lbnRzIiwiZG9tSXRlcmFibGVzIiwiQ1NTUnVsZUxpc3QiLCJDU1NTdHlsZURlY2xhcmF0aW9uIiwiQ1NTVmFsdWVMaXN0IiwiQ2xpZW50UmVjdExpc3QiLCJET01SZWN0TGlzdCIsIkRPTVN0cmluZ0xpc3QiLCJET01Ub2tlbkxpc3QiLCJEYXRhVHJhbnNmZXJJdGVtTGlzdCIsIkZpbGVMaXN0IiwiSFRNTEFsbENvbGxlY3Rpb24iLCJIVE1MQ29sbGVjdGlvbiIsIkhUTUxGb3JtRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiTWVkaWFMaXN0IiwiTWltZVR5cGVBcnJheSIsIk5hbWVkTm9kZU1hcCIsIk5vZGVMaXN0IiwiUGFpbnRSZXF1ZXN0TGlzdCIsIlBsdWdpbiIsIlBsdWdpbkFycmF5IiwiU1ZHTGVuZ3RoTGlzdCIsIlNWR051bWJlckxpc3QiLCJTVkdQYXRoU2VnTGlzdCIsIlNWR1BvaW50TGlzdCIsIlNWR1N0cmluZ0xpc3QiLCJTVkdUcmFuc2Zvcm1MaXN0IiwiU291cmNlQnVmZmVyTGlzdCIsIlN0eWxlU2hlZXRMaXN0IiwiVGV4dFRyYWNrQ3VlTGlzdCIsIlRleHRUcmFja0xpc3QiLCJUb3VjaExpc3QiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJET01Ub2tlbkxpc3RQcm90b3R5cGUkMSIsImRvbVRva2VuTGlzdFByb3RvdHlwZSIsImdsb2JhbCRhIiwiRE9NSXRlcmFibGVzIiwiRE9NVG9rZW5MaXN0UHJvdG90eXBlIiwiQXJyYXlJdGVyYXRvck1ldGhvZHMiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkiLCJ3ZWxsS25vd25TeW1ib2wkYSIsIklURVJBVE9SJDMiLCJUT19TVFJJTkdfVEFHJDIiLCJBcnJheVZhbHVlcyIsImhhbmRsZVByb3RvdHlwZSIsIkNvbGxlY3Rpb25Qcm90b3R5cGUiLCJDT0xMRUNUSU9OX05BTUUiLCJNRVRIT0RfTkFNRSIsIkRFU0NSSVBUT1JTJDIiLCJ1bmN1cnJ5VGhpcyQ2IiwiY2FsbCQ5IiwiZmFpbHMkNiIsIm9iamVjdEtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsInRvT2JqZWN0JDIiLCJJbmRleGVkT2JqZWN0JDEiLCIkYXNzaWduIiwiYXNzaWduIiwiZGVmaW5lUHJvcGVydHkkMSIsIm9iamVjdEFzc2lnbiIsImIiLCJBIiwiQiIsImFscGhhYmV0IiwiZm9yRWFjaCIsImNociIsIlQiLCJhcmd1bWVudHNMZW5ndGgiLCJTIiwiaiIsIiQkYiIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJlIiwicmVqZWN0ZWQiLCJ0aGVuIiwiU3VwcHJlc3NlZEVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJFcnJvciIsIkNsb3NlSWNvbiIsInhtbG5zIiwiaGVpZ2h0Iiwidmlld0JveCIsIndpZHRoIiwiZmlsbCIsImNoaWxkcmVuIiwiZCIsIkNsb3NlQnV0dG9uIiwib25DbGljayIsImNsYXNzTmFtZSIsIk1vZGFsSGVhZGVyIiwidGl0bGUiLCJvbkNsb3NlTW9kYWwiLCJhZGRpdGlvbmFsQ2xhc3NlcyIsIkJhY2tBcnJvd0ljb24iLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsIkJhY2tBcnJvdyIsIldhbGxldE5ldHdvcmtDaGFuZ2VkIiwic2VsZWN0b3IiLCJvbkJhY2siLCJuZXR3b3JrIiwibmV0d29ya0lkIiwidHJ5VG9TdHJpbmckMyIsIiRUeXBlRXJyb3IkNyIsImRlbGV0ZVByb3BlcnR5T3JUaHJvdyQxIiwid2VsbEtub3duU3ltYm9sJDkiLCJUT19TVFJJTkdfVEFHJDEiLCJ0ZXN0JDEiLCJ0b1N0cmluZ1RhZ1N1cHBvcnQiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJpc0NhbGxhYmxlJDYiLCJjbGFzc29mUmF3Iiwid2VsbEtub3duU3ltYm9sJDgiLCIkT2JqZWN0IiwiQ09SUkVDVF9BUkdVTUVOVFMiLCJ0cnlHZXQiLCJjbGFzc29mJDUiLCJ0YWciLCJjYWxsZWUiLCJjbGFzc29mJDQiLCIkU3RyaW5nIiwidG9TdHJpbmckMyIsInRvUHJvcGVydHlLZXkiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yIiwiY3JlYXRlUHJvcGVydHkkMSIsInByb3BlcnR5S2V5IiwidG9BYnNvbHV0ZUluZGV4IiwibGVuZ3RoT2ZBcnJheUxpa2UkMyIsImNyZWF0ZVByb3BlcnR5IiwiJEFycmF5IiwiYXJyYXlTbGljZVNpbXBsZSIsInN0YXJ0IiwiZW5kIiwiayIsImZpbiIsImFycmF5U2xpY2UkMiIsIm1lcmdlU29ydCIsImFycmF5IiwiY29tcGFyZWZuIiwibWlkZGxlIiwiaW5zZXJ0aW9uU29ydCIsIm1lcmdlIiwiZWxlbWVudCIsImxlZnQiLCJyaWdodCIsImxsZW5ndGgiLCJybGVuZ3RoIiwibGluZGV4IiwicmluZGV4IiwiYXJyYXlTb3J0IiwiZmFpbHMkNSIsImFycmF5TWV0aG9kSXNTdHJpY3QkMiIsInVzZXJBZ2VudCQ0IiwiZmlyZWZveCIsImVuZ2luZUZmVmVyc2lvbiIsIlVBIiwiZW5naW5lSXNJZU9yRWRnZSIsInVzZXJBZ2VudCQzIiwid2Via2l0IiwiZW5naW5lV2Via2l0VmVyc2lvbiIsIiQkYSIsInVuY3VycnlUaGlzJDUiLCJhQ2FsbGFibGUkNyIsInRvT2JqZWN0JDEiLCJsZW5ndGhPZkFycmF5TGlrZSQyIiwiZGVsZXRlUHJvcGVydHlPclRocm93IiwidG9TdHJpbmckMiIsImZhaWxzJDQiLCJpbnRlcm5hbFNvcnQiLCJhcnJheU1ldGhvZElzU3RyaWN0JDEiLCJGRiIsIklFX09SX0VER0UiLCJWOCIsIldFQktJVCIsInVuJFNvcnQiLCJzb3J0IiwiRkFJTFNfT05fVU5ERUZJTkVEIiwiRkFJTFNfT05fTlVMTCIsIlNUUklDVF9NRVRIT0QkMSIsIlNUQUJMRV9TT1JUIiwiY29kZSIsImZyb21DaGFyQ29kZSIsInYiLCJjaGFyQXQiLCJnZXRTb3J0Q29tcGFyZSIsInkiLCJpdGVtcyIsImFycmF5TGVuZ3RoIiwiaXRlbXNMZW5ndGgiLCIkJDkiLCIkaW5jbHVkZXMiLCJmYWlscyQzIiwiYWRkVG9VbnNjb3BhYmxlcyIsIkJST0tFTl9PTl9TUEFSU0UiLCJpc09iamVjdCQyIiwiY2xhc3NvZiQzIiwid2VsbEtub3duU3ltYm9sJDciLCJNQVRDSCQxIiwiaXNSZWdleHAiLCJpc1JlZ0V4cCIsIiRUeXBlRXJyb3IkNiIsIm5vdEFSZWdleHAiLCJ3ZWxsS25vd25TeW1ib2wkNiIsIk1BVENIIiwiY29ycmVjdElzUmVnZXhwTG9naWMiLCJyZWdleHAiLCJlcnJvcjEiLCJlcnJvcjIiLCIkJDgiLCJ1bmN1cnJ5VGhpcyQ0Iiwibm90QVJlZ0V4cCIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCJ0b1N0cmluZyQxIiwiY29ycmVjdElzUmVnRXhwTG9naWMiLCJzdHJpbmdJbmRleE9mIiwic2VhcmNoU3RyaW5nIiwiYUNhbGxhYmxlJDYiLCJ0b09iamVjdCIsIkluZGV4ZWRPYmplY3QiLCJsZW5ndGhPZkFycmF5TGlrZSQxIiwiJFR5cGVFcnJvciQ1IiwiY3JlYXRlTWV0aG9kIiwiSVNfUklHSFQiLCJ0aGF0IiwiY2FsbGJhY2tmbiIsIm1lbW8iLCJhcnJheVJlZHVjZSIsImNsYXNzb2YkMiIsImdsb2JhbCQ5IiwiZW5naW5lSXNOb2RlIiwiJCQ3IiwiJHJlZHVjZSIsImFycmF5TWV0aG9kSXNTdHJpY3QiLCJDSFJPTUVfVkVSU0lPTiIsIklTX05PREUkMyIsIlNUUklDVF9NRVRIT0QiLCJDSFJPTUVfQlVHIiwicmVkdWNlIiwiJCQ2IiwiREVTQ1JJUFRPUlMkMSIsImdsb2JhbCQ4IiwidW5jdXJyeVRoaXMkMyIsImhhc093biQyIiwiaXNDYWxsYWJsZSQ1IiwiaXNQcm90b3R5cGVPZiQzIiwiY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyIsIk5hdGl2ZVN5bWJvbCIsIlN5bWJvbFByb3RvdHlwZSIsIkVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSIsIlN5bWJvbFdyYXBwZXIiLCJOQVRJVkVfU1lNQk9MIiwic3ltYm9sVG9TdHJpbmciLCJzeW1ib2xWYWx1ZU9mIiwic3RyaW5nU2xpY2UiLCJkZXNjIiwiV2FybmluZ0ljb24iLCJXYWxsZXRPcHRpb25zIiwiaGFuZGxlV2FsbGV0Q2xpY2siLCJtb2R1bGVzIiwic2V0TW9kdWxlcyIsInJlY2VudE1vZHVsZXMiLCJzZXRSZWNlbnRNb2R1bGVzIiwibW9yZU1vZHVsZXMiLCJzZXRNb3JlTW9kdWxlcyIsImFjdGl2ZVdhbGxldElkIiwic2V0QWN0aXZlV2FsbGV0SWQiLCJzdWJzY3JpcHRpb24iLCJvYnNlcnZhYmxlIiwic3Vic2NyaWJlIiwic2VsZWN0ZWRXYWxsZXRJZCIsImdldFN0YXRlIiwid2FsbGV0cyIsImZpbHRlciIsIm1vZHVsZSIsIm9wdGltaXplV2FsbGV0T3JkZXIiLCJkZXByZWNhdGVkIiwiYXZhaWxhYmxlIiwibW9yZVdhbGxldHMiLCJyZWNlbnRseVNpZ25lZEluV2FsbGV0cyIsInJhbmRvbWl6ZVdhbGxldE9yZGVyIiwidW5zdWJzY3JpYmUiLCJyZW5kZXJPcHRpb25zTGlzdCIsIm1vZHVsZXNUb1JlbmRlciIsImljb25VcmwiLCJzZWxlY3RlZCIsInRhYkluZGV4IiwiYWx0IiwiQ29ubmVjdGlvbkVycm9ySWNvbiIsIkNvbm5lY3Rpb25TdWNjZXNzSWNvbiIsIkNvbm5lY3Rpb25SZXN1bHQiLCJlcnIiLCJvblJldHJ5IiwiQWxlcnRNZXNzYWdlIiwiZ2V0QnVpbHRJbiQzIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUiLCJ3ZWxsS25vd25TeW1ib2wkNSIsIkRFU0NSSVBUT1JTIiwiU1BFQ0lFUyQyIiwic2V0U3BlY2llcyQxIiwiQ09OU1RSVUNUT1JfTkFNRSIsIkNvbnN0cnVjdG9yIiwiaXNQcm90b3R5cGVPZiQyIiwiJFR5cGVFcnJvciQ0IiwiYW5JbnN0YW5jZSQxIiwiUHJvdG90eXBlIiwidW5jdXJyeVRoaXMkMiIsImZhaWxzJDIiLCJpc0NhbGxhYmxlJDQiLCJjbGFzc29mJDEiLCJnZXRCdWlsdEluJDIiLCJpbnNwZWN0U291cmNlJDEiLCJub29wIiwiZW1wdHkiLCJjb25zdHJ1Y3QiLCJjb25zdHJ1Y3RvclJlZ0V4cCIsIklOQ09SUkVDVF9UT19TVFJJTkciLCJpc0NvbnN0cnVjdG9yTW9kZXJuIiwiaXNDb25zdHJ1Y3RvciIsImlzQ29uc3RydWN0b3JMZWdhY3kiLCJpc0NvbnN0cnVjdG9yJDEiLCJjYWxsZWQiLCJ0cnlUb1N0cmluZyQyIiwiJFR5cGVFcnJvciQzIiwiYUNvbnN0cnVjdG9yJDEiLCJhbk9iamVjdCQ2IiwiYUNvbnN0cnVjdG9yIiwid2VsbEtub3duU3ltYm9sJDQiLCJTUEVDSUVTJDEiLCJzcGVjaWVzQ29uc3RydWN0b3IkMSIsImRlZmF1bHRDb25zdHJ1Y3RvciIsIkMiLCJOQVRJVkVfQklORCQxIiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJhcHBseSQxIiwiY2FsbCQ4IiwiZnVuY3Rpb25BcHBseSIsIlJlZmxlY3QiLCJ1bmN1cnJ5VGhpcyQxIiwiYUNhbGxhYmxlJDUiLCJOQVRJVkVfQklORCIsImJpbmQkNCIsImZ1bmN0aW9uQmluZENvbnRleHQiLCJ1bmN1cnJ5VGhpcyIsImFycmF5U2xpY2UkMSIsIiRUeXBlRXJyb3IkMiIsInZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEiLCJwYXNzZWQiLCJyZXF1aXJlZCIsInVzZXJBZ2VudCQyIiwiZW5naW5lSXNJb3MiLCJnbG9iYWwkNyIsImJpbmQkMyIsImlzQ2FsbGFibGUkMyIsImhhc093biQxIiwiZmFpbHMkMSIsImh0bWwiLCJhcnJheVNsaWNlIiwidmFsaWRhdGVBcmd1bWVudHNMZW5ndGgiLCJJU19JT1MkMSIsIklTX05PREUkMiIsInNldEltbWVkaWF0ZSIsImNsZWFyIiwiY2xlYXJJbW1lZGlhdGUiLCJwcm9jZXNzJDIiLCJEaXNwYXRjaCIsIkZ1bmN0aW9uJDEiLCJNZXNzYWdlQ2hhbm5lbCIsIlN0cmluZyQxIiwiY291bnRlciIsInF1ZXVlJDEiLCJPTlJFQURZU1RBVEVDSEFOR0UiLCJsb2NhdGlvbiIsImRlZmVyIiwiY2hhbm5lbCIsInBvcnQiLCJydW4iLCJydW5uZXIiLCJsaXN0ZW5lciIsImV2ZW50IiwicG9zdCIsInBvc3RNZXNzYWdlIiwicHJvdG9jb2wiLCJob3N0IiwiaGFuZGxlciIsImFyZ3MiLCJuZXh0VGljayIsIm5vdyIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsInRhc2skMSIsInVzZXJBZ2VudCQxIiwiZ2xvYmFsJDYiLCJlbmdpbmVJc0lvc1BlYmJsZSIsIlBlYmJsZSIsInVzZXJBZ2VudCIsImVuZ2luZUlzV2Vib3NXZWJraXQiLCJnbG9iYWwkNSIsImJpbmQkMiIsIm1hY3JvdGFzayIsIklTX0lPUyIsIklTX0lPU19QRUJCTEUiLCJJU19XRUJPU19XRUJLSVQiLCJJU19OT0RFJDEiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImRvY3VtZW50JDIiLCJwcm9jZXNzJDEiLCJQcm9taXNlJDEiLCJxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IiLCJxdWV1ZU1pY3JvdGFzayIsImZsdXNoIiwiaGVhZCIsImxhc3QiLCJub3RpZnkkMSIsInRvZ2dsZSIsIm5vZGUiLCJwcm9taXNlIiwicGFyZW50IiwiZXhpdCIsImVudGVyIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsIm1pY3JvdGFzayQxIiwidGFzayIsImdsb2JhbCQ0IiwiaG9zdFJlcG9ydEVycm9ycyQxIiwiY29uc29sZSIsInBlcmZvcm0kMyIsIlF1ZXVlJDEiLCJ0YWlsIiwiYWRkIiwiaXRlbSIsImVudHJ5IiwicXVldWUiLCJnbG9iYWwkMyIsInByb21pc2VOYXRpdmVDb25zdHJ1Y3RvciIsImVuZ2luZUlzQnJvd3NlciIsImdsb2JhbCQyIiwiTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMiLCJpc0NhbGxhYmxlJDIiLCJpc0ZvcmNlZCIsIndlbGxLbm93blN5bWJvbCQzIiwiSVNfQlJPV1NFUiIsIlY4X1ZFUlNJT04iLCJTUEVDSUVTIiwiU1VCQ0xBU1NJTkciLCJOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUiLCJQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSIsIkdMT0JBTF9DT1JFX0pTX1BST01JU0UiLCJGYWtlUHJvbWlzZSIsInByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiIsIkNPTlNUUlVDVE9SIiwiUkVKRUNUSU9OX0VWRU5UIiwibmV3UHJvbWlzZUNhcGFiaWxpdHkkMiIsImFDYWxsYWJsZSQ0IiwiUHJvbWlzZUNhcGFiaWxpdHkiLCIkJHJlc29sdmUiLCIkJHJlamVjdCIsIiQkNSIsIklTX05PREUiLCJnbG9iYWwkMSIsImNhbGwkNyIsImRlZmluZUJ1aWx0SW4kMiIsInNldFRvU3RyaW5nVGFnIiwic2V0U3BlY2llcyIsImFDYWxsYWJsZSQzIiwiaXNDYWxsYWJsZSQxIiwiaXNPYmplY3QkMSIsImFuSW5zdGFuY2UiLCJzcGVjaWVzQ29uc3RydWN0b3IiLCJtaWNyb3Rhc2siLCJob3N0UmVwb3J0RXJyb3JzIiwicGVyZm9ybSQyIiwiUXVldWUiLCJJbnRlcm5hbFN0YXRlTW9kdWxlIiwiTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIiLCJQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24iLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzIiwiUFJPTUlTRSIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQiLCJOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQiLCJOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyIsImdldEludGVybmFsUHJvbWlzZVN0YXRlIiwic2V0SW50ZXJuYWxTdGF0ZSIsIk5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSIsIlByb21pc2VDb25zdHJ1Y3RvciIsIlByb21pc2VQcm90b3R5cGUiLCJUeXBlRXJyb3IkMSIsImRvY3VtZW50JDEiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eSQxIiwibmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5IiwiRElTUEFUQ0hfRVZFTlQiLCJjcmVhdGVFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJVTkhBTkRMRURfUkVKRUNUSU9OIiwiUkVKRUNUSU9OX0hBTkRMRUQiLCJQRU5ESU5HIiwiRlVMRklMTEVEIiwiUkVKRUNURUQiLCJIQU5ETEVEIiwiVU5IQU5ETEVEIiwiSW50ZXJuYWwiLCJPd25Qcm9taXNlQ2FwYWJpbGl0eSIsIlByb21pc2VXcmFwcGVyIiwibmF0aXZlVGhlbiIsImlzVGhlbmFibGUiLCJjYWxsUmVhY3Rpb24iLCJyZWFjdGlvbiIsIm9rIiwiZmFpbCIsImV4aXRlZCIsInJlamVjdGlvbiIsIm9uSGFuZGxlVW5oYW5kbGVkIiwibm90aWZ5IiwiaXNSZWplY3QiLCJub3RpZmllZCIsInJlYWN0aW9ucyIsIm9uVW5oYW5kbGVkIiwicmVhc29uIiwiaW5pdEV2ZW50IiwiSVNfVU5IQU5ETEVEIiwiaXNVbmhhbmRsZWQiLCJlbWl0IiwiYmluZCQxIiwidW53cmFwIiwiaW50ZXJuYWxSZWplY3QiLCJpbnRlcm5hbFJlc29sdmUiLCJ3cmFwcGVyIiwiZXhlY3V0b3IiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJ3cmFwIiwid2VsbEtub3duU3ltYm9sJDIiLCJJdGVyYXRvcnMkMSIsIklURVJBVE9SJDIiLCJBcnJheVByb3RvdHlwZSIsImlzQXJyYXlJdGVyYXRvck1ldGhvZCQxIiwiY2xhc3NvZiIsImdldE1ldGhvZCQxIiwiSXRlcmF0b3JzIiwid2VsbEtub3duU3ltYm9sJDEiLCJJVEVSQVRPUiQxIiwiZ2V0SXRlcmF0b3JNZXRob2QkMiIsImNhbGwkNiIsImFDYWxsYWJsZSQyIiwiYW5PYmplY3QkNSIsInRyeVRvU3RyaW5nJDEiLCJnZXRJdGVyYXRvck1ldGhvZCQxIiwiJFR5cGVFcnJvciQxIiwiZ2V0SXRlcmF0b3IkMSIsInVzaW5nSXRlcmF0b3IiLCJpdGVyYXRvck1ldGhvZCIsImNhbGwkNSIsImFuT2JqZWN0JDQiLCJnZXRNZXRob2QiLCJpdGVyYXRvckNsb3NlJDEiLCJpbm5lclJlc3VsdCIsImlubmVyRXJyb3IiLCJjYWxsJDQiLCJhbk9iamVjdCQzIiwidHJ5VG9TdHJpbmciLCJpc0FycmF5SXRlcmF0b3JNZXRob2QiLCJsZW5ndGhPZkFycmF5TGlrZSIsImlzUHJvdG90eXBlT2YkMSIsImdldEl0ZXJhdG9yIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJpdGVyYXRvckNsb3NlIiwiJFR5cGVFcnJvciIsIlJlc3VsdCIsInN0b3BwZWQiLCJSZXN1bHRQcm90b3R5cGUiLCJpdGVyYXRlJDIiLCJpdGVyYWJsZSIsInVuYm91bmRGdW5jdGlvbiIsIkFTX0VOVFJJRVMiLCJJU19JVEVSQVRPUiIsIklOVEVSUlVQVEVEIiwiaXRlckZuIiwic3RvcCIsImNvbmRpdGlvbiIsImNhbGxGbiIsIndlbGxLbm93blN5bWJvbCIsIklURVJBVE9SIiwiU0FGRV9DTE9TSU5HIiwiaXRlcmF0b3JXaXRoUmV0dXJuIiwiZnJvbSIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxIiwiU0tJUF9DTE9TSU5HIiwiSVRFUkFUSU9OX1NVUFBPUlQiLCJOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMSIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMiLCJwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbiIsImFsbCIsIiQkNCIsImNhbGwkMyIsImFDYWxsYWJsZSQxIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMiIsInBlcmZvcm0kMSIsIml0ZXJhdGUkMSIsIlBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEiLCJjYXBhYmlsaXR5IiwiJHByb21pc2VSZXNvbHZlIiwicmVtYWluaW5nIiwiYWxyZWFkeUNhbGxlZCIsIiQkMyIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIiLCJOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IiLCJnZXRCdWlsdEluJDEiLCJpc0NhbGxhYmxlIiwiZGVmaW5lQnVpbHRJbiQxIiwiTmF0aXZlUHJvbWlzZVByb3RvdHlwZSIsInJlYWwiLCIkJDIiLCJjYWxsJDIiLCJhQ2FsbGFibGUiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxIiwicGVyZm9ybSIsIml0ZXJhdGUiLCJQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiIsInJhY2UiLCIkJDEiLCJjYWxsJDEiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEiLCJyIiwiYW5PYmplY3QkMiIsImlzT2JqZWN0IiwibmV3UHJvbWlzZUNhcGFiaWxpdHkiLCJwcm9taXNlUmVzb2x2ZSQxIiwicHJvbWlzZUNhcGFiaWxpdHkiLCIkIiwiZ2V0QnVpbHRJbiIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIiwicHJvbWlzZVJlc29sdmUiLCJIYXJkd2FyZVdhbGxldEFjY291bnRzRm9ybSIsImFjY291bnRzIiwib25TZWxlY3RlZENoYW5nZWQiLCJvblN1Ym1pdCIsIm9uQ2hhbmdlUm91dGUiLCJtYXAiLCJhY2NvdW50Iiwib25DaGFuZ2UiLCJjaGVja2VkIiwiYWNjb3VudElkIiwiaHRtbEZvciIsImRpc2FibGVkIiwic29tZSIsImltZyIsIldhbGxldENvbm5lY3RpbmciLCJ3YWxsZXQiLCJMZWRnZXJEZXZpY2VJY29uIiwiZmlsbFJ1bGUiLCJjbGlwUnVsZSIsImN4IiwiY3kiLCJyeCIsInJ5IiwidHJhbnNmb3JtIiwieDEiLCJ5MSIsIngyIiwieTIiLCJncmFkaWVudFVuaXRzIiwib2Zmc2V0Iiwic3RvcENvbG9yIiwiVXBBcnJvd0ljb24iLCJEb3duQXJyb3dJY29uIiwiREVGQVVMVF9ERVJJVkFUSU9OX1BBVEgiLCJEZXJpdmF0aW9uUGF0aCIsIm9uQ29ubmVjdGVkIiwicGFyYW1zIiwib25FcnJvciIsInJvdXRlIiwic2V0Um91dGUiLCJkZXJpdmF0aW9uUGF0aCIsInNldERlcml2YXRpb25QYXRoIiwiY3VzdG9tRGVyaXZhdGlvblBhdGgiLCJzZXRDdXN0b21EZXJpdmF0aW9uUGF0aCIsInNldEFjY291bnRzIiwic2VsZWN0ZWRBY2NvdW50cyIsInNldFNlbGVjdGVkQWNjb3VudHMiLCJoYXJkd2FyZVdhbGxldCIsInNldEhhcmR3YXJlV2FsbGV0IiwiY3VzdG9tQWNjb3VudElkIiwic2V0Q3VzdG9tQWNjb3VudElkIiwiY29ubmVjdGluZyIsInNldENvbm5lY3RpbmciLCJpbml0YWxIZWFkZXJUaXRsZSIsImhlYWRlclRpdGxlIiwic2V0SGVhZGVyVGl0bGUiLCJnZXRBY2NvdW50SWRzIiwicHVibGljS2V5IiwicmVzcG9uc2UiLCJmZXRjaCIsImluZGV4ZXJVcmwiLCJhY2NvdW50SWRzIiwianNvbiIsImlzQXJyYXkiLCJyZXNvbHZlQWNjb3VudHMiLCJnZXRQdWJsaWNLZXkiLCJoYW5kbGVWYWxpZGF0ZUFjY291bnQiLCJ3YWxsZXRJZCIsInJlc29sdmVkQWNjb3VudHMiLCJub0FjY291bnRzIiwibXVsdGlwbGVBY2NvdW50cyIsImhhbmRsZUFkZEN1c3RvbUFjY291bnRJZCIsImFjY291bnRMaXN0IiwiaGFuZGxlU2lnbkluIiwibWFwQWNjb3VudHMiLCJzaWduSW4iLCJjb250cmFjdElkIiwibWV0aG9kTmFtZXMiLCJjYXRjaCIsImhhbmRsZU9uQmFja0J1dHRvbkNsaWNrIiwibmV3VmFsdWUiLCJwYXRoIiwiaHJlZiIsInByZXZBY2NvdW50cyIsInVwZGF0ZUFjY291bnRzIiwiaWR4Iiwic2VsZWN0ZWRWYWx1ZSIsImFjYyIsInByZXZlbnREZWZhdWx0Iiwic2VsZWN0ZWRBY2MiLCJudW1iZXJPZkFjY291bnRzIiwibmV3Um91dGUiLCJwbGFjZWhvbGRlciIsIldhbGxldE5vdEluc3RhbGxlZCIsInJlbG9hZCIsImRvd25sb2FkVXJsIiwiUVJJY29uIiwiTGlua0ljb24iLCJLZXlJY29uIiwiRm9sZGVySWNvbiIsIldhbGxldEhvbWUiLCJmaWx0ZXJCeVR5cGUiLCJmaWx0ZXJlZE1vZHVsZXMiLCJnZXRXYWxsZXRVcmwiLCJ1cmwiLCJ3YWxsZXRVcmwiLCJxckljb24iLCJoZXJlV2FsbGV0VHlwZSIsIldhbGxldENvbm5lY3RlZCIsImFuT2JqZWN0JDEiLCJyZWdleHBGbGFncyIsImhhc0luZGljZXMiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwiZG90QWxsIiwidW5pY29kZSIsInVuaWNvZGVTZXRzIiwic3RpY2t5IiwicmVnRXhwRmxhZ3MiLCJSZWdFeHBQcm90b3R5cGUkMSIsIlJlZ0V4cCIsInJlZ2V4cEdldEZsYWdzIiwiUiIsImZsYWdzIiwiUFJPUEVSX0ZVTkNUSU9OX05BTUUiLCJkZWZpbmVCdWlsdEluIiwiYW5PYmplY3QiLCIkdG9TdHJpbmciLCJmYWlscyIsImdldFJlZ0V4cEZsYWdzIiwiVE9fU1RSSU5HIiwiUmVnRXhwUHJvdG90eXBlIiwibiRUb1N0cmluZyIsIk5PVF9HRU5FUklDIiwiSU5DT1JSRUNUX05BTUUiLCJwYXR0ZXJuIiwiQ29weUljb24iLCJmb3JtYXRRUkNvZGVJbWFnZSIsIm1hcmdpbiIsIlNjYW5RUkNvZGUiLCJ1cmkiLCJoYW5kbGVPcGVuRGVmYXVsdE1vZGFsIiwibm90aWZpY2F0aW9uIiwic2V0Tm90aWZpY2F0aW9uIiwic3ZnIiwic2V0U3ZnIiwiY29weVRvQ2xpcGJvYXJkIiwic3VjY2VzcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiZ2V0VGhlbWVDbGFzcyIsInRoZW1lIiwiTW9kYWwiLCJ2aXNpYmxlIiwiaGlkZSIsImVtaXR0ZXIiLCJfYSIsIl9iIiwiX2MiLCJhbGVydE1lc3NhZ2UiLCJzZXRBbGVydE1lc3NhZ2UiLCJzZWxlY3RlZFdhbGxldCIsInNldFNlbGVjdGVkV2FsbGV0IiwiYnJpZGdlV2FsbGV0VXJpIiwic2V0QnJpZGdlV2FsbGV0VXJpIiwibGFuZ3VhZ2VDb2RlIiwiZmluZCIsIm0iLCJvbiIsImhhbmRsZURpc21pc3NDbGljayIsInJlbW92ZSIsImhpZGVSZWFzb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicXJDb2RlTW9kYWwiLCJzdWNjZXNzVXJsIiwiZmFpbHVyZVVybCIsInJldHJ5IiwiZmluZE1vZHVsZSIsIk1PREFMX0VMRU1FTlRfSUQiLCJtb2RhbEluc3RhbmNlIiwicm9vdCIsInNldHVwTW9kYWwiLCJib2R5IiwiY29udGFpbmVyIiwicmVuZGVyIiwic2hvdyIsImV2ZW50TmFtZSIsImNhbGxiYWNrIiwib2ZmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/modal-ui/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/my-near-wallet/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/my-near-wallet/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupMyNearWallet: () => (/* binding */ setupMyNearWallet)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var _near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @near-wallet-selector/wallet-utils */ \"(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.js\");\n\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar check = function(it) {\n    return it && it.Math == Math && it;\n};\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$o = // eslint-disable-next-line es-x/no-global-this -- safe\ncheck(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\ncheck(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback\nfunction() {\n    return this;\n}() || Function(\"return this\")();\nvar objectGetOwnPropertyDescriptor = {};\nvar fails$k = function(exec) {\n    try {\n        return !!exec();\n    } catch (error) {\n        return true;\n    }\n};\nvar fails$j = fails$k;\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$j(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty({}, 1, {\n        get: function() {\n            return 7;\n        }\n    })[1] != 7;\n});\nvar fails$i = fails$k;\nvar functionBindNative = !fails$i(function() {\n    // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n    var test = (function() {}).bind();\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$3 = functionBindNative;\nvar call$k = Function.prototype.call;\nvar functionCall = NATIVE_BIND$3 ? call$k.bind(call$k) : function() {\n    return call$k.apply(call$k, arguments);\n};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({\n    1: 2\n}, 1);\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n    var descriptor = getOwnPropertyDescriptor$3(this, V);\n    return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar createPropertyDescriptor$5 = function(bitmap, value) {\n    return {\n        enumerable: !(bitmap & 1),\n        configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        value: value\n    };\n};\nvar NATIVE_BIND$2 = functionBindNative;\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$8 = FunctionPrototype$2.bind;\nvar call$j = FunctionPrototype$2.call;\nvar uncurryThis$m = NATIVE_BIND$2 && bind$8.bind(call$j, call$j);\nvar functionUncurryThis = NATIVE_BIND$2 ? function(fn) {\n    return fn && uncurryThis$m(fn);\n} : function(fn) {\n    return fn && function() {\n        return call$j.apply(fn, arguments);\n    };\n};\nvar uncurryThis$l = functionUncurryThis;\nvar toString$6 = uncurryThis$l({}.toString);\nvar stringSlice$6 = uncurryThis$l(\"\".slice);\nvar classofRaw$1 = function(it) {\n    return stringSlice$6(toString$6(it), 8, -1);\n};\nvar uncurryThis$k = functionUncurryThis;\nvar fails$h = fails$k;\nvar classof$7 = classofRaw$1;\nvar $Object$4 = Object;\nvar split$3 = uncurryThis$k(\"\".split);\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$h(function() {\n    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return !$Object$4(\"z\").propertyIsEnumerable(0);\n}) ? function(it) {\n    return classof$7(it) == \"String\" ? split$3(it, \"\") : $Object$4(it);\n} : $Object$4;\nvar $TypeError$c = TypeError;\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$4 = function(it) {\n    if (it == undefined) throw $TypeError$c(\"Can't call method on \" + it);\n    return it;\n};\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$3 = requireObjectCoercible$4;\nvar toIndexedObject$5 = function(it) {\n    return IndexedObject$1(requireObjectCoercible$3(it));\n};\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function(argument) {\n    return typeof argument == \"function\";\n};\nvar isCallable$m = isCallable$n;\nvar isObject$8 = function(it) {\n    return typeof it == \"object\" ? it !== null : isCallable$m(it);\n};\nvar global$n = global$o;\nvar isCallable$l = isCallable$n;\nvar aFunction = function(argument) {\n    return isCallable$l(argument) ? argument : undefined;\n};\nvar getBuiltIn$8 = function(namespace, method) {\n    return arguments.length < 2 ? aFunction(global$n[namespace]) : global$n[namespace] && global$n[namespace][method];\n};\nvar uncurryThis$j = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$j({}.isPrototypeOf);\nvar getBuiltIn$7 = getBuiltIn$8;\nvar engineUserAgent = getBuiltIn$7(\"navigator\", \"userAgent\") || \"\";\nvar global$m = global$o;\nvar userAgent$3 = engineUserAgent;\nvar process$3 = global$m.process;\nvar Deno$1 = global$m.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n    match = v8.split(\".\");\n    // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n    // but their correct versions are not interesting for us\n    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$3) {\n    match = userAgent$3.match(/Edge\\/(\\d+)/);\n    if (!match || match[1] >= 74) {\n        match = userAgent$3.match(/Chrome\\/(\\d+)/);\n        if (match) version = +match[1];\n    }\n}\nvar engineV8Version = version;\n/* eslint-disable es-x/no-symbol -- required for testing */ var V8_VERSION$1 = engineV8Version;\nvar fails$g = fails$k;\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function() {\n    var symbol = Symbol();\n    // Chrome 38 Symbol has incorrect toString conversion\n    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n/* eslint-disable es-x/no-symbol -- required for testing */ var NATIVE_SYMBOL$1 = nativeSymbol;\nvar useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar $Object$3 = Object;\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {\n    return typeof it == \"symbol\";\n} : function(it) {\n    var $Symbol = getBuiltIn$6(\"Symbol\");\n    return isCallable$k($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$3(it));\n};\nvar $String$3 = String;\nvar tryToString$4 = function(argument) {\n    try {\n        return $String$3(argument);\n    } catch (error) {\n        return \"Object\";\n    }\n};\nvar isCallable$j = isCallable$n;\nvar tryToString$3 = tryToString$4;\nvar $TypeError$b = TypeError;\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function(argument) {\n    if (isCallable$j(argument)) return argument;\n    throw $TypeError$b(tryToString$3(argument) + \" is not a function\");\n};\nvar aCallable$6 = aCallable$7;\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function(V, P) {\n    var func = V[P];\n    return func == null ? undefined : aCallable$6(func);\n};\nvar call$i = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$7 = isObject$8;\nvar $TypeError$a = TypeError;\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function(input, pref) {\n    var fn, val;\n    if (pref === \"string\" && isCallable$i(fn = input.toString) && !isObject$7(val = call$i(fn, input))) return val;\n    if (isCallable$i(fn = input.valueOf) && !isObject$7(val = call$i(fn, input))) return val;\n    if (pref !== \"string\" && isCallable$i(fn = input.toString) && !isObject$7(val = call$i(fn, input))) return val;\n    throw $TypeError$a(\"Can't convert object to primitive value\");\n};\nvar shared$4 = {\n    exports: {}\n};\nvar isPure = false;\nvar global$l = global$o;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\nvar defineGlobalProperty$3 = function(key, value) {\n    try {\n        defineProperty$6(global$l, key, {\n            value: value,\n            configurable: true,\n            writable: true\n        });\n    } catch (error) {\n        global$l[key] = value;\n    }\n    return value;\n};\nvar global$k = global$o;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\nvar SHARED = \"__core-js_shared__\";\nvar store$3 = global$k[SHARED] || defineGlobalProperty$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$4.exports = function(key, value) {\n    return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})(\"versions\", []).push({\n    version: \"3.23.3\",\n    mode: \"global\",\n    copyright: \"\\xa9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n});\nvar requireObjectCoercible$2 = requireObjectCoercible$4;\nvar $Object$2 = Object;\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$5 = function(argument) {\n    return $Object$2(requireObjectCoercible$2(argument));\n};\nvar uncurryThis$i = functionUncurryThis;\nvar toObject$4 = toObject$5;\nvar hasOwnProperty = uncurryThis$i({}.hasOwnProperty);\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n    return hasOwnProperty(toObject$4(it), key);\n};\nvar uncurryThis$h = functionUncurryThis;\nvar id = 0;\nvar postfix = Math.random();\nvar toString$5 = uncurryThis$h(1.0.toString);\nvar uid$2 = function(key) {\n    return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString$5(++id + postfix, 36);\n};\nvar global$j = global$o;\nvar shared$3 = shared$4.exports;\nvar hasOwn$c = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$3(\"wks\");\nvar Symbol$1 = global$j.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1[\"for\"];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\nvar wellKnownSymbol$i = function(name) {\n    if (!hasOwn$c(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n        var description = \"Symbol.\" + name;\n        if (NATIVE_SYMBOL && hasOwn$c(Symbol$1, name)) {\n            WellKnownSymbolsStore[name] = Symbol$1[name];\n        } else if (USE_SYMBOL_AS_UID && symbolFor) {\n            WellKnownSymbolsStore[name] = symbolFor(description);\n        } else {\n            WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n        }\n    }\n    return WellKnownSymbolsStore[name];\n};\nvar call$h = functionCall;\nvar isObject$6 = isObject$8;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$h = wellKnownSymbol$i;\nvar $TypeError$9 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$h(\"toPrimitive\");\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function(input, pref) {\n    if (!isObject$6(input) || isSymbol$1(input)) return input;\n    var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n    var result;\n    if (exoticToPrim) {\n        if (pref === undefined) pref = \"default\";\n        result = call$h(exoticToPrim, input, pref);\n        if (!isObject$6(result) || isSymbol$1(result)) return result;\n        throw $TypeError$9(\"Can't convert object to primitive value\");\n    }\n    if (pref === undefined) pref = \"number\";\n    return ordinaryToPrimitive(input, pref);\n};\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$3 = function(argument) {\n    var key = toPrimitive(argument, \"string\");\n    return isSymbol(key) ? key : key + \"\";\n};\nvar global$i = global$o;\nvar isObject$5 = isObject$8;\nvar document$3 = global$i.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);\nvar documentCreateElement$2 = function(it) {\n    return EXISTS$1 ? document$3.createElement(it) : {};\n};\nvar DESCRIPTORS$c = descriptors;\nvar fails$f = fails$k;\nvar createElement$1 = documentCreateElement$2;\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$c && !fails$f(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(createElement$1(\"div\"), \"a\", {\n        get: function() {\n            return 7;\n        }\n    }).a != 7;\n});\nvar DESCRIPTORS$b = descriptors;\nvar call$g = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toPropertyKey$2 = toPropertyKey$3;\nvar hasOwn$b = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$b ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n    O = toIndexedObject$4(O);\n    P = toPropertyKey$2(P);\n    if (IE8_DOM_DEFINE$1) try {\n        return $getOwnPropertyDescriptor$1(O, P);\n    } catch (error) {}\n    if (hasOwn$b(O, P)) return createPropertyDescriptor$4(!call$g(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\nvar objectDefineProperty = {};\nvar DESCRIPTORS$a = descriptors;\nvar fails$e = fails$k;\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$a && fails$e(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(function() {}, \"prototype\", {\n        value: 42,\n        writable: false\n    }).prototype != 42;\n});\nvar isObject$4 = isObject$8;\nvar $String$2 = String;\nvar $TypeError$8 = TypeError;\n// `Assert: Type(argument) is Object`\nvar anObject$g = function(argument) {\n    if (isObject$4(argument)) return argument;\n    throw $TypeError$8($String$2(argument) + \" is not an object\");\n};\nvar DESCRIPTORS$9 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$f = anObject$g;\nvar toPropertyKey$1 = toPropertyKey$3;\nvar $TypeError$7 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = \"enumerable\";\nvar CONFIGURABLE$1 = \"configurable\";\nvar WRITABLE = \"writable\";\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$9 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n    anObject$f(O);\n    P = toPropertyKey$1(P);\n    anObject$f(Attributes);\n    if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n        var current = $getOwnPropertyDescriptor(O, P);\n        if (current && current[WRITABLE]) {\n            O[P] = Attributes.value;\n            Attributes = {\n                configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                writable: false\n            };\n        }\n    }\n    return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n    anObject$f(O);\n    P = toPropertyKey$1(P);\n    anObject$f(Attributes);\n    if (IE8_DOM_DEFINE) try {\n        return $defineProperty(O, P, Attributes);\n    } catch (error) {}\n    if (\"get\" in Attributes || \"set\" in Attributes) throw $TypeError$7(\"Accessors not supported\");\n    if (\"value\" in Attributes) O[P] = Attributes.value;\n    return O;\n};\nvar DESCRIPTORS$8 = descriptors;\nvar definePropertyModule$5 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$5 = DESCRIPTORS$8 ? function(object, key, value) {\n    return definePropertyModule$5.f(object, key, createPropertyDescriptor$3(1, value));\n} : function(object, key, value) {\n    object[key] = value;\n    return object;\n};\nvar makeBuiltIn$3 = {\n    exports: {}\n};\nvar DESCRIPTORS$7 = descriptors;\nvar hasOwn$a = hasOwnProperty_1;\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$7 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$a(FunctionPrototype$1, \"name\");\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() {}).name === \"something\";\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$7 || DESCRIPTORS$7 && getDescriptor(FunctionPrototype$1, \"name\").configurable);\nvar functionName = {\n    EXISTS: EXISTS,\n    PROPER: PROPER,\n    CONFIGURABLE: CONFIGURABLE\n};\nvar uncurryThis$g = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$g(Function.toString);\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n    store$1.inspectSource = function(it) {\n        return functionToString(it);\n    };\n}\nvar inspectSource$4 = store$1.inspectSource;\nvar global$h = global$o;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\nvar WeakMap$1 = global$h.WeakMap;\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\nvar shared$2 = shared$4.exports;\nvar uid = uid$2;\nvar keys = shared$2(\"keys\");\nvar sharedKey$3 = function(key) {\n    return keys[key] || (keys[key] = uid(key));\n};\nvar hiddenKeys$4 = {};\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$g = global$o;\nvar uncurryThis$f = functionUncurryThis;\nvar isObject$3 = isObject$8;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$5;\nvar hasOwn$9 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\nvar OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\nvar TypeError$4 = global$g.TypeError;\nvar WeakMap = global$g.WeakMap;\nvar set$1, get, has;\nvar enforce = function(it) {\n    return has(it) ? get(it) : set$1(it, {});\n};\nvar getterFor = function(TYPE) {\n    return function(it) {\n        var state;\n        if (!isObject$3(it) || (state = get(it)).type !== TYPE) {\n            throw TypeError$4(\"Incompatible receiver, \" + TYPE + \" required\");\n        }\n        return state;\n    };\n};\nif (NATIVE_WEAK_MAP || shared$1.state) {\n    var store = shared$1.state || (shared$1.state = new WeakMap());\n    var wmget = uncurryThis$f(store.get);\n    var wmhas = uncurryThis$f(store.has);\n    var wmset = uncurryThis$f(store.set);\n    set$1 = function(it, metadata) {\n        if (wmhas(store, it)) throw new TypeError$4(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        wmset(store, it, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return wmget(store, it) || {};\n    };\n    has = function(it) {\n        return wmhas(store, it);\n    };\n} else {\n    var STATE = sharedKey$2(\"state\");\n    hiddenKeys$3[STATE] = true;\n    set$1 = function(it, metadata) {\n        if (hasOwn$9(it, STATE)) throw new TypeError$4(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        createNonEnumerableProperty$4(it, STATE, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return hasOwn$9(it, STATE) ? it[STATE] : {};\n    };\n    has = function(it) {\n        return hasOwn$9(it, STATE);\n    };\n}\nvar internalState = {\n    set: set$1,\n    get: get,\n    has: has,\n    enforce: enforce,\n    getterFor: getterFor\n};\nvar fails$d = fails$k;\nvar isCallable$f = isCallable$n;\nvar hasOwn$8 = hasOwnProperty_1;\nvar DESCRIPTORS$6 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\nvar enforceInternalState = InternalStateModule$5.enforce;\nvar getInternalState$3 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$5 = Object.defineProperty;\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$6 && !fails$d(function() {\n    return defineProperty$5(function() {}, \"length\", {\n        value: 8\n    }).length !== 8;\n});\nvar TEMPLATE = String(String).split(\"String\");\nvar makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name, options) {\n    if (String(name).slice(0, 7) === \"Symbol(\") {\n        name = \"[\" + String(name).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n    }\n    if (options && options.getter) name = \"get \" + name;\n    if (options && options.setter) name = \"set \" + name;\n    if (!hasOwn$8(value, \"name\") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {\n        if (DESCRIPTORS$6) defineProperty$5(value, \"name\", {\n            value: name,\n            configurable: true\n        });\n        else value.name = name;\n    }\n    if (CONFIGURABLE_LENGTH && options && hasOwn$8(options, \"arity\") && value.length !== options.arity) {\n        defineProperty$5(value, \"length\", {\n            value: options.arity\n        });\n    }\n    try {\n        if (options && hasOwn$8(options, \"constructor\") && options.constructor) {\n            if (DESCRIPTORS$6) defineProperty$5(value, \"prototype\", {\n                writable: false\n            });\n        // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n        } else if (value.prototype) value.prototype = undefined;\n    } catch (error) {}\n    var state = enforceInternalState(value);\n    if (!hasOwn$8(state, \"source\")) {\n        state.source = TEMPLATE.join(typeof name == \"string\" ? name : \"\");\n    }\n    return value;\n};\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$2(function toString() {\n    return isCallable$f(this) && getInternalState$3(this).source || inspectSource$2(this);\n}, \"toString\");\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$4 = objectDefineProperty;\nvar makeBuiltIn$1 = makeBuiltIn$3.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\nvar defineBuiltIn$a = function(O, key, value, options) {\n    if (!options) options = {};\n    var simple = options.enumerable;\n    var name = options.name !== undefined ? options.name : key;\n    if (isCallable$e(value)) makeBuiltIn$1(value, name, options);\n    if (options.global) {\n        if (simple) O[key] = value;\n        else defineGlobalProperty$1(key, value);\n    } else {\n        try {\n            if (!options.unsafe) delete O[key];\n            else if (O[key]) simple = true;\n        } catch (error) {}\n        if (simple) O[key] = value;\n        else definePropertyModule$4.f(O, key, {\n            value: value,\n            enumerable: false,\n            configurable: !options.nonConfigurable,\n            writable: !options.nonWritable\n        });\n    }\n    return O;\n};\nvar objectGetOwnPropertyNames = {};\nvar ceil = Math.ceil;\nvar floor$4 = Math.floor;\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n    var n = +x;\n    return (n > 0 ? floor$4 : ceil)(n);\n};\nvar trunc = mathTrunc;\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$4 = function(argument) {\n    var number = +argument;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number !== number || number === 0 ? 0 : trunc(number);\n};\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$4;\nvar max$2 = Math.max;\nvar min$2 = Math.min;\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$2 = function(index, length) {\n    var integer = toIntegerOrInfinity$3(index);\n    return integer < 0 ? max$2(integer + length, 0) : min$2(integer, length);\n};\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$4;\nvar min$1 = Math.min;\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$2 = function(argument) {\n    return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\nvar toLength$1 = toLength$2;\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$4 = function(obj) {\n    return toLength$1(obj.length);\n};\nvar toIndexedObject$3 = toIndexedObject$5;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$2;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$4;\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$1 = function(IS_INCLUDES) {\n    return function($this, el, fromIndex) {\n        var O = toIndexedObject$3($this);\n        var length = lengthOfArrayLike$3(O);\n        var index = toAbsoluteIndex$1(fromIndex, length);\n        var value;\n        // Array#includes uses SameValueZero equality algorithm\n        // eslint-disable-next-line no-self-compare -- NaN check\n        if (IS_INCLUDES && el != el) while(length > index){\n            value = O[index++];\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (value != value) return true;\n        // Array#indexOf ignores holes, Array#includes - not\n        }\n        else for(; length > index; index++){\n            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n        }\n        return !IS_INCLUDES && -1;\n    };\n};\nvar arrayIncludes = {\n    // `Array.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-array.prototype.includes\n    includes: createMethod$1(true),\n    // `Array.prototype.indexOf` method\n    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n    indexOf: createMethod$1(false)\n};\nvar uncurryThis$e = functionUncurryThis;\nvar hasOwn$7 = hasOwnProperty_1;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar push$4 = uncurryThis$e([].push);\nvar objectKeysInternal = function(object, names) {\n    var O = toIndexedObject$2(object);\n    var i = 0;\n    var result = [];\n    var key;\n    for(key in O)!hasOwn$7(hiddenKeys$2, key) && hasOwn$7(O, key) && push$4(result, key);\n    // Don't enum bug & hidden keys\n    while(names.length > i)if (hasOwn$7(O, key = names[i++])) {\n        ~indexOf$1(result, key) || push$4(result, key);\n    }\n    return result;\n};\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n    \"constructor\",\n    \"hasOwnProperty\",\n    \"isPrototypeOf\",\n    \"propertyIsEnumerable\",\n    \"toLocaleString\",\n    \"toString\",\n    \"valueOf\"\n];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\nvar hiddenKeys$1 = enumBugKeys$2.concat(\"length\", \"prototype\");\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return internalObjectKeys$1(O, hiddenKeys$1);\n};\nvar objectGetOwnPropertySymbols = {};\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$d = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$e = anObject$g;\nvar concat$2 = uncurryThis$d([].concat);\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n    var keys = getOwnPropertyNamesModule.f(anObject$e(it));\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n    return getOwnPropertySymbols ? concat$2(keys, getOwnPropertySymbols(it)) : keys;\n};\nvar hasOwn$6 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$3 = objectDefineProperty;\nvar copyConstructorProperties$1 = function(target, source, exceptions) {\n    var keys = ownKeys(source);\n    var defineProperty = definePropertyModule$3.f;\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        if (!hasOwn$6(target, key) && !(exceptions && hasOwn$6(exceptions, key))) {\n            defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n        }\n    }\n};\nvar fails$c = fails$k;\nvar isCallable$d = isCallable$n;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$2 = function(feature, detection) {\n    var value = data[normalize(feature)];\n    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$d(detection) ? fails$c(detection) : !!detection;\n};\nvar normalize = isForced$2.normalize = function(string) {\n    return String(string).replace(replacement, \".\").toLowerCase();\n};\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = \"N\";\nvar POLYFILL = isForced$2.POLYFILL = \"P\";\nvar isForced_1 = isForced$2;\nvar global$f = global$o;\nvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$5;\nvar defineBuiltIn$9 = defineBuiltIn$a;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ var _export = function(options, source) {\n    var TARGET = options.target;\n    var GLOBAL = options.global;\n    var STATIC = options.stat;\n    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n    if (GLOBAL) {\n        target = global$f;\n    } else if (STATIC) {\n        target = global$f[TARGET] || defineGlobalProperty(TARGET, {});\n    } else {\n        target = (global$f[TARGET] || {}).prototype;\n    }\n    if (target) for(key in source){\n        sourceProperty = source[key];\n        if (options.dontCallGetSet) {\n            descriptor = getOwnPropertyDescriptor$2(target, key);\n            targetProperty = descriptor && descriptor.value;\n        } else targetProperty = target[key];\n        FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n        // contained in target\n        if (!FORCED && targetProperty !== undefined) {\n            if (typeof sourceProperty == typeof targetProperty) continue;\n            copyConstructorProperties(sourceProperty, targetProperty);\n        }\n        // add a flag to not completely full polyfills\n        if (options.sham || targetProperty && targetProperty.sham) {\n            createNonEnumerableProperty$3(sourceProperty, \"sham\", true);\n        }\n        defineBuiltIn$9(target, key, sourceProperty, options);\n    }\n};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n    return internalObjectKeys(O, enumBugKeys$1);\n};\nvar DESCRIPTORS$5 = descriptors;\nvar uncurryThis$c = functionUncurryThis;\nvar call$f = functionCall;\nvar fails$b = fails$k;\nvar objectKeys$1 = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$3 = toObject$5;\nvar IndexedObject = indexedObject;\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$4 = Object.defineProperty;\nvar concat$1 = uncurryThis$c([].concat);\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$b(function() {\n    // should have correct order of operations (Edge bug)\n    if (DESCRIPTORS$5 && $assign({\n        b: 1\n    }, $assign(defineProperty$4({}, \"a\", {\n        enumerable: true,\n        get: function() {\n            defineProperty$4(this, \"b\", {\n                value: 3,\n                enumerable: false\n            });\n        }\n    }), {\n        b: 2\n    })).b !== 1) return true;\n    // should work with symbols and should have deterministic property order (V8 bug)\n    var A = {};\n    var B = {};\n    // eslint-disable-next-line es-x/no-symbol -- safe\n    var symbol = Symbol();\n    var alphabet = \"abcdefghijklmnopqrst\";\n    A[symbol] = 7;\n    alphabet.split(\"\").forEach(function(chr) {\n        B[chr] = chr;\n    });\n    return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join(\"\") != alphabet;\n}) ? function assign(target, source) {\n    var T = toObject$3(target);\n    var argumentsLength = arguments.length;\n    var index = 1;\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n    var propertyIsEnumerable = propertyIsEnumerableModule.f;\n    while(argumentsLength > index){\n        var S = IndexedObject(arguments[index++]);\n        var keys = getOwnPropertySymbols ? concat$1(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);\n        var length = keys.length;\n        var j = 0;\n        var key;\n        while(length > j){\n            key = keys[j++];\n            if (!DESCRIPTORS$5 || call$f(propertyIsEnumerable, S, key)) T[key] = S[key];\n        }\n    }\n    return T;\n} : $assign;\nvar $$a = _export;\nvar assign$1 = objectAssign;\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$a({\n    target: \"Object\",\n    stat: true,\n    arity: 2,\n    forced: Object.assign !== assign$1\n}, {\n    assign: assign$1\n});\nvar wellKnownSymbol$g = wellKnownSymbol$i;\nvar TO_STRING_TAG$3 = wellKnownSymbol$g(\"toStringTag\");\nvar test = {};\ntest[TO_STRING_TAG$3] = \"z\";\nvar toStringTagSupport = String(test) === \"[object z]\";\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$c = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$f = wellKnownSymbol$i;\nvar TO_STRING_TAG$2 = wellKnownSymbol$f(\"toStringTag\");\nvar $Object$1 = Object;\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function() {\n    return arguments;\n}()) == \"Arguments\";\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key) {\n    try {\n        return it[key];\n    } catch (error) {}\n};\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$6 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n    var O, tag, result;\n    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && isCallable$c(O.callee) ? \"Arguments\" : result;\n};\nvar classof$5 = classof$6;\nvar $String$1 = String;\nvar toString$4 = function(argument) {\n    if (classof$5(argument) === \"Symbol\") throw TypeError(\"Cannot convert a Symbol value to a string\");\n    return $String$1(argument);\n};\nvar anObject$d = anObject$g;\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function() {\n    var that = anObject$d(this);\n    var result = \"\";\n    if (that.hasIndices) result += \"d\";\n    if (that.global) result += \"g\";\n    if (that.ignoreCase) result += \"i\";\n    if (that.multiline) result += \"m\";\n    if (that.dotAll) result += \"s\";\n    if (that.unicode) result += \"u\";\n    if (that.unicodeSets) result += \"v\";\n    if (that.sticky) result += \"y\";\n    return result;\n};\nvar call$e = functionCall;\nvar hasOwn$5 = hasOwnProperty_1;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags$1;\nvar RegExpPrototype$2 = RegExp.prototype;\nvar regexpGetFlags = function(R) {\n    var flags = R.flags;\n    return flags === undefined && !(\"flags\" in RegExpPrototype$2) && !hasOwn$5(R, \"flags\") && isPrototypeOf$2(RegExpPrototype$2, R) ? call$e(regExpFlags, R) : flags;\n};\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar defineBuiltIn$8 = defineBuiltIn$a;\nvar anObject$c = anObject$g;\nvar $toString$2 = toString$4;\nvar fails$a = fails$k;\nvar getRegExpFlags = regexpGetFlags;\nvar TO_STRING = \"toString\";\nvar RegExpPrototype$1 = RegExp.prototype;\nvar n$ToString = RegExpPrototype$1[TO_STRING];\nvar NOT_GENERIC = fails$a(function() {\n    return n$ToString.call({\n        source: \"a\",\n        flags: \"b\"\n    }) != \"/a/b\";\n});\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME$1 && n$ToString.name != TO_STRING;\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n    defineBuiltIn$8(RegExp.prototype, TO_STRING, function toString() {\n        var R = anObject$c(this);\n        var pattern = $toString$2(R.source);\n        var flags = $toString$2(getRegExpFlags(R));\n        return \"/\" + pattern + \"/\" + flags;\n    }, {\n        unsafe: true\n    });\n}\nvar objectDefineProperties = {};\nvar DESCRIPTORS$4 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$b = anObject$g;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar objectKeys = objectKeys$2;\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$4 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n    anObject$b(O);\n    var props = toIndexedObject$1(Properties);\n    var keys = objectKeys(Properties);\n    var length = keys.length;\n    var index = 0;\n    var key;\n    while(length > index)definePropertyModule$2.f(O, key = keys[index++], props[key]);\n    return O;\n};\nvar getBuiltIn$4 = getBuiltIn$8;\nvar html$2 = getBuiltIn$4(\"document\", \"documentElement\");\n/* global ActiveXObject -- old IE, WSH */ var anObject$a = anObject$g;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\nvar GT = \">\";\nvar LT = \"<\";\nvar PROTOTYPE = \"prototype\";\nvar SCRIPT = \"script\";\nvar IE_PROTO$1 = sharedKey$1(\"IE_PROTO\");\nvar EmptyConstructor = function() {};\nvar scriptTag = function(content) {\n    return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n};\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function(activeXDocument) {\n    activeXDocument.write(scriptTag(\"\"));\n    activeXDocument.close();\n    var temp = activeXDocument.parentWindow.Object;\n    activeXDocument = null; // avoid memory leak\n    return temp;\n};\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function() {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = documentCreateElement$1(\"iframe\");\n    var JS = \"java\" + SCRIPT + \":\";\n    var iframeDocument;\n    iframe.style.display = \"none\";\n    html$1.appendChild(iframe);\n    // https://github.com/zloirock/core-js/issues/475\n    iframe.src = String(JS);\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(scriptTag(\"document.F=Object\"));\n    iframeDocument.close();\n    return iframeDocument.F;\n};\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function() {\n    try {\n        activeXDocument = new ActiveXObject(\"htmlfile\");\n    } catch (error) {}\n    NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n     : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n    var length = enumBugKeys.length;\n    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n    return NullProtoObject();\n};\nhiddenKeys[IE_PROTO$1] = true;\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n    var result;\n    if (O !== null) {\n        EmptyConstructor[PROTOTYPE] = anObject$a(O);\n        result = new EmptyConstructor();\n        EmptyConstructor[PROTOTYPE] = null;\n        // add \"__proto__\" for Object.getPrototypeOf polyfill\n        result[IE_PROTO$1] = O;\n    } else result = NullProtoObject();\n    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\nvar wellKnownSymbol$e = wellKnownSymbol$i;\nvar create$3 = objectCreate;\nvar defineProperty$3 = objectDefineProperty.f;\nvar UNSCOPABLES = wellKnownSymbol$e(\"unscopables\");\nvar ArrayPrototype$1 = Array.prototype;\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n    defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {\n        configurable: true,\n        value: create$3(null)\n    });\n}\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function(key) {\n    ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\nvar iterators = {};\nvar fails$9 = fails$k;\nvar correctPrototypeGetter = !fails$9(function() {\n    function F() {}\n    F.prototype.constructor = null;\n    // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n    return Object.getPrototypeOf(new F()) !== F.prototype;\n});\nvar hasOwn$4 = hasOwnProperty_1;\nvar isCallable$b = isCallable$n;\nvar toObject$2 = toObject$5;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\nvar IE_PROTO = sharedKey(\"IE_PROTO\");\nvar $Object = Object;\nvar ObjectPrototype = $Object.prototype;\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {\n    var object = toObject$2(O);\n    if (hasOwn$4(object, IE_PROTO)) return object[IE_PROTO];\n    var constructor = object.constructor;\n    if (isCallable$b(constructor) && object instanceof constructor) {\n        return constructor.prototype;\n    }\n    return object instanceof $Object ? ObjectPrototype : null;\n};\nvar fails$8 = fails$k;\nvar isCallable$a = isCallable$n;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$7 = defineBuiltIn$a;\nvar wellKnownSymbol$d = wellKnownSymbol$i;\nvar ITERATOR$7 = wellKnownSymbol$d(\"iterator\");\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n/* eslint-disable es-x/no-array-prototype-keys -- safe */ if ([].keys) {\n    arrayIterator = [].keys();\n    // Safari 8 has buggy iterators w/o `next`\n    if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n    else {\n        PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n    }\n}\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$8(function() {\n    var test = {};\n    // FF44- legacy iterators case\n    return IteratorPrototype$2[ITERATOR$7].call(test) !== test;\n});\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$a(IteratorPrototype$2[ITERATOR$7])) {\n    defineBuiltIn$7(IteratorPrototype$2, ITERATOR$7, function() {\n        return this;\n    });\n}\nvar iteratorsCore = {\n    IteratorPrototype: IteratorPrototype$2,\n    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\nvar defineProperty$2 = objectDefineProperty.f;\nvar hasOwn$3 = hasOwnProperty_1;\nvar wellKnownSymbol$c = wellKnownSymbol$i;\nvar TO_STRING_TAG$1 = wellKnownSymbol$c(\"toStringTag\");\nvar setToStringTag$5 = function(target, TAG, STATIC) {\n    if (target && !STATIC) target = target.prototype;\n    if (target && !hasOwn$3(target, TO_STRING_TAG$1)) {\n        defineProperty$2(target, TO_STRING_TAG$1, {\n            configurable: true,\n            value: TAG\n        });\n    }\n};\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$4 = setToStringTag$5;\nvar Iterators$4 = iterators;\nvar returnThis$1 = function() {\n    return this;\n};\nvar createIteratorConstructor$2 = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    IteratorConstructor.prototype = create$2(IteratorPrototype$1, {\n        next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next)\n    });\n    setToStringTag$4(IteratorConstructor, TO_STRING_TAG, false);\n    Iterators$4[TO_STRING_TAG] = returnThis$1;\n    return IteratorConstructor;\n};\nvar isCallable$9 = isCallable$n;\nvar $String = String;\nvar $TypeError$6 = TypeError;\nvar aPossiblePrototype$1 = function(argument) {\n    if (typeof argument == \"object\" || isCallable$9(argument)) return argument;\n    throw $TypeError$6(\"Can't set \" + $String(argument) + \" as a prototype\");\n};\n/* eslint-disable no-proto -- safe */ var uncurryThis$b = functionUncurryThis;\nvar anObject$9 = anObject$g;\nvar aPossiblePrototype = aPossiblePrototype$1;\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n    var CORRECT_SETTER = false;\n    var test = {};\n    var setter;\n    try {\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        setter = uncurryThis$b(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set);\n        setter(test, []);\n        CORRECT_SETTER = test instanceof Array;\n    } catch (error) {}\n    return function setPrototypeOf(O, proto) {\n        anObject$9(O);\n        aPossiblePrototype(proto);\n        if (CORRECT_SETTER) setter(O, proto);\n        else O.__proto__ = proto;\n        return O;\n    };\n}() : undefined);\nvar $$9 = _export;\nvar call$d = functionCall;\nvar FunctionName = functionName;\nvar isCallable$8 = isCallable$n;\nvar createIteratorConstructor$1 = createIteratorConstructor$2;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$5;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$5;\nvar defineBuiltIn$6 = defineBuiltIn$a;\nvar wellKnownSymbol$b = wellKnownSymbol$i;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$6 = wellKnownSymbol$b(\"iterator\");\nvar KEYS = \"keys\";\nvar VALUES = \"values\";\nvar ENTRIES = \"entries\";\nvar returnThis = function() {\n    return this;\n};\nvar defineIterator$2 = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n    createIteratorConstructor$1(IteratorConstructor, NAME, next);\n    var getIterationMethod = function(KIND) {\n        if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n        switch(KIND){\n            case KEYS:\n                return function keys() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case VALUES:\n                return function values() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case ENTRIES:\n                return function entries() {\n                    return new IteratorConstructor(this, KIND);\n                };\n        }\n        return function() {\n            return new IteratorConstructor(this);\n        };\n    };\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    var INCORRECT_VALUES_NAME = false;\n    var IterablePrototype = Iterable.prototype;\n    var nativeIterator = IterablePrototype[ITERATOR$6] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n    var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n    var CurrentIteratorPrototype, methods, KEY;\n    // fix native\n    if (anyNativeIterator) {\n        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n            if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n                if (setPrototypeOf$1) {\n                    setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n                } else if (!isCallable$8(CurrentIteratorPrototype[ITERATOR$6])) {\n                    defineBuiltIn$6(CurrentIteratorPrototype, ITERATOR$6, returnThis);\n                }\n            }\n            // Set @@toStringTag to native iterators\n            setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG, true);\n        }\n    }\n    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n    if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n        if (CONFIGURABLE_FUNCTION_NAME) {\n            createNonEnumerableProperty$2(IterablePrototype, \"name\", VALUES);\n        } else {\n            INCORRECT_VALUES_NAME = true;\n            defaultIterator = function values() {\n                return call$d(nativeIterator, this);\n            };\n        }\n    }\n    // export additional methods\n    if (DEFAULT) {\n        methods = {\n            values: getIterationMethod(VALUES),\n            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n            entries: getIterationMethod(ENTRIES)\n        };\n        if (FORCED) for(KEY in methods){\n            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n                defineBuiltIn$6(IterablePrototype, KEY, methods[KEY]);\n            }\n        }\n        else $$9({\n            target: NAME,\n            proto: true,\n            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n        }, methods);\n    }\n    // define iterator\n    if (IterablePrototype[ITERATOR$6] !== defaultIterator) {\n        defineBuiltIn$6(IterablePrototype, ITERATOR$6, defaultIterator, {\n            name: DEFAULT\n        });\n    }\n    Iterators$3[NAME] = defaultIterator;\n    return methods;\n};\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables = addToUnscopables$1;\nvar Iterators$2 = iterators;\nvar InternalStateModule$4 = internalState;\nvar defineProperty$1 = objectDefineProperty.f;\nvar defineIterator$1 = defineIterator$2;\nvar DESCRIPTORS$3 = descriptors;\nvar ARRAY_ITERATOR = \"Array Iterator\";\nvar setInternalState$4 = InternalStateModule$4.set;\nvar getInternalState$2 = InternalStateModule$4.getterFor(ARRAY_ITERATOR);\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator$1(Array, \"Array\", function(iterated, kind) {\n    setInternalState$4(this, {\n        type: ARRAY_ITERATOR,\n        target: toIndexedObject(iterated),\n        index: 0,\n        kind: kind // kind\n    });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function() {\n    var state = getInternalState$2(this);\n    var target = state.target;\n    var kind = state.kind;\n    var index = state.index++;\n    if (!target || index >= target.length) {\n        state.target = undefined;\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    if (kind == \"keys\") return {\n        value: index,\n        done: false\n    };\n    if (kind == \"values\") return {\n        value: target[index],\n        done: false\n    };\n    return {\n        value: [\n            index,\n            target[index]\n        ],\n        done: false\n    };\n}, \"values\");\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(\"keys\");\naddToUnscopables(\"values\");\naddToUnscopables(\"entries\");\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$3 && values.name !== \"values\") try {\n    defineProperty$1(values, \"name\", {\n        value: \"values\"\n    });\n} catch (error) {}\nvar classof$4 = classofRaw$1;\nvar global$e = global$o;\nvar engineIsNode = classof$4(global$e.process) == \"process\";\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule$1 = objectDefineProperty;\nvar wellKnownSymbol$a = wellKnownSymbol$i;\nvar DESCRIPTORS$2 = descriptors;\nvar SPECIES$3 = wellKnownSymbol$a(\"species\");\nvar setSpecies$1 = function(CONSTRUCTOR_NAME) {\n    var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n    var defineProperty = definePropertyModule$1.f;\n    if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {\n        defineProperty(Constructor, SPECIES$3, {\n            configurable: true,\n            get: function() {\n                return this;\n            }\n        });\n    }\n};\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar $TypeError$5 = TypeError;\nvar anInstance$3 = function(it, Prototype) {\n    if (isPrototypeOf$1(Prototype, it)) return it;\n    throw $TypeError$5(\"Incorrect invocation\");\n};\nvar uncurryThis$a = functionUncurryThis;\nvar fails$7 = fails$k;\nvar isCallable$7 = isCallable$n;\nvar classof$3 = classof$6;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\nvar noop = function() {};\nvar empty = [];\nvar construct = getBuiltIn$2(\"Reflect\", \"construct\");\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$3 = uncurryThis$a(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\nvar isConstructorModern = function isConstructor(argument) {\n    if (!isCallable$7(argument)) return false;\n    try {\n        construct(noop, empty, argument);\n        return true;\n    } catch (error) {\n        return false;\n    }\n};\nvar isConstructorLegacy = function isConstructor(argument) {\n    if (!isCallable$7(argument)) return false;\n    switch(classof$3(argument)){\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n            return false;\n    }\n    try {\n        // we can't check .prototype since constructors produced by .bind haven't it\n        // `Function#toString` throws on some built-it function in some legacy engines\n        // (for example, `DOMQuad` and similar in FF41-)\n        return INCORRECT_TO_STRING || !!exec$3(constructorRegExp, inspectSource$1(argument));\n    } catch (error) {\n        return true;\n    }\n};\nisConstructorLegacy.sham = true;\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$7(function() {\n    var called;\n    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {\n        called = true;\n    }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$2 = tryToString$4;\nvar $TypeError$4 = TypeError;\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function(argument) {\n    if (isConstructor$1(argument)) return argument;\n    throw $TypeError$4(tryToString$2(argument) + \" is not a constructor\");\n};\nvar anObject$8 = anObject$g;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$9 = wellKnownSymbol$i;\nvar SPECIES$2 = wellKnownSymbol$9(\"species\");\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function(O, defaultConstructor) {\n    var C = anObject$8(O).constructor;\n    var S;\n    return C === undefined || (S = anObject$8(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);\n};\nvar NATIVE_BIND$1 = functionBindNative;\nvar FunctionPrototype = Function.prototype;\nvar apply$2 = FunctionPrototype.apply;\nvar call$c = FunctionPrototype.call;\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND$1 ? call$c.bind(apply$2) : function() {\n    return call$c.apply(apply$2, arguments);\n});\nvar uncurryThis$9 = functionUncurryThis;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND = functionBindNative;\nvar bind$7 = uncurryThis$9(uncurryThis$9.bind);\n// optional / simple context binding\nvar functionBindContext = function(fn, that) {\n    aCallable$5(fn);\n    return that === undefined ? fn : NATIVE_BIND ? bind$7(fn, that) : function() {\n        return fn.apply(that, arguments);\n    };\n};\nvar uncurryThis$8 = functionUncurryThis;\nvar arraySlice$3 = uncurryThis$8([].slice);\nvar $TypeError$3 = TypeError;\nvar validateArgumentsLength$3 = function(passed, required) {\n    if (passed < required) throw $TypeError$3(\"Not enough arguments\");\n    return passed;\n};\nvar userAgent$2 = engineUserAgent;\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\nvar global$d = global$o;\nvar apply$1 = functionApply;\nvar bind$6 = functionBindContext;\nvar isCallable$6 = isCallable$n;\nvar hasOwn$2 = hasOwnProperty_1;\nvar fails$6 = fails$k;\nvar html = html$2;\nvar arraySlice$2 = arraySlice$3;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength$2 = validateArgumentsLength$3;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\nvar set = global$d.setImmediate;\nvar clear = global$d.clearImmediate;\nvar process$2 = global$d.process;\nvar Dispatch = global$d.Dispatch;\nvar Function$1 = global$d.Function;\nvar MessageChannel = global$d.MessageChannel;\nvar String$1 = global$d.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = \"onreadystatechange\";\nvar location, defer, channel, port;\ntry {\n    // Deno throws a ReferenceError on `location` access without `--location` flag\n    location = global$d.location;\n} catch (error) {}\nvar run = function(id) {\n    if (hasOwn$2(queue$1, id)) {\n        var fn = queue$1[id];\n        delete queue$1[id];\n        fn();\n    }\n};\nvar runner = function(id) {\n    return function() {\n        run(id);\n    };\n};\nvar listener = function(event) {\n    run(event.data);\n};\nvar post = function(id) {\n    // old engines have not location.origin\n    global$d.postMessage(String$1(id), location.protocol + \"//\" + location.host);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n    set = function setImmediate(handler) {\n        validateArgumentsLength$2(arguments.length, 1);\n        var fn = isCallable$6(handler) ? handler : Function$1(handler);\n        var args = arraySlice$2(arguments, 1);\n        queue$1[++counter] = function() {\n            apply$1(fn, undefined, args);\n        };\n        defer(counter);\n        return counter;\n    };\n    clear = function clearImmediate(id) {\n        delete queue$1[id];\n    };\n    // Node.js 0.8-\n    if (IS_NODE$2) {\n        defer = function(id) {\n            process$2.nextTick(runner(id));\n        };\n    // Sphere (JS game engine) Dispatch API\n    } else if (Dispatch && Dispatch.now) {\n        defer = function(id) {\n            Dispatch.now(runner(id));\n        };\n    // Browsers with MessageChannel, includes WebWorkers\n    // except iOS - https://github.com/zloirock/core-js/issues/624\n    } else if (MessageChannel && !IS_IOS$1) {\n        channel = new MessageChannel();\n        port = channel.port2;\n        channel.port1.onmessage = listener;\n        defer = bind$6(port.postMessage, port);\n    // Browsers with postMessage, skip WebWorkers\n    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n    } else if (global$d.addEventListener && isCallable$6(global$d.postMessage) && !global$d.importScripts && location && location.protocol !== \"file:\" && !fails$6(post)) {\n        defer = post;\n        global$d.addEventListener(\"message\", listener, false);\n    // IE8-\n    } else if (ONREADYSTATECHANGE in createElement(\"script\")) {\n        defer = function(id) {\n            html.appendChild(createElement(\"script\"))[ONREADYSTATECHANGE] = function() {\n                html.removeChild(this);\n                run(id);\n            };\n        };\n    // Rest old browsers\n    } else {\n        defer = function(id) {\n            setTimeout(runner(id), 0);\n        };\n    }\n}\nvar task$1 = {\n    set: set,\n    clear: clear\n};\nvar userAgent$1 = engineUserAgent;\nvar global$c = global$o;\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$c.Pebble !== undefined;\nvar userAgent = engineUserAgent;\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\nvar global$b = global$o;\nvar bind$5 = functionBindContext;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\nvar MutationObserver = global$b.MutationObserver || global$b.WebKitMutationObserver;\nvar document$2 = global$b.document;\nvar process$1 = global$b.process;\nvar Promise$1 = global$b.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$b, \"queueMicrotask\");\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\nvar flush, head, last, notify$1, toggle, node, promise, then;\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n    flush = function() {\n        var parent, fn;\n        if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n        while(head){\n            fn = head.fn;\n            head = head.next;\n            try {\n                fn();\n            } catch (error) {\n                if (head) notify$1();\n                else last = undefined;\n                throw error;\n            }\n        }\n        last = undefined;\n        if (parent) parent.enter();\n    };\n    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n    if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n        toggle = true;\n        node = document$2.createTextNode(\"\");\n        new MutationObserver(flush).observe(node, {\n            characterData: true\n        });\n        notify$1 = function() {\n            node.data = toggle = !toggle;\n        };\n    // environments with maybe non-completely correct, but existent Promise\n    } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n        // Promise.resolve without an argument throws an error in LG WebOS 2\n        promise = Promise$1.resolve(undefined);\n        // workaround of WebKit ~ iOS Safari 10.1 bug\n        promise.constructor = Promise$1;\n        then = bind$5(promise.then, promise);\n        notify$1 = function() {\n            then(flush);\n        };\n    // Node.js without promises\n    } else if (IS_NODE$1) {\n        notify$1 = function() {\n            process$1.nextTick(flush);\n        };\n    // for other environments - macrotask based on:\n    // - setImmediate\n    // - MessageChannel\n    // - window.postMessage\n    // - onreadystatechange\n    // - setTimeout\n    } else {\n        // strange IE + webpack dev server bug - use .bind(global)\n        macrotask = bind$5(macrotask, global$b);\n        notify$1 = function() {\n            macrotask(flush);\n        };\n    }\n}\nvar microtask$1 = queueMicrotask || function(fn) {\n    var task = {\n        fn: fn,\n        next: undefined\n    };\n    if (last) last.next = task;\n    if (!head) {\n        head = task;\n        notify$1();\n    }\n    last = task;\n};\nvar global$a = global$o;\nvar hostReportErrors$1 = function(a, b) {\n    var console = global$a.console;\n    if (console && console.error) {\n        arguments.length == 1 ? console.error(a) : console.error(a, b);\n    }\n};\nvar perform$3 = function(exec) {\n    try {\n        return {\n            error: false,\n            value: exec()\n        };\n    } catch (error) {\n        return {\n            error: true,\n            value: error\n        };\n    }\n};\nvar Queue$1 = function() {\n    this.head = null;\n    this.tail = null;\n};\nQueue$1.prototype = {\n    add: function(item) {\n        var entry = {\n            item: item,\n            next: null\n        };\n        if (this.head) this.tail.next = entry;\n        else this.head = entry;\n        this.tail = entry;\n    },\n    get: function() {\n        var entry = this.head;\n        if (entry) {\n            this.head = entry.next;\n            if (this.tail === entry) this.tail = null;\n            return entry.item;\n        }\n    }\n};\nvar queue = Queue$1;\nvar global$9 = global$o;\nvar promiseNativeConstructor = global$9.Promise;\nvar engineIsBrowser =  false && 0;\nvar global$8 = global$o;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$5 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$8 = wellKnownSymbol$i;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$1 = wellKnownSymbol$8(\"species\");\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$5(global$8.PromiseRejectionEvent);\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced(\"Promise\", function() {\n    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n    // We can't detect it synchronously, so just check versions\n    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n    // We can't use @@species feature detection in V8 since it causes\n    // deoptimization and performance degradation\n    // https://github.com/zloirock/core-js/issues/679\n    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n    // Detect correctness of subclassing with @@species support\n    var promise = new NativePromiseConstructor$3(function(resolve) {\n        resolve(1);\n    });\n    var FakePromise = function(exec) {\n        exec(function() {}, function() {});\n    };\n    var constructor = promise.constructor = {};\n    constructor[SPECIES$1] = FakePromise;\n    SUBCLASSING = promise.then(function() {}) instanceof FakePromise;\n    if (!SUBCLASSING) return true;\n    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\nvar promiseConstructorDetection = {\n    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n    SUBCLASSING: SUBCLASSING\n};\nvar newPromiseCapability$2 = {};\nvar aCallable$4 = aCallable$7;\nvar PromiseCapability = function(C) {\n    var resolve, reject;\n    this.promise = new C(function($$resolve, $$reject) {\n        if (resolve !== undefined || reject !== undefined) throw TypeError(\"Bad Promise constructor\");\n        resolve = $$resolve;\n        reject = $$reject;\n    });\n    this.resolve = aCallable$4(resolve);\n    this.reject = aCallable$4(reject);\n};\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function(C) {\n    return new PromiseCapability(C);\n};\nvar $$8 = _export;\nvar IS_NODE = engineIsNode;\nvar global$7 = global$o;\nvar call$b = functionCall;\nvar defineBuiltIn$5 = defineBuiltIn$a;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag$2 = setToStringTag$5;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$7;\nvar isCallable$4 = isCallable$n;\nvar isObject$2 = isObject$8;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$3 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\nvar PROMISE = \"Promise\";\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$3.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$3.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$3 = global$7.TypeError;\nvar document$1 = global$7.document;\nvar process = global$7.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$7.dispatchEvent);\nvar UNHANDLED_REJECTION = \"unhandledrejection\";\nvar REJECTION_HANDLED = \"rejectionhandled\";\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n// helpers\nvar isThenable = function(it) {\n    var then;\n    return isObject$2(it) && isCallable$4(then = it.then) ? then : false;\n};\nvar callReaction = function(reaction, state) {\n    var value = state.value;\n    var ok = state.state == FULFILLED;\n    var handler = ok ? reaction.ok : reaction.fail;\n    var resolve = reaction.resolve;\n    var reject = reaction.reject;\n    var domain = reaction.domain;\n    var result, then, exited;\n    try {\n        if (handler) {\n            if (!ok) {\n                if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n                state.rejection = HANDLED;\n            }\n            if (handler === true) result = value;\n            else {\n                if (domain) domain.enter();\n                result = handler(value); // can throw\n                if (domain) {\n                    domain.exit();\n                    exited = true;\n                }\n            }\n            if (result === reaction.promise) {\n                reject(TypeError$3(\"Promise-chain cycle\"));\n            } else if (then = isThenable(result)) {\n                call$b(then, result, resolve, reject);\n            } else resolve(result);\n        } else reject(value);\n    } catch (error) {\n        if (domain && !exited) domain.exit();\n        reject(error);\n    }\n};\nvar notify = function(state, isReject) {\n    if (state.notified) return;\n    state.notified = true;\n    microtask(function() {\n        var reactions = state.reactions;\n        var reaction;\n        while(reaction = reactions.get()){\n            callReaction(reaction, state);\n        }\n        state.notified = false;\n        if (isReject && !state.rejection) onUnhandled(state);\n    });\n};\nvar dispatchEvent = function(name, promise, reason) {\n    var event, handler;\n    if (DISPATCH_EVENT) {\n        event = document$1.createEvent(\"Event\");\n        event.promise = promise;\n        event.reason = reason;\n        event.initEvent(name, false, true);\n        global$7.dispatchEvent(event);\n    } else event = {\n        promise: promise,\n        reason: reason\n    };\n    if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$7[\"on\" + name])) handler(event);\n    else if (name === UNHANDLED_REJECTION) hostReportErrors(\"Unhandled promise rejection\", reason);\n};\nvar onUnhandled = function(state) {\n    call$b(task, global$7, function() {\n        var promise = state.facade;\n        var value = state.value;\n        var IS_UNHANDLED = isUnhandled(state);\n        var result;\n        if (IS_UNHANDLED) {\n            result = perform$2(function() {\n                if (IS_NODE) {\n                    process.emit(\"unhandledRejection\", value, promise);\n                } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n            });\n            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n            if (result.error) throw result.value;\n        }\n    });\n};\nvar isUnhandled = function(state) {\n    return state.rejection !== HANDLED && !state.parent;\n};\nvar onHandleUnhandled = function(state) {\n    call$b(task, global$7, function() {\n        var promise = state.facade;\n        if (IS_NODE) {\n            process.emit(\"rejectionHandled\", promise);\n        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n    });\n};\nvar bind$4 = function(fn, state, unwrap) {\n    return function(value) {\n        fn(state, value, unwrap);\n    };\n};\nvar internalReject = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    state.value = value;\n    state.state = REJECTED;\n    notify(state, true);\n};\nvar internalResolve = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    try {\n        if (state.facade === value) throw TypeError$3(\"Promise can't be resolved itself\");\n        var then = isThenable(value);\n        if (then) {\n            microtask(function() {\n                var wrapper = {\n                    done: false\n                };\n                try {\n                    call$b(then, value, bind$4(internalResolve, wrapper, state), bind$4(internalReject, wrapper, state));\n                } catch (error) {\n                    internalReject(wrapper, error, state);\n                }\n            });\n        } else {\n            state.value = value;\n            state.state = FULFILLED;\n            notify(state, false);\n        }\n    } catch (error) {\n        internalReject({\n            done: false\n        }, error, state);\n    }\n};\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n    // 25.4.3.1 Promise(executor)\n    PromiseConstructor = function Promise1(executor) {\n        anInstance$2(this, PromisePrototype);\n        aCallable$3(executor);\n        call$b(Internal, this);\n        var state = getInternalPromiseState(this);\n        try {\n            executor(bind$4(internalResolve, state), bind$4(internalReject, state));\n        } catch (error) {\n            internalReject(state, error);\n        }\n    };\n    PromisePrototype = PromiseConstructor.prototype;\n    // eslint-disable-next-line no-unused-vars -- required for `.length`\n    Internal = function Promise1(executor) {\n        setInternalState$3(this, {\n            type: PROMISE,\n            done: false,\n            notified: false,\n            parent: false,\n            reactions: new Queue(),\n            rejection: false,\n            state: PENDING,\n            value: undefined\n        });\n    };\n    // `Promise.prototype.then` method\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\n    Internal.prototype = defineBuiltIn$5(PromisePrototype, \"then\", function then(onFulfilled, onRejected) {\n        var state = getInternalPromiseState(this);\n        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n        state.parent = true;\n        reaction.ok = isCallable$4(onFulfilled) ? onFulfilled : true;\n        reaction.fail = isCallable$4(onRejected) && onRejected;\n        reaction.domain = IS_NODE ? process.domain : undefined;\n        if (state.state == PENDING) state.reactions.add(reaction);\n        else microtask(function() {\n            callReaction(reaction, state);\n        });\n        return reaction.promise;\n    });\n    OwnPromiseCapability = function() {\n        var promise = new Internal();\n        var state = getInternalPromiseState(promise);\n        this.promise = promise;\n        this.resolve = bind$4(internalResolve, state);\n        this.reject = bind$4(internalReject, state);\n    };\n    newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function(C) {\n        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n    };\n    if (isCallable$4(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n        nativeThen = NativePromisePrototype$1.then;\n        if (!NATIVE_PROMISE_SUBCLASSING) {\n            // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n            defineBuiltIn$5(NativePromisePrototype$1, \"then\", function then(onFulfilled, onRejected) {\n                var that = this;\n                return new PromiseConstructor(function(resolve, reject) {\n                    call$b(nativeThen, that, resolve, reject);\n                }).then(onFulfilled, onRejected);\n            // https://github.com/zloirock/core-js/issues/640\n            }, {\n                unsafe: true\n            });\n        }\n        // make `.constructor === Promise` work for native promise-based APIs\n        try {\n            delete NativePromisePrototype$1.constructor;\n        } catch (error) {}\n        // make `instanceof Promise` work for native promise-based APIs\n        if (setPrototypeOf) {\n            setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n        }\n    }\n}\n$$8({\n    global: true,\n    constructor: true,\n    wrap: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$4\n}, {\n    Promise: PromiseConstructor\n});\nsetToStringTag$2(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\nvar wellKnownSymbol$7 = wellKnownSymbol$i;\nvar Iterators$1 = iterators;\nvar ITERATOR$5 = wellKnownSymbol$7(\"iterator\");\nvar ArrayPrototype = Array.prototype;\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function(it) {\n    return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$5] === it);\n};\nvar classof$2 = classof$6;\nvar getMethod$2 = getMethod$4;\nvar Iterators = iterators;\nvar wellKnownSymbol$6 = wellKnownSymbol$i;\nvar ITERATOR$4 = wellKnownSymbol$6(\"iterator\");\nvar getIteratorMethod$4 = function(it) {\n    if (it != undefined) return getMethod$2(it, ITERATOR$4) || getMethod$2(it, \"@@iterator\") || Iterators[classof$2(it)];\n};\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$7 = anObject$g;\nvar tryToString$1 = tryToString$4;\nvar getIteratorMethod$3 = getIteratorMethod$4;\nvar $TypeError$2 = TypeError;\nvar getIterator$3 = function(argument, usingIterator) {\n    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$3(argument) : usingIterator;\n    if (aCallable$2(iteratorMethod)) return anObject$7(call$a(iteratorMethod, argument));\n    throw $TypeError$2(tryToString$1(argument) + \" is not iterable\");\n};\nvar call$9 = functionCall;\nvar anObject$6 = anObject$g;\nvar getMethod$1 = getMethod$4;\nvar iteratorClose$2 = function(iterator, kind, value) {\n    var innerResult, innerError;\n    anObject$6(iterator);\n    try {\n        innerResult = getMethod$1(iterator, \"return\");\n        if (!innerResult) {\n            if (kind === \"throw\") throw value;\n            return value;\n        }\n        innerResult = call$9(innerResult, iterator);\n    } catch (error) {\n        innerError = true;\n        innerResult = error;\n    }\n    if (kind === \"throw\") throw value;\n    if (innerError) throw innerResult;\n    anObject$6(innerResult);\n    return value;\n};\nvar bind$3 = functionBindContext;\nvar call$8 = functionCall;\nvar anObject$5 = anObject$g;\nvar tryToString = tryToString$4;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$4;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar getIterator$2 = getIterator$3;\nvar getIteratorMethod$2 = getIteratorMethod$4;\nvar iteratorClose$1 = iteratorClose$2;\nvar $TypeError$1 = TypeError;\nvar Result = function(stopped, result) {\n    this.stopped = stopped;\n    this.result = result;\n};\nvar ResultPrototype = Result.prototype;\nvar iterate$2 = function(iterable, unboundFunction, options) {\n    var that = options && options.that;\n    var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n    var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n    var INTERRUPTED = !!(options && options.INTERRUPTED);\n    var fn = bind$3(unboundFunction, that);\n    var iterator, iterFn, index, length, result, next, step;\n    var stop = function(condition) {\n        if (iterator) iteratorClose$1(iterator, \"normal\", condition);\n        return new Result(true, condition);\n    };\n    var callFn = function(value) {\n        if (AS_ENTRIES) {\n            anObject$5(value);\n            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n        }\n        return INTERRUPTED ? fn(value, stop) : fn(value);\n    };\n    if (IS_ITERATOR) {\n        iterator = iterable;\n    } else {\n        iterFn = getIteratorMethod$2(iterable);\n        if (!iterFn) throw $TypeError$1(tryToString(iterable) + \" is not iterable\");\n        // optimisation for array iterators\n        if (isArrayIteratorMethod$1(iterFn)) {\n            for(index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++){\n                result = callFn(iterable[index]);\n                if (result && isPrototypeOf(ResultPrototype, result)) return result;\n            }\n            return new Result(false);\n        }\n        iterator = getIterator$2(iterable, iterFn);\n    }\n    next = iterator.next;\n    while(!(step = call$8(next, iterator)).done){\n        try {\n            result = callFn(step.value);\n        } catch (error) {\n            iteratorClose$1(iterator, \"throw\", error);\n        }\n        if (typeof result == \"object\" && result && isPrototypeOf(ResultPrototype, result)) return result;\n    }\n    return new Result(false);\n};\nvar wellKnownSymbol$5 = wellKnownSymbol$i;\nvar ITERATOR$3 = wellKnownSymbol$5(\"iterator\");\nvar SAFE_CLOSING = false;\ntry {\n    var called = 0;\n    var iteratorWithReturn = {\n        next: function() {\n            return {\n                done: !!called++\n            };\n        },\n        \"return\": function() {\n            SAFE_CLOSING = true;\n        }\n    };\n    iteratorWithReturn[ITERATOR$3] = function() {\n        return this;\n    };\n    // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n    Array.from(iteratorWithReturn, function() {\n        throw 2;\n    });\n} catch (error) {}\nvar checkCorrectnessOfIteration$1 = function(exec, SKIP_CLOSING) {\n    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n    var ITERATION_SUPPORT = false;\n    try {\n        var object = {};\n        object[ITERATOR$3] = function() {\n            return {\n                next: function() {\n                    return {\n                        done: ITERATION_SUPPORT = true\n                    };\n                }\n            };\n        };\n        exec(object);\n    } catch (error) {}\n    return ITERATION_SUPPORT;\n};\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function(iterable) {\n    NativePromiseConstructor$1.all(iterable).then(undefined, function() {});\n});\nvar $$7 = _export;\nvar call$7 = functionCall;\nvar aCallable$1 = aCallable$7;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$7({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION$1\n}, {\n    all: function all(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$2.f(C);\n        var resolve = capability.resolve;\n        var reject = capability.reject;\n        var result = perform$1(function() {\n            var $promiseResolve = aCallable$1(C.resolve);\n            var values = [];\n            var counter = 0;\n            var remaining = 1;\n            iterate$1(iterable, function(promise) {\n                var index = counter++;\n                var alreadyCalled = false;\n                remaining++;\n                call$7($promiseResolve, C, promise).then(function(value) {\n                    if (alreadyCalled) return;\n                    alreadyCalled = true;\n                    values[index] = value;\n                    --remaining || resolve(values);\n                }, reject);\n            });\n            --remaining || resolve(values);\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$6 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$3 = isCallable$n;\nvar defineBuiltIn$4 = defineBuiltIn$a;\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$6({\n    target: \"Promise\",\n    proto: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$2,\n    real: true\n}, {\n    \"catch\": function(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n});\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$3(NativePromiseConstructor)) {\n    var method = getBuiltIn$1(\"Promise\").prototype[\"catch\"];\n    if (NativePromisePrototype[\"catch\"] !== method) {\n        defineBuiltIn$4(NativePromisePrototype, \"catch\", method, {\n            unsafe: true\n        });\n    }\n}\nvar $$5 = _export;\nvar call$6 = functionCall;\nvar aCallable = aCallable$7;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$5({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION\n}, {\n    race: function race(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$1.f(C);\n        var reject = capability.reject;\n        var result = perform(function() {\n            var $promiseResolve = aCallable(C.resolve);\n            iterate(iterable, function(promise) {\n                call$6($promiseResolve, C, promise).then(capability.resolve, reject);\n            });\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$4 = _export;\nvar call$5 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$4({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$1\n}, {\n    reject: function reject(r) {\n        var capability = newPromiseCapabilityModule.f(this);\n        call$5(capability.reject, undefined, r);\n        return capability.promise;\n    }\n});\nvar anObject$4 = anObject$g;\nvar isObject$1 = isObject$8;\nvar newPromiseCapability = newPromiseCapability$2;\nvar promiseResolve$1 = function(C, x) {\n    anObject$4(C);\n    if (isObject$1(x) && x.constructor === C) return x;\n    var promiseCapability = newPromiseCapability.f(C);\n    var resolve = promiseCapability.resolve;\n    resolve(x);\n    return promiseCapability.promise;\n};\nvar $$3 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\ngetBuiltIn(\"Promise\");\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$3({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR\n}, {\n    resolve: function resolve(x) {\n        return promiseResolve(this, x);\n    }\n});\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n};\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\nvar classList = documentCreateElement(\"span\").classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\nvar global$6 = global$o;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$5;\nvar wellKnownSymbol$4 = wellKnownSymbol$i;\nvar ITERATOR$2 = wellKnownSymbol$4(\"iterator\");\nvar TO_STRING_TAG = wellKnownSymbol$4(\"toStringTag\");\nvar ArrayValues = ArrayIteratorMethods.values;\nvar handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {\n    if (CollectionPrototype) {\n        // some Chrome versions have non-configurable methods on DOMTokenList\n        if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {\n            createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$2, ArrayValues);\n        } catch (error) {\n            CollectionPrototype[ITERATOR$2] = ArrayValues;\n        }\n        if (!CollectionPrototype[TO_STRING_TAG]) {\n            createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n        }\n        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){\n            // some Chrome versions have non-configurable methods on DOMTokenList\n            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n                createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n            } catch (error) {\n                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n            }\n        }\n    }\n};\nfor(var COLLECTION_NAME in DOMIterables){\n    handlePrototype(global$6[COLLECTION_NAME] && global$6[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\nhandlePrototype(DOMTokenListPrototype, \"DOMTokenList\");\nvar uncurryThis$7 = functionUncurryThis;\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$4;\nvar toString$3 = toString$4;\nvar requireObjectCoercible$1 = requireObjectCoercible$4;\nvar charAt$6 = uncurryThis$7(\"\".charAt);\nvar charCodeAt$1 = uncurryThis$7(\"\".charCodeAt);\nvar stringSlice$5 = uncurryThis$7(\"\".slice);\nvar createMethod = function(CONVERT_TO_STRING) {\n    return function($this, pos) {\n        var S = toString$3(requireObjectCoercible$1($this));\n        var position = toIntegerOrInfinity$1(pos);\n        var size = S.length;\n        var first, second;\n        if (position < 0 || position >= size) return CONVERT_TO_STRING ? \"\" : undefined;\n        first = charCodeAt$1(S, position);\n        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$6(S, position) : first : CONVERT_TO_STRING ? stringSlice$5(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n    };\n};\nvar stringMultibyte = {\n    // `String.prototype.codePointAt` method\n    // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n    codeAt: createMethod(false),\n    // `String.prototype.at` method\n    // https://github.com/mathiasbynens/String.prototype.at\n    charAt: createMethod(true)\n};\nvar charAt$5 = stringMultibyte.charAt;\nvar toString$2 = toString$4;\nvar InternalStateModule$2 = internalState;\nvar defineIterator = defineIterator$2;\nvar STRING_ITERATOR = \"String Iterator\";\nvar setInternalState$2 = InternalStateModule$2.set;\nvar getInternalState$1 = InternalStateModule$2.getterFor(STRING_ITERATOR);\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, \"String\", function(iterated) {\n    setInternalState$2(this, {\n        type: STRING_ITERATOR,\n        string: toString$2(iterated),\n        index: 0\n    });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n    var state = getInternalState$1(this);\n    var string = state.string;\n    var index = state.index;\n    var point;\n    if (index >= string.length) return {\n        value: undefined,\n        done: true\n    };\n    point = charAt$5(string, index);\n    state.index += point.length;\n    return {\n        value: point,\n        done: false\n    };\n});\nvar fails$5 = fails$k;\nvar wellKnownSymbol$3 = wellKnownSymbol$i;\nvar IS_PURE = isPure;\nvar ITERATOR$1 = wellKnownSymbol$3(\"iterator\");\nvar nativeUrl = !fails$5(function() {\n    // eslint-disable-next-line unicorn/relative-url-style -- required for testing\n    var url = new URL(\"b?a=1&b=2&c=3\", \"http://a\");\n    var searchParams = url.searchParams;\n    var result = \"\";\n    url.pathname = \"c%20d\";\n    searchParams.forEach(function(value, key) {\n        searchParams[\"delete\"](\"b\");\n        result += key + value;\n    });\n    return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== \"http://a/c%20d?a=1&c=3\" || searchParams.get(\"c\") !== \"3\" || String(new URLSearchParams(\"?a=1\")) !== \"a=1\" || !searchParams[ITERATOR$1] || new URL(\"https://a@b\").username !== \"a\" || new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") !== \"b\" || new URL(\"http://тест\").host !== \"xn--e1aybc\" || new URL(\"http://a#б\").hash !== \"#%D0%B1\" || result !== \"a1c3\" || new URL(\"http://x\", undefined).host !== \"x\";\n});\nvar makeBuiltIn = makeBuiltIn$3.exports;\nvar defineProperty = objectDefineProperty;\nvar defineBuiltInAccessor$1 = function(target, name, descriptor) {\n    if (descriptor.get) makeBuiltIn(descriptor.get, name, {\n        getter: true\n    });\n    if (descriptor.set) makeBuiltIn(descriptor.set, name, {\n        setter: true\n    });\n    return defineProperty.f(target, name, descriptor);\n};\nvar anObject$3 = anObject$g;\nvar iteratorClose = iteratorClose$2;\n// call something on iterator step with safe closing on error\nvar callWithSafeIterationClosing$1 = function(iterator, fn, value, ENTRIES) {\n    try {\n        return ENTRIES ? fn(anObject$3(value)[0], value[1]) : fn(value);\n    } catch (error) {\n        iteratorClose(iterator, \"throw\", error);\n    }\n};\nvar toPropertyKey = toPropertyKey$3;\nvar definePropertyModule = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\nvar createProperty$2 = function(object, key, value) {\n    var propertyKey = toPropertyKey(key);\n    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n    else object[propertyKey] = value;\n};\nvar bind$2 = functionBindContext;\nvar call$4 = functionCall;\nvar toObject$1 = toObject$5;\nvar callWithSafeIterationClosing = callWithSafeIterationClosing$1;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar isConstructor = isConstructor$2;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$4;\nvar createProperty$1 = createProperty$2;\nvar getIterator$1 = getIterator$3;\nvar getIteratorMethod$1 = getIteratorMethod$4;\nvar $Array$1 = Array;\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nvar arrayFrom$1 = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {\n    var O = toObject$1(arrayLike);\n    var IS_CONSTRUCTOR = isConstructor(this);\n    var argumentsLength = arguments.length;\n    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    if (mapping) mapfn = bind$2(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n    var iteratorMethod = getIteratorMethod$1(O);\n    var index = 0;\n    var length, result, step, iterator, next, value;\n    // if the target is not iterable or it's an array with the default iterator - use a simple case\n    if (iteratorMethod && !(this === $Array$1 && isArrayIteratorMethod(iteratorMethod))) {\n        iterator = getIterator$1(O, iteratorMethod);\n        next = iterator.next;\n        result = IS_CONSTRUCTOR ? new this() : [];\n        for(; !(step = call$4(next, iterator)).done; index++){\n            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [\n                step.value,\n                index\n            ], true) : step.value;\n            createProperty$1(result, index, value);\n        }\n    } else {\n        length = lengthOfArrayLike$1(O);\n        result = IS_CONSTRUCTOR ? new this(length) : $Array$1(length);\n        for(; length > index; index++){\n            value = mapping ? mapfn(O[index], index) : O[index];\n            createProperty$1(result, index, value);\n        }\n    }\n    result.length = index;\n    return result;\n};\nvar toAbsoluteIndex = toAbsoluteIndex$2;\nvar lengthOfArrayLike = lengthOfArrayLike$4;\nvar createProperty = createProperty$2;\nvar $Array = Array;\nvar max$1 = Math.max;\nvar arraySliceSimple = function(O, start, end) {\n    var length = lengthOfArrayLike(O);\n    var k = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    var result = $Array(max$1(fin - k, 0));\n    for(var n = 0; k < fin; k++, n++)createProperty(result, n, O[k]);\n    result.length = n;\n    return result;\n};\n// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\nvar uncurryThis$6 = functionUncurryThis;\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = \"-\"; // '\\x2D'\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nvar OVERFLOW_ERROR = \"Overflow: input needs wider integers to process\";\nvar baseMinusTMin = base - tMin;\nvar $RangeError = RangeError;\nvar exec$2 = uncurryThis$6(regexSeparators.exec);\nvar floor$3 = Math.floor;\nvar fromCharCode = String.fromCharCode;\nvar charCodeAt = uncurryThis$6(\"\".charCodeAt);\nvar join$2 = uncurryThis$6([].join);\nvar push$3 = uncurryThis$6([].push);\nvar replace$4 = uncurryThis$6(\"\".replace);\nvar split$2 = uncurryThis$6(\"\".split);\nvar toLowerCase$1 = uncurryThis$6(\"\".toLowerCase);\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */ var ucs2decode = function(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    while(counter < length){\n        var value = charCodeAt(string, counter++);\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            var extra = charCodeAt(string, counter++);\n            if ((extra & 0xFC00) == 0xDC00) {\n                push$3(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n            } else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                push$3(output, value);\n                counter--;\n            }\n        } else {\n            push$3(output, value);\n        }\n    }\n    return output;\n};\n/**\n * Converts a digit/integer into a basic code point.\n */ var digitToBasic = function(digit) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26);\n};\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */ var adapt = function(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor$3(delta / damp) : delta >> 1;\n    delta += floor$3(delta / numPoints);\n    while(delta > baseMinusTMin * tMax >> 1){\n        delta = floor$3(delta / baseMinusTMin);\n        k += base;\n    }\n    return floor$3(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */ var encode = function(input) {\n    var output = [];\n    // Convert the input in UCS-2 to an array of Unicode code points.\n    input = ucs2decode(input);\n    // Cache the length.\n    var inputLength = input.length;\n    // Initialize the state.\n    var n = initialN;\n    var delta = 0;\n    var bias = initialBias;\n    var i, currentValue;\n    // Handle the basic code points.\n    for(i = 0; i < input.length; i++){\n        currentValue = input[i];\n        if (currentValue < 0x80) {\n            push$3(output, fromCharCode(currentValue));\n        }\n    }\n    var basicLength = output.length; // number of basic code points.\n    var handledCPCount = basicLength; // number of code points that have been handled;\n    // Finish the basic string with a delimiter unless it's empty.\n    if (basicLength) {\n        push$3(output, delimiter);\n    }\n    // Main encoding loop:\n    while(handledCPCount < inputLength){\n        // All non-basic code points < n have been handled already. Find the next larger one:\n        var m = maxInt;\n        for(i = 0; i < input.length; i++){\n            currentValue = input[i];\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n        var handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor$3((maxInt - delta) / handledCPCountPlusOne)) {\n            throw $RangeError(OVERFLOW_ERROR);\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for(i = 0; i < input.length; i++){\n            currentValue = input[i];\n            if (currentValue < n && ++delta > maxInt) {\n                throw $RangeError(OVERFLOW_ERROR);\n            }\n            if (currentValue == n) {\n                // Represent delta as a generalized variable-length integer.\n                var q = delta;\n                var k = base;\n                while(true){\n                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) break;\n                    var qMinusT = q - t;\n                    var baseMinusT = base - t;\n                    push$3(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n                    q = floor$3(qMinusT / baseMinusT);\n                    k += base;\n                }\n                push$3(output, fromCharCode(digitToBasic(q)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                delta = 0;\n                handledCPCount++;\n            }\n        }\n        delta++;\n        n++;\n    }\n    return join$2(output, \"\");\n};\nvar stringPunycodeToAscii = function(input) {\n    var encoded = [];\n    var labels = split$2(replace$4(toLowerCase$1(input), regexSeparators, \".\"), \".\");\n    var i, label;\n    for(i = 0; i < labels.length; i++){\n        label = labels[i];\n        push$3(encoded, exec$2(regexNonASCII, label) ? \"xn--\" + encode(label) : label);\n    }\n    return join$2(encoded, \".\");\n};\nvar defineBuiltIn$3 = defineBuiltIn$a;\nvar defineBuiltIns$1 = function(target, src, options) {\n    for(var key in src)defineBuiltIn$3(target, key, src[key], options);\n    return target;\n};\nvar arraySlice$1 = arraySliceSimple;\nvar floor$2 = Math.floor;\nvar mergeSort = function(array, comparefn) {\n    var length = array.length;\n    var middle = floor$2(length / 2);\n    return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice$1(array, 0, middle), comparefn), mergeSort(arraySlice$1(array, middle), comparefn), comparefn);\n};\nvar insertionSort = function(array, comparefn) {\n    var length = array.length;\n    var i = 1;\n    var element, j;\n    while(i < length){\n        j = i;\n        element = array[i];\n        while(j && comparefn(array[j - 1], element) > 0){\n            array[j] = array[--j];\n        }\n        if (j !== i++) array[j] = element;\n    }\n    return array;\n};\nvar merge = function(array, left, right, comparefn) {\n    var llength = left.length;\n    var rlength = right.length;\n    var lindex = 0;\n    var rindex = 0;\n    while(lindex < llength || rindex < rlength){\n        array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];\n    }\n    return array;\n};\nvar arraySort$1 = mergeSort;\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\nvar $$2 = _export;\nvar global$5 = global$o;\nvar call$3 = functionCall;\nvar uncurryThis$5 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar USE_NATIVE_URL$1 = nativeUrl;\nvar defineBuiltIn$2 = defineBuiltIn$a;\nvar defineBuiltIns = defineBuiltIns$1;\nvar setToStringTag$1 = setToStringTag$5;\nvar createIteratorConstructor = createIteratorConstructor$2;\nvar InternalStateModule$1 = internalState;\nvar anInstance$1 = anInstance$3;\nvar isCallable$2 = isCallable$n;\nvar hasOwn$1 = hasOwnProperty_1;\nvar bind$1 = functionBindContext;\nvar classof$1 = classof$6;\nvar anObject$2 = anObject$g;\nvar isObject = isObject$8;\nvar $toString$1 = toString$4;\nvar create$1 = objectCreate;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar getIterator = getIterator$3;\nvar getIteratorMethod = getIteratorMethod$4;\nvar validateArgumentsLength$1 = validateArgumentsLength$3;\nvar wellKnownSymbol$2 = wellKnownSymbol$i;\nvar arraySort = arraySort$1;\nvar ITERATOR = wellKnownSymbol$2(\"iterator\");\nvar URL_SEARCH_PARAMS = \"URLSearchParams\";\nvar URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + \"Iterator\";\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalParamsState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS);\nvar getInternalIteratorState = InternalStateModule$1.getterFor(URL_SEARCH_PARAMS_ITERATOR);\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n// Avoid NodeJS experimental warning\nvar safeGetBuiltIn = function(name) {\n    if (!DESCRIPTORS$1) return global$5[name];\n    var descriptor = getOwnPropertyDescriptor(global$5, name);\n    return descriptor && descriptor.value;\n};\nvar nativeFetch = safeGetBuiltIn(\"fetch\");\nvar NativeRequest = safeGetBuiltIn(\"Request\");\nvar Headers = safeGetBuiltIn(\"Headers\");\nvar RequestPrototype = NativeRequest && NativeRequest.prototype;\nvar HeadersPrototype = Headers && Headers.prototype;\nvar RegExp$1 = global$5.RegExp;\nvar TypeError$2 = global$5.TypeError;\nvar decodeURIComponent = global$5.decodeURIComponent;\nvar encodeURIComponent$1 = global$5.encodeURIComponent;\nvar charAt$4 = uncurryThis$5(\"\".charAt);\nvar join$1 = uncurryThis$5([].join);\nvar push$2 = uncurryThis$5([].push);\nvar replace$3 = uncurryThis$5(\"\".replace);\nvar shift$1 = uncurryThis$5([].shift);\nvar splice = uncurryThis$5([].splice);\nvar split$1 = uncurryThis$5(\"\".split);\nvar stringSlice$4 = uncurryThis$5(\"\".slice);\nvar plus = /\\+/g;\nvar sequences = Array(4);\nvar percentSequence = function(bytes) {\n    return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp$1(\"((?:%[\\\\da-f]{2}){\" + bytes + \"})\", \"gi\"));\n};\nvar percentDecode = function(sequence) {\n    try {\n        return decodeURIComponent(sequence);\n    } catch (error) {\n        return sequence;\n    }\n};\nvar deserialize = function(it) {\n    var result = replace$3(it, plus, \" \");\n    var bytes = 4;\n    try {\n        return decodeURIComponent(result);\n    } catch (error) {\n        while(bytes){\n            result = replace$3(result, percentSequence(bytes--), percentDecode);\n        }\n        return result;\n    }\n};\nvar find = /[!'()~]|%20/g;\nvar replacements = {\n    \"!\": \"%21\",\n    \"'\": \"%27\",\n    \"(\": \"%28\",\n    \")\": \"%29\",\n    \"~\": \"%7E\",\n    \"%20\": \"+\"\n};\nvar replacer = function(match) {\n    return replacements[match];\n};\nvar serialize = function(it) {\n    return replace$3(encodeURIComponent$1(it), find, replacer);\n};\nvar URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {\n    setInternalState$1(this, {\n        type: URL_SEARCH_PARAMS_ITERATOR,\n        iterator: getIterator(getInternalParamsState(params).entries),\n        kind: kind\n    });\n}, \"Iterator\", function next() {\n    var state = getInternalIteratorState(this);\n    var kind = state.kind;\n    var step = state.iterator.next();\n    var entry = step.value;\n    if (!step.done) {\n        step.value = kind === \"keys\" ? entry.key : kind === \"values\" ? entry.value : [\n            entry.key,\n            entry.value\n        ];\n    }\n    return step;\n}, true);\nvar URLSearchParamsState = function(init) {\n    this.entries = [];\n    this.url = null;\n    if (init !== undefined) {\n        if (isObject(init)) this.parseObject(init);\n        else this.parseQuery(typeof init == \"string\" ? charAt$4(init, 0) === \"?\" ? stringSlice$4(init, 1) : init : $toString$1(init));\n    }\n};\nURLSearchParamsState.prototype = {\n    type: URL_SEARCH_PARAMS,\n    bindURL: function(url) {\n        this.url = url;\n        this.update();\n    },\n    parseObject: function(object) {\n        var iteratorMethod = getIteratorMethod(object);\n        var iterator, next, step, entryIterator, entryNext, first, second;\n        if (iteratorMethod) {\n            iterator = getIterator(object, iteratorMethod);\n            next = iterator.next;\n            while(!(step = call$3(next, iterator)).done){\n                entryIterator = getIterator(anObject$2(step.value));\n                entryNext = entryIterator.next;\n                if ((first = call$3(entryNext, entryIterator)).done || (second = call$3(entryNext, entryIterator)).done || !call$3(entryNext, entryIterator).done) throw TypeError$2(\"Expected sequence with length 2\");\n                push$2(this.entries, {\n                    key: $toString$1(first.value),\n                    value: $toString$1(second.value)\n                });\n            }\n        } else for(var key in object)if (hasOwn$1(object, key)) {\n            push$2(this.entries, {\n                key: key,\n                value: $toString$1(object[key])\n            });\n        }\n    },\n    parseQuery: function(query) {\n        if (query) {\n            var attributes = split$1(query, \"&\");\n            var index = 0;\n            var attribute, entry;\n            while(index < attributes.length){\n                attribute = attributes[index++];\n                if (attribute.length) {\n                    entry = split$1(attribute, \"=\");\n                    push$2(this.entries, {\n                        key: deserialize(shift$1(entry)),\n                        value: deserialize(join$1(entry, \"=\"))\n                    });\n                }\n            }\n        }\n    },\n    serialize: function() {\n        var entries = this.entries;\n        var result = [];\n        var index = 0;\n        var entry;\n        while(index < entries.length){\n            entry = entries[index++];\n            push$2(result, serialize(entry.key) + \"=\" + serialize(entry.value));\n        }\n        return join$1(result, \"&\");\n    },\n    update: function() {\n        this.entries.length = 0;\n        this.parseQuery(this.url.query);\n    },\n    updateURL: function() {\n        if (this.url) this.url.update();\n    }\n};\n// `URLSearchParams` constructor\n// https://url.spec.whatwg.org/#interface-urlsearchparams\nvar URLSearchParamsConstructor = function URLSearchParams1() {\n    anInstance$1(this, URLSearchParamsPrototype);\n    var init = arguments.length > 0 ? arguments[0] : undefined;\n    setInternalState$1(this, new URLSearchParamsState(init));\n};\nvar URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;\ndefineBuiltIns(URLSearchParamsPrototype, {\n    // `URLSearchParams.prototype.append` method\n    // https://url.spec.whatwg.org/#dom-urlsearchparams-append\n    append: function append(name, value) {\n        validateArgumentsLength$1(arguments.length, 2);\n        var state = getInternalParamsState(this);\n        push$2(state.entries, {\n            key: $toString$1(name),\n            value: $toString$1(value)\n        });\n        state.updateURL();\n    },\n    // `URLSearchParams.prototype.delete` method\n    // https://url.spec.whatwg.org/#dom-urlsearchparams-delete\n    \"delete\": function(name) {\n        validateArgumentsLength$1(arguments.length, 1);\n        var state = getInternalParamsState(this);\n        var entries = state.entries;\n        var key = $toString$1(name);\n        var index = 0;\n        while(index < entries.length){\n            if (entries[index].key === key) splice(entries, index, 1);\n            else index++;\n        }\n        state.updateURL();\n    },\n    // `URLSearchParams.prototype.get` method\n    // https://url.spec.whatwg.org/#dom-urlsearchparams-get\n    get: function get(name) {\n        validateArgumentsLength$1(arguments.length, 1);\n        var entries = getInternalParamsState(this).entries;\n        var key = $toString$1(name);\n        var index = 0;\n        for(; index < entries.length; index++){\n            if (entries[index].key === key) return entries[index].value;\n        }\n        return null;\n    },\n    // `URLSearchParams.prototype.getAll` method\n    // https://url.spec.whatwg.org/#dom-urlsearchparams-getall\n    getAll: function getAll(name) {\n        validateArgumentsLength$1(arguments.length, 1);\n        var entries = getInternalParamsState(this).entries;\n        var key = $toString$1(name);\n        var result = [];\n        var index = 0;\n        for(; index < entries.length; index++){\n            if (entries[index].key === key) push$2(result, entries[index].value);\n        }\n        return result;\n    },\n    // `URLSearchParams.prototype.has` method\n    // https://url.spec.whatwg.org/#dom-urlsearchparams-has\n    has: function has(name) {\n        validateArgumentsLength$1(arguments.length, 1);\n        var entries = getInternalParamsState(this).entries;\n        var key = $toString$1(name);\n        var index = 0;\n        while(index < entries.length){\n            if (entries[index++].key === key) return true;\n        }\n        return false;\n    },\n    // `URLSearchParams.prototype.set` method\n    // https://url.spec.whatwg.org/#dom-urlsearchparams-set\n    set: function set(name, value) {\n        validateArgumentsLength$1(arguments.length, 1);\n        var state = getInternalParamsState(this);\n        var entries = state.entries;\n        var found = false;\n        var key = $toString$1(name);\n        var val = $toString$1(value);\n        var index = 0;\n        var entry;\n        for(; index < entries.length; index++){\n            entry = entries[index];\n            if (entry.key === key) {\n                if (found) splice(entries, index--, 1);\n                else {\n                    found = true;\n                    entry.value = val;\n                }\n            }\n        }\n        if (!found) push$2(entries, {\n            key: key,\n            value: val\n        });\n        state.updateURL();\n    },\n    // `URLSearchParams.prototype.sort` method\n    // https://url.spec.whatwg.org/#dom-urlsearchparams-sort\n    sort: function sort() {\n        var state = getInternalParamsState(this);\n        arraySort(state.entries, function(a, b) {\n            return a.key > b.key ? 1 : -1;\n        });\n        state.updateURL();\n    },\n    // `URLSearchParams.prototype.forEach` method\n    forEach: function forEach(callback /* , thisArg */ ) {\n        var entries = getInternalParamsState(this).entries;\n        var boundFunction = bind$1(callback, arguments.length > 1 ? arguments[1] : undefined);\n        var index = 0;\n        var entry;\n        while(index < entries.length){\n            entry = entries[index++];\n            boundFunction(entry.value, entry.key, this);\n        }\n    },\n    // `URLSearchParams.prototype.keys` method\n    keys: function keys() {\n        return new URLSearchParamsIterator(this, \"keys\");\n    },\n    // `URLSearchParams.prototype.values` method\n    values: function values() {\n        return new URLSearchParamsIterator(this, \"values\");\n    },\n    // `URLSearchParams.prototype.entries` method\n    entries: function entries() {\n        return new URLSearchParamsIterator(this, \"entries\");\n    }\n}, {\n    enumerable: true\n});\n// `URLSearchParams.prototype[@@iterator]` method\ndefineBuiltIn$2(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, {\n    name: \"entries\"\n});\n// `URLSearchParams.prototype.toString` method\n// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\ndefineBuiltIn$2(URLSearchParamsPrototype, \"toString\", function toString() {\n    return getInternalParamsState(this).serialize();\n}, {\n    enumerable: true\n});\nsetToStringTag$1(URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n$$2({\n    global: true,\n    constructor: true,\n    forced: !USE_NATIVE_URL$1\n}, {\n    URLSearchParams: URLSearchParamsConstructor\n});\n// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`\nif (!USE_NATIVE_URL$1 && isCallable$2(Headers)) {\n    var headersHas = uncurryThis$5(HeadersPrototype.has);\n    var headersSet = uncurryThis$5(HeadersPrototype.set);\n    var wrapRequestOptions = function(init) {\n        if (isObject(init)) {\n            var body = init.body;\n            var headers;\n            if (classof$1(body) === URL_SEARCH_PARAMS) {\n                headers = init.headers ? new Headers(init.headers) : new Headers();\n                if (!headersHas(headers, \"content-type\")) {\n                    headersSet(headers, \"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n                }\n                return create$1(init, {\n                    body: createPropertyDescriptor(0, $toString$1(body)),\n                    headers: createPropertyDescriptor(0, headers)\n                });\n            }\n        }\n        return init;\n    };\n    if (isCallable$2(nativeFetch)) {\n        $$2({\n            global: true,\n            enumerable: true,\n            dontCallGetSet: true,\n            forced: true\n        }, {\n            fetch: function fetch(input /* , init */ ) {\n                return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});\n            }\n        });\n    }\n    if (isCallable$2(NativeRequest)) {\n        var RequestConstructor = function Request(input /* , init */ ) {\n            anInstance$1(this, RequestPrototype);\n            return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});\n        };\n        RequestPrototype.constructor = RequestConstructor;\n        RequestConstructor.prototype = RequestPrototype;\n        $$2({\n            global: true,\n            constructor: true,\n            dontCallGetSet: true,\n            forced: true\n        }, {\n            Request: RequestConstructor\n        });\n    }\n}\nvar web_urlSearchParams_constructor = {\n    URLSearchParams: URLSearchParamsConstructor,\n    getState: getInternalParamsState\n};\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\nvar $$1 = _export;\nvar DESCRIPTORS = descriptors;\nvar USE_NATIVE_URL = nativeUrl;\nvar global$4 = global$o;\nvar bind = functionBindContext;\nvar uncurryThis$4 = functionUncurryThis;\nvar defineBuiltIn$1 = defineBuiltIn$a;\nvar defineBuiltInAccessor = defineBuiltInAccessor$1;\nvar anInstance = anInstance$3;\nvar hasOwn = hasOwnProperty_1;\nvar assign = objectAssign;\nvar arrayFrom = arrayFrom$1;\nvar arraySlice = arraySliceSimple;\nvar codeAt = stringMultibyte.codeAt;\nvar toASCII = stringPunycodeToAscii;\nvar $toString = toString$4;\nvar setToStringTag = setToStringTag$5;\nvar validateArgumentsLength = validateArgumentsLength$3;\nvar URLSearchParamsModule = web_urlSearchParams_constructor;\nvar InternalStateModule = internalState;\nvar setInternalState = InternalStateModule.set;\nvar getInternalURLState = InternalStateModule.getterFor(\"URL\");\nvar URLSearchParams$1 = URLSearchParamsModule.URLSearchParams;\nvar getInternalSearchParamsState = URLSearchParamsModule.getState;\nvar NativeURL = global$4.URL;\nvar TypeError$1 = global$4.TypeError;\nvar parseInt = global$4.parseInt;\nvar floor$1 = Math.floor;\nvar pow = Math.pow;\nvar charAt$3 = uncurryThis$4(\"\".charAt);\nvar exec$1 = uncurryThis$4(/./.exec);\nvar join = uncurryThis$4([].join);\nvar numberToString = uncurryThis$4(1.0.toString);\nvar pop = uncurryThis$4([].pop);\nvar push$1 = uncurryThis$4([].push);\nvar replace$2 = uncurryThis$4(\"\".replace);\nvar shift = uncurryThis$4([].shift);\nvar split = uncurryThis$4(\"\".split);\nvar stringSlice$3 = uncurryThis$4(\"\".slice);\nvar toLowerCase = uncurryThis$4(\"\".toLowerCase);\nvar unshift = uncurryThis$4([].unshift);\nvar INVALID_AUTHORITY = \"Invalid authority\";\nvar INVALID_SCHEME = \"Invalid scheme\";\nvar INVALID_HOST = \"Invalid host\";\nvar INVALID_PORT = \"Invalid port\";\nvar ALPHA = /[a-z]/i;\n// eslint-disable-next-line regexp/no-obscure-range -- safe\nvar ALPHANUMERIC = /[\\d+-.a-z]/i;\nvar DIGIT = /\\d/;\nvar HEX_START = /^0x/i;\nvar OCT = /^[0-7]+$/;\nvar DEC = /^\\d+$/;\nvar HEX = /^[\\da-f]+$/i;\n/* eslint-disable regexp/no-control-character -- safe */ var FORBIDDEN_HOST_CODE_POINT = /[\\0\\t\\n\\r #%/:<>?@[\\\\\\]^|]/;\nvar FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\\0\\t\\n\\r #/:<>?@[\\\\\\]^|]/;\nvar LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\\u0000-\\u0020]+|[\\u0000-\\u0020]+$/g;\nvar TAB_AND_NEW_LINE = /[\\t\\n\\r]/g;\n/* eslint-enable regexp/no-control-character -- safe */ var EOF;\n// https://url.spec.whatwg.org/#ipv4-number-parser\nvar parseIPv4 = function(input) {\n    var parts = split(input, \".\");\n    var partsLength, numbers, index, part, radix, number, ipv4;\n    if (parts.length && parts[parts.length - 1] == \"\") {\n        parts.length--;\n    }\n    partsLength = parts.length;\n    if (partsLength > 4) return input;\n    numbers = [];\n    for(index = 0; index < partsLength; index++){\n        part = parts[index];\n        if (part == \"\") return input;\n        radix = 10;\n        if (part.length > 1 && charAt$3(part, 0) == \"0\") {\n            radix = exec$1(HEX_START, part) ? 16 : 8;\n            part = stringSlice$3(part, radix == 8 ? 1 : 2);\n        }\n        if (part === \"\") {\n            number = 0;\n        } else {\n            if (!exec$1(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;\n            number = parseInt(part, radix);\n        }\n        push$1(numbers, number);\n    }\n    for(index = 0; index < partsLength; index++){\n        number = numbers[index];\n        if (index == partsLength - 1) {\n            if (number >= pow(256, 5 - partsLength)) return null;\n        } else if (number > 255) return null;\n    }\n    ipv4 = pop(numbers);\n    for(index = 0; index < numbers.length; index++){\n        ipv4 += numbers[index] * pow(256, 3 - index);\n    }\n    return ipv4;\n};\n// https://url.spec.whatwg.org/#concept-ipv6-parser\n// eslint-disable-next-line max-statements -- TODO\nvar parseIPv6 = function(input) {\n    var address = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    var pieceIndex = 0;\n    var compress = null;\n    var pointer = 0;\n    var value, length, numbersSeen, ipv4Piece, number, swaps, swap;\n    var chr = function() {\n        return charAt$3(input, pointer);\n    };\n    if (chr() == \":\") {\n        if (charAt$3(input, 1) != \":\") return;\n        pointer += 2;\n        pieceIndex++;\n        compress = pieceIndex;\n    }\n    while(chr()){\n        if (pieceIndex == 8) return;\n        if (chr() == \":\") {\n            if (compress !== null) return;\n            pointer++;\n            pieceIndex++;\n            compress = pieceIndex;\n            continue;\n        }\n        value = length = 0;\n        while(length < 4 && exec$1(HEX, chr())){\n            value = value * 16 + parseInt(chr(), 16);\n            pointer++;\n            length++;\n        }\n        if (chr() == \".\") {\n            if (length == 0) return;\n            pointer -= length;\n            if (pieceIndex > 6) return;\n            numbersSeen = 0;\n            while(chr()){\n                ipv4Piece = null;\n                if (numbersSeen > 0) {\n                    if (chr() == \".\" && numbersSeen < 4) pointer++;\n                    else return;\n                }\n                if (!exec$1(DIGIT, chr())) return;\n                while(exec$1(DIGIT, chr())){\n                    number = parseInt(chr(), 10);\n                    if (ipv4Piece === null) ipv4Piece = number;\n                    else if (ipv4Piece == 0) return;\n                    else ipv4Piece = ipv4Piece * 10 + number;\n                    if (ipv4Piece > 255) return;\n                    pointer++;\n                }\n                address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;\n                numbersSeen++;\n                if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;\n            }\n            if (numbersSeen != 4) return;\n            break;\n        } else if (chr() == \":\") {\n            pointer++;\n            if (!chr()) return;\n        } else if (chr()) return;\n        address[pieceIndex++] = value;\n    }\n    if (compress !== null) {\n        swaps = pieceIndex - compress;\n        pieceIndex = 7;\n        while(pieceIndex != 0 && swaps > 0){\n            swap = address[pieceIndex];\n            address[pieceIndex--] = address[compress + swaps - 1];\n            address[compress + --swaps] = swap;\n        }\n    } else if (pieceIndex != 8) return;\n    return address;\n};\nvar findLongestZeroSequence = function(ipv6) {\n    var maxIndex = null;\n    var maxLength = 1;\n    var currStart = null;\n    var currLength = 0;\n    var index = 0;\n    for(; index < 8; index++){\n        if (ipv6[index] !== 0) {\n            if (currLength > maxLength) {\n                maxIndex = currStart;\n                maxLength = currLength;\n            }\n            currStart = null;\n            currLength = 0;\n        } else {\n            if (currStart === null) currStart = index;\n            ++currLength;\n        }\n    }\n    if (currLength > maxLength) {\n        maxIndex = currStart;\n        maxLength = currLength;\n    }\n    return maxIndex;\n};\n// https://url.spec.whatwg.org/#host-serializing\nvar serializeHost = function(host) {\n    var result, index, compress, ignore0;\n    // ipv4\n    if (typeof host == \"number\") {\n        result = [];\n        for(index = 0; index < 4; index++){\n            unshift(result, host % 256);\n            host = floor$1(host / 256);\n        }\n        return join(result, \".\");\n    // ipv6\n    } else if (typeof host == \"object\") {\n        result = \"\";\n        compress = findLongestZeroSequence(host);\n        for(index = 0; index < 8; index++){\n            if (ignore0 && host[index] === 0) continue;\n            if (ignore0) ignore0 = false;\n            if (compress === index) {\n                result += index ? \":\" : \"::\";\n                ignore0 = true;\n            } else {\n                result += numberToString(host[index], 16);\n                if (index < 7) result += \":\";\n            }\n        }\n        return \"[\" + result + \"]\";\n    }\n    return host;\n};\nvar C0ControlPercentEncodeSet = {};\nvar fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {\n    \" \": 1,\n    '\"': 1,\n    \"<\": 1,\n    \">\": 1,\n    \"`\": 1\n});\nvar pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {\n    \"#\": 1,\n    \"?\": 1,\n    \"{\": 1,\n    \"}\": 1\n});\nvar userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {\n    \"/\": 1,\n    \":\": 1,\n    \";\": 1,\n    \"=\": 1,\n    \"@\": 1,\n    \"[\": 1,\n    \"\\\\\": 1,\n    \"]\": 1,\n    \"^\": 1,\n    \"|\": 1\n});\nvar percentEncode = function(chr, set) {\n    var code = codeAt(chr, 0);\n    return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);\n};\n// https://url.spec.whatwg.org/#special-scheme\nvar specialSchemes = {\n    ftp: 21,\n    file: null,\n    http: 80,\n    https: 443,\n    ws: 80,\n    wss: 443\n};\n// https://url.spec.whatwg.org/#windows-drive-letter\nvar isWindowsDriveLetter = function(string, normalized) {\n    var second;\n    return string.length == 2 && exec$1(ALPHA, charAt$3(string, 0)) && ((second = charAt$3(string, 1)) == \":\" || !normalized && second == \"|\");\n};\n// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter\nvar startsWithWindowsDriveLetter = function(string) {\n    var third;\n    return string.length > 1 && isWindowsDriveLetter(stringSlice$3(string, 0, 2)) && (string.length == 2 || (third = charAt$3(string, 2)) === \"/\" || third === \"\\\\\" || third === \"?\" || third === \"#\");\n};\n// https://url.spec.whatwg.org/#single-dot-path-segment\nvar isSingleDot = function(segment) {\n    return segment === \".\" || toLowerCase(segment) === \"%2e\";\n};\n// https://url.spec.whatwg.org/#double-dot-path-segment\nvar isDoubleDot = function(segment) {\n    segment = toLowerCase(segment);\n    return segment === \"..\" || segment === \"%2e.\" || segment === \".%2e\" || segment === \"%2e%2e\";\n};\n// States:\nvar SCHEME_START = {};\nvar SCHEME = {};\nvar NO_SCHEME = {};\nvar SPECIAL_RELATIVE_OR_AUTHORITY = {};\nvar PATH_OR_AUTHORITY = {};\nvar RELATIVE = {};\nvar RELATIVE_SLASH = {};\nvar SPECIAL_AUTHORITY_SLASHES = {};\nvar SPECIAL_AUTHORITY_IGNORE_SLASHES = {};\nvar AUTHORITY = {};\nvar HOST = {};\nvar HOSTNAME = {};\nvar PORT = {};\nvar FILE = {};\nvar FILE_SLASH = {};\nvar FILE_HOST = {};\nvar PATH_START = {};\nvar PATH = {};\nvar CANNOT_BE_A_BASE_URL_PATH = {};\nvar QUERY = {};\nvar FRAGMENT = {};\nvar URLState = function(url, isBase, base) {\n    var urlString = $toString(url);\n    var baseState, failure, searchParams;\n    if (isBase) {\n        failure = this.parse(urlString);\n        if (failure) throw TypeError$1(failure);\n        this.searchParams = null;\n    } else {\n        if (base !== undefined) baseState = new URLState(base, true);\n        failure = this.parse(urlString, null, baseState);\n        if (failure) throw TypeError$1(failure);\n        searchParams = getInternalSearchParamsState(new URLSearchParams$1());\n        searchParams.bindURL(this);\n        this.searchParams = searchParams;\n    }\n};\nURLState.prototype = {\n    type: \"URL\",\n    // https://url.spec.whatwg.org/#url-parsing\n    // eslint-disable-next-line max-statements -- TODO\n    parse: function(input, stateOverride, base) {\n        var url = this;\n        var state = stateOverride || SCHEME_START;\n        var pointer = 0;\n        var buffer = \"\";\n        var seenAt = false;\n        var seenBracket = false;\n        var seenPasswordToken = false;\n        var codePoints, chr, bufferCodePoints, failure;\n        input = $toString(input);\n        if (!stateOverride) {\n            url.scheme = \"\";\n            url.username = \"\";\n            url.password = \"\";\n            url.host = null;\n            url.port = null;\n            url.path = [];\n            url.query = null;\n            url.fragment = null;\n            url.cannotBeABaseURL = false;\n            input = replace$2(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, \"\");\n        }\n        input = replace$2(input, TAB_AND_NEW_LINE, \"\");\n        codePoints = arrayFrom(input);\n        while(pointer <= codePoints.length){\n            chr = codePoints[pointer];\n            switch(state){\n                case SCHEME_START:\n                    if (chr && exec$1(ALPHA, chr)) {\n                        buffer += toLowerCase(chr);\n                        state = SCHEME;\n                    } else if (!stateOverride) {\n                        state = NO_SCHEME;\n                        continue;\n                    } else return INVALID_SCHEME;\n                    break;\n                case SCHEME:\n                    if (chr && (exec$1(ALPHANUMERIC, chr) || chr == \"+\" || chr == \"-\" || chr == \".\")) {\n                        buffer += toLowerCase(chr);\n                    } else if (chr == \":\") {\n                        if (stateOverride && (url.isSpecial() != hasOwn(specialSchemes, buffer) || buffer == \"file\" && (url.includesCredentials() || url.port !== null) || url.scheme == \"file\" && !url.host)) return;\n                        url.scheme = buffer;\n                        if (stateOverride) {\n                            if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;\n                            return;\n                        }\n                        buffer = \"\";\n                        if (url.scheme == \"file\") {\n                            state = FILE;\n                        } else if (url.isSpecial() && base && base.scheme == url.scheme) {\n                            state = SPECIAL_RELATIVE_OR_AUTHORITY;\n                        } else if (url.isSpecial()) {\n                            state = SPECIAL_AUTHORITY_SLASHES;\n                        } else if (codePoints[pointer + 1] == \"/\") {\n                            state = PATH_OR_AUTHORITY;\n                            pointer++;\n                        } else {\n                            url.cannotBeABaseURL = true;\n                            push$1(url.path, \"\");\n                            state = CANNOT_BE_A_BASE_URL_PATH;\n                        }\n                    } else if (!stateOverride) {\n                        buffer = \"\";\n                        state = NO_SCHEME;\n                        pointer = 0;\n                        continue;\n                    } else return INVALID_SCHEME;\n                    break;\n                case NO_SCHEME:\n                    if (!base || base.cannotBeABaseURL && chr != \"#\") return INVALID_SCHEME;\n                    if (base.cannotBeABaseURL && chr == \"#\") {\n                        url.scheme = base.scheme;\n                        url.path = arraySlice(base.path);\n                        url.query = base.query;\n                        url.fragment = \"\";\n                        url.cannotBeABaseURL = true;\n                        state = FRAGMENT;\n                        break;\n                    }\n                    state = base.scheme == \"file\" ? FILE : RELATIVE;\n                    continue;\n                case SPECIAL_RELATIVE_OR_AUTHORITY:\n                    if (chr == \"/\" && codePoints[pointer + 1] == \"/\") {\n                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n                        pointer++;\n                    } else {\n                        state = RELATIVE;\n                        continue;\n                    }\n                    break;\n                case PATH_OR_AUTHORITY:\n                    if (chr == \"/\") {\n                        state = AUTHORITY;\n                        break;\n                    } else {\n                        state = PATH;\n                        continue;\n                    }\n                case RELATIVE:\n                    url.scheme = base.scheme;\n                    if (chr == EOF) {\n                        url.username = base.username;\n                        url.password = base.password;\n                        url.host = base.host;\n                        url.port = base.port;\n                        url.path = arraySlice(base.path);\n                        url.query = base.query;\n                    } else if (chr == \"/\" || chr == \"\\\\\" && url.isSpecial()) {\n                        state = RELATIVE_SLASH;\n                    } else if (chr == \"?\") {\n                        url.username = base.username;\n                        url.password = base.password;\n                        url.host = base.host;\n                        url.port = base.port;\n                        url.path = arraySlice(base.path);\n                        url.query = \"\";\n                        state = QUERY;\n                    } else if (chr == \"#\") {\n                        url.username = base.username;\n                        url.password = base.password;\n                        url.host = base.host;\n                        url.port = base.port;\n                        url.path = arraySlice(base.path);\n                        url.query = base.query;\n                        url.fragment = \"\";\n                        state = FRAGMENT;\n                    } else {\n                        url.username = base.username;\n                        url.password = base.password;\n                        url.host = base.host;\n                        url.port = base.port;\n                        url.path = arraySlice(base.path);\n                        url.path.length--;\n                        state = PATH;\n                        continue;\n                    }\n                    break;\n                case RELATIVE_SLASH:\n                    if (url.isSpecial() && (chr == \"/\" || chr == \"\\\\\")) {\n                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n                    } else if (chr == \"/\") {\n                        state = AUTHORITY;\n                    } else {\n                        url.username = base.username;\n                        url.password = base.password;\n                        url.host = base.host;\n                        url.port = base.port;\n                        state = PATH;\n                        continue;\n                    }\n                    break;\n                case SPECIAL_AUTHORITY_SLASHES:\n                    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n                    if (chr != \"/\" || charAt$3(buffer, pointer + 1) != \"/\") continue;\n                    pointer++;\n                    break;\n                case SPECIAL_AUTHORITY_IGNORE_SLASHES:\n                    if (chr != \"/\" && chr != \"\\\\\") {\n                        state = AUTHORITY;\n                        continue;\n                    }\n                    break;\n                case AUTHORITY:\n                    if (chr == \"@\") {\n                        if (seenAt) buffer = \"%40\" + buffer;\n                        seenAt = true;\n                        bufferCodePoints = arrayFrom(buffer);\n                        for(var i = 0; i < bufferCodePoints.length; i++){\n                            var codePoint = bufferCodePoints[i];\n                            if (codePoint == \":\" && !seenPasswordToken) {\n                                seenPasswordToken = true;\n                                continue;\n                            }\n                            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);\n                            if (seenPasswordToken) url.password += encodedCodePoints;\n                            else url.username += encodedCodePoints;\n                        }\n                        buffer = \"\";\n                    } else if (chr == EOF || chr == \"/\" || chr == \"?\" || chr == \"#\" || chr == \"\\\\\" && url.isSpecial()) {\n                        if (seenAt && buffer == \"\") return INVALID_AUTHORITY;\n                        pointer -= arrayFrom(buffer).length + 1;\n                        buffer = \"\";\n                        state = HOST;\n                    } else buffer += chr;\n                    break;\n                case HOST:\n                case HOSTNAME:\n                    if (stateOverride && url.scheme == \"file\") {\n                        state = FILE_HOST;\n                        continue;\n                    } else if (chr == \":\" && !seenBracket) {\n                        if (buffer == \"\") return INVALID_HOST;\n                        failure = url.parseHost(buffer);\n                        if (failure) return failure;\n                        buffer = \"\";\n                        state = PORT;\n                        if (stateOverride == HOSTNAME) return;\n                    } else if (chr == EOF || chr == \"/\" || chr == \"?\" || chr == \"#\" || chr == \"\\\\\" && url.isSpecial()) {\n                        if (url.isSpecial() && buffer == \"\") return INVALID_HOST;\n                        if (stateOverride && buffer == \"\" && (url.includesCredentials() || url.port !== null)) return;\n                        failure = url.parseHost(buffer);\n                        if (failure) return failure;\n                        buffer = \"\";\n                        state = PATH_START;\n                        if (stateOverride) return;\n                        continue;\n                    } else {\n                        if (chr == \"[\") seenBracket = true;\n                        else if (chr == \"]\") seenBracket = false;\n                        buffer += chr;\n                    }\n                    break;\n                case PORT:\n                    if (exec$1(DIGIT, chr)) {\n                        buffer += chr;\n                    } else if (chr == EOF || chr == \"/\" || chr == \"?\" || chr == \"#\" || chr == \"\\\\\" && url.isSpecial() || stateOverride) {\n                        if (buffer != \"\") {\n                            var port = parseInt(buffer, 10);\n                            if (port > 0xFFFF) return INVALID_PORT;\n                            url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;\n                            buffer = \"\";\n                        }\n                        if (stateOverride) return;\n                        state = PATH_START;\n                        continue;\n                    } else return INVALID_PORT;\n                    break;\n                case FILE:\n                    url.scheme = \"file\";\n                    if (chr == \"/\" || chr == \"\\\\\") state = FILE_SLASH;\n                    else if (base && base.scheme == \"file\") {\n                        if (chr == EOF) {\n                            url.host = base.host;\n                            url.path = arraySlice(base.path);\n                            url.query = base.query;\n                        } else if (chr == \"?\") {\n                            url.host = base.host;\n                            url.path = arraySlice(base.path);\n                            url.query = \"\";\n                            state = QUERY;\n                        } else if (chr == \"#\") {\n                            url.host = base.host;\n                            url.path = arraySlice(base.path);\n                            url.query = base.query;\n                            url.fragment = \"\";\n                            state = FRAGMENT;\n                        } else {\n                            if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), \"\"))) {\n                                url.host = base.host;\n                                url.path = arraySlice(base.path);\n                                url.shortenPath();\n                            }\n                            state = PATH;\n                            continue;\n                        }\n                    } else {\n                        state = PATH;\n                        continue;\n                    }\n                    break;\n                case FILE_SLASH:\n                    if (chr == \"/\" || chr == \"\\\\\") {\n                        state = FILE_HOST;\n                        break;\n                    }\n                    if (base && base.scheme == \"file\" && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), \"\"))) {\n                        if (isWindowsDriveLetter(base.path[0], true)) push$1(url.path, base.path[0]);\n                        else url.host = base.host;\n                    }\n                    state = PATH;\n                    continue;\n                case FILE_HOST:\n                    if (chr == EOF || chr == \"/\" || chr == \"\\\\\" || chr == \"?\" || chr == \"#\") {\n                        if (!stateOverride && isWindowsDriveLetter(buffer)) {\n                            state = PATH;\n                        } else if (buffer == \"\") {\n                            url.host = \"\";\n                            if (stateOverride) return;\n                            state = PATH_START;\n                        } else {\n                            failure = url.parseHost(buffer);\n                            if (failure) return failure;\n                            if (url.host == \"localhost\") url.host = \"\";\n                            if (stateOverride) return;\n                            buffer = \"\";\n                            state = PATH_START;\n                        }\n                        continue;\n                    } else buffer += chr;\n                    break;\n                case PATH_START:\n                    if (url.isSpecial()) {\n                        state = PATH;\n                        if (chr != \"/\" && chr != \"\\\\\") continue;\n                    } else if (!stateOverride && chr == \"?\") {\n                        url.query = \"\";\n                        state = QUERY;\n                    } else if (!stateOverride && chr == \"#\") {\n                        url.fragment = \"\";\n                        state = FRAGMENT;\n                    } else if (chr != EOF) {\n                        state = PATH;\n                        if (chr != \"/\") continue;\n                    }\n                    break;\n                case PATH:\n                    if (chr == EOF || chr == \"/\" || chr == \"\\\\\" && url.isSpecial() || !stateOverride && (chr == \"?\" || chr == \"#\")) {\n                        if (isDoubleDot(buffer)) {\n                            url.shortenPath();\n                            if (chr != \"/\" && !(chr == \"\\\\\" && url.isSpecial())) {\n                                push$1(url.path, \"\");\n                            }\n                        } else if (isSingleDot(buffer)) {\n                            if (chr != \"/\" && !(chr == \"\\\\\" && url.isSpecial())) {\n                                push$1(url.path, \"\");\n                            }\n                        } else {\n                            if (url.scheme == \"file\" && !url.path.length && isWindowsDriveLetter(buffer)) {\n                                if (url.host) url.host = \"\";\n                                buffer = charAt$3(buffer, 0) + \":\"; // normalize windows drive letter\n                            }\n                            push$1(url.path, buffer);\n                        }\n                        buffer = \"\";\n                        if (url.scheme == \"file\" && (chr == EOF || chr == \"?\" || chr == \"#\")) {\n                            while(url.path.length > 1 && url.path[0] === \"\"){\n                                shift(url.path);\n                            }\n                        }\n                        if (chr == \"?\") {\n                            url.query = \"\";\n                            state = QUERY;\n                        } else if (chr == \"#\") {\n                            url.fragment = \"\";\n                            state = FRAGMENT;\n                        }\n                    } else {\n                        buffer += percentEncode(chr, pathPercentEncodeSet);\n                    }\n                    break;\n                case CANNOT_BE_A_BASE_URL_PATH:\n                    if (chr == \"?\") {\n                        url.query = \"\";\n                        state = QUERY;\n                    } else if (chr == \"#\") {\n                        url.fragment = \"\";\n                        state = FRAGMENT;\n                    } else if (chr != EOF) {\n                        url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);\n                    }\n                    break;\n                case QUERY:\n                    if (!stateOverride && chr == \"#\") {\n                        url.fragment = \"\";\n                        state = FRAGMENT;\n                    } else if (chr != EOF) {\n                        if (chr == \"'\" && url.isSpecial()) url.query += \"%27\";\n                        else if (chr == \"#\") url.query += \"%23\";\n                        else url.query += percentEncode(chr, C0ControlPercentEncodeSet);\n                    }\n                    break;\n                case FRAGMENT:\n                    if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);\n                    break;\n            }\n            pointer++;\n        }\n    },\n    // https://url.spec.whatwg.org/#host-parsing\n    parseHost: function(input) {\n        var result, codePoints, index;\n        if (charAt$3(input, 0) == \"[\") {\n            if (charAt$3(input, input.length - 1) != \"]\") return INVALID_HOST;\n            result = parseIPv6(stringSlice$3(input, 1, -1));\n            if (!result) return INVALID_HOST;\n            this.host = result;\n        // opaque host\n        } else if (!this.isSpecial()) {\n            if (exec$1(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;\n            result = \"\";\n            codePoints = arrayFrom(input);\n            for(index = 0; index < codePoints.length; index++){\n                result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);\n            }\n            this.host = result;\n        } else {\n            input = toASCII(input);\n            if (exec$1(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;\n            result = parseIPv4(input);\n            if (result === null) return INVALID_HOST;\n            this.host = result;\n        }\n    },\n    // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n    cannotHaveUsernamePasswordPort: function() {\n        return !this.host || this.cannotBeABaseURL || this.scheme == \"file\";\n    },\n    // https://url.spec.whatwg.org/#include-credentials\n    includesCredentials: function() {\n        return this.username != \"\" || this.password != \"\";\n    },\n    // https://url.spec.whatwg.org/#is-special\n    isSpecial: function() {\n        return hasOwn(specialSchemes, this.scheme);\n    },\n    // https://url.spec.whatwg.org/#shorten-a-urls-path\n    shortenPath: function() {\n        var path = this.path;\n        var pathSize = path.length;\n        if (pathSize && (this.scheme != \"file\" || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {\n            path.length--;\n        }\n    },\n    // https://url.spec.whatwg.org/#concept-url-serializer\n    serialize: function() {\n        var url = this;\n        var scheme = url.scheme;\n        var username = url.username;\n        var password = url.password;\n        var host = url.host;\n        var port = url.port;\n        var path = url.path;\n        var query = url.query;\n        var fragment = url.fragment;\n        var output = scheme + \":\";\n        if (host !== null) {\n            output += \"//\";\n            if (url.includesCredentials()) {\n                output += username + (password ? \":\" + password : \"\") + \"@\";\n            }\n            output += serializeHost(host);\n            if (port !== null) output += \":\" + port;\n        } else if (scheme == \"file\") output += \"//\";\n        output += url.cannotBeABaseURL ? path[0] : path.length ? \"/\" + join(path, \"/\") : \"\";\n        if (query !== null) output += \"?\" + query;\n        if (fragment !== null) output += \"#\" + fragment;\n        return output;\n    },\n    // https://url.spec.whatwg.org/#dom-url-href\n    setHref: function(href) {\n        var failure = this.parse(href);\n        if (failure) throw TypeError$1(failure);\n        this.searchParams.update();\n    },\n    // https://url.spec.whatwg.org/#dom-url-origin\n    getOrigin: function() {\n        var scheme = this.scheme;\n        var port = this.port;\n        if (scheme == \"blob\") try {\n            return new URLConstructor(scheme.path[0]).origin;\n        } catch (error) {\n            return \"null\";\n        }\n        if (scheme == \"file\" || !this.isSpecial()) return \"null\";\n        return scheme + \"://\" + serializeHost(this.host) + (port !== null ? \":\" + port : \"\");\n    },\n    // https://url.spec.whatwg.org/#dom-url-protocol\n    getProtocol: function() {\n        return this.scheme + \":\";\n    },\n    setProtocol: function(protocol) {\n        this.parse($toString(protocol) + \":\", SCHEME_START);\n    },\n    // https://url.spec.whatwg.org/#dom-url-username\n    getUsername: function() {\n        return this.username;\n    },\n    setUsername: function(username) {\n        var codePoints = arrayFrom($toString(username));\n        if (this.cannotHaveUsernamePasswordPort()) return;\n        this.username = \"\";\n        for(var i = 0; i < codePoints.length; i++){\n            this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n        }\n    },\n    // https://url.spec.whatwg.org/#dom-url-password\n    getPassword: function() {\n        return this.password;\n    },\n    setPassword: function(password) {\n        var codePoints = arrayFrom($toString(password));\n        if (this.cannotHaveUsernamePasswordPort()) return;\n        this.password = \"\";\n        for(var i = 0; i < codePoints.length; i++){\n            this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n        }\n    },\n    // https://url.spec.whatwg.org/#dom-url-host\n    getHost: function() {\n        var host = this.host;\n        var port = this.port;\n        return host === null ? \"\" : port === null ? serializeHost(host) : serializeHost(host) + \":\" + port;\n    },\n    setHost: function(host) {\n        if (this.cannotBeABaseURL) return;\n        this.parse(host, HOST);\n    },\n    // https://url.spec.whatwg.org/#dom-url-hostname\n    getHostname: function() {\n        var host = this.host;\n        return host === null ? \"\" : serializeHost(host);\n    },\n    setHostname: function(hostname) {\n        if (this.cannotBeABaseURL) return;\n        this.parse(hostname, HOSTNAME);\n    },\n    // https://url.spec.whatwg.org/#dom-url-port\n    getPort: function() {\n        var port = this.port;\n        return port === null ? \"\" : $toString(port);\n    },\n    setPort: function(port) {\n        if (this.cannotHaveUsernamePasswordPort()) return;\n        port = $toString(port);\n        if (port == \"\") this.port = null;\n        else this.parse(port, PORT);\n    },\n    // https://url.spec.whatwg.org/#dom-url-pathname\n    getPathname: function() {\n        var path = this.path;\n        return this.cannotBeABaseURL ? path[0] : path.length ? \"/\" + join(path, \"/\") : \"\";\n    },\n    setPathname: function(pathname) {\n        if (this.cannotBeABaseURL) return;\n        this.path = [];\n        this.parse(pathname, PATH_START);\n    },\n    // https://url.spec.whatwg.org/#dom-url-search\n    getSearch: function() {\n        var query = this.query;\n        return query ? \"?\" + query : \"\";\n    },\n    setSearch: function(search) {\n        search = $toString(search);\n        if (search == \"\") {\n            this.query = null;\n        } else {\n            if (\"?\" == charAt$3(search, 0)) search = stringSlice$3(search, 1);\n            this.query = \"\";\n            this.parse(search, QUERY);\n        }\n        this.searchParams.update();\n    },\n    // https://url.spec.whatwg.org/#dom-url-searchparams\n    getSearchParams: function() {\n        return this.searchParams.facade;\n    },\n    // https://url.spec.whatwg.org/#dom-url-hash\n    getHash: function() {\n        var fragment = this.fragment;\n        return fragment ? \"#\" + fragment : \"\";\n    },\n    setHash: function(hash) {\n        hash = $toString(hash);\n        if (hash == \"\") {\n            this.fragment = null;\n            return;\n        }\n        if (\"#\" == charAt$3(hash, 0)) hash = stringSlice$3(hash, 1);\n        this.fragment = \"\";\n        this.parse(hash, FRAGMENT);\n    },\n    update: function() {\n        this.query = this.searchParams.serialize() || null;\n    }\n};\n// `URL` constructor\n// https://url.spec.whatwg.org/#url-class\nvar URLConstructor = function URL1(url /* , base */ ) {\n    var that = anInstance(this, URLPrototype);\n    var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;\n    var state = setInternalState(that, new URLState(url, false, base));\n    if (!DESCRIPTORS) {\n        that.href = state.serialize();\n        that.origin = state.getOrigin();\n        that.protocol = state.getProtocol();\n        that.username = state.getUsername();\n        that.password = state.getPassword();\n        that.host = state.getHost();\n        that.hostname = state.getHostname();\n        that.port = state.getPort();\n        that.pathname = state.getPathname();\n        that.search = state.getSearch();\n        that.searchParams = state.getSearchParams();\n        that.hash = state.getHash();\n    }\n};\nvar URLPrototype = URLConstructor.prototype;\nvar accessorDescriptor = function(getter, setter) {\n    return {\n        get: function() {\n            return getInternalURLState(this)[getter]();\n        },\n        set: setter && function(value) {\n            return getInternalURLState(this)[setter](value);\n        },\n        configurable: true,\n        enumerable: true\n    };\n};\nif (DESCRIPTORS) {\n    // `URL.prototype.href` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-href\n    defineBuiltInAccessor(URLPrototype, \"href\", accessorDescriptor(\"serialize\", \"setHref\"));\n    // `URL.prototype.origin` getter\n    // https://url.spec.whatwg.org/#dom-url-origin\n    defineBuiltInAccessor(URLPrototype, \"origin\", accessorDescriptor(\"getOrigin\"));\n    // `URL.prototype.protocol` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-protocol\n    defineBuiltInAccessor(URLPrototype, \"protocol\", accessorDescriptor(\"getProtocol\", \"setProtocol\"));\n    // `URL.prototype.username` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-username\n    defineBuiltInAccessor(URLPrototype, \"username\", accessorDescriptor(\"getUsername\", \"setUsername\"));\n    // `URL.prototype.password` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-password\n    defineBuiltInAccessor(URLPrototype, \"password\", accessorDescriptor(\"getPassword\", \"setPassword\"));\n    // `URL.prototype.host` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-host\n    defineBuiltInAccessor(URLPrototype, \"host\", accessorDescriptor(\"getHost\", \"setHost\"));\n    // `URL.prototype.hostname` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-hostname\n    defineBuiltInAccessor(URLPrototype, \"hostname\", accessorDescriptor(\"getHostname\", \"setHostname\"));\n    // `URL.prototype.port` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-port\n    defineBuiltInAccessor(URLPrototype, \"port\", accessorDescriptor(\"getPort\", \"setPort\"));\n    // `URL.prototype.pathname` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-pathname\n    defineBuiltInAccessor(URLPrototype, \"pathname\", accessorDescriptor(\"getPathname\", \"setPathname\"));\n    // `URL.prototype.search` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-search\n    defineBuiltInAccessor(URLPrototype, \"search\", accessorDescriptor(\"getSearch\", \"setSearch\"));\n    // `URL.prototype.searchParams` getter\n    // https://url.spec.whatwg.org/#dom-url-searchparams\n    defineBuiltInAccessor(URLPrototype, \"searchParams\", accessorDescriptor(\"getSearchParams\"));\n    // `URL.prototype.hash` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-hash\n    defineBuiltInAccessor(URLPrototype, \"hash\", accessorDescriptor(\"getHash\", \"setHash\"));\n}\n// `URL.prototype.toJSON` method\n// https://url.spec.whatwg.org/#dom-url-tojson\ndefineBuiltIn$1(URLPrototype, \"toJSON\", function toJSON() {\n    return getInternalURLState(this).serialize();\n}, {\n    enumerable: true\n});\n// `URL.prototype.toString` method\n// https://url.spec.whatwg.org/#URL-stringification-behavior\ndefineBuiltIn$1(URLPrototype, \"toString\", function toString() {\n    return getInternalURLState(this).serialize();\n}, {\n    enumerable: true\n});\nif (NativeURL) {\n    var nativeCreateObjectURL = NativeURL.createObjectURL;\n    var nativeRevokeObjectURL = NativeURL.revokeObjectURL;\n    // `URL.createObjectURL` method\n    // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n    if (nativeCreateObjectURL) defineBuiltIn$1(URLConstructor, \"createObjectURL\", bind(nativeCreateObjectURL, NativeURL));\n    // `URL.revokeObjectURL` method\n    // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n    if (nativeRevokeObjectURL) defineBuiltIn$1(URLConstructor, \"revokeObjectURL\", bind(nativeRevokeObjectURL, NativeURL));\n}\nsetToStringTag(URLConstructor, \"URL\");\n$$1({\n    global: true,\n    constructor: true,\n    forced: !USE_NATIVE_URL,\n    sham: !DESCRIPTORS\n}, {\n    URL: URLConstructor\n});\nvar fails$4 = fails$k;\nvar global$3 = global$o;\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$3.RegExp;\nvar UNSUPPORTED_Y$1 = fails$4(function() {\n    var re = $RegExp$2(\"a\", \"y\");\n    re.lastIndex = 2;\n    return re.exec(\"abcd\") != null;\n});\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$1 || fails$4(function() {\n    return !$RegExp$2(\"a\", \"y\").sticky;\n});\nvar BROKEN_CARET = UNSUPPORTED_Y$1 || fails$4(function() {\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n    var re = $RegExp$2(\"^r\", \"gy\");\n    re.lastIndex = 2;\n    return re.exec(\"str\") != null;\n});\nvar regexpStickyHelpers = {\n    BROKEN_CARET: BROKEN_CARET,\n    MISSED_STICKY: MISSED_STICKY,\n    UNSUPPORTED_Y: UNSUPPORTED_Y$1\n};\nvar fails$3 = fails$k;\nvar global$2 = global$o;\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$2.RegExp;\nvar regexpUnsupportedDotAll = fails$3(function() {\n    var re = $RegExp$1(\".\", \"s\");\n    return !(re.dotAll && re.exec(\"\\n\") && re.flags === \"s\");\n});\nvar fails$2 = fails$k;\nvar global$1 = global$o;\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$1.RegExp;\nvar regexpUnsupportedNcg = fails$2(function() {\n    var re = $RegExp(\"(?<a>b)\", \"g\");\n    return re.exec(\"b\").groups.a !== \"b\" || \"b\".replace(re, \"$<a>c\") !== \"bc\";\n});\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */ /* eslint-disable regexp/no-useless-quantifier -- testing */ var call$2 = functionCall;\nvar uncurryThis$3 = functionUncurryThis;\nvar toString$1 = toString$4;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create = objectCreate;\nvar getInternalState = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\nvar nativeReplace = shared(\"native-string-replace\", String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$3(\"\".charAt);\nvar indexOf = uncurryThis$3(\"\".indexOf);\nvar replace$1 = uncurryThis$3(\"\".replace);\nvar stringSlice$2 = uncurryThis$3(\"\".slice);\nvar UPDATES_LAST_INDEX_WRONG = function() {\n    var re1 = /a/;\n    var re2 = /b*/g;\n    call$2(nativeExec, re1, \"a\");\n    call$2(nativeExec, re2, \"a\");\n    return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n}();\nvar UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec(\"\")[1] !== undefined;\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\nif (PATCH) {\n    patchedExec = function exec(string) {\n        var re = this;\n        var state = getInternalState(re);\n        var str = toString$1(string);\n        var raw = state.raw;\n        var result, reCopy, lastIndex, match, i, object, group;\n        if (raw) {\n            raw.lastIndex = re.lastIndex;\n            result = call$2(patchedExec, raw, str);\n            re.lastIndex = raw.lastIndex;\n            return result;\n        }\n        var groups = state.groups;\n        var sticky = UNSUPPORTED_Y && re.sticky;\n        var flags = call$2(regexpFlags, re);\n        var source = re.source;\n        var charsAdded = 0;\n        var strCopy = str;\n        if (sticky) {\n            flags = replace$1(flags, \"y\", \"\");\n            if (indexOf(flags, \"g\") === -1) {\n                flags += \"g\";\n            }\n            strCopy = stringSlice$2(str, re.lastIndex);\n            // Support anchored sticky behavior.\n            if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== \"\\n\")) {\n                source = \"(?: \" + source + \")\";\n                strCopy = \" \" + strCopy;\n                charsAdded++;\n            }\n            // ^(? + rx + ) is needed, in combination with some str slicing, to\n            // simulate the 'y' flag.\n            reCopy = new RegExp(\"^(?:\" + source + \")\", flags);\n        }\n        if (NPCG_INCLUDED) {\n            reCopy = new RegExp(\"^\" + source + \"$(?!\\\\s)\", flags);\n        }\n        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n        match = call$2(nativeExec, sticky ? reCopy : re, strCopy);\n        if (sticky) {\n            if (match) {\n                match.input = stringSlice$2(match.input, charsAdded);\n                match[0] = stringSlice$2(match[0], charsAdded);\n                match.index = re.lastIndex;\n                re.lastIndex += match[0].length;\n            } else re.lastIndex = 0;\n        } else if (UPDATES_LAST_INDEX_WRONG && match) {\n            re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n        }\n        if (NPCG_INCLUDED && match && match.length > 1) {\n            // Fix browsers whose `exec` methods don't consistently return `undefined`\n            // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n            call$2(nativeReplace, match[0], reCopy, function() {\n                for(i = 1; i < arguments.length - 2; i++){\n                    if (arguments[i] === undefined) match[i] = undefined;\n                }\n            });\n        }\n        if (match && groups) {\n            match.groups = object = create(null);\n            for(i = 0; i < groups.length; i++){\n                group = groups[i];\n                object[group[0]] = match[group[1]];\n            }\n        }\n        return match;\n    };\n}\nvar regexpExec$2 = patchedExec;\nvar $ = _export;\nvar exec = regexpExec$2;\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$({\n    target: \"RegExp\",\n    proto: true,\n    forced: /./.exec !== exec\n}, {\n    exec: exec\n});\n// TODO: Remove from `core-js@4` since it's moved to entry points\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$a;\nvar regexpExec$1 = regexpExec$2;\nvar fails$1 = fails$k;\nvar wellKnownSymbol$1 = wellKnownSymbol$i;\nvar createNonEnumerableProperty = createNonEnumerableProperty$5;\nvar SPECIES = wellKnownSymbol$1(\"species\");\nvar RegExpPrototype = RegExp.prototype;\nvar fixRegexpWellKnownSymbolLogic = function(KEY, exec, FORCED, SHAM) {\n    var SYMBOL = wellKnownSymbol$1(KEY);\n    var DELEGATES_TO_SYMBOL = !fails$1(function() {\n        // String methods call symbol-named RegEp methods\n        var O = {};\n        O[SYMBOL] = function() {\n            return 7;\n        };\n        return \"\"[KEY](O) != 7;\n    });\n    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function() {\n        // Symbol-named RegExp methods call .exec\n        var execCalled = false;\n        var re = /a/;\n        if (KEY === \"split\") {\n            // We can't use real regex here since it causes deoptimization\n            // and serious performance degradation in V8\n            // https://github.com/zloirock/core-js/issues/306\n            re = {};\n            // RegExp[@@split] doesn't call the regex's exec method, but first creates\n            // a new one. We need to return the patched regex when creating the new one.\n            re.constructor = {};\n            re.constructor[SPECIES] = function() {\n                return re;\n            };\n            re.flags = \"\";\n            re[SYMBOL] = /./[SYMBOL];\n        }\n        re.exec = function() {\n            execCalled = true;\n            return null;\n        };\n        re[SYMBOL](\"\");\n        return !execCalled;\n    });\n    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {\n        var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n        var methods = exec(SYMBOL, \"\"[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {\n            var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n            var $exec = regexp.exec;\n            if ($exec === regexpExec$1 || $exec === RegExpPrototype.exec) {\n                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n                    // The native String method already delegates to @@method (this\n                    // polyfilled function), leasing to infinite recursion.\n                    // We avoid it by directly calling the native @@method method.\n                    return {\n                        done: true,\n                        value: uncurriedNativeRegExpMethod(regexp, str, arg2)\n                    };\n                }\n                return {\n                    done: true,\n                    value: uncurriedNativeMethod(str, regexp, arg2)\n                };\n            }\n            return {\n                done: false\n            };\n        });\n        defineBuiltIn(String.prototype, KEY, methods[0]);\n        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n    }\n    if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], \"sham\", true);\n};\nvar charAt$1 = stringMultibyte.charAt;\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function(S, index, unicode) {\n    return index + (unicode ? charAt$1(S, index).length : 1);\n};\nvar uncurryThis$1 = functionUncurryThis;\nvar toObject = toObject$5;\nvar floor = Math.floor;\nvar charAt = uncurryThis$1(\"\".charAt);\nvar replace = uncurryThis$1(\"\".replace);\nvar stringSlice$1 = uncurryThis$1(\"\".slice);\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d{1,2})/g;\n// `GetSubstitution` abstract operation\n// https://tc39.es/ecma262/#sec-getsubstitution\nvar getSubstitution$1 = function(matched, str, position, captures, namedCaptures, replacement) {\n    var tailPos = position + matched.length;\n    var m = captures.length;\n    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n    if (namedCaptures !== undefined) {\n        namedCaptures = toObject(namedCaptures);\n        symbols = SUBSTITUTION_SYMBOLS;\n    }\n    return replace(replacement, symbols, function(match, ch) {\n        var capture;\n        switch(charAt(ch, 0)){\n            case \"$\":\n                return \"$\";\n            case \"&\":\n                return matched;\n            case \"`\":\n                return stringSlice$1(str, 0, position);\n            case \"'\":\n                return stringSlice$1(str, tailPos);\n            case \"<\":\n                capture = namedCaptures[stringSlice$1(ch, 1, -1)];\n                break;\n            default:\n                var n = +ch;\n                if (n === 0) return match;\n                if (n > m) {\n                    var f = floor(n / 10);\n                    if (f === 0) return match;\n                    if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);\n                    return match;\n                }\n                capture = captures[n - 1];\n        }\n        return capture === undefined ? \"\" : capture;\n    });\n};\nvar call$1 = functionCall;\nvar anObject$1 = anObject$g;\nvar isCallable$1 = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec = regexpExec$2;\nvar $TypeError = TypeError;\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function(R, S) {\n    var exec = R.exec;\n    if (isCallable$1(exec)) {\n        var result = call$1(exec, R, S);\n        if (result !== null) anObject$1(result);\n        return result;\n    }\n    if (classof(R) === \"RegExp\") return call$1(regexpExec, R, S);\n    throw $TypeError(\"RegExp#exec called on incompatible receiver\");\n};\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar fails = fails$k;\nvar anObject = anObject$g;\nvar isCallable = isCallable$n;\nvar toIntegerOrInfinity = toIntegerOrInfinity$4;\nvar toLength = toLength$2;\nvar toString = toString$4;\nvar requireObjectCoercible = requireObjectCoercible$4;\nvar advanceStringIndex = advanceStringIndex$1;\nvar getMethod = getMethod$4;\nvar getSubstitution = getSubstitution$1;\nvar regExpExec = regexpExecAbstract;\nvar wellKnownSymbol = wellKnownSymbol$i;\nvar REPLACE = wellKnownSymbol(\"replace\");\nvar max = Math.max;\nvar min = Math.min;\nvar concat = uncurryThis([].concat);\nvar push = uncurryThis([].push);\nvar stringIndexOf = uncurryThis(\"\".indexOf);\nvar stringSlice = uncurryThis(\"\".slice);\nvar maybeToString = function(it) {\n    return it === undefined ? it : String(it);\n};\n// IE <= 11 replaces $0 with the whole match, as if it was $&\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\nvar REPLACE_KEEPS_$0 = function() {\n    // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing\n    return \"a\".replace(/./, \"$0\") === \"$0\";\n}();\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {\n    if (/./[REPLACE]) {\n        return /./[REPLACE](\"a\", \"$0\") === \"\";\n    }\n    return false;\n}();\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {\n    var re = /./;\n    re.exec = function() {\n        var result = [];\n        result.groups = {\n            a: \"7\"\n        };\n        return result;\n    };\n    // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive\n    return \"\".replace(re, \"$<a>\") !== \"7\";\n});\n// @@replace logic\nfixRegExpWellKnownSymbolLogic(\"replace\", function(_, nativeReplace, maybeCallNative) {\n    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? \"$\" : \"$0\";\n    return [\n        // `String.prototype.replace` method\n        // https://tc39.es/ecma262/#sec-string.prototype.replace\n        function replace(searchValue, replaceValue) {\n            var O = requireObjectCoercible(this);\n            var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);\n            return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);\n        },\n        // `RegExp.prototype[@@replace]` method\n        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n        function(string, replaceValue) {\n            var rx = anObject(this);\n            var S = toString(string);\n            if (typeof replaceValue == \"string\" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, \"$<\") === -1) {\n                var res = maybeCallNative(nativeReplace, rx, S, replaceValue);\n                if (res.done) return res.value;\n            }\n            var functionalReplace = isCallable(replaceValue);\n            if (!functionalReplace) replaceValue = toString(replaceValue);\n            var global1 = rx.global;\n            if (global1) {\n                var fullUnicode = rx.unicode;\n                rx.lastIndex = 0;\n            }\n            var results = [];\n            while(true){\n                var result = regExpExec(rx, S);\n                if (result === null) break;\n                push(results, result);\n                if (!global1) break;\n                var matchStr = toString(result[0]);\n                if (matchStr === \"\") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n            }\n            var accumulatedResult = \"\";\n            var nextSourcePosition = 0;\n            for(var i = 0; i < results.length; i++){\n                result = results[i];\n                var matched = toString(result[0]);\n                var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);\n                var captures = [];\n                // NOTE: This is equivalent to\n                //   captures = result.slice(1).map(maybeToString)\n                // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n                // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n                // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n                for(var j = 1; j < result.length; j++)push(captures, maybeToString(result[j]));\n                var namedCaptures = result.groups;\n                if (functionalReplace) {\n                    var replacerArgs = concat([\n                        matched\n                    ], captures, position, S);\n                    if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);\n                    var replacement = toString(apply(replaceValue, undefined, replacerArgs));\n                } else {\n                    replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n                }\n                if (position >= nextSourcePosition) {\n                    accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;\n                    nextSourcePosition = position + matched.length;\n                }\n            }\n            return accumulatedResult + stringSlice(S, nextSourcePosition);\n        }\n    ];\n}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar icon = `data:image/png;base64,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`;\nconst resolveWalletUrl = (network, walletUrl)=>{\n    if (walletUrl) {\n        return walletUrl;\n    }\n    switch(network.networkId){\n        case \"mainnet\":\n            return \"https://app.mynearwallet.com\";\n        case \"testnet\":\n            return \"https://testnet.mynearwallet.com\";\n        default:\n            throw new Error(\"Invalid wallet url\");\n    }\n};\nconst setupWalletState = (params, network)=>__awaiter(void 0, void 0, void 0, function*() {\n        const keyStore = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.keyStores.BrowserLocalStorageKeyStore();\n        const near = yield near_api_js__WEBPACK_IMPORTED_MODULE_0__.connect(Object.assign(Object.assign({\n            keyStore,\n            walletUrl: params.walletUrl\n        }, network), {\n            headers: {}\n        }));\n        const wallet = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.WalletConnection(near, \"near_app\");\n        return {\n            wallet,\n            keyStore\n        };\n    });\nconst MyNearWallet = ({ metadata, options, store, params, logger, id })=>__awaiter(void 0, void 0, void 0, function*() {\n        const _state = yield setupWalletState(params, options.network);\n        const getAccounts = ()=>__awaiter(void 0, void 0, void 0, function*() {\n                const accountId = _state.wallet.getAccountId();\n                const account = _state.wallet.account();\n                if (!accountId || !account) {\n                    return [];\n                }\n                const publicKey = yield account.connection.signer.getPublicKey(account.accountId, options.network.networkId);\n                return [\n                    {\n                        accountId,\n                        publicKey: publicKey ? publicKey.toString() : \"\"\n                    }\n                ];\n            });\n        const transformTransactions = (transactions)=>__awaiter(void 0, void 0, void 0, function*() {\n                const account = _state.wallet.account();\n                const { networkId, signer, provider } = account.connection;\n                const localKey = yield signer.getPublicKey(account.accountId, networkId);\n                return Promise.all(transactions.map((transaction, index)=>__awaiter(void 0, void 0, void 0, function*() {\n                        const actions = transaction.actions.map((action)=>(0,_near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__.createAction)(action));\n                        const accessKey = yield account.accessKeyForTransaction(transaction.receiverId, actions, localKey);\n                        if (!accessKey) {\n                            throw new Error(`Failed to find matching key for transaction sent to ${transaction.receiverId}`);\n                        }\n                        const block = yield provider.block({\n                            finality: \"final\"\n                        });\n                        return near_api_js__WEBPACK_IMPORTED_MODULE_0__.transactions.createTransaction(account.accountId, near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.PublicKey.from(accessKey.public_key), transaction.receiverId, accessKey.access_key.nonce + index + 1, actions, near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.serialize.base_decode(block.header.hash));\n                    })));\n            });\n        return {\n            signIn ({ contractId, methodNames, successUrl, failureUrl }) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    const existingAccounts = yield getAccounts();\n                    if (existingAccounts.length) {\n                        return existingAccounts;\n                    }\n                    yield _state.wallet.requestSignIn({\n                        contractId,\n                        methodNames,\n                        successUrl,\n                        failureUrl\n                    });\n                    return getAccounts();\n                });\n            },\n            signOut () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    if (_state.wallet.isSignedIn()) {\n                        _state.wallet.signOut();\n                    }\n                });\n            },\n            getAccounts () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    return getAccounts();\n                });\n            },\n            verifyOwner () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    throw new Error(`Method not supported by ${metadata.name}`);\n                });\n            },\n            signMessage ({ message, nonce, recipient, callbackUrl, state }) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"sign message\", {\n                        message\n                    });\n                    if (id !== \"my-near-wallet\") {\n                        throw Error(`The signMessage method is not supported by ${metadata.name}`);\n                    }\n                    const locationUrl =  false ? 0 : \"\";\n                    const url = callbackUrl || locationUrl;\n                    if (!url) {\n                        throw new Error(`The callbackUrl is missing for ${metadata.name}`);\n                    }\n                    const href = new URL(params.walletUrl);\n                    href.pathname = \"sign-message\";\n                    href.searchParams.append(\"message\", message);\n                    href.searchParams.append(\"nonce\", nonce.toString());\n                    href.searchParams.append(\"recipient\", recipient);\n                    href.searchParams.append(\"callbackUrl\", url);\n                    if (state) {\n                        href.searchParams.append(\"state\", state);\n                    }\n                    window.location.replace(href.toString());\n                    return;\n                });\n            },\n            signAndSendTransaction ({ signerId, receiverId, actions, callbackUrl }) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"signAndSendTransaction\", {\n                        signerId,\n                        receiverId,\n                        actions,\n                        callbackUrl\n                    });\n                    const { contract } = store.getState();\n                    if (!_state.wallet.isSignedIn() || !contract) {\n                        throw new Error(\"Wallet not signed in\");\n                    }\n                    const account = _state.wallet.account();\n                    return account[\"signAndSendTransaction\"]({\n                        receiverId: receiverId || contract.contractId,\n                        actions: actions.map((action)=>(0,_near_wallet_selector_wallet_utils__WEBPACK_IMPORTED_MODULE_1__.createAction)(action)),\n                        walletCallbackUrl: callbackUrl\n                    });\n                });\n            },\n            signAndSendTransactions ({ transactions, callbackUrl }) {\n                return __awaiter(this, void 0, void 0, function*() {\n                    logger.log(\"signAndSendTransactions\", {\n                        transactions,\n                        callbackUrl\n                    });\n                    if (!_state.wallet.isSignedIn()) {\n                        throw new Error(\"Wallet not signed in\");\n                    }\n                    return _state.wallet.requestSignTransactions({\n                        transactions: yield transformTransactions(transactions),\n                        callbackUrl\n                    });\n                });\n            },\n            buildImportAccountsUrl () {\n                return `${params.walletUrl}/batch-import`;\n            }\n        };\n    });\nfunction setupMyNearWallet({ walletUrl, iconUrl = icon, deprecated = false, successUrl = \"\", failureUrl = \"\" } = {}) {\n    return (moduleOptions)=>__awaiter(this, void 0, void 0, function*() {\n            return {\n                id: \"my-near-wallet\",\n                type: \"browser\",\n                metadata: {\n                    name: \"MyNearWallet\",\n                    description: \"NEAR wallet to store, buy, send and stake assets for DeFi.\",\n                    iconUrl,\n                    deprecated,\n                    available: true,\n                    successUrl,\n                    failureUrl,\n                    walletUrl: resolveWalletUrl(moduleOptions.options.network, walletUrl)\n                },\n                init: (options)=>{\n                    return MyNearWallet(Object.assign(Object.assign({}, options), {\n                        params: {\n                            walletUrl: resolveWalletUrl(options.options.network, walletUrl)\n                        }\n                    }));\n                }\n            };\n        });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL215LW5lYXItd2FsbGV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1QztBQUMyQjtBQUVsRSxJQUFJRSxpQkFBaUIsT0FBT0MsZUFBZSxjQUFjQSxhQUFhLE1BQWtCLEdBQWNDLENBQU1BLEdBQUcsT0FBT0MsV0FBVyxjQUFjQSxTQUFTLE9BQU9DLFNBQVMsY0FBY0EsT0FBTyxDQUFDO0FBRTlMLElBQUlDLFFBQVEsU0FBVUMsRUFBRTtJQUN0QixPQUFPQSxNQUFNQSxHQUFHQyxJQUFJLElBQUlBLFFBQVFEO0FBQ2xDO0FBRUEsdUVBQXVFO0FBQ3ZFLElBQUlFLFdBQ0YsdURBQXVEO0FBQ3ZESCxNQUFNLE9BQU9KLGNBQWMsWUFBWUEsZUFDdkNJLE1BQU0sTUFBaUIsSUFBWUgsQ0FBTUEsS0FDekMseURBQXlEO0FBQ3pERyxNQUFNLE9BQU9ELFFBQVEsWUFBWUEsU0FDakNDLE1BQU0sT0FBT0wsa0JBQWtCLFlBQVlBLG1CQUUzQyxtREFEbUQ7QUFDbEQ7SUFBYyxPQUFPLElBQUk7QUFBRSxPQUFRUyxTQUFTO0FBRS9DLElBQUlDLGlDQUFpQyxDQUFDO0FBRXRDLElBQUlDLFVBQVUsU0FBVUMsSUFBSTtJQUMxQixJQUFJO1FBQ0YsT0FBTyxDQUFDLENBQUNBO0lBQ1gsRUFBRSxPQUFPQyxPQUFPO1FBQ2QsT0FBTztJQUNUO0FBQ0Y7QUFFQSxJQUFJQyxVQUFVSDtBQUVkLHdEQUF3RDtBQUN4RCxJQUFJSSxjQUFjLENBQUNELFFBQVE7SUFDekIsaUZBQWlGO0lBQ2pGLE9BQU9FLE9BQU9DLGNBQWMsQ0FBQyxDQUFDLEdBQUcsR0FBRztRQUFFQyxLQUFLO1lBQWMsT0FBTztRQUFHO0lBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSTtBQUNoRjtBQUVBLElBQUlDLFVBQVVSO0FBRWQsSUFBSVMscUJBQXFCLENBQUNELFFBQVE7SUFDaEMsbUVBQW1FO0lBQ25FLElBQUlFLE9BQU8sQ0FB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LXNlbGVjdG9yL215LW5lYXItd2FsbGV0L2luZGV4LmpzPzQ0YTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbmVhckFQSSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24gfSBmcm9tICdAbmVhci13YWxsZXQtc2VsZWN0b3Ivd2FsbGV0LXV0aWxzJztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkbyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRrID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyRqID0gZmFpbHMkaztcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyRqKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxudmFyIGZhaWxzJGkgPSBmYWlscyRrO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJGkoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGsgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDMgPyBjYWxsJGsuYmluZChjYWxsJGspIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRrLmFwcGx5KGNhbGwkaywgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDModGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kJDggPSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQ7XG52YXIgY2FsbCRqID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xudmFyIHVuY3VycnlUaGlzJG0gPSBOQVRJVkVfQklORCQyICYmIGJpbmQkOC5iaW5kKGNhbGwkaiwgY2FsbCRqKTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQyID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyRtKGZuKTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRqLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJGwgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgdG9TdHJpbmckNiA9IHVuY3VycnlUaGlzJGwoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlJDYgPSB1bmN1cnJ5VGhpcyRsKCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UkNih0b1N0cmluZyQ2KGl0KSwgOCwgLTEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGsgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGggPSBmYWlscyRrO1xudmFyIGNsYXNzb2YkNyA9IGNsYXNzb2ZSYXckMTtcblxudmFyICRPYmplY3QkNCA9IE9iamVjdDtcbnZhciBzcGxpdCQzID0gdW5jdXJyeVRoaXMkaygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gISRPYmplY3QkNCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YkNyhpdCkgPT0gJ1N0cmluZycgPyBzcGxpdCQzKGl0LCAnJykgOiAkT2JqZWN0JDQoaXQpO1xufSA6ICRPYmplY3QkNDtcblxudmFyICRUeXBlRXJyb3IkYyA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkYyhcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QkMSA9IGluZGV4ZWRPYmplY3Q7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQzID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQ0O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDMoaXQpKTtcbn07XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxudmFyIGlzQ2FsbGFibGUkbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDYWxsYWJsZSRtID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgaXNPYmplY3QkOCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJG0oaXQpO1xufTtcblxudmFyIGdsb2JhbCRuID0gZ2xvYmFsJG87XG52YXIgaXNDYWxsYWJsZSRsID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGwoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ4ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkbltuYW1lc3BhY2VdKSA6IGdsb2JhbCRuW25hbWVzcGFjZV0gJiYgZ2xvYmFsJG5bbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJGooe30uaXNQcm90b3R5cGVPZik7XG5cbnZhciBnZXRCdWlsdEluJDcgPSBnZXRCdWlsdEluJDg7XG5cbnZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluJDcoJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxudmFyIGdsb2JhbCRtID0gZ2xvYmFsJG87XG52YXIgdXNlckFnZW50JDMgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBwcm9jZXNzJDMgPSBnbG9iYWwkbS5wcm9jZXNzO1xudmFyIERlbm8kMSA9IGdsb2JhbCRtLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzJDMgJiYgcHJvY2VzcyQzLnZlcnNpb25zIHx8IERlbm8kMSAmJiBEZW5vJDEudmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50JDMpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQkMy5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQkMy5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgVjhfVkVSU0lPTiQxID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIGZhaWxzJGcgPSBmYWlscyRrO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgbmF0aXZlU3ltYm9sID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyRnKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OJDEgJiYgVjhfVkVSU0lPTiQxIDwgNDE7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cblxudmFyIE5BVElWRV9TWU1CT0wkMSA9IG5hdGl2ZVN5bWJvbDtcblxudmFyIHVzZVN5bWJvbEFzVWlkID0gTkFUSVZFX1NZTUJPTCQxXG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG52YXIgZ2V0QnVpbHRJbiQ2ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkayA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyICRPYmplY3QkMyA9IE9iamVjdDtcblxudmFyIGlzU3ltYm9sJDIgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ2KCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaygkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJDMoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMyhpdCkpO1xufTtcblxudmFyICRTdHJpbmckMyA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQzKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJGogPSBpc0NhbGxhYmxlJG47XG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDQ7XG5cbnZhciAkVHlwZUVycm9yJGIgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkaihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciRiKHRyeVRvU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDc7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkNCA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ2KGZ1bmMpO1xufTtcblxudmFyIGNhbGwkaSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGkgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNPYmplY3QkNyA9IGlzT2JqZWN0JDg7XG5cbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNyh2YWwgPSBjYWxsJGkoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkNyh2YWwgPSBjYWxsJGkoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGkoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDcodmFsID0gY2FsbCRpKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJGEoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgc2hhcmVkJDQgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaXNQdXJlID0gZmFsc2U7XG5cbnZhciBnbG9iYWwkbCA9IGdsb2JhbCRvO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ2KGdsb2JhbCRsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJGsgPSBnbG9iYWwkbztcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwka1tTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQ7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQyKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMihhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDQgPSB0b09iamVjdCQ1O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRpKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCQ0KGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRoID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyQ1ID0gdW5jdXJyeVRoaXMkaCgxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckNSgrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcblxudmFyIGdsb2JhbCRqID0gZ2xvYmFsJG87XG52YXIgc2hhcmVkJDMgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGhhc093biRjID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMSA9IHVpZCQyO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQzKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRqLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDE7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkaSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093biRjKFN5bWJvbCQxLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sJDFbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgY2FsbCRoID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCQ4O1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQyO1xudmFyIGdldE1ldGhvZCQzID0gZ2V0TWV0aG9kJDQ7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaCA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgJFR5cGVFcnJvciQ5ID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRoKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQ2KGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDMoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkaChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JDYocmVzdWx0KSB8fCBpc1N5bWJvbCQxKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQ5KFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDI7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkMyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBnbG9iYWwkaSA9IGdsb2JhbCRvO1xudmFyIGlzT2JqZWN0JDUgPSBpc09iamVjdCQ4O1xuXG52YXIgZG9jdW1lbnQkMyA9IGdsb2JhbCRpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTJDEgPSBpc09iamVjdCQ1KGRvY3VtZW50JDMpICYmIGlzT2JqZWN0JDUoZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KTtcblxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMkMSA/IGRvY3VtZW50JDMuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkZiA9IGZhaWxzJGs7XG52YXIgY3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbi8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIGllOERvbURlZmluZSA9ICFERVNDUklQVE9SUyRjICYmICFmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCQxKCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkYiA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkZyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIHRvUHJvcGVydHlLZXkkMiA9IHRvUHJvcGVydHlLZXkkMztcbnZhciBoYXNPd24kYiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJGIgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biRiKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQoIWNhbGwkZyhwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkYSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJGUgPSBmYWlscyRrO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJGEgJiYgZmFpbHMkZShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JDg7XG5cbnZhciAkU3RyaW5nJDIgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQ4ID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG52YXIgYW5PYmplY3QkZyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QkNChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ4KCRTdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cbnZhciBERVNDUklQVE9SUyQ5ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBpZThEb21EZWZpbmU7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGFuT2JqZWN0JGYgPSBhbk9iamVjdCRnO1xudmFyIHRvUHJvcGVydHlLZXkkMSA9IHRvUHJvcGVydHlLZXkkMztcblxudmFyICRUeXBlRXJyb3IkNyA9IFR5cGVFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUkMSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxub2JqZWN0RGVmaW5lUHJvcGVydHkuZiA9IERFU0NSSVBUT1JTJDkgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID8gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRmKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBhbk9iamVjdCRmKEF0dHJpYnV0ZXMpO1xuICBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRmKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBhbk9iamVjdCRmKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyAkVHlwZUVycm9yJDcoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG5cbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSA9IERFU0NSSVBUT1JTJDggPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1LmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIG1ha2VCdWlsdEluJDMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgREVTQ1JJUFRPUlMkNyA9IGRlc2NyaXB0b3JzO1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkNyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJGEoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkNyB8fCAoREVTQ1JJUFRPUlMkNyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRnID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJG47XG52YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJGcoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkaChzdG9yZSQxLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlJDEuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxudmFyIGluc3BlY3RTb3VyY2UkNCA9IHN0b3JlJDEuaW5zcGVjdFNvdXJjZTtcblxudmFyIGdsb2JhbCRoID0gZ2xvYmFsJG87XG52YXIgaXNDYWxsYWJsZSRnID0gaXNDYWxsYWJsZSRuO1xudmFyIGluc3BlY3RTb3VyY2UkMyA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCRoLldlYWtNYXA7XG5cbnZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZSRnKFdlYWtNYXAkMSkgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UkMyhXZWFrTWFwJDEpKTtcblxudmFyIHNoYXJlZCQyID0gc2hhcmVkJDQuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMigna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDQgPSB7fTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkbztcbnZhciB1bmN1cnJ5VGhpcyRmID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCQzID0gaXNPYmplY3QkODtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1O1xudmFyIGhhc093biQ5ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQ0ID0gZ2xvYmFsJGcuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkZy5XZWFrTWFwO1xudmFyIHNldCQxLCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0JDEoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkMyhpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDQoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZCQxLnN0YXRlIHx8IChzaGFyZWQkMS5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyRmKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJGYoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkZihzdG9yZS5zZXQpO1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQ0KE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQyKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ5KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkNChPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDkoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDEsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBmYWlscyRkID0gZmFpbHMkaztcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJG47XG52YXIgaGFzT3duJDggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1ID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmdldDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyQ2ICYmICFmYWlscyRkKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDUoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4kMiA9IG1ha2VCdWlsdEluJDMuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoU3RyaW5nKG5hbWUpLnNsaWNlKDAsIDcpID09PSAnU3ltYm9sKCcpIHtcbiAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZXR0ZXIpIG5hbWUgPSAnZ2V0ICcgKyBuYW1lO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNldHRlcikgbmFtZSA9ICdzZXQgJyArIG5hbWU7XG4gIGlmICghaGFzT3duJDgodmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMkNikgZGVmaW5lUHJvcGVydHkkNSh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093biQ4KG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5JDUodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDgob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTJDYpIGRlZmluZVByb3BlcnR5JDUodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAvLyBpbiBWOCB+IENocm9tZSA1MywgcHJvdG90eXBlcyBvZiBzb21lIG1ldGhvZHMsIGxpa2UgYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgLCBhcmUgbm9uLXdyaXRhYmxlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5wcm90b3R5cGUpIHZhbHVlLnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghaGFzT3duJDgoc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluJDIoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGYodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSQzKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlJDIodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxudmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkbjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgbWFrZUJ1aWx0SW4kMSA9IG1ha2VCdWlsdEluJDMuZXhwb3J0cztcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQxID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIGRlZmluZUJ1aWx0SW4kYSA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucy5lbnVtZXJhYmxlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICBpZiAoaXNDYWxsYWJsZSRlKHZhbHVlKSkgbWFrZUJ1aWx0SW4kMSh2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0LmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQ0ID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDQgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ0ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDMgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG5cbnZhciBtYXgkMiA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkMiA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQzKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDIoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMiA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcblxudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGgkMSA9IHRvTGVuZ3RoJDI7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoJDEob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDMgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQyO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDMgPSBsZW5ndGhPZkFycmF5TGlrZSQ0O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQzKCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMyhPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMShmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDEodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDEoZmFsc2UpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgaW5kZXhPZiQxID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkNCA9IHVuY3VycnlUaGlzJGUoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQyKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDcoaGlkZGVuS2V5cyQyLCBrZXkpICYmIGhhc093biQ3KE8sIGtleSkgJiYgcHVzaCQ0KHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ3KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkMShyZXN1bHQsIGtleSkgfHwgcHVzaCQ0KHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMkMSA9IGVudW1CdWdLZXlzJDIuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGhpZGRlbktleXMkMSk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJGQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JGUgPSBhbk9iamVjdCRnO1xuXG52YXIgY29uY2F0JDIgPSB1bmN1cnJ5VGhpcyRkKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDUoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkZShpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQyKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xuXG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24kNih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093biQ2KGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFpbHMkYyA9IGZhaWxzJGs7XG52YXIgaXNDYWxsYWJsZSRkID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQkMiA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZSRkKGRldGVjdGlvbikgPyBmYWlscyRjKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkJDIubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZCQyLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZCQyLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkJDIuUE9MWUZJTEwgPSAnUCc7XG5cbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQkMjtcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJG87XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1O1xudmFyIGRlZmluZUJ1aWx0SW4kOSA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGRlZmluZUdsb2JhbFByb3BlcnR5JDM7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMTtcbnZhciBpc0ZvcmNlZCQxID0gaXNGb3JjZWRfMTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbnZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbCRmO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbCRmW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbCRmW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQkMShHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4kOSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMiA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzJDEpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciB1bmN1cnJ5VGhpcyRjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBjYWxsJGYgPSBmdW5jdGlvbkNhbGw7XG52YXIgZmFpbHMkYiA9IGZhaWxzJGs7XG52YXIgb2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5cyQyO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0JDMgPSB0b09iamVjdCQ1O1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5JDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyRjKFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMkNSAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JDQoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSQ0KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzJDEoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QkMyh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKG9iamVjdEtleXMkMShTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMkMShTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkNSB8fCBjYWxsJGYocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQkYSA9IF9leHBvcnQ7XG52YXIgYXNzaWduJDEgPSBvYmplY3RBc3NpZ247XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCRhKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgYXJpdHk6IDIsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduJDEgfSwge1xuICBhc3NpZ246IGFzc2lnbiQxXG59KTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkZygndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBRyQzXSA9ICd6JztcblxudmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2wkZigndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0JDEgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiQ2ID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QkMShpdCksIFRPX1NUUklOR19UQUckMikpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZSRjKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxudmFyIGNsYXNzb2YkNSA9IGNsYXNzb2YkNjtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YkNShhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiAkU3RyaW5nJDEoYXJndW1lbnQpO1xufTtcblxudmFyIGFuT2JqZWN0JGQgPSBhbk9iamVjdCRnO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCRkKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmhhc0luZGljZXMpIHJlc3VsdCArPSAnZCc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnVuaWNvZGVTZXRzKSByZXN1bHQgKz0gJ3YnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY2FsbCRlID0gZnVuY3Rpb25DYWxsO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIHJlZ0V4cEZsYWdzID0gcmVnZXhwRmxhZ3MkMTtcblxudmFyIFJlZ0V4cFByb3RvdHlwZSQyID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyIHJlZ2V4cEdldEZsYWdzID0gZnVuY3Rpb24gKFIpIHtcbiAgdmFyIGZsYWdzID0gUi5mbGFncztcbiAgcmV0dXJuIGZsYWdzID09PSB1bmRlZmluZWQgJiYgISgnZmxhZ3MnIGluIFJlZ0V4cFByb3RvdHlwZSQyKSAmJiAhaGFzT3duJDUoUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZiQyKFJlZ0V4cFByb3RvdHlwZSQyLCBSKVxuICAgID8gY2FsbCRlKHJlZ0V4cEZsYWdzLCBSKSA6IGZsYWdzO1xufTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4kOCA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciBhbk9iamVjdCRjID0gYW5PYmplY3QkZztcbnZhciAkdG9TdHJpbmckMiA9IHRvU3RyaW5nJDQ7XG52YXIgZmFpbHMkYSA9IGZhaWxzJGs7XG52YXIgZ2V0UmVnRXhwRmxhZ3MgPSByZWdleHBHZXRGbGFncztcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG4kVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGUkMVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyRhKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG4kVG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxudmFyIElOQ09SUkVDVF9OQU1FID0gUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSAmJiBuJFRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICBkZWZpbmVCdWlsdEluJDgoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0JGModGhpcyk7XG4gICAgdmFyIHBhdHRlcm4gPSAkdG9TdHJpbmckMihSLnNvdXJjZSk7XG4gICAgdmFyIGZsYWdzID0gJHRvU3RyaW5nJDIoZ2V0UmVnRXhwRmxhZ3MoUikpO1xuICAgIHJldHVybiAnLycgKyBwYXR0ZXJuICsgJy8nICsgZmxhZ3M7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JGIgPSBhbk9iamVjdCRnO1xudmFyIHRvSW5kZXhlZE9iamVjdCQxID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDQgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDEoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDIuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ0ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgaHRtbCQyID0gZ2V0QnVpbHRJbiQ0KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cblxudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRnO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzID0gaGlkZGVuS2V5cyQ0O1xudmFyIGh0bWwkMSA9IGh0bWwkMjtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5JDEoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwkMS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnXG4gICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG4gICAgICA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSAvLyBvbGQgSUVcbiAgICAgIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKClcbiAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzW0lFX1BST1RPJDFdID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QkYShPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UTyQxXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRlID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgY3JlYXRlJDMgPSBvYmplY3RDcmVhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCRlKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlJDFbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eSQzKEFycmF5UHJvdG90eXBlJDEsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUkMyhudWxsKVxuICB9KTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIGFkZFRvVW5zY29wYWJsZXMkMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGUkMVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciBmYWlscyQ5ID0gZmFpbHMkaztcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJG47XG52YXIgdG9PYmplY3QkMiA9IHRvT2JqZWN0JDU7XG52YXIgc2hhcmVkS2V5ID0gc2hhcmVkS2V5JDM7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JDIoTyk7XG4gIGlmIChoYXNPd24kNChvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUkYihjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cbnZhciBmYWlscyQ4ID0gZmFpbHMkaztcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJG47XG52YXIgZ2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIGRlZmluZUJ1aWx0SW4kNyA9IGRlZmluZUJ1aWx0SW4kYTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgSVRFUkFUT1IkNyA9IHdlbGxLbm93blN5bWJvbCRkKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IGZhbHNlO1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMiwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDEoZ2V0UHJvdG90eXBlT2YkMShhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG52YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9IEl0ZXJhdG9yUHJvdG90eXBlJDIgPT0gdW5kZWZpbmVkIHx8IGZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkN10uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUkMiA9IHt9O1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoIWlzQ2FsbGFibGUkYShJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDddKSkge1xuICBkZWZpbmVCdWlsdEluJDcoSXRlcmF0b3JQcm90b3R5cGUkMiwgSVRFUkFUT1IkNywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbn1cblxudmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSQyLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDFcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCRjKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckNSA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duJDModGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMih0YXJnZXQsIFRPX1NUUklOR19UQUckMSwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSQxID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUkMiA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHNldFRvU3RyaW5nVGFnJDQgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMiA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlJDIoSXRlcmF0b3JQcm90b3R5cGUkMSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMigrIUVOVU1FUkFCTEVfTkVYVCwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnJDQoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UpO1xuICBJdGVyYXRvcnMkNFtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXMkMTtcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgaXNDYWxsYWJsZSQ5ID0gaXNDYWxsYWJsZSRuO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDYgPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkOShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ2KFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyhhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG5cbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkZztcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBhUG9zc2libGVQcm90b3R5cGUkMTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMkYihPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QkOShPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgJCQ5ID0gX2V4cG9ydDtcbnZhciBjYWxsJGQgPSBmdW5jdGlvbkNhbGw7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkbjtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDEgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDI7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiQxID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMyA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNTtcbnZhciBkZWZpbmVCdWlsdEluJDYgPSBkZWZpbmVCdWlsdEluJGE7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkaTtcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciBJdGVyYXRvcnNDb3JlID0gaXRlcmF0b3JzQ29yZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkNiA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMiA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgICBpZiAoIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDZdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YkMSkge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mJDEoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUkOChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkNl0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbiQ2KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkNiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBpZiAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJGQobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDYoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCQ5KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kNihJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkNiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IGFkZFRvVW5zY29wYWJsZXMkMTtcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDQgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGRlZmluZUl0ZXJhdG9yJDEgPSBkZWZpbmVJdGVyYXRvciQyO1xudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDQgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkMiA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yJDEoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDQodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG52YXIgdmFsdWVzID0gSXRlcmF0b3JzJDIuQXJndW1lbnRzID0gSXRlcmF0b3JzJDIuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vLyBWOCB+IENocm9tZSA0NS0gYnVnXG5pZiAoREVTQ1JJUFRPUlMkMyAmJiB2YWx1ZXMubmFtZSAhPT0gJ3ZhbHVlcycpIHRyeSB7XG4gIGRlZmluZVByb3BlcnR5JDEodmFsdWVzLCAnbmFtZScsIHsgdmFsdWU6ICd2YWx1ZXMnIH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZlJhdyQxO1xudmFyIGdsb2JhbCRlID0gZ2xvYmFsJG87XG5cbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJDQoZ2xvYmFsJGUucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRpO1xudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcblxudmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCRhKCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzJDEgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluJDMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMkMiAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFUyQzXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTJDMsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxudmFyIGFuSW5zdGFuY2UkMyA9IGZ1bmN0aW9uIChpdCwgUHJvdG90eXBlKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mJDEoUHJvdG90eXBlLCBpdCkpIHJldHVybiBpdDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ1KCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGEgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDcgPSBmYWlscyRrO1xudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkbjtcbnZhciBjbGFzc29mJDMgPSBjbGFzc29mJDY7XG52YXIgZ2V0QnVpbHRJbiQyID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGluc3BlY3RTb3VyY2UkMSA9IGluc3BlY3RTb3VyY2UkNDtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgZW1wdHkgPSBbXTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluJDIoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMkMyA9IHVuY3VycnlUaGlzJGEoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiQzKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyQzKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlJDEoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG52YXIgaXNDb25zdHJ1Y3RvciQyID0gIWNvbnN0cnVjdCB8fCBmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXG4gICAgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcblxudmFyIGlzQ29uc3RydWN0b3IkMSA9IGlzQ29uc3RydWN0b3IkMjtcbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNDtcblxudmFyICRUeXBlRXJyb3IkNCA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDb25zdHJ1Y3RvciQxKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGc7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDkgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCQ5KCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdCQ4KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0JDgoQylbU1BFQ0lFUyQyXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQyID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCRjID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJGMuYmluZChhcHBseSQyKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkYy5hcHBseShhcHBseSQyLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyQ5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ3O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ3ID0gdW5jdXJyeVRoaXMkOSh1bmN1cnJ5VGhpcyQ5LmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDcoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGFycmF5U2xpY2UkMyA9IHVuY3VycnlUaGlzJDgoW10uc2xpY2UpO1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMyA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgJFR5cGVFcnJvciQzKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcblxudmFyIHVzZXJBZ2VudCQyID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNJb3MgPSAvKD86aXBhZHxpcGhvbmV8aXBvZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQkMik7XG5cbnZhciBnbG9iYWwkZCA9IGdsb2JhbCRvO1xudmFyIGFwcGx5JDEgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkNiA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgaXNDYWxsYWJsZSQ2ID0gaXNDYWxsYWJsZSRuO1xudmFyIGhhc093biQyID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBmYWlscyQ2ID0gZmFpbHMkaztcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2UkMztcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMiA9IHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDM7XG52YXIgSVNfSU9TJDEgPSBlbmdpbmVJc0lvcztcbnZhciBJU19OT0RFJDIgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBzZXQgPSBnbG9iYWwkZC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwkZC5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzJDIgPSBnbG9iYWwkZC5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsJGQuRGlzcGF0Y2g7XG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCRkLkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsJGQuTWVzc2FnZUNoYW5uZWw7XG52YXIgU3RyaW5nJDEgPSBnbG9iYWwkZC5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUkMSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGxvY2F0aW9uLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudHJ5IHtcbiAgLy8gRGVubyB0aHJvd3MgYSBSZWZlcmVuY2VFcnJvciBvbiBgbG9jYXRpb25gIGFjY2VzcyB3aXRob3V0IGAtLWxvY2F0aW9uYCBmbGFnXG4gIGxvY2F0aW9uID0gZ2xvYmFsJGQubG9jYXRpb247XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGhhc093biQyKHF1ZXVlJDEsIGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlJDFbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsJGQucG9zdE1lc3NhZ2UoU3RyaW5nJDEoaWQpLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0IHx8ICFjbGVhcikge1xuICBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoaGFuZGxlcikge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDIoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQ2KGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlJDIoYXJndW1lbnRzLCAxKTtcbiAgICBxdWV1ZSQxWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseSQxKGZuLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWUkMVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoSVNfTk9ERSQyKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MkMi5uZXh0VGljayhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgLy8gZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82MjRcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCAmJiAhSVNfSU9TJDEpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGJpbmQkNihwb3J0LnBvc3RNZXNzYWdlLCBwb3J0KTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoXG4gICAgZ2xvYmFsJGQuYWRkRXZlbnRMaXN0ZW5lciAmJlxuICAgIGlzQ2FsbGFibGUkNihnbG9iYWwkZC5wb3N0TWVzc2FnZSkgJiZcbiAgICAhZ2xvYmFsJGQuaW1wb3J0U2NyaXB0cyAmJlxuICAgIGxvY2F0aW9uICYmIGxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgIWZhaWxzJDYocG9zdClcbiAgKSB7XG4gICAgZGVmZXIgPSBwb3N0O1xuICAgIGdsb2JhbCRkLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgdGFzayQxID0ge1xuICBzZXQ6IHNldCxcbiAgY2xlYXI6IGNsZWFyXG59O1xuXG52YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkbztcblxudmFyIGVuZ2luZUlzSW9zUGViYmxlID0gL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCQxKSAmJiBnbG9iYWwkYy5QZWJibGUgIT09IHVuZGVmaW5lZDtcblxudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzV2Vib3NXZWJraXQgPSAvd2ViMHMoPyEuKmNocm9tZSkvaS50ZXN0KHVzZXJBZ2VudCk7XG5cbnZhciBnbG9iYWwkYiA9IGdsb2JhbCRvO1xudmFyIGJpbmQkNSA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBtYWNyb3Rhc2sgPSB0YXNrJDEuc2V0O1xudmFyIElTX0lPUyA9IGVuZ2luZUlzSW9zO1xudmFyIElTX0lPU19QRUJCTEUgPSBlbmdpbmVJc0lvc1BlYmJsZTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSBlbmdpbmVJc1dlYm9zV2Via2l0O1xudmFyIElTX05PREUkMSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwkYi5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbCRiLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQkMiA9IGdsb2JhbCRiLmRvY3VtZW50O1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbCRiLnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsJGIuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShnbG9iYWwkYiwgJ3F1ZXVlTWljcm90YXNrJyk7XG52YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSQxLCB0b2dnbGUsIG5vZGUsIHByb21pc2UsIHRoZW47XG5cbi8vIG1vZGVybiBlbmdpbmVzIGhhdmUgcXVldWVNaWNyb3Rhc2sgbWV0aG9kXG5pZiAoIXF1ZXVlTWljcm90YXNrKSB7XG4gIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChJU19OT0RFJDEgJiYgKHBhcmVudCA9IHByb2Nlc3MkMS5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkkMSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIC8vIGFsc28gZXhjZXB0IFdlYk9TIFdlYmtpdCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODk4XG4gIGlmICghSVNfSU9TICYmICFJU19OT0RFJDEgJiYgIUlTX1dFQk9TX1dFQktJVCAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGRvY3VtZW50JDIpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudCQyLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoIUlTX0lPU19QRUJCTEUgJiYgUHJvbWlzZSQxICYmIFByb21pc2UkMS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAvLyB3b3JrYXJvdW5kIG9mIFdlYktpdCB+IGlPUyBTYWZhcmkgMTAuMSBidWdcbiAgICBwcm9taXNlLmNvbnN0cnVjdG9yID0gUHJvbWlzZSQxO1xuICAgIHRoZW4gPSBiaW5kJDUocHJvbWlzZS50aGVuLCBwcm9taXNlKTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIE5vZGUuanMgd2l0aG91dCBwcm9taXNlc1xuICB9IGVsc2UgaWYgKElTX05PREUkMSkge1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdlXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5iaW5kKGdsb2JhbClcbiAgICBtYWNyb3Rhc2sgPSBiaW5kJDUobWFjcm90YXNrLCBnbG9iYWwkYik7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYWNyb3Rhc2soZmx1c2gpO1xuICAgIH07XG4gIH1cbn1cblxudmFyIG1pY3JvdGFzayQxID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYgKCFoZWFkKSB7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5JDEoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG5cbnZhciBnbG9iYWwkYSA9IGdsb2JhbCRvO1xuXG52YXIgaG9zdFJlcG9ydEVycm9ycyQxID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGNvbnNvbGUgPSBnbG9iYWwkYS5jb25zb2xlO1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG5cbnZhciBwZXJmb3JtJDMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcblxudmFyIFF1ZXVlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIHRoaXMudGFpbCA9IG51bGw7XG59O1xuXG5RdWV1ZSQxLnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBlbnRyeSA9IHsgaXRlbTogaXRlbSwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgdGhpcy5oZWFkID0gZW50cnkubmV4dDtcbiAgICAgIGlmICh0aGlzLnRhaWwgPT09IGVudHJ5KSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgcmV0dXJuIGVudHJ5Lml0ZW07XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVldWUgPSBRdWV1ZSQxO1xuXG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkbztcblxudmFyIHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbCQ5LlByb21pc2U7XG5cbnZhciBlbmdpbmVJc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHR5cGVvZiBEZW5vICE9ICdvYmplY3QnO1xuXG52YXIgZ2xvYmFsJDggPSBnbG9iYWwkbztcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJG47XG52YXIgaXNGb3JjZWQgPSBpc0ZvcmNlZF8xO1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkaTtcbnZhciBJU19CUk9XU0VSID0gZW5naW5lSXNCcm93c2VyO1xudmFyIFY4X1ZFUlNJT04gPSBlbmdpbmVWOFZlcnNpb247XG5cbk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzLnByb3RvdHlwZTtcbnZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2wkOCgnc3BlY2llcycpO1xudmFyIFNVQkNMQVNTSU5HID0gZmFsc2U7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEgPSBpc0NhbGxhYmxlJDUoZ2xvYmFsJDguUHJvbWlzZVJlamVjdGlvbkV2ZW50KTtcblxudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUgPSBpc0ZvcmNlZCgnUHJvbWlzZScsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFID0gaW5zcGVjdFNvdXJjZShOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIHZhciBHTE9CQUxfQ09SRV9KU19QUk9NSVNFID0gUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgIT09IFN0cmluZyhOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyk7XG4gIC8vIFY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gIC8vIFdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gIGlmICghR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBWOF9WRVJTSU9OID09PSA2NikgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSkpIHJldHVybiBmYWxzZTtcbiAgLy8gRGV0ZWN0IGNvcnJlY3RuZXNzIG9mIHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgdmFyIHByb21pc2UgPSBuZXcgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSgxKTsgfSk7XG4gIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIH07XG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTtcbiAgY29uc3RydWN0b3JbU1BFQ0lFUyQxXSA9IEZha2VQcm9taXNlO1xuICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIGlmICghU1VCQ0xBU1NJTkcpIHJldHVybiB0cnVlO1xuICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMTtcbn0pO1xuXG52YXIgcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0ge1xuICBDT05TVFJVQ1RPUjogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSxcbiAgUkVKRUNUSU9OX0VWRU5UOiBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMiA9IHt9O1xuXG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkNztcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFDYWxsYWJsZSQ0KHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZSQ0KHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubmV3UHJvbWlzZUNhcGFiaWxpdHkkMi5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkbztcbnZhciBjYWxsJGIgPSBmdW5jdGlvbkNhbGw7XG52YXIgZGVmaW5lQnVpbHRJbiQ1ID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDU7XG52YXIgc2V0U3BlY2llcyA9IHNldFNwZWNpZXMkMTtcbnZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ3O1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkODtcbnZhciBhbkluc3RhbmNlJDIgPSBhbkluc3RhbmNlJDM7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gc3BlY2llc0NvbnN0cnVjdG9yJDE7XG52YXIgdGFzayA9IHRhc2skMS5zZXQ7XG52YXIgbWljcm90YXNrID0gbWljcm90YXNrJDE7XG52YXIgaG9zdFJlcG9ydEVycm9ycyA9IGhvc3RSZXBvcnRFcnJvcnMkMTtcbnZhciBwZXJmb3JtJDIgPSBwZXJmb3JtJDM7XG52YXIgUXVldWUgPSBxdWV1ZTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDMgPSBpbnRlcm5hbFN0YXRlO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLmdldHRlckZvcihQUk9NSVNFKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDMgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMjtcbnZhciBQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxO1xudmFyIFR5cGVFcnJvciQzID0gZ2xvYmFsJDcuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkNy5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJDcucHJvY2VzcztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDEgJiYgZG9jdW1lbnQkMS5jcmVhdGVFdmVudCAmJiBnbG9iYWwkNy5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcblxudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QkMihpdCkgJiYgaXNDYWxsYWJsZSQ0KHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQzKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwkYih0aGVuLCByZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFjdGlvbnMgPSBzdGF0ZS5yZWFjdGlvbnM7XG4gICAgdmFyIHJlYWN0aW9uO1xuICAgIHdoaWxlIChyZWFjdGlvbiA9IHJlYWN0aW9ucy5nZXQoKSkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsJDcuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWwkN1snb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJGIodGFzaywgZ2xvYmFsJDcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybSQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkYih0YXNrLCBnbG9iYWwkNywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kJDQgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUuZmFjYWRlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDMoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsJGIodGhlbiwgdmFsdWUsXG4gICAgICAgICAgICBiaW5kJDQoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kJDQoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSQyKHRoaXMsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIGFDYWxsYWJsZSQzKGV4ZWN1dG9yKTtcbiAgICBjYWxsJGIoSW50ZXJuYWwsIHRoaXMpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kJDQoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSksIGJpbmQkNChpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaW50ZXJuYWxSZWplY3Qoc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbWlzZVByb3RvdHlwZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQzKHRoaXMsIHtcbiAgICAgIHR5cGU6IFBST01JU0UsXG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIG5vdGlmaWVkOiBmYWxzZSxcbiAgICAgIHBhcmVudDogZmFsc2UsXG4gICAgICByZWFjdGlvbnM6IG5ldyBRdWV1ZSgpLFxuICAgICAgcmVqZWN0aW9uOiBmYWxzZSxcbiAgICAgIHN0YXRlOiBQRU5ESU5HLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGBQcm9taXNlLnByb3RvdHlwZS50aGVuYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS50aGVuXG4gIEludGVybmFsLnByb3RvdHlwZSA9IGRlZmluZUJ1aWx0SW4kNShQcm9taXNlUHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZSQ0KG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICByZWFjdGlvbi5mYWlsID0gaXNDYWxsYWJsZSQ0KG9uUmVqZWN0ZWQpICYmIG9uUmVqZWN0ZWQ7XG4gICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgIGlmIChzdGF0ZS5zdGF0ZSA9PSBQRU5ESU5HKSBzdGF0ZS5yZWFjdGlvbnMuYWRkKHJlYWN0aW9uKTtcbiAgICBlbHNlIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsUmVhY3Rpb24ocmVhY3Rpb24sIHN0YXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgfSk7XG5cbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZShwcm9taXNlKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGJpbmQkNChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKTtcbiAgICB0aGlzLnJlamVjdCA9IGJpbmQkNChpbnRlcm5hbFJlamVjdCwgc3RhdGUpO1xuICB9O1xuXG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoaXNDYWxsYWJsZSQ0KE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyKSAmJiBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBuYXRpdmVUaGVuID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLnRoZW47XG5cbiAgICBpZiAoIU5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HKSB7XG4gICAgICAvLyBtYWtlIGBQcm9taXNlI3RoZW5gIHJldHVybiBhIHBvbHlmaWxsZWQgYFByb21pc2VgIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgICBkZWZpbmVCdWlsdEluJDUoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgY2FsbCRiKG5hdGl2ZVRoZW4sIHRoYXQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY0MFxuICAgICAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBgLmNvbnN0cnVjdG9yID09PSBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEuY29uc3RydWN0b3I7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4gICAgLy8gbWFrZSBgaW5zdGFuY2VvZiBQcm9taXNlYCB3b3JrIGZvciBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzXG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICBzZXRQcm90b3R5cGVPZihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4kJDgoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyQyKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQ1ID0gd2VsbEtub3duU3ltYm9sJDcoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDEuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SJDVdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiQyID0gY2xhc3NvZiQ2O1xudmFyIGdldE1ldGhvZCQyID0gZ2V0TWV0aG9kJDQ7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJDYoJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBnZXRNZXRob2QkMihpdCwgSVRFUkFUT1IkNClcbiAgICB8fCBnZXRNZXRob2QkMihpdCwgJ0BAaXRlcmF0b3InKVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mJDIoaXQpXTtcbn07XG5cbnZhciBjYWxsJGEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkNztcbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkZztcbnZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNDtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQzID0gZ2V0SXRlcmF0b3JNZXRob2QkNDtcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDMgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQzKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkMihpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ3KGNhbGwkYShpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQyKHRyeVRvU3RyaW5nJDEoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGc7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkNDtcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMiA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ2KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgaWYgKCFpbm5lclJlc3VsdCkge1xuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpbm5lclJlc3VsdCA9IGNhbGwkOShpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0JDYoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgYmluZCQzID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDggPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNSA9IGFuT2JqZWN0JGc7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ0O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJDQ7XG52YXIgaXNQcm90b3R5cGVPZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0SXRlcmF0b3IkMiA9IGdldEl0ZXJhdG9yJDM7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMiA9IGdldEl0ZXJhdG9yTWV0aG9kJDQ7XG52YXIgaXRlcmF0b3JDbG9zZSQxID0gaXRlcmF0b3JDbG9zZSQyO1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBSZXN1bHRQcm90b3R5cGUgPSBSZXN1bHQucHJvdG90eXBlO1xuXG52YXIgaXRlcmF0ZSQyID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQkMyh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZSQxKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkNSh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kJDIoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyAkVHlwZUVycm9yJDEodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QkMShpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMihpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMihpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gY2FsbCQ4KG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UkMShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJGk7XG5cbnZhciBJVEVSQVRPUiQzID0gd2VsbEtub3duU3ltYm9sJDUoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDNdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMS5hbGwoaXRlcmFibGUpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciAkJDcgPSBfZXhwb3J0O1xudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ2FsbGFibGUkMSA9IGFDYWxsYWJsZSQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0kMSA9IHBlcmZvcm0kMztcbnZhciBpdGVyYXRlJDEgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFsbFxuJCQ3KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSB9LCB7XG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMi5mKEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUkMShDLnJlc29sdmUpO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlJDEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIGNhbGwkNygkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGdldEJ1aWx0SW4kMSA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJG47XG52YXIgZGVmaW5lQnVpbHRJbiQ0ID0gZGVmaW5lQnVpbHRJbiRhO1xuXG52YXIgTmF0aXZlUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4vLyBgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5jYXRjaFxuJCQ2KHsgdGFyZ2V0OiAnUHJvbWlzZScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIsIHJlYWw6IHRydWUgfSwge1xuICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgfVxufSk7XG5cbi8vIG1ha2VzIHN1cmUgdGhhdCBuYXRpdmUgcHJvbWlzZS1iYXNlZCBBUElzIGBQcm9taXNlI2NhdGNoYCBwcm9wZXJseSB3b3JrcyB3aXRoIHBhdGNoZWQgYFByb21pc2UjdGhlbmBcbmlmIChpc0NhbGxhYmxlJDMoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKSkge1xuICB2YXIgbWV0aG9kID0gZ2V0QnVpbHRJbiQxKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQ0KE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICdjYXRjaCcsIG1ldGhvZCwgeyB1bnNhZmU6IHRydWUgfSk7XG4gIH1cbn1cblxudmFyICQkNSA9IF9leHBvcnQ7XG52YXIgY2FsbCQ2ID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0gPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5yYWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4kJDUoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxLmYoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkNigkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDQgPSBfZXhwb3J0O1xudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkNCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkNShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDQgPSBhbk9iamVjdCRnO1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCQ4O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQ0KEMpO1xuICBpZiAoaXNPYmplY3QkMSh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cbnZhciAkJDMgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQkMyh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG52YXIgZG9tSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxuLy8gaW4gb2xkIFdlYktpdCB2ZXJzaW9ucywgYGVsZW1lbnQuY2xhc3NMaXN0YCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgZ2xvYmFsIGBET01Ub2tlbkxpc3RgXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG5cbnZhciBjbGFzc0xpc3QgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ3NwYW4nKS5jbGFzc0xpc3Q7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPSBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBkb21Ub2tlbkxpc3RQcm90b3R5cGUgPSBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHVuZGVmaW5lZCA6IERPTVRva2VuTGlzdFByb3RvdHlwZSQxO1xuXG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkbztcbnZhciBET01JdGVyYWJsZXMgPSBkb21JdGVyYWJsZXM7XG52YXIgRE9NVG9rZW5MaXN0UHJvdG90eXBlID0gZG9tVG9rZW5MaXN0UHJvdG90eXBlO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gZXNfYXJyYXlfaXRlcmF0b3I7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNCA9IHdlbGxLbm93blN5bWJvbCRpO1xuXG52YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCQ0KCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2wkNCgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxudmFyIGhhbmRsZVByb3RvdHlwZSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpIHtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQyXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiQyLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1IkMl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsJDZbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWwkNltDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKTtcbn1cblxuaGFuZGxlUHJvdG90eXBlKERPTVRva2VuTGlzdFByb3RvdHlwZSwgJ0RPTVRva2VuTGlzdCcpO1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIHRvU3RyaW5nJDMgPSB0b1N0cmluZyQ0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNDtcblxudmFyIGNoYXJBdCQ2ID0gdW5jdXJyeVRoaXMkNygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQkMSA9IHVuY3VycnlUaGlzJDcoJycuY2hhckNvZGVBdCk7XG52YXIgc3RyaW5nU2xpY2UkNSA9IHVuY3VycnlUaGlzJDcoJycuc2xpY2UpO1xuXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmckMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5JDEocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IGNoYXJBdCQ2KFMsIHBvc2l0aW9uKVxuICAgICAgICAgIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gc3RyaW5nU2xpY2UkNShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKVxuICAgICAgICAgIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdNdWx0aWJ5dGUgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuXG52YXIgY2hhckF0JDUgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQyO1xuXG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiB0b1N0cmluZyQyKGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTtcbi8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQkNShzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxudmFyIGZhaWxzJDUgPSBmYWlscyRrO1xudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgSVNfUFVSRSA9IGlzUHVyZTtcblxudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2wkMygnaXRlcmF0b3InKTtcblxudmFyIG5hdGl2ZVVybCA9ICFmYWlscyQ1KGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcmVsYXRpdmUtdXJsLXN0eWxlIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciB1cmwgPSBuZXcgVVJMKCdiP2E9MSZiPTImYz0zJywgJ2h0dHA6Ly9hJyk7XG4gIHZhciBzZWFyY2hQYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHVybC5wYXRobmFtZSA9ICdjJTIwZCc7XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgc2VhcmNoUGFyYW1zWydkZWxldGUnXSgnYicpO1xuICAgIHJlc3VsdCArPSBrZXkgKyB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiAoSVNfUFVSRSAmJiAhdXJsLnRvSlNPTilcbiAgICB8fCAhc2VhcmNoUGFyYW1zLnNvcnRcbiAgICB8fCB1cmwuaHJlZiAhPT0gJ2h0dHA6Ly9hL2MlMjBkP2E9MSZjPTMnXG4gICAgfHwgc2VhcmNoUGFyYW1zLmdldCgnYycpICE9PSAnMydcbiAgICB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcygnP2E9MScpKSAhPT0gJ2E9MSdcbiAgICB8fCAhc2VhcmNoUGFyYW1zW0lURVJBVE9SJDFdXG4gICAgLy8gdGhyb3dzIGluIEVkZ2VcbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2FAYicpLnVzZXJuYW1lICE9PSAnYSdcbiAgICB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9YicpKS5nZXQoJ2EnKSAhPT0gJ2InXG4gICAgLy8gbm90IHB1bnljb2RlZCBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cDovL9GC0LXRgdGCJykuaG9zdCAhPT0gJ3huLS1lMWF5YmMnXG4gICAgLy8gbm90IGVzY2FwZWQgaW4gQ2hyb21lIDYyLVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnXG4gICAgLy8gZmFpbHMgaW4gQ2hyb21lIDY2LVxuICAgIHx8IHJlc3VsdCAhPT0gJ2ExYzMnXG4gICAgLy8gdGhyb3dzIGluIFNhZmFyaVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly94JywgdW5kZWZpbmVkKS5ob3N0ICE9PSAneCc7XG59KTtcblxudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMy5leHBvcnRzO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSBtYWtlQnVpbHRJbihkZXNjcmlwdG9yLmdldCwgbmFtZSwgeyBnZXR0ZXI6IHRydWUgfSk7XG4gIGlmIChkZXNjcmlwdG9yLnNldCkgbWFrZUJ1aWx0SW4oZGVzY3JpcHRvci5zZXQsIG5hbWUsIHsgc2V0dGVyOiB0cnVlIH0pO1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkuZih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcblxudmFyIGFuT2JqZWN0JDMgPSBhbk9iamVjdCRnO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDI7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QkMyh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gIH1cbn07XG5cbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZVByb3BlcnR5JDIgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbnZhciBiaW5kJDIgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkNCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB0b09iamVjdCQxID0gdG9PYmplY3QkNTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMSA9IGxlbmd0aE9mQXJyYXlMaWtlJDQ7XG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGNyZWF0ZVByb3BlcnR5JDI7XG52YXIgZ2V0SXRlcmF0b3IkMSA9IGdldEl0ZXJhdG9yJDM7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDQ7XG5cbnZhciAkQXJyYXkkMSA9IEFycmF5O1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbnZhciBhcnJheUZyb20kMSA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCQxKGFycmF5TGlrZSk7XG4gIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQkMihtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDEoTyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQsIHZhbHVlO1xuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuICBpZiAoaXRlcmF0b3JNZXRob2QgJiYgISh0aGlzID09PSAkQXJyYXkkMSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMShPLCBpdGVyYXRvck1ldGhvZCk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcygpIDogW107XG4gICAgZm9yICg7IShzdGVwID0gY2FsbCQ0KG5leHQsIGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5JDEocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQxKE8pO1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMobGVuZ3RoKSA6ICRBcnJheSQxKGxlbmd0aCk7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5JDEocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSQ0O1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkMjtcblxudmFyICRBcnJheSA9IEFycmF5O1xudmFyIG1heCQxID0gTWF0aC5tYXg7XG5cbnZhciBhcnJheVNsaWNlU2ltcGxlID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheShtYXgkMShmaW4gLSBrLCAwKSk7XG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMvYmxvYi9tYXN0ZXIvcHVueWNvZGUuanNcbnZhciB1bmN1cnJ5VGhpcyQ2ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxcdTAwN0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1suXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nOyAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG52YXIgT1ZFUkZMT1dfRVJST1IgPSAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnO1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcblxudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbnZhciBleGVjJDIgPSB1bmN1cnJ5VGhpcyQ2KHJlZ2V4U2VwYXJhdG9ycy5leGVjKTtcbnZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcyQ2KCcnLmNoYXJDb2RlQXQpO1xudmFyIGpvaW4kMiA9IHVuY3VycnlUaGlzJDYoW10uam9pbik7XG52YXIgcHVzaCQzID0gdW5jdXJyeVRoaXMkNihbXS5wdXNoKTtcbnZhciByZXBsYWNlJDQgPSB1bmN1cnJ5VGhpcyQ2KCcnLnJlcGxhY2UpO1xudmFyIHNwbGl0JDIgPSB1bmN1cnJ5VGhpcyQ2KCcnLnNwbGl0KTtcbnZhciB0b0xvd2VyQ2FzZSQxID0gdW5jdXJyeVRoaXMkNignJy50b0xvd2VyQ2FzZSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICovXG52YXIgdWNzMmRlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGNoYXJDb2RlQXQoc3RyaW5nLCBjb3VudGVyKyspO1xuICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgIC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICB2YXIgZXh0cmEgPSBjaGFyQ29kZUF0KHN0cmluZywgY291bnRlcisrKTtcbiAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuICAgICAgICBwdXNoJDMob3V0cHV0LCAoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcbiAgICAgICAgLy8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIHB1c2gkMyhvdXRwdXQsIHZhbHVlKTtcbiAgICAgICAgY291bnRlci0tO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoJDMob3V0cHV0LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIChkaWdpdCkge1xuICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKi9cbnZhciBhZGFwdCA9IGZ1bmN0aW9uIChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgdmFyIGsgPSAwO1xuICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yJDMoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG4gIGRlbHRhICs9IGZsb29yJDMoZGVsdGEgLyBudW1Qb2ludHMpO1xuICB3aGlsZSAoZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxKSB7XG4gICAgZGVsdGEgPSBmbG9vciQzKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG4gICAgayArPSBiYXNlO1xuICB9XG4gIHJldHVybiBmbG9vciQzKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcblxuICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG4gIC8vIENhY2hlIHRoZSBsZW5ndGguXG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cbiAgdmFyIG4gPSBpbml0aWFsTjtcbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIGJpYXMgPSBpbml0aWFsQmlhcztcbiAgdmFyIGksIGN1cnJlbnRWYWx1ZTtcblxuICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgcHVzaCQzKG91dHB1dCwgZnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7IC8vIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cbiAgdmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7IC8vIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXG4gIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG4gIGlmIChiYXNpY0xlbmd0aCkge1xuICAgIHB1c2gkMyhvdXRwdXQsIGRlbGltaXRlcik7XG4gIH1cblxuICAvLyBNYWluIGVuY29kaW5nIGxvb3A6XG4gIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dCBsYXJnZXIgb25lOlxuICAgIHZhciBtID0gbWF4SW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICBtID0gY3VycmVudFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPiwgYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG4gICAgdmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcbiAgICBpZiAobSAtIG4gPiBmbG9vciQzKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG4gICAgICB0aHJvdyAkUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICAgfVxuXG4gICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgICBuID0gbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgICAgIHRocm93ICRSYW5nZUVycm9yKE9WRVJGTE9XX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgICAgdmFyIHEgPSBkZWx0YTtcbiAgICAgICAgdmFyIGsgPSBiYXNlO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcbiAgICAgICAgICBpZiAocSA8IHQpIGJyZWFrO1xuICAgICAgICAgIHZhciBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgdmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICBwdXNoJDMob3V0cHV0LCBmcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCkpKTtcbiAgICAgICAgICBxID0gZmxvb3IkMyhxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgayArPSBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaCQzKG91dHB1dCwgZnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxKSkpO1xuICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgIGhhbmRsZWRDUENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsdGErKztcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIGpvaW4kMihvdXRwdXQsICcnKTtcbn07XG5cbnZhciBzdHJpbmdQdW55Y29kZVRvQXNjaWkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIGVuY29kZWQgPSBbXTtcbiAgdmFyIGxhYmVscyA9IHNwbGl0JDIocmVwbGFjZSQ0KHRvTG93ZXJDYXNlJDEoaW5wdXQpLCByZWdleFNlcGFyYXRvcnMsICdcXHUwMDJFJyksICcuJyk7XG4gIHZhciBpLCBsYWJlbDtcbiAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgIHB1c2gkMyhlbmNvZGVkLCBleGVjJDIocmVnZXhOb25BU0NJSSwgbGFiZWwpID8gJ3huLS0nICsgZW5jb2RlKGxhYmVsKSA6IGxhYmVsKTtcbiAgfVxuICByZXR1cm4gam9pbiQyKGVuY29kZWQsICcuJyk7XG59O1xuXG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiRhO1xuXG52YXIgZGVmaW5lQnVpbHRJbnMkMSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluJDModGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBhcnJheVNsaWNlJDEgPSBhcnJheVNsaWNlU2ltcGxlO1xuXG52YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IkMihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoXG4gICAgYXJyYXksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMShhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZSQxKGFycmF5LCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIGNvbXBhcmVmblxuICApO1xufTtcblxudmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IDE7XG4gIHZhciBlbGVtZW50LCBqO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaiA9IGk7XG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdO1xuICAgIH1cbiAgICBpZiAoaiAhPT0gaSsrKSBhcnJheVtqXSA9IGVsZW1lbnQ7XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKGFycmF5LCBsZWZ0LCByaWdodCwgY29tcGFyZWZuKSB7XG4gIHZhciBsbGVuZ3RoID0gbGVmdC5sZW5ndGg7XG4gIHZhciBybGVuZ3RoID0gcmlnaHQubGVuZ3RoO1xuICB2YXIgbGluZGV4ID0gMDtcbiAgdmFyIHJpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkge1xuICAgIGFycmF5W2xpbmRleCArIHJpbmRleF0gPSAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKVxuICAgICAgPyBjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK11cbiAgICAgIDogbGluZGV4IDwgbGxlbmd0aCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdO1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheVNvcnQkMSA9IG1lcmdlU29ydDtcblxuLy8gVE9ETzogaW4gY29yZS1qc0A0LCBtb3ZlIC9tb2R1bGVzLyBkZXBlbmRlbmNpZXMgdG8gcHVibGljIGVudHJpZXMgZm9yIGJldHRlciBvcHRpbWl6YXRpb24gYnkgdG9vbHMgbGlrZSBgcHJlc2V0LWVudmBcblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkbztcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xudmFyIFVTRV9OQVRJVkVfVVJMJDEgPSBuYXRpdmVVcmw7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIGRlZmluZUJ1aWx0SW5zID0gZGVmaW5lQnVpbHRJbnMkMTtcbnZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckNTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQyO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMSA9IGludGVybmFsU3RhdGU7XG52YXIgYW5JbnN0YW5jZSQxID0gYW5JbnN0YW5jZSQzO1xudmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkbjtcbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgYmluZCQxID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJDY7XG52YXIgYW5PYmplY3QkMiA9IGFuT2JqZWN0JGc7XG52YXIgaXNPYmplY3QgPSBpc09iamVjdCQ4O1xudmFyICR0b1N0cmluZyQxID0gdG9TdHJpbmckNDtcbnZhciBjcmVhdGUkMSA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBnZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDM7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQ0O1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQzO1xudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgYXJyYXlTb3J0ID0gYXJyYXlTb3J0JDE7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCQyKCdpdGVyYXRvcicpO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TID0gJ1VSTFNlYXJjaFBhcmFtcyc7XG52YXIgVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IgPSBVUkxfU0VBUkNIX1BBUkFNUyArICdJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNUyk7XG52YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBBdm9pZCBOb2RlSlMgZXhwZXJpbWVudGFsIHdhcm5pbmdcbnZhciBzYWZlR2V0QnVpbHRJbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghREVTQ1JJUFRPUlMkMSkgcmV0dXJuIGdsb2JhbCQ1W25hbWVdO1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwkNSwgbmFtZSk7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG59O1xuXG52YXIgbmF0aXZlRmV0Y2ggPSBzYWZlR2V0QnVpbHRJbignZmV0Y2gnKTtcbnZhciBOYXRpdmVSZXF1ZXN0ID0gc2FmZUdldEJ1aWx0SW4oJ1JlcXVlc3QnKTtcbnZhciBIZWFkZXJzID0gc2FmZUdldEJ1aWx0SW4oJ0hlYWRlcnMnKTtcbnZhciBSZXF1ZXN0UHJvdG90eXBlID0gTmF0aXZlUmVxdWVzdCAmJiBOYXRpdmVSZXF1ZXN0LnByb3RvdHlwZTtcbnZhciBIZWFkZXJzUHJvdG90eXBlID0gSGVhZGVycyAmJiBIZWFkZXJzLnByb3RvdHlwZTtcbnZhciBSZWdFeHAkMSA9IGdsb2JhbCQ1LlJlZ0V4cDtcbnZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCQ1LlR5cGVFcnJvcjtcbnZhciBkZWNvZGVVUklDb21wb25lbnQgPSBnbG9iYWwkNS5kZWNvZGVVUklDb21wb25lbnQ7XG52YXIgZW5jb2RlVVJJQ29tcG9uZW50JDEgPSBnbG9iYWwkNS5lbmNvZGVVUklDb21wb25lbnQ7XG52YXIgY2hhckF0JDQgPSB1bmN1cnJ5VGhpcyQ1KCcnLmNoYXJBdCk7XG52YXIgam9pbiQxID0gdW5jdXJyeVRoaXMkNShbXS5qb2luKTtcbnZhciBwdXNoJDIgPSB1bmN1cnJ5VGhpcyQ1KFtdLnB1c2gpO1xudmFyIHJlcGxhY2UkMyA9IHVuY3VycnlUaGlzJDUoJycucmVwbGFjZSk7XG52YXIgc2hpZnQkMSA9IHVuY3VycnlUaGlzJDUoW10uc2hpZnQpO1xudmFyIHNwbGljZSA9IHVuY3VycnlUaGlzJDUoW10uc3BsaWNlKTtcbnZhciBzcGxpdCQxID0gdW5jdXJyeVRoaXMkNSgnJy5zcGxpdCk7XG52YXIgc3RyaW5nU2xpY2UkNCA9IHVuY3VycnlUaGlzJDUoJycuc2xpY2UpO1xuXG52YXIgcGx1cyA9IC9cXCsvZztcbnZhciBzZXF1ZW5jZXMgPSBBcnJheSg0KTtcblxudmFyIHBlcmNlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gc2VxdWVuY2VzW2J5dGVzIC0gMV0gfHwgKHNlcXVlbmNlc1tieXRlcyAtIDFdID0gUmVnRXhwJDEoJygoPzolW1xcXFxkYS1mXXsyfSl7JyArIGJ5dGVzICsgJ30pJywgJ2dpJykpO1xufTtcblxudmFyIHBlcmNlbnREZWNvZGUgPSBmdW5jdGlvbiAoc2VxdWVuY2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHNlcXVlbmNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gc2VxdWVuY2U7XG4gIH1cbn07XG5cbnZhciBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gcmVwbGFjZSQzKGl0LCBwbHVzLCAnICcpO1xuICB2YXIgYnl0ZXMgPSA0O1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3aGlsZSAoYnl0ZXMpIHtcbiAgICAgIHJlc3VsdCA9IHJlcGxhY2UkMyhyZXN1bHQsIHBlcmNlbnRTZXF1ZW5jZShieXRlcy0tKSwgcGVyY2VudERlY29kZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmaW5kID0gL1shJygpfl18JTIwL2c7XG5cbnZhciByZXBsYWNlbWVudHMgPSB7XG4gICchJzogJyUyMScsXG4gIFwiJ1wiOiAnJTI3JyxcbiAgJygnOiAnJTI4JyxcbiAgJyknOiAnJTI5JyxcbiAgJ34nOiAnJTdFJyxcbiAgJyUyMCc6ICcrJ1xufTtcblxudmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gIHJldHVybiByZXBsYWNlbWVudHNbbWF0Y2hdO1xufTtcblxudmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gcmVwbGFjZSQzKGVuY29kZVVSSUNvbXBvbmVudCQxKGl0KSwgZmluZCwgcmVwbGFjZXIpO1xufTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihmdW5jdGlvbiBJdGVyYXRvcihwYXJhbXMsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUixcbiAgICBpdGVyYXRvcjogZ2V0SXRlcmF0b3IoZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZShwYXJhbXMpLmVudHJpZXMpLFxuICAgIGtpbmQ6IGtpbmRcbiAgfSk7XG59LCAnSXRlcmF0b3InLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIHN0ZXAgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gIGlmICghc3RlcC5kb25lKSB7XG4gICAgc3RlcC52YWx1ZSA9IGtpbmQgPT09ICdrZXlzJyA/IGVudHJ5LmtleSA6IGtpbmQgPT09ICd2YWx1ZXMnID8gZW50cnkudmFsdWUgOiBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV07XG4gIH0gcmV0dXJuIHN0ZXA7XG59LCB0cnVlKTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc1N0YXRlID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG4gIHRoaXMudXJsID0gbnVsbDtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB0aGlzLnBhcnNlT2JqZWN0KGluaXQpO1xuICAgIGVsc2UgdGhpcy5wYXJzZVF1ZXJ5KHR5cGVvZiBpbml0ID09ICdzdHJpbmcnID8gY2hhckF0JDQoaW5pdCwgMCkgPT09ICc/JyA/IHN0cmluZ1NsaWNlJDQoaW5pdCwgMSkgOiBpbml0IDogJHRvU3RyaW5nJDEoaW5pdCkpO1xuICB9XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TLFxuICBiaW5kVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSxcbiAgcGFyc2VPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChvYmplY3QpO1xuICAgIHZhciBpdGVyYXRvciwgbmV4dCwgc3RlcCwgZW50cnlJdGVyYXRvciwgZW50cnlOZXh0LCBmaXJzdCwgc2Vjb25kO1xuXG4gICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKG9iamVjdCwgaXRlcmF0b3JNZXRob2QpO1xuICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgICB3aGlsZSAoIShzdGVwID0gY2FsbCQzKG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICAgICBlbnRyeUl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoYW5PYmplY3QkMihzdGVwLnZhbHVlKSk7XG4gICAgICAgIGVudHJ5TmV4dCA9IGVudHJ5SXRlcmF0b3IubmV4dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChmaXJzdCA9IGNhbGwkMyhlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XG4gICAgICAgICAgKHNlY29uZCA9IGNhbGwkMyhlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XG4gICAgICAgICAgIWNhbGwkMyhlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpLmRvbmVcbiAgICAgICAgKSB0aHJvdyBUeXBlRXJyb3IkMignRXhwZWN0ZWQgc2VxdWVuY2Ugd2l0aCBsZW5ndGggMicpO1xuICAgICAgICBwdXNoJDIodGhpcy5lbnRyaWVzLCB7IGtleTogJHRvU3RyaW5nJDEoZmlyc3QudmFsdWUpLCB2YWx1ZTogJHRvU3RyaW5nJDEoc2Vjb25kLnZhbHVlKSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgZm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKGhhc093biQxKG9iamVjdCwga2V5KSkge1xuICAgICAgcHVzaCQyKHRoaXMuZW50cmllcywgeyBrZXk6IGtleSwgdmFsdWU6ICR0b1N0cmluZyQxKG9iamVjdFtrZXldKSB9KTtcbiAgICB9XG4gIH0sXG4gIHBhcnNlUXVlcnk6IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzcGxpdCQxKHF1ZXJ5LCAnJicpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBhdHRyaWJ1dGUsIGVudHJ5O1xuICAgICAgd2hpbGUgKGluZGV4IDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleCsrXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICBlbnRyeSA9IHNwbGl0JDEoYXR0cmlidXRlLCAnPScpO1xuICAgICAgICAgIHB1c2gkMih0aGlzLmVudHJpZXMsIHtcbiAgICAgICAgICAgIGtleTogZGVzZXJpYWxpemUoc2hpZnQkMShlbnRyeSkpLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2VyaWFsaXplKGpvaW4kMShlbnRyeSwgJz0nKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBlbnRyeSA9IGVudHJpZXNbaW5kZXgrK107XG4gICAgICBwdXNoJDIocmVzdWx0LCBzZXJpYWxpemUoZW50cnkua2V5KSArICc9JyArIHNlcmlhbGl6ZShlbnRyeS52YWx1ZSkpO1xuICAgIH0gcmV0dXJuIGpvaW4kMShyZXN1bHQsICcmJyk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGFyc2VRdWVyeSh0aGlzLnVybC5xdWVyeSk7XG4gIH0sXG4gIHVwZGF0ZVVSTDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnVybCkgdGhpcy51cmwudXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXNgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS11cmxzZWFyY2hwYXJhbXNcbnZhciBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcygvKiBpbml0ICovKSB7XG4gIGFuSW5zdGFuY2UkMSh0aGlzLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUpO1xuICB2YXIgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywgbmV3IFVSTFNlYXJjaFBhcmFtc1N0YXRlKGluaXQpKTtcbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbmRlZmluZUJ1aWx0SW5zKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwge1xuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtYXBwZW5kXG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHB1c2gkMihzdGF0ZS5lbnRyaWVzLCB7IGtleTogJHRvU3RyaW5nJDEobmFtZSksIHZhbHVlOiAkdG9TdHJpbmckMSh2YWx1ZSkgfSk7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1kZWxldGVcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nJDEobmFtZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSBzcGxpY2UoZW50cmllcywgaW5kZXgsIDEpO1xuICAgICAgZWxzZSBpbmRleCsrO1xuICAgIH1cbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWdldFxuICBnZXQ6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nJDEobmFtZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSByZXR1cm4gZW50cmllc1tpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXRBbGxgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0YWxsXG4gIGdldEFsbDogZnVuY3Rpb24gZ2V0QWxsKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmckMShuYW1lKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSBwdXNoJDIocmVzdWx0LCBlbnRyaWVzW2luZGV4XS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmhhc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1oYXNcbiAgaGFzOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9ICR0b1N0cmluZyQxKG5hbWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4KytdLmtleSA9PT0ga2V5KSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zZXRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtc2V0XG4gIHNldDogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMShhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nJDEobmFtZSk7XG4gICAgdmFyIHZhbCA9ICR0b1N0cmluZyQxKHZhbHVlKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIGlmIChlbnRyeS5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoZm91bmQpIHNwbGljZShlbnRyaWVzLCBpbmRleC0tLCAxKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGVudHJ5LnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIHB1c2gkMihlbnRyaWVzLCB7IGtleToga2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zb3J0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNvcnRcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIGFycmF5U29ydChzdGF0ZS5lbnRyaWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEua2V5ID4gYi5rZXkgPyAxIDogLTE7XG4gICAgfSk7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZCQxKGNhbGxiYWNrLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgfVxuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5rZXlzYCBtZXRob2RcbiAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICdrZXlzJyk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ3ZhbHVlcycpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICdlbnRyaWVzJyk7XG4gIH1cbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuZGVmaW5lQnVpbHRJbiQyKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgSVRFUkFUT1IsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5lbnRyaWVzLCB7IG5hbWU6ICdlbnRyaWVzJyB9KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXG5kZWZpbmVCdWlsdEluJDIoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuc2VyaWFsaXplKCk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbnNldFRvU3RyaW5nVGFnJDEoVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsIFVSTF9TRUFSQ0hfUEFSQU1TKTtcblxuJCQyKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiAhVVNFX05BVElWRV9VUkwkMSB9LCB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3Jcbn0pO1xuXG4vLyBXcmFwIGBmZXRjaGAgYW5kIGBSZXF1ZXN0YCBmb3IgY29ycmVjdCB3b3JrIHdpdGggcG9seWZpbGxlZCBgVVJMU2VhcmNoUGFyYW1zYFxuaWYgKCFVU0VfTkFUSVZFX1VSTCQxICYmIGlzQ2FsbGFibGUkMihIZWFkZXJzKSkge1xuICB2YXIgaGVhZGVyc0hhcyA9IHVuY3VycnlUaGlzJDUoSGVhZGVyc1Byb3RvdHlwZS5oYXMpO1xuICB2YXIgaGVhZGVyc1NldCA9IHVuY3VycnlUaGlzJDUoSGVhZGVyc1Byb3RvdHlwZS5zZXQpO1xuXG4gIHZhciB3cmFwUmVxdWVzdE9wdGlvbnMgPSBmdW5jdGlvbiAoaW5pdCkge1xuICAgIGlmIChpc09iamVjdChpbml0KSkge1xuICAgICAgdmFyIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgICB2YXIgaGVhZGVycztcbiAgICAgIGlmIChjbGFzc29mJDEoYm9keSkgPT09IFVSTF9TRUFSQ0hfUEFSQU1TKSB7XG4gICAgICAgIGhlYWRlcnMgPSBpbml0LmhlYWRlcnMgPyBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpIDogbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKCFoZWFkZXJzSGFzKGhlYWRlcnMsICdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICAgIGhlYWRlcnNTZXQoaGVhZGVycywgJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGUkMShpbml0LCB7XG4gICAgICAgICAgYm9keTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsICR0b1N0cmluZyQxKGJvZHkpKSxcbiAgICAgICAgICBoZWFkZXJzOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgaGVhZGVycylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSByZXR1cm4gaW5pdDtcbiAgfTtcblxuICBpZiAoaXNDYWxsYWJsZSQyKG5hdGl2ZUZldGNoKSkge1xuICAgICQkMih7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZG9udENhbGxHZXRTZXQ6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQgLyogLCBpbml0ICovKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVGZXRjaChpbnB1dCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB3cmFwUmVxdWVzdE9wdGlvbnMoYXJndW1lbnRzWzFdKSA6IHt9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0NhbGxhYmxlJDIoTmF0aXZlUmVxdWVzdCkpIHtcbiAgICB2YXIgUmVxdWVzdENvbnN0cnVjdG9yID0gZnVuY3Rpb24gUmVxdWVzdChpbnB1dCAvKiAsIGluaXQgKi8pIHtcbiAgICAgIGFuSW5zdGFuY2UkMSh0aGlzLCBSZXF1ZXN0UHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBuZXcgTmF0aXZlUmVxdWVzdChpbnB1dCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB3cmFwUmVxdWVzdE9wdGlvbnMoYXJndW1lbnRzWzFdKSA6IHt9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcXVlc3RDb25zdHJ1Y3RvcjtcbiAgICBSZXF1ZXN0Q29uc3RydWN0b3IucHJvdG90eXBlID0gUmVxdWVzdFByb3RvdHlwZTtcblxuICAgICQkMih7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGRvbnRDYWxsR2V0U2V0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgICAgUmVxdWVzdDogUmVxdWVzdENvbnN0cnVjdG9yXG4gICAgfSk7XG4gIH1cbn1cblxudmFyIHdlYl91cmxTZWFyY2hQYXJhbXNfY29uc3RydWN0b3IgPSB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsXG4gIGdldFN0YXRlOiBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlXG59O1xuXG4vLyBUT0RPOiBpbiBjb3JlLWpzQDQsIG1vdmUgL21vZHVsZXMvIGRlcGVuZGVuY2llcyB0byBwdWJsaWMgZW50cmllcyBmb3IgYmV0dGVyIG9wdGltaXphdGlvbiBieSB0b29scyBsaWtlIGBwcmVzZXQtZW52YFxuXG52YXIgJCQxID0gX2V4cG9ydDtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gbmF0aXZlVXJsO1xudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJG87XG52YXIgYmluZCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZGVmaW5lQnVpbHRJbiQxID0gZGVmaW5lQnVpbHRJbiRhO1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciA9IGRlZmluZUJ1aWx0SW5BY2Nlc3NvciQxO1xudmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDM7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBhc3NpZ24gPSBvYmplY3RBc3NpZ247XG52YXIgYXJyYXlGcm9tID0gYXJyYXlGcm9tJDE7XG52YXIgYXJyYXlTbGljZSA9IGFycmF5U2xpY2VTaW1wbGU7XG52YXIgY29kZUF0ID0gc3RyaW5nTXVsdGlieXRlLmNvZGVBdDtcbnZhciB0b0FTQ0lJID0gc3RyaW5nUHVueWNvZGVUb0FzY2lpO1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nJDQ7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQ1O1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMztcbnZhciBVUkxTZWFyY2hQYXJhbXNNb2R1bGUgPSB3ZWJfdXJsU2VhcmNoUGFyYW1zX2NvbnN0cnVjdG9yO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsVVJMU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcignVVJMJyk7XG52YXIgVVJMU2VhcmNoUGFyYW1zJDEgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuVVJMU2VhcmNoUGFyYW1zO1xudmFyIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuZ2V0U3RhdGU7XG5cbnZhciBOYXRpdmVVUkwgPSBnbG9iYWwkNC5VUkw7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkNC5UeXBlRXJyb3I7XG52YXIgcGFyc2VJbnQgPSBnbG9iYWwkNC5wYXJzZUludDtcbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBjaGFyQXQkMyA9IHVuY3VycnlUaGlzJDQoJycuY2hhckF0KTtcbnZhciBleGVjJDEgPSB1bmN1cnJ5VGhpcyQ0KC8uLy5leGVjKTtcbnZhciBqb2luID0gdW5jdXJyeVRoaXMkNChbXS5qb2luKTtcbnZhciBudW1iZXJUb1N0cmluZyA9IHVuY3VycnlUaGlzJDQoMS4wLnRvU3RyaW5nKTtcbnZhciBwb3AgPSB1bmN1cnJ5VGhpcyQ0KFtdLnBvcCk7XG52YXIgcHVzaCQxID0gdW5jdXJyeVRoaXMkNChbXS5wdXNoKTtcbnZhciByZXBsYWNlJDIgPSB1bmN1cnJ5VGhpcyQ0KCcnLnJlcGxhY2UpO1xudmFyIHNoaWZ0ID0gdW5jdXJyeVRoaXMkNChbXS5zaGlmdCk7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyQ0KCcnLnNwbGl0KTtcbnZhciBzdHJpbmdTbGljZSQzID0gdW5jdXJyeVRoaXMkNCgnJy5zbGljZSk7XG52YXIgdG9Mb3dlckNhc2UgPSB1bmN1cnJ5VGhpcyQ0KCcnLnRvTG93ZXJDYXNlKTtcbnZhciB1bnNoaWZ0ID0gdW5jdXJyeVRoaXMkNChbXS51bnNoaWZ0KTtcblxudmFyIElOVkFMSURfQVVUSE9SSVRZID0gJ0ludmFsaWQgYXV0aG9yaXR5JztcbnZhciBJTlZBTElEX1NDSEVNRSA9ICdJbnZhbGlkIHNjaGVtZSc7XG52YXIgSU5WQUxJRF9IT1NUID0gJ0ludmFsaWQgaG9zdCc7XG52YXIgSU5WQUxJRF9QT1JUID0gJ0ludmFsaWQgcG9ydCc7XG5cbnZhciBBTFBIQSA9IC9bYS16XS9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1vYnNjdXJlLXJhbmdlIC0tIHNhZmVcbnZhciBBTFBIQU5VTUVSSUMgPSAvW1xcZCstLmEtel0vaTtcbnZhciBESUdJVCA9IC9cXGQvO1xudmFyIEhFWF9TVEFSVCA9IC9eMHgvaTtcbnZhciBPQ1QgPSAvXlswLTddKyQvO1xudmFyIERFQyA9IC9eXFxkKyQvO1xudmFyIEhFWCA9IC9eW1xcZGEtZl0rJC9pO1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLWNvbnRyb2wtY2hhcmFjdGVyIC0tIHNhZmUgKi9cbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UID0gL1tcXDBcXHRcXG5cXHIgIyUvOjw+P0BbXFxcXFxcXV58XS87XG52YXIgRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVF9FWENMVURJTkdfUEVSQ0VOVCA9IC9bXFwwXFx0XFxuXFxyICMvOjw+P0BbXFxcXFxcXV58XS87XG52YXIgTEVBRElOR19BTkRfVFJBSUxJTkdfQzBfQ09OVFJPTF9PUl9TUEFDRSA9IC9eW1xcdTAwMDAtXFx1MDAyMF0rfFtcXHUwMDAwLVxcdTAwMjBdKyQvZztcbnZhciBUQUJfQU5EX05FV19MSU5FID0gL1tcXHRcXG5cXHJdL2c7XG4vKiBlc2xpbnQtZW5hYmxlIHJlZ2V4cC9uby1jb250cm9sLWNoYXJhY3RlciAtLSBzYWZlICovXG52YXIgRU9GO1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2lwdjQtbnVtYmVyLXBhcnNlclxudmFyIHBhcnNlSVB2NCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgcGFydHMgPSBzcGxpdChpbnB1dCwgJy4nKTtcbiAgdmFyIHBhcnRzTGVuZ3RoLCBudW1iZXJzLCBpbmRleCwgcGFydCwgcmFkaXgsIG51bWJlciwgaXB2NDtcbiAgaWYgKHBhcnRzLmxlbmd0aCAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PSAnJykge1xuICAgIHBhcnRzLmxlbmd0aC0tO1xuICB9XG4gIHBhcnRzTGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuICBpZiAocGFydHNMZW5ndGggPiA0KSByZXR1cm4gaW5wdXQ7XG4gIG51bWJlcnMgPSBbXTtcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFydHNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBwYXJ0ID0gcGFydHNbaW5kZXhdO1xuICAgIGlmIChwYXJ0ID09ICcnKSByZXR1cm4gaW5wdXQ7XG4gICAgcmFkaXggPSAxMDtcbiAgICBpZiAocGFydC5sZW5ndGggPiAxICYmIGNoYXJBdCQzKHBhcnQsIDApID09ICcwJykge1xuICAgICAgcmFkaXggPSBleGVjJDEoSEVYX1NUQVJULCBwYXJ0KSA/IDE2IDogODtcbiAgICAgIHBhcnQgPSBzdHJpbmdTbGljZSQzKHBhcnQsIHJhZGl4ID09IDggPyAxIDogMik7XG4gICAgfVxuICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgbnVtYmVyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFleGVjJDEocmFkaXggPT0gMTAgPyBERUMgOiByYWRpeCA9PSA4ID8gT0NUIDogSEVYLCBwYXJ0KSkgcmV0dXJuIGlucHV0O1xuICAgICAgbnVtYmVyID0gcGFyc2VJbnQocGFydCwgcmFkaXgpO1xuICAgIH1cbiAgICBwdXNoJDEobnVtYmVycywgbnVtYmVyKTtcbiAgfVxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0c0xlbmd0aDsgaW5kZXgrKykge1xuICAgIG51bWJlciA9IG51bWJlcnNbaW5kZXhdO1xuICAgIGlmIChpbmRleCA9PSBwYXJ0c0xlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChudW1iZXIgPj0gcG93KDI1NiwgNSAtIHBhcnRzTGVuZ3RoKSkgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPiAyNTUpIHJldHVybiBudWxsO1xuICB9XG4gIGlwdjQgPSBwb3AobnVtYmVycyk7XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG51bWJlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaXB2NCArPSBudW1iZXJzW2luZGV4XSAqIHBvdygyNTYsIDMgLSBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIGlwdjQ7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaXB2Ni1wYXJzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXG52YXIgcGFyc2VJUHY2ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBhZGRyZXNzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICB2YXIgcGllY2VJbmRleCA9IDA7XG4gIHZhciBjb21wcmVzcyA9IG51bGw7XG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIHZhbHVlLCBsZW5ndGgsIG51bWJlcnNTZWVuLCBpcHY0UGllY2UsIG51bWJlciwgc3dhcHMsIHN3YXA7XG5cbiAgdmFyIGNociA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhckF0JDMoaW5wdXQsIHBvaW50ZXIpO1xuICB9O1xuXG4gIGlmIChjaHIoKSA9PSAnOicpIHtcbiAgICBpZiAoY2hhckF0JDMoaW5wdXQsIDEpICE9ICc6JykgcmV0dXJuO1xuICAgIHBvaW50ZXIgKz0gMjtcbiAgICBwaWVjZUluZGV4Kys7XG4gICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICB9XG4gIHdoaWxlIChjaHIoKSkge1xuICAgIGlmIChwaWVjZUluZGV4ID09IDgpIHJldHVybjtcbiAgICBpZiAoY2hyKCkgPT0gJzonKSB7XG4gICAgICBpZiAoY29tcHJlc3MgIT09IG51bGwpIHJldHVybjtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIHBpZWNlSW5kZXgrKztcbiAgICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKGxlbmd0aCA8IDQgJiYgZXhlYyQxKEhFWCwgY2hyKCkpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICogMTYgKyBwYXJzZUludChjaHIoKSwgMTYpO1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgbGVuZ3RoKys7XG4gICAgfVxuICAgIGlmIChjaHIoKSA9PSAnLicpIHtcbiAgICAgIGlmIChsZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgcG9pbnRlciAtPSBsZW5ndGg7XG4gICAgICBpZiAocGllY2VJbmRleCA+IDYpIHJldHVybjtcbiAgICAgIG51bWJlcnNTZWVuID0gMDtcbiAgICAgIHdoaWxlIChjaHIoKSkge1xuICAgICAgICBpcHY0UGllY2UgPSBudWxsO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPiAwKSB7XG4gICAgICAgICAgaWYgKGNocigpID09ICcuJyAmJiBudW1iZXJzU2VlbiA8IDQpIHBvaW50ZXIrKztcbiAgICAgICAgICBlbHNlIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4ZWMkMShESUdJVCwgY2hyKCkpKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChleGVjJDEoRElHSVQsIGNocigpKSkge1xuICAgICAgICAgIG51bWJlciA9IHBhcnNlSW50KGNocigpLCAxMCk7XG4gICAgICAgICAgaWYgKGlwdjRQaWVjZSA9PT0gbnVsbCkgaXB2NFBpZWNlID0gbnVtYmVyO1xuICAgICAgICAgIGVsc2UgaWYgKGlwdjRQaWVjZSA9PSAwKSByZXR1cm47XG4gICAgICAgICAgZWxzZSBpcHY0UGllY2UgPSBpcHY0UGllY2UgKiAxMCArIG51bWJlcjtcbiAgICAgICAgICBpZiAoaXB2NFBpZWNlID4gMjU1KSByZXR1cm47XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3NbcGllY2VJbmRleF0gPSBhZGRyZXNzW3BpZWNlSW5kZXhdICogMjU2ICsgaXB2NFBpZWNlO1xuICAgICAgICBudW1iZXJzU2VlbisrO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPT0gMiB8fCBudW1iZXJzU2VlbiA9PSA0KSBwaWVjZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyc1NlZW4gIT0gNCkgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaHIoKSA9PSAnOicpIHtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIGlmICghY2hyKCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGNocigpKSByZXR1cm47XG4gICAgYWRkcmVzc1twaWVjZUluZGV4KytdID0gdmFsdWU7XG4gIH1cbiAgaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XG4gICAgc3dhcHMgPSBwaWVjZUluZGV4IC0gY29tcHJlc3M7XG4gICAgcGllY2VJbmRleCA9IDc7XG4gICAgd2hpbGUgKHBpZWNlSW5kZXggIT0gMCAmJiBzd2FwcyA+IDApIHtcbiAgICAgIHN3YXAgPSBhZGRyZXNzW3BpZWNlSW5kZXhdO1xuICAgICAgYWRkcmVzc1twaWVjZUluZGV4LS1dID0gYWRkcmVzc1tjb21wcmVzcyArIHN3YXBzIC0gMV07XG4gICAgICBhZGRyZXNzW2NvbXByZXNzICsgLS1zd2Fwc10gPSBzd2FwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwaWVjZUluZGV4ICE9IDgpIHJldHVybjtcbiAgcmV0dXJuIGFkZHJlc3M7XG59O1xuXG52YXIgZmluZExvbmdlc3RaZXJvU2VxdWVuY2UgPSBmdW5jdGlvbiAoaXB2Nikge1xuICB2YXIgbWF4SW5kZXggPSBudWxsO1xuICB2YXIgbWF4TGVuZ3RoID0gMTtcbiAgdmFyIGN1cnJTdGFydCA9IG51bGw7XG4gIHZhciBjdXJyTGVuZ3RoID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICg7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgIGlmIChpcHY2W2luZGV4XSAhPT0gMCkge1xuICAgICAgaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gICAgICB9XG4gICAgICBjdXJyU3RhcnQgPSBudWxsO1xuICAgICAgY3Vyckxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpIGN1cnJTdGFydCA9IGluZGV4O1xuICAgICAgKytjdXJyTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoY3Vyckxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIG1heEluZGV4ID0gY3VyclN0YXJ0O1xuICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNob3N0LXNlcmlhbGl6aW5nXG52YXIgc2VyaWFsaXplSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gIHZhciByZXN1bHQsIGluZGV4LCBjb21wcmVzcywgaWdub3JlMDtcbiAgLy8gaXB2NFxuICBpZiAodHlwZW9mIGhvc3QgPT0gJ251bWJlcicpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0OyBpbmRleCsrKSB7XG4gICAgICB1bnNoaWZ0KHJlc3VsdCwgaG9zdCAlIDI1Nik7XG4gICAgICBob3N0ID0gZmxvb3IkMShob3N0IC8gMjU2KTtcbiAgICB9IHJldHVybiBqb2luKHJlc3VsdCwgJy4nKTtcbiAgLy8gaXB2NlxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3N0ID09ICdvYmplY3QnKSB7XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgY29tcHJlc3MgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShob3N0KTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoaWdub3JlMCAmJiBob3N0W2luZGV4XSA9PT0gMCkgY29udGludWU7XG4gICAgICBpZiAoaWdub3JlMCkgaWdub3JlMCA9IGZhbHNlO1xuICAgICAgaWYgKGNvbXByZXNzID09PSBpbmRleCkge1xuICAgICAgICByZXN1bHQgKz0gaW5kZXggPyAnOicgOiAnOjonO1xuICAgICAgICBpZ25vcmUwID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBudW1iZXJUb1N0cmluZyhob3N0W2luZGV4XSwgMTYpO1xuICAgICAgICBpZiAoaW5kZXggPCA3KSByZXN1bHQgKz0gJzonO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1snICsgcmVzdWx0ICsgJ10nO1xuICB9IHJldHVybiBob3N0O1xufTtcblxudmFyIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQgPSB7fTtcbnZhciBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJyAnOiAxLCAnXCInOiAxLCAnPCc6IDEsICc+JzogMSwgJ2AnOiAxXG59KTtcbnZhciBwYXRoUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcjJzogMSwgJz8nOiAxLCAneyc6IDEsICd9JzogMVxufSk7XG52YXIgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBwYXRoUGVyY2VudEVuY29kZVNldCwge1xuICAnLyc6IDEsICc6JzogMSwgJzsnOiAxLCAnPSc6IDEsICdAJzogMSwgJ1snOiAxLCAnXFxcXCc6IDEsICddJzogMSwgJ14nOiAxLCAnfCc6IDFcbn0pO1xuXG52YXIgcGVyY2VudEVuY29kZSA9IGZ1bmN0aW9uIChjaHIsIHNldCkge1xuICB2YXIgY29kZSA9IGNvZGVBdChjaHIsIDApO1xuICByZXR1cm4gY29kZSA+IDB4MjAgJiYgY29kZSA8IDB4N0YgJiYgIWhhc093bihzZXQsIGNocikgPyBjaHIgOiBlbmNvZGVVUklDb21wb25lbnQoY2hyKTtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3BlY2lhbC1zY2hlbWVcbnZhciBzcGVjaWFsU2NoZW1lcyA9IHtcbiAgZnRwOiAyMSxcbiAgZmlsZTogbnVsbCxcbiAgaHR0cDogODAsXG4gIGh0dHBzOiA0NDMsXG4gIHdzOiA4MCxcbiAgd3NzOiA0NDNcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jd2luZG93cy1kcml2ZS1sZXR0ZXJcbnZhciBpc1dpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcsIG5vcm1hbGl6ZWQpIHtcbiAgdmFyIHNlY29uZDtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPT0gMiAmJiBleGVjJDEoQUxQSEEsIGNoYXJBdCQzKHN0cmluZywgMCkpXG4gICAgJiYgKChzZWNvbmQgPSBjaGFyQXQkMyhzdHJpbmcsIDEpKSA9PSAnOicgfHwgKCFub3JtYWxpemVkICYmIHNlY29uZCA9PSAnfCcpKTtcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RhcnQtd2l0aC1hLXdpbmRvd3MtZHJpdmUtbGV0dGVyXG52YXIgc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHRoaXJkO1xuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoc3RyaW5nU2xpY2UkMyhzdHJpbmcsIDAsIDIpKSAmJiAoXG4gICAgc3RyaW5nLmxlbmd0aCA9PSAyIHx8XG4gICAgKCh0aGlyZCA9IGNoYXJBdCQzKHN0cmluZywgMikpID09PSAnLycgfHwgdGhpcmQgPT09ICdcXFxcJyB8fCB0aGlyZCA9PT0gJz8nIHx8IHRoaXJkID09PSAnIycpXG4gICk7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3NpbmdsZS1kb3QtcGF0aC1zZWdtZW50XG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4nIHx8IHRvTG93ZXJDYXNlKHNlZ21lbnQpID09PSAnJTJlJztcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG91YmxlLWRvdC1wYXRoLXNlZ21lbnRcbnZhciBpc0RvdWJsZURvdCA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gIHNlZ21lbnQgPSB0b0xvd2VyQ2FzZShzZWdtZW50KTtcbiAgcmV0dXJuIHNlZ21lbnQgPT09ICcuLicgfHwgc2VnbWVudCA9PT0gJyUyZS4nIHx8IHNlZ21lbnQgPT09ICcuJTJlJyB8fCBzZWdtZW50ID09PSAnJTJlJTJlJztcbn07XG5cbi8vIFN0YXRlczpcbnZhciBTQ0hFTUVfU1RBUlQgPSB7fTtcbnZhciBTQ0hFTUUgPSB7fTtcbnZhciBOT19TQ0hFTUUgPSB7fTtcbnZhciBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWSA9IHt9O1xudmFyIFBBVEhfT1JfQVVUSE9SSVRZID0ge307XG52YXIgUkVMQVRJVkUgPSB7fTtcbnZhciBSRUxBVElWRV9TTEFTSCA9IHt9O1xudmFyIFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVMgPSB7fTtcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUyA9IHt9O1xudmFyIEFVVEhPUklUWSA9IHt9O1xudmFyIEhPU1QgPSB7fTtcbnZhciBIT1NUTkFNRSA9IHt9O1xudmFyIFBPUlQgPSB7fTtcbnZhciBGSUxFID0ge307XG52YXIgRklMRV9TTEFTSCA9IHt9O1xudmFyIEZJTEVfSE9TVCA9IHt9O1xudmFyIFBBVEhfU1RBUlQgPSB7fTtcbnZhciBQQVRIID0ge307XG52YXIgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSCA9IHt9O1xudmFyIFFVRVJZID0ge307XG52YXIgRlJBR01FTlQgPSB7fTtcblxudmFyIFVSTFN0YXRlID0gZnVuY3Rpb24gKHVybCwgaXNCYXNlLCBiYXNlKSB7XG4gIHZhciB1cmxTdHJpbmcgPSAkdG9TdHJpbmcodXJsKTtcbiAgdmFyIGJhc2VTdGF0ZSwgZmFpbHVyZSwgc2VhcmNoUGFyYW1zO1xuICBpZiAoaXNCYXNlKSB7XG4gICAgZmFpbHVyZSA9IHRoaXMucGFyc2UodXJsU3RyaW5nKTtcbiAgICBpZiAoZmFpbHVyZSkgdGhyb3cgVHlwZUVycm9yJDEoZmFpbHVyZSk7XG4gICAgdGhpcy5zZWFyY2hQYXJhbXMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIGJhc2VTdGF0ZSA9IG5ldyBVUkxTdGF0ZShiYXNlLCB0cnVlKTtcbiAgICBmYWlsdXJlID0gdGhpcy5wYXJzZSh1cmxTdHJpbmcsIG51bGwsIGJhc2VTdGF0ZSk7XG4gICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvciQxKGZhaWx1cmUpO1xuICAgIHNlYXJjaFBhcmFtcyA9IGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUobmV3IFVSTFNlYXJjaFBhcmFtcyQxKCkpO1xuICAgIHNlYXJjaFBhcmFtcy5iaW5kVVJMKHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1zO1xuICB9XG59O1xuXG5VUkxTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICdVUkwnLFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXG4gIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQsIHN0YXRlT3ZlcnJpZGUsIGJhc2UpIHtcbiAgICB2YXIgdXJsID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzdGF0ZU92ZXJyaWRlIHx8IFNDSEVNRV9TVEFSVDtcbiAgICB2YXIgcG9pbnRlciA9IDA7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciBzZWVuQXQgPSBmYWxzZTtcbiAgICB2YXIgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICB2YXIgc2VlblBhc3N3b3JkVG9rZW4gPSBmYWxzZTtcbiAgICB2YXIgY29kZVBvaW50cywgY2hyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xuXG4gICAgaW5wdXQgPSAkdG9TdHJpbmcoaW5wdXQpO1xuXG4gICAgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgICB1cmwudXNlcm5hbWUgPSAnJztcbiAgICAgIHVybC5wYXNzd29yZCA9ICcnO1xuICAgICAgdXJsLmhvc3QgPSBudWxsO1xuICAgICAgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgdXJsLnBhdGggPSBbXTtcbiAgICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICAgICB1cmwuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgdXJsLmNhbm5vdEJlQUJhc2VVUkwgPSBmYWxzZTtcbiAgICAgIGlucHV0ID0gcmVwbGFjZSQyKGlucHV0LCBMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFLCAnJyk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSByZXBsYWNlJDIoaW5wdXQsIFRBQl9BTkRfTkVXX0xJTkUsICcnKTtcblxuICAgIGNvZGVQb2ludHMgPSBhcnJheUZyb20oaW5wdXQpO1xuXG4gICAgd2hpbGUgKHBvaW50ZXIgPD0gY29kZVBvaW50cy5sZW5ndGgpIHtcbiAgICAgIGNociA9IGNvZGVQb2ludHNbcG9pbnRlcl07XG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgU0NIRU1FX1NUQVJUOlxuICAgICAgICAgIGlmIChjaHIgJiYgZXhlYyQxKEFMUEhBLCBjaHIpKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gdG9Mb3dlckNhc2UoY2hyKTtcbiAgICAgICAgICAgIHN0YXRlID0gU0NIRU1FO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFNDSEVNRTpcbiAgICAgICAgICBpZiAoY2hyICYmIChleGVjJDEoQUxQSEFOVU1FUklDLCBjaHIpIHx8IGNociA9PSAnKycgfHwgY2hyID09ICctJyB8fCBjaHIgPT0gJy4nKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHRvTG93ZXJDYXNlKGNocik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJzonKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiAoXG4gICAgICAgICAgICAgICh1cmwuaXNTcGVjaWFsKCkgIT0gaGFzT3duKHNwZWNpYWxTY2hlbWVzLCBidWZmZXIpKSB8fFxuICAgICAgICAgICAgICAoYnVmZmVyID09ICdmaWxlJyAmJiAodXJsLmluY2x1ZGVzQ3JlZGVudGlhbHMoKSB8fCB1cmwucG9ydCAhPT0gbnVsbCkpIHx8XG4gICAgICAgICAgICAgICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAhdXJsLmhvc3QpXG4gICAgICAgICAgICApKSByZXR1cm47XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gYnVmZmVyO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiBzcGVjaWFsU2NoZW1lc1t1cmwuc2NoZW1lXSA9PSB1cmwucG9ydCkgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIGlmICh1cmwuc2NoZW1lID09ICdmaWxlJykge1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZJTEU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiBiYXNlICYmIGJhc2Uuc2NoZW1lID09IHVybC5zY2hlbWUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXJsLmlzU3BlY2lhbCgpKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcHVzaCQxKHVybC5wYXRoLCAnJyk7XG4gICAgICAgICAgICAgIHN0YXRlID0gQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgICAgICAgICAgcG9pbnRlciA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgTk9fU0NIRU1FOlxuICAgICAgICAgIGlmICghYmFzZSB8fCAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNociAhPSAnIycpKSByZXR1cm4gSU5WQUxJRF9TQ0hFTUU7XG4gICAgICAgICAgaWYgKGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUgPSBiYXNlLnNjaGVtZSA9PSAnZmlsZScgPyBGSUxFIDogUkVMQVRJVkU7XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTpcbiAgICAgICAgICBpZiAoY2hyID09ICcvJyAmJiBjb2RlUG9pbnRzW3BvaW50ZXIgKyAxXSA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gUkVMQVRJVkU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUEFUSF9PUl9BVVRIT1JJVFk6XG4gICAgICAgICAgaWYgKGNociA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFTEFUSVZFOlxuICAgICAgICAgIHVybC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICAgICAgICBpZiAoY2hyID09IEVPRikge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcvJyB8fCAoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFX1NMQVNIO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnBhdGgubGVuZ3RoLS07XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUkVMQVRJVkVfU0xBU0g6XG4gICAgICAgICAgaWYgKHVybC5pc1NwZWNpYWwoKSAmJiAoY2hyID09ICcvJyB8fCBjaHIgPT0gJ1xcXFwnKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUzpcbiAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgICAgICAgIGlmIChjaHIgIT0gJy8nIHx8IGNoYXJBdCQzKGJ1ZmZlciwgcG9pbnRlciArIDEpICE9ICcvJykgY29udGludWU7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XG4gICAgICAgICAgaWYgKGNociAhPSAnLycgJiYgY2hyICE9ICdcXFxcJykge1xuICAgICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQVVUSE9SSVRZOlxuICAgICAgICAgIGlmIChjaHIgPT0gJ0AnKSB7XG4gICAgICAgICAgICBpZiAoc2VlbkF0KSBidWZmZXIgPSAnJTQwJyArIGJ1ZmZlcjtcbiAgICAgICAgICAgIHNlZW5BdCA9IHRydWU7XG4gICAgICAgICAgICBidWZmZXJDb2RlUG9pbnRzID0gYXJyYXlGcm9tKGJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IGJ1ZmZlckNvZGVQb2ludHNbaV07XG4gICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT0gJzonICYmICFzZWVuUGFzc3dvcmRUb2tlbikge1xuICAgICAgICAgICAgICAgIHNlZW5QYXNzd29yZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgZW5jb2RlZENvZGVQb2ludHMgPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludCwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICAgICAgaWYgKHNlZW5QYXNzd29yZFRva2VuKSB1cmwucGFzc3dvcmQgKz0gZW5jb2RlZENvZGVQb2ludHM7XG4gICAgICAgICAgICAgIGVsc2UgdXJsLnVzZXJuYW1lICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChzZWVuQXQgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9BVVRIT1JJVFk7XG4gICAgICAgICAgICBwb2ludGVyIC09IGFycmF5RnJvbShidWZmZXIpLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gSE9TVDtcbiAgICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEhPU1Q6XG4gICAgICAgIGNhc2UgSE9TVE5BTUU6XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgdXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJzonICYmICFzZWVuQnJhY2tldCkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgICAgICAgIGZhaWx1cmUgPSB1cmwucGFyc2VIb3N0KGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUE9SVDtcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlID09IEhPU1ROQU1FKSByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgYnVmZmVyID09ICcnICYmICh1cmwuaW5jbHVkZXNDcmVkZW50aWFscygpIHx8IHVybC5wb3J0ICE9PSBudWxsKSkgcmV0dXJuO1xuICAgICAgICAgICAgZmFpbHVyZSA9IHVybC5wYXJzZUhvc3QoYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hyID09ICdbJykgc2VlbkJyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09ICddJykgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFBPUlQ6XG4gICAgICAgICAgaWYgKGV4ZWMkMShESUdJVCwgY2hyKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJyB8fFxuICAgICAgICAgICAgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSB8fFxuICAgICAgICAgICAgc3RhdGVPdmVycmlkZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciAhPSAnJykge1xuICAgICAgICAgICAgICB2YXIgcG9ydCA9IHBhcnNlSW50KGJ1ZmZlciwgMTApO1xuICAgICAgICAgICAgICBpZiAocG9ydCA+IDB4RkZGRikgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgICAgICAgdXJsLnBvcnQgPSAodXJsLmlzU3BlY2lhbCgpICYmIHBvcnQgPT09IHNwZWNpYWxTY2hlbWVzW3VybC5zY2hlbWVdKSA/IG51bGwgOiBwb3J0O1xuICAgICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEZJTEU6XG4gICAgICAgICAgdXJsLnNjaGVtZSA9ICdmaWxlJztcbiAgICAgICAgICBpZiAoY2hyID09ICcvJyB8fCBjaHIgPT0gJ1xcXFwnKSBzdGF0ZSA9IEZJTEVfU0xBU0g7XG4gICAgICAgICAgZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGlmIChjaHIgPT0gRU9GKSB7XG4gICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoam9pbihhcnJheVNsaWNlKGNvZGVQb2ludHMsIHBvaW50ZXIpLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgICAgdXJsLnNob3J0ZW5QYXRoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIEZJTEVfU0xBU0g6XG4gICAgICAgICAgaWYgKGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJykge1xuICAgICAgICAgICAgc3RhdGUgPSBGSUxFX0hPU1Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnICYmICFzdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyKGpvaW4oYXJyYXlTbGljZShjb2RlUG9pbnRzLCBwb2ludGVyKSwgJycpKSkge1xuICAgICAgICAgICAgaWYgKGlzV2luZG93c0RyaXZlTGV0dGVyKGJhc2UucGF0aFswXSwgdHJ1ZSkpIHB1c2gkMSh1cmwucGF0aCwgYmFzZS5wYXRoWzBdKTtcbiAgICAgICAgICAgIGVsc2UgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBjYXNlIEZJTEVfSE9TVDpcbiAgICAgICAgICBpZiAoY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8IGNociA9PSAnXFxcXCcgfHwgY2hyID09ICc/JyB8fCBjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlciA9PSAnJykge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmYWlsdXJlID0gdXJsLnBhcnNlSG9zdChidWZmZXIpO1xuICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XG4gICAgICAgICAgICAgIGlmICh1cmwuaG9zdCA9PSAnbG9jYWxob3N0JykgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICAgICAgICAgIH0gY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQQVRIX1NUQVJUOlxuICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGlmIChjaHIgIT0gJy8nICYmIGNociAhPSAnXFxcXCcpIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyICE9IEVPRikge1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgaWYgKGNociAhPSAnLycpIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQQVRIOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fFxuICAgICAgICAgICAgKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSB8fFxuICAgICAgICAgICAgKCFzdGF0ZU92ZXJyaWRlICYmIChjaHIgPT0gJz8nIHx8IGNociA9PSAnIycpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGlzRG91YmxlRG90KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgdXJsLnNob3J0ZW5QYXRoKCk7XG4gICAgICAgICAgICAgIGlmIChjaHIgIT0gJy8nICYmICEoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpKSB7XG4gICAgICAgICAgICAgICAgcHVzaCQxKHVybC5wYXRoLCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xuICAgICAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiAhKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSkge1xuICAgICAgICAgICAgICAgIHB1c2gkMSh1cmwucGF0aCwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5wYXRoLmxlbmd0aCAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybC5ob3N0KSB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNoYXJBdCQzKGJ1ZmZlciwgMCkgKyAnOic7IC8vIG5vcm1hbGl6ZSB3aW5kb3dzIGRyaXZlIGxldHRlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHB1c2gkMSh1cmwucGF0aCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmIChjaHIgPT0gRU9GIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJykpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHVybC5wYXRoLmxlbmd0aCA+IDEgJiYgdXJsLnBhdGhbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2hpZnQodXJsLnBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBwYXRoUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg6XG4gICAgICAgICAgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIHVybC5wYXRoWzBdICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUVVFUlk6XG4gICAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIGlmIChjaHIgPT0gXCInXCIgJiYgdXJsLmlzU3BlY2lhbCgpKSB1cmwucXVlcnkgKz0gJyUyNyc7XG4gICAgICAgICAgICBlbHNlIGlmIChjaHIgPT0gJyMnKSB1cmwucXVlcnkgKz0gJyUyMyc7XG4gICAgICAgICAgICBlbHNlIHVybC5xdWVyeSArPSBwZXJjZW50RW5jb2RlKGNociwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIEZSQUdNRU5UOlxuICAgICAgICAgIGlmIChjaHIgIT0gRU9GKSB1cmwuZnJhZ21lbnQgKz0gcGVyY2VudEVuY29kZShjaHIsIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBvaW50ZXIrKztcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaG9zdC1wYXJzaW5nXG4gIHBhcnNlSG9zdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHJlc3VsdCwgY29kZVBvaW50cywgaW5kZXg7XG4gICAgaWYgKGNoYXJBdCQzKGlucHV0LCAwKSA9PSAnWycpIHtcbiAgICAgIGlmIChjaGFyQXQkMyhpbnB1dCwgaW5wdXQubGVuZ3RoIC0gMSkgIT0gJ10nKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgcmVzdWx0ID0gcGFyc2VJUHY2KHN0cmluZ1NsaWNlJDMoaW5wdXQsIDEsIC0xKSk7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHRoaXMuaG9zdCA9IHJlc3VsdDtcbiAgICAvLyBvcGFxdWUgaG9zdFxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTcGVjaWFsKCkpIHtcbiAgICAgIGlmIChleGVjJDEoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVF9FWENMVURJTkdfUEVSQ0VOVCwgaW5wdXQpKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvZGVQb2ludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaW5kZXhdLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdCA9IHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSB0b0FTQ0lJKGlucHV0KTtcbiAgICAgIGlmIChleGVjJDEoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVCwgaW5wdXQpKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgcmVzdWx0ID0gcGFyc2VJUHY0KGlucHV0KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICB0aGlzLmhvc3QgPSByZXN1bHQ7XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2Nhbm5vdC1oYXZlLWEtdXNlcm5hbWUtcGFzc3dvcmQtcG9ydFxuICBjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaG9zdCB8fCB0aGlzLmNhbm5vdEJlQUJhc2VVUkwgfHwgdGhpcy5zY2hlbWUgPT0gJ2ZpbGUnO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2luY2x1ZGUtY3JlZGVudGlhbHNcbiAgaW5jbHVkZXNDcmVkZW50aWFsczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXJuYW1lICE9ICcnIHx8IHRoaXMucGFzc3dvcmQgIT0gJyc7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaXMtc3BlY2lhbFxuICBpc1NwZWNpYWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGFzT3duKHNwZWNpYWxTY2hlbWVzLCB0aGlzLnNjaGVtZSk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc2hvcnRlbi1hLXVybHMtcGF0aFxuICBzaG9ydGVuUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIHZhciBwYXRoU2l6ZSA9IHBhdGgubGVuZ3RoO1xuICAgIGlmIChwYXRoU2l6ZSAmJiAodGhpcy5zY2hlbWUgIT0gJ2ZpbGUnIHx8IHBhdGhTaXplICE9IDEgfHwgIWlzV2luZG93c0RyaXZlTGV0dGVyKHBhdGhbMF0sIHRydWUpKSkge1xuICAgICAgcGF0aC5sZW5ndGgtLTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtc2VyaWFsaXplclxuICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXJsID0gdGhpcztcbiAgICB2YXIgc2NoZW1lID0gdXJsLnNjaGVtZTtcbiAgICB2YXIgdXNlcm5hbWUgPSB1cmwudXNlcm5hbWU7XG4gICAgdmFyIHBhc3N3b3JkID0gdXJsLnBhc3N3b3JkO1xuICAgIHZhciBob3N0ID0gdXJsLmhvc3Q7XG4gICAgdmFyIHBvcnQgPSB1cmwucG9ydDtcbiAgICB2YXIgcGF0aCA9IHVybC5wYXRoO1xuICAgIHZhciBxdWVyeSA9IHVybC5xdWVyeTtcbiAgICB2YXIgZnJhZ21lbnQgPSB1cmwuZnJhZ21lbnQ7XG4gICAgdmFyIG91dHB1dCA9IHNjaGVtZSArICc6JztcbiAgICBpZiAoaG9zdCAhPT0gbnVsbCkge1xuICAgICAgb3V0cHV0ICs9ICcvLyc7XG4gICAgICBpZiAodXJsLmluY2x1ZGVzQ3JlZGVudGlhbHMoKSkge1xuICAgICAgICBvdXRwdXQgKz0gdXNlcm5hbWUgKyAocGFzc3dvcmQgPyAnOicgKyBwYXNzd29yZCA6ICcnKSArICdAJztcbiAgICAgIH1cbiAgICAgIG91dHB1dCArPSBzZXJpYWxpemVIb3N0KGhvc3QpO1xuICAgICAgaWYgKHBvcnQgIT09IG51bGwpIG91dHB1dCArPSAnOicgKyBwb3J0O1xuICAgIH0gZWxzZSBpZiAoc2NoZW1lID09ICdmaWxlJykgb3V0cHV0ICs9ICcvLyc7XG4gICAgb3V0cHV0ICs9IHVybC5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgam9pbihwYXRoLCAnLycpIDogJyc7XG4gICAgaWYgKHF1ZXJ5ICE9PSBudWxsKSBvdXRwdXQgKz0gJz8nICsgcXVlcnk7XG4gICAgaWYgKGZyYWdtZW50ICE9PSBudWxsKSBvdXRwdXQgKz0gJyMnICsgZnJhZ21lbnQ7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhyZWZcbiAgc2V0SHJlZjogZnVuY3Rpb24gKGhyZWYpIHtcbiAgICB2YXIgZmFpbHVyZSA9IHRoaXMucGFyc2UoaHJlZik7XG4gICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvciQxKGZhaWx1cmUpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zLnVwZGF0ZSgpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gIGdldE9yaWdpbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2hlbWUgPSB0aGlzLnNjaGVtZTtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICBpZiAoc2NoZW1lID09ICdibG9iJykgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgVVJMQ29uc3RydWN0b3Ioc2NoZW1lLnBhdGhbMF0pLm9yaWdpbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKHNjaGVtZSA9PSAnZmlsZScgfHwgIXRoaXMuaXNTcGVjaWFsKCkpIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHNjaGVtZSArICc6Ly8nICsgc2VyaWFsaXplSG9zdCh0aGlzLmhvc3QpICsgKHBvcnQgIT09IG51bGwgPyAnOicgKyBwb3J0IDogJycpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcHJvdG9jb2xcbiAgZ2V0UHJvdG9jb2w6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2hlbWUgKyAnOic7XG4gIH0sXG4gIHNldFByb3RvY29sOiBmdW5jdGlvbiAocHJvdG9jb2wpIHtcbiAgICB0aGlzLnBhcnNlKCR0b1N0cmluZyhwcm90b2NvbCkgKyAnOicsIFNDSEVNRV9TVEFSVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC11c2VybmFtZVxuICBnZXRVc2VybmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXJuYW1lO1xuICB9LFxuICBzZXRVc2VybmFtZTogZnVuY3Rpb24gKHVzZXJuYW1lKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oJHRvU3RyaW5nKHVzZXJuYW1lKSk7XG4gICAgaWYgKHRoaXMuY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KCkpIHJldHVybjtcbiAgICB0aGlzLnVzZXJuYW1lID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVzZXJuYW1lICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXNzd29yZFxuICBnZXRQYXNzd29yZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhc3N3b3JkO1xuICB9LFxuICBzZXRQYXNzd29yZDogZnVuY3Rpb24gKHBhc3N3b3JkKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oJHRvU3RyaW5nKHBhc3N3b3JkKSk7XG4gICAgaWYgKHRoaXMuY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KCkpIHJldHVybjtcbiAgICB0aGlzLnBhc3N3b3JkID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnBhc3N3b3JkICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0XG4gIGdldEhvc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnXG4gICAgICA6IHBvcnQgPT09IG51bGwgPyBzZXJpYWxpemVIb3N0KGhvc3QpXG4gICAgICA6IHNlcmlhbGl6ZUhvc3QoaG9zdCkgKyAnOicgKyBwb3J0O1xuICB9LFxuICBzZXRIb3N0OiBmdW5jdGlvbiAoaG9zdCkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhcnNlKGhvc3QsIEhPU1QpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdG5hbWVcbiAgZ2V0SG9zdG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnIDogc2VyaWFsaXplSG9zdChob3N0KTtcbiAgfSxcbiAgc2V0SG9zdG5hbWU6IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhcnNlKGhvc3RuYW1lLCBIT1NUTkFNRSk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wb3J0XG4gIGdldFBvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICByZXR1cm4gcG9ydCA9PT0gbnVsbCA/ICcnIDogJHRvU3RyaW5nKHBvcnQpO1xuICB9LFxuICBzZXRQb3J0OiBmdW5jdGlvbiAocG9ydCkge1xuICAgIGlmICh0aGlzLmNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCgpKSByZXR1cm47XG4gICAgcG9ydCA9ICR0b1N0cmluZyhwb3J0KTtcbiAgICBpZiAocG9ydCA9PSAnJykgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICBlbHNlIHRoaXMucGFyc2UocG9ydCwgUE9SVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXRobmFtZVxuICBnZXRQYXRobmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIHJldHVybiB0aGlzLmNhbm5vdEJlQUJhc2VVUkwgPyBwYXRoWzBdIDogcGF0aC5sZW5ndGggPyAnLycgKyBqb2luKHBhdGgsICcvJykgOiAnJztcbiAgfSxcbiAgc2V0UGF0aG5hbWU6IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhdGggPSBbXTtcbiAgICB0aGlzLnBhcnNlKHBhdGhuYW1lLCBQQVRIX1NUQVJUKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaFxuICBnZXRTZWFyY2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgIHJldHVybiBxdWVyeSA/ICc/JyArIHF1ZXJ5IDogJyc7XG4gIH0sXG4gIHNldFNlYXJjaDogZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgIHNlYXJjaCA9ICR0b1N0cmluZyhzZWFyY2gpO1xuICAgIGlmIChzZWFyY2ggPT0gJycpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJz8nID09IGNoYXJBdCQzKHNlYXJjaCwgMCkpIHNlYXJjaCA9IHN0cmluZ1NsaWNlJDMoc2VhcmNoLCAxKTtcbiAgICAgIHRoaXMucXVlcnkgPSAnJztcbiAgICAgIHRoaXMucGFyc2Uoc2VhcmNoLCBRVUVSWSk7XG4gICAgfVxuICAgIHRoaXMuc2VhcmNoUGFyYW1zLnVwZGF0ZSgpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNocGFyYW1zXG4gIGdldFNlYXJjaFBhcmFtczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlYXJjaFBhcmFtcy5mYWNhZGU7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1oYXNoXG4gIGdldEhhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuICAgIHJldHVybiBmcmFnbWVudCA/ICcjJyArIGZyYWdtZW50IDogJyc7XG4gIH0sXG4gIHNldEhhc2g6IGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgaGFzaCA9ICR0b1N0cmluZyhoYXNoKTtcbiAgICBpZiAoaGFzaCA9PSAnJykge1xuICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgnIycgPT0gY2hhckF0JDMoaGFzaCwgMCkpIGhhc2ggPSBzdHJpbmdTbGljZSQzKGhhc2gsIDEpO1xuICAgIHRoaXMuZnJhZ21lbnQgPSAnJztcbiAgICB0aGlzLnBhcnNlKGhhc2gsIEZSQUdNRU5UKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoUGFyYW1zLnNlcmlhbGl6ZSgpIHx8IG51bGw7XG4gIH1cbn07XG5cbi8vIGBVUkxgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1jbGFzc1xudmFyIFVSTENvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMKHVybCAvKiAsIGJhc2UgKi8pIHtcbiAgdmFyIHRoYXQgPSBhbkluc3RhbmNlKHRoaXMsIFVSTFByb3RvdHlwZSk7XG4gIHZhciBiYXNlID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSkgPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgc3RhdGUgPSBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIG5ldyBVUkxTdGF0ZSh1cmwsIGZhbHNlLCBiYXNlKSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgICB0aGF0LmhyZWYgPSBzdGF0ZS5zZXJpYWxpemUoKTtcbiAgICB0aGF0Lm9yaWdpbiA9IHN0YXRlLmdldE9yaWdpbigpO1xuICAgIHRoYXQucHJvdG9jb2wgPSBzdGF0ZS5nZXRQcm90b2NvbCgpO1xuICAgIHRoYXQudXNlcm5hbWUgPSBzdGF0ZS5nZXRVc2VybmFtZSgpO1xuICAgIHRoYXQucGFzc3dvcmQgPSBzdGF0ZS5nZXRQYXNzd29yZCgpO1xuICAgIHRoYXQuaG9zdCA9IHN0YXRlLmdldEhvc3QoKTtcbiAgICB0aGF0Lmhvc3RuYW1lID0gc3RhdGUuZ2V0SG9zdG5hbWUoKTtcbiAgICB0aGF0LnBvcnQgPSBzdGF0ZS5nZXRQb3J0KCk7XG4gICAgdGhhdC5wYXRobmFtZSA9IHN0YXRlLmdldFBhdGhuYW1lKCk7XG4gICAgdGhhdC5zZWFyY2ggPSBzdGF0ZS5nZXRTZWFyY2goKTtcbiAgICB0aGF0LnNlYXJjaFBhcmFtcyA9IHN0YXRlLmdldFNlYXJjaFBhcmFtcygpO1xuICAgIHRoYXQuaGFzaCA9IHN0YXRlLmdldEhhc2goKTtcbiAgfVxufTtcblxudmFyIFVSTFByb3RvdHlwZSA9IFVSTENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcylbZ2V0dGVyXSgpO1xuICAgIH0sXG4gICAgc2V0OiBzZXR0ZXIgJiYgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKVtzZXR0ZXJdKHZhbHVlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG59O1xuXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaHJlZmAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhyZWZcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hyZWYnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ3NlcmlhbGl6ZScsICdzZXRIcmVmJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5vcmlnaW5gIGdldHRlclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdvcmlnaW4nLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldE9yaWdpbicpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUucHJvdG9jb2xgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wcm90b2NvbFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAncHJvdG9jb2wnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFByb3RvY29sJywgJ3NldFByb3RvY29sJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS51c2VybmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXVzZXJuYW1lXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICd1c2VybmFtZScsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0VXNlcm5hbWUnLCAnc2V0VXNlcm5hbWUnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLnBhc3N3b3JkYCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGFzc3dvcmRcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ3Bhc3N3b3JkJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRQYXNzd29yZCcsICdzZXRQYXNzd29yZCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hvc3QnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhvc3QnLCAnc2V0SG9zdCcpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdG5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0bmFtZVxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnaG9zdG5hbWUnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhvc3RuYW1lJywgJ3NldEhvc3RuYW1lJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5wb3J0YCBhY2Nlc3NvcnMgcGFpclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcG9ydFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAncG9ydCcsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UG9ydCcsICdzZXRQb3J0JykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5wYXRobmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhdGhuYW1lXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdwYXRobmFtZScsIGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UGF0aG5hbWUnLCAnc2V0UGF0aG5hbWUnKSk7XG4gIC8vIGBVUkwucHJvdG90eXBlLnNlYXJjaGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaFxuICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVVJMUHJvdG90eXBlLCAnc2VhcmNoJywgYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRTZWFyY2gnLCAnc2V0U2VhcmNoJykpO1xuICAvLyBgVVJMLnByb3RvdHlwZS5zZWFyY2hQYXJhbXNgIGdldHRlclxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNocGFyYW1zXG4gIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxQcm90b3R5cGUsICdzZWFyY2hQYXJhbXMnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFNlYXJjaFBhcmFtcycpKTtcbiAgLy8gYFVSTC5wcm90b3R5cGUuaGFzaGAgYWNjZXNzb3JzIHBhaXJcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhhc2hcbiAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yKFVSTFByb3RvdHlwZSwgJ2hhc2gnLCBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldEhhc2gnLCAnc2V0SGFzaCcpKTtcbn1cblxuLy8gYFVSTC5wcm90b3R5cGUudG9KU09OYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cbmRlZmluZUJ1aWx0SW4kMShVUkxQcm90b3R5cGUsICd0b0pTT04nLCBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNlcmlhbGl6ZSgpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBgVVJMLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI1VSTC1zdHJpbmdpZmljYXRpb24tYmVoYXZpb3JcbmRlZmluZUJ1aWx0SW4kMShVUkxQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zZXJpYWxpemUoKTtcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuaWYgKE5hdGl2ZVVSTCkge1xuICB2YXIgbmF0aXZlQ3JlYXRlT2JqZWN0VVJMID0gTmF0aXZlVVJMLmNyZWF0ZU9iamVjdFVSTDtcbiAgdmFyIG5hdGl2ZVJldm9rZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5yZXZva2VPYmplY3RVUkw7XG4gIC8vIGBVUkwuY3JlYXRlT2JqZWN0VVJMYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9jcmVhdGVPYmplY3RVUkxcbiAgaWYgKG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCkgZGVmaW5lQnVpbHRJbiQxKFVSTENvbnN0cnVjdG9yLCAnY3JlYXRlT2JqZWN0VVJMJywgYmluZChuYXRpdmVDcmVhdGVPYmplY3RVUkwsIE5hdGl2ZVVSTCkpO1xuICAvLyBgVVJMLnJldm9rZU9iamVjdFVSTGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvcmV2b2tlT2JqZWN0VVJMXG4gIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpIGRlZmluZUJ1aWx0SW4kMShVUkxDb25zdHJ1Y3RvciwgJ3Jldm9rZU9iamVjdFVSTCcsIGJpbmQobmF0aXZlUmV2b2tlT2JqZWN0VVJMLCBOYXRpdmVVUkwpKTtcbn1cblxuc2V0VG9TdHJpbmdUYWcoVVJMQ29uc3RydWN0b3IsICdVUkwnKTtcblxuJCQxKHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiAhVVNFX05BVElWRV9VUkwsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIFVSTDogVVJMQ29uc3RydWN0b3Jcbn0pO1xuXG52YXIgZmFpbHMkNCA9IGZhaWxzJGs7XG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkbztcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDIgPSBnbG9iYWwkMy5SZWdFeHA7XG5cbnZhciBVTlNVUFBPUlRFRF9ZJDEgPSBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCQyKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbi8vIFVDIEJyb3dzZXIgYnVnXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTAwOFxudmFyIE1JU1NFRF9TVElDS1kgPSBVTlNVUFBPUlRFRF9ZJDEgfHwgZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhJFJlZ0V4cCQyKCdhJywgJ3knKS5zdGlja3k7XG59KTtcblxudmFyIEJST0tFTl9DQVJFVCA9IFVOU1VQUE9SVEVEX1kkMSB8fCBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzczNjg3XG4gIHZhciByZSA9ICRSZWdFeHAkMignXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9IG51bGw7XG59KTtcblxudmFyIHJlZ2V4cFN0aWNreUhlbHBlcnMgPSB7XG4gIEJST0tFTl9DQVJFVDogQlJPS0VOX0NBUkVULFxuICBNSVNTRURfU1RJQ0tZOiBNSVNTRURfU1RJQ0tZLFxuICBVTlNVUFBPUlRFRF9ZOiBVTlNVUFBPUlRFRF9ZJDFcbn07XG5cbnZhciBmYWlscyQzID0gZmFpbHMkaztcbnZhciBnbG9iYWwkMiA9IGdsb2JhbCRvO1xuXG4vLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJy4nLCAncycpIC0+IC8uL3MgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyICRSZWdFeHAkMSA9IGdsb2JhbCQyLlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsID0gZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMSgnLicsICdzJyk7XG4gIHJldHVybiAhKHJlLmRvdEFsbCAmJiByZS5leGVjKCdcXG4nKSAmJiByZS5mbGFncyA9PT0gJ3MnKTtcbn0pO1xuXG52YXIgZmFpbHMkMiA9IGZhaWxzJGs7XG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkbztcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcoPzxhPmIpJywgJ2cnKSAtPiAvKD88YT5iKS9nIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwID0gZ2xvYmFsJDEuUmVnRXhwO1xuXG52YXIgcmVnZXhwVW5zdXBwb3J0ZWROY2cgPSBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gJFJlZ0V4cCgnKD88YT5iKScsICdnJyk7XG4gIHJldHVybiByZS5leGVjKCdiJykuZ3JvdXBzLmEgIT09ICdiJyB8fFxuICAgICdiJy5yZXBsYWNlKHJlLCAnJDxhPmMnKSAhPT0gJ2JjJztcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tZW1wdHktY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJDEgPSB0b1N0cmluZyQ0O1xudmFyIHJlZ2V4cEZsYWdzID0gcmVnZXhwRmxhZ3MkMTtcbnZhciBzdGlja3lIZWxwZXJzID0gcmVnZXhwU3RpY2t5SGVscGVycztcbnZhciBzaGFyZWQgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGNyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5nZXQ7XG52YXIgVU5TVVBQT1JURURfRE9UX0FMTCA9IHJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsO1xudmFyIFVOU1VQUE9SVEVEX05DRyA9IHJlZ2V4cFVuc3VwcG9ydGVkTmNnO1xuXG52YXIgbmF0aXZlUmVwbGFjZSA9IHNoYXJlZCgnbmF0aXZlLXN0cmluZy1yZXBsYWNlJywgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcbnZhciBjaGFyQXQkMiA9IHVuY3VycnlUaGlzJDMoJycuY2hhckF0KTtcbnZhciBpbmRleE9mID0gdW5jdXJyeVRoaXMkMygnJy5pbmRleE9mKTtcbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyQzKCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlJDIgPSB1bmN1cnJ5VGhpcyQzKCcnLnNsaWNlKTtcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgY2FsbCQyKG5hdGl2ZUV4ZWMsIHJlMSwgJ2EnKTtcbiAgY2FsbCQyKG5hdGl2ZUV4ZWMsIHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZID0gc3RpY2t5SGVscGVycy5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kgfHwgVU5TVVBQT1JURURfRE9UX0FMTCB8fCBVTlNVUFBPUlRFRF9OQ0c7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyaW5nKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHJlKTtcbiAgICB2YXIgc3RyID0gdG9TdHJpbmckMShzdHJpbmcpO1xuICAgIHZhciByYXcgPSBzdGF0ZS5yYXc7XG4gICAgdmFyIHJlc3VsdCwgcmVDb3B5LCBsYXN0SW5kZXgsIG1hdGNoLCBpLCBvYmplY3QsIGdyb3VwO1xuXG4gICAgaWYgKHJhdykge1xuICAgICAgcmF3Lmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIHJlc3VsdCA9IGNhbGwkMihwYXRjaGVkRXhlYywgcmF3LCBzdHIpO1xuICAgICAgcmUubGFzdEluZGV4ID0gcmF3Lmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHN0YXRlLmdyb3VwcztcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gY2FsbCQyKHJlZ2V4cEZsYWdzLCByZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IHJlcGxhY2UkMShmbGFncywgJ3knLCAnJyk7XG4gICAgICBpZiAoaW5kZXhPZihmbGFncywgJ2cnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgICAgfVxuXG4gICAgICBzdHJDb3B5ID0gc3RyaW5nU2xpY2UkMihzdHIsIHJlLmxhc3RJbmRleCk7XG4gICAgICAvLyBTdXBwb3J0IGFuY2hvcmVkIHN0aWNreSBiZWhhdmlvci5cbiAgICAgIGlmIChyZS5sYXN0SW5kZXggPiAwICYmICghcmUubXVsdGlsaW5lIHx8IHJlLm11bHRpbGluZSAmJiBjaGFyQXQkMihzdHIsIHJlLmxhc3RJbmRleCAtIDEpICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBjYWxsJDIobmF0aXZlRXhlYywgc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gc3RyaW5nU2xpY2UkMihtYXRjaC5pbnB1dCwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gc3RyaW5nU2xpY2UkMihtYXRjaFswXSwgY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBjYWxsJDIobmF0aXZlUmVwbGFjZSwgbWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG52YXIgcmVnZXhwRXhlYyQyID0gcGF0Y2hlZEV4ZWM7XG5cbnZhciAkID0gX2V4cG9ydDtcbnZhciBleGVjID0gcmVnZXhwRXhlYyQyO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5leGVjYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS5leGVjXG4kKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMgfSwge1xuICBleGVjOiBleGVjXG59KTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJGE7XG52YXIgcmVnZXhwRXhlYyQxID0gcmVnZXhwRXhlYyQyO1xudmFyIGZhaWxzJDEgPSBmYWlscyRrO1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDU7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sJDEoJ3NwZWNpZXMnKTtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgZml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBGT1JDRUQsIFNIQU0pIHtcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbCQxKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgICAgcmUuZmxhZ3MgPSAnJztcbiAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcbiAgICB9XG5cbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIEZPUkNFRFxuICApIHtcbiAgICB2YXIgdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kID0gdW5jdXJyeVRoaXMkMigvLi9bU1lNQk9MXSk7XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMkMihuYXRpdmVNZXRob2QpO1xuICAgICAgdmFyICRleGVjID0gcmVnZXhwLmV4ZWM7XG4gICAgICBpZiAoJGV4ZWMgPT09IHJlZ2V4cEV4ZWMkMSB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlLmV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW4oU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICBkZWZpbmVCdWlsdEluKFJlZ0V4cFByb3RvdHlwZSwgU1lNQk9MLCBtZXRob2RzWzFdKTtcbiAgfVxuXG4gIGlmIChTSEFNKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwUHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuXG52YXIgY2hhckF0JDEgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4JDEgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQkMShTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQ1O1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzJDEoJycuY2hhckF0KTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMkMSgnJy5yZXBsYWNlKTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkMSgnJy5zbGljZSk7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGR7MSwyfXw8W14+XSo+KS9nO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEID0gL1xcJChbJCYnYF18XFxkezEsMn0pL2c7XG5cbi8vIGBHZXRTdWJzdGl0dXRpb25gIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbnZhciBnZXRTdWJzdGl0dXRpb24kMSA9IGZ1bmN0aW9uIChtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICB2YXIgY2FwdHVyZTtcbiAgICBzd2l0Y2ggKGNoYXJBdChjaCwgMCkpIHtcbiAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHJpbmdTbGljZSQxKHN0ciwgMCwgcG9zaXRpb24pO1xuICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0cmluZ1NsaWNlJDEoc3RyLCB0YWlsUG9zKTtcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tzdHJpbmdTbGljZSQxKGNoLCAxLCAtMSldO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoYXJBdChjaCwgMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaGFyQXQoY2gsIDEpO1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICB9KTtcbn07XG5cbnZhciBjYWxsJDEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMSA9IGFuT2JqZWN0JGc7XG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YgPSBjbGFzc29mUmF3JDE7XG52YXIgcmVnZXhwRXhlYyA9IHJlZ2V4cEV4ZWMkMjtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xudmFyIHJlZ2V4cEV4ZWNBYnN0cmFjdCA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAoaXNDYWxsYWJsZSQxKGV4ZWMpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhbGwkMShleGVjLCBSLCBTKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBhbk9iamVjdCQxKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSA9PT0gJ1JlZ0V4cCcpIHJldHVybiBjYWxsJDEocmVnZXhwRXhlYywgUiwgUyk7XG4gIHRocm93ICRUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbn07XG5cbnZhciBhcHBseSA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgY2FsbCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYztcbnZhciBmYWlscyA9IGZhaWxzJGs7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRnO1xudmFyIGlzQ2FsbGFibGUgPSBpc0NhbGxhYmxlJG47XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDI7XG52YXIgdG9TdHJpbmcgPSB0b1N0cmluZyQ0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQ7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4JDE7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDQ7XG52YXIgZ2V0U3Vic3RpdHV0aW9uID0gZ2V0U3Vic3RpdHV0aW9uJDE7XG52YXIgcmVnRXhwRXhlYyA9IHJlZ2V4cEV4ZWNBYnN0cmFjdDtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkaTtcblxudmFyIFJFUExBQ0UgPSB3ZWxsS25vd25TeW1ib2woJ3JlcGxhY2UnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMoJycuaW5kZXhPZik7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gSUUgPD0gMTEgcmVwbGFjZXMgJDAgd2l0aCB0aGUgd2hvbGUgbWF0Y2gsIGFzIGlmIGl0IHdhcyAkJlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjAyNDY2Ni9nZXR0aW5nLWllLXRvLXJlcGxhY2UtYS1yZWdleC13aXRoLXRoZS1saXRlcmFsLXN0cmluZy0wXG52YXIgUkVQTEFDRV9LRUVQU18kMCA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvcHJlZmVyLWVzY2FwZS1yZXBsYWNlbWVudC1kb2xsYXItY2hhciAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gJ2EnLnJlcGxhY2UoLy4vLCAnJDAnKSA9PT0gJyQwJztcbn0pKCk7XG5cbi8vIFNhZmFyaSA8PSAxMy4wLjMoPykgc3Vic3RpdHV0ZXMgbnRoIGNhcHR1cmUgd2hlcmUgbj5tIHdpdGggYW4gZW1wdHkgc3RyaW5nXG52YXIgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoLy4vW1JFUExBQ0VdKSB7XG4gICAgcmV0dXJuIC8uL1tSRVBMQUNFXSgnYScsICckMCcpID09PSAnJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSgpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tdXNlbGVzcy1kb2xsYXItcmVwbGFjZW1lbnRzIC0tIGZhbHNlIHBvc2l0aXZlXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygncmVwbGFjZScsIGZ1bmN0aW9uIChfLCBuYXRpdmVSZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIFVOU0FGRV9TVUJTVElUVVRFID0gUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPyAnJCcgOiAnJDAnO1xuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGdldE1ldGhvZChzZWFyY2hWYWx1ZSwgUkVQTEFDRSk7XG4gICAgICByZXR1cm4gcmVwbGFjZXJcbiAgICAgICAgPyBjYWxsKHJlcGxhY2VyLCBzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IGNhbGwobmF0aXZlUmVwbGFjZSwgdG9TdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChzdHJpbmcsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PSAnc3RyaW5nJyAmJlxuICAgICAgICBzdHJpbmdJbmRleE9mKHJlcGxhY2VWYWx1ZSwgVU5TQUZFX1NVQlNUSVRVVEUpID09PSAtMSAmJlxuICAgICAgICBzdHJpbmdJbmRleE9mKHJlcGxhY2VWYWx1ZSwgJyQ8JykgPT09IC0xXG4gICAgICApIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVSZXBsYWNlLCByeCwgUywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSBpc0NhbGxhYmxlKHJlcGxhY2VWYWx1ZSk7XG4gICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSB0b1N0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcHVzaChyZXN1bHRzLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIG1hdGNoU3RyID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gdG9TdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXJPckluZmluaXR5KHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHB1c2goY2FwdHVyZXMsIG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IGNvbmNhdChbbWF0Y2hlZF0sIGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcHVzaChyZXBsYWNlckFyZ3MsIG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHRvU3RyaW5nKGFwcGx5KHJlcGxhY2VWYWx1ZSwgdW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IHN0cmluZ1NsaWNlKFMsIG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgc3RyaW5nU2xpY2UoUywgbmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG59LCAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgfHwgIVJFUExBQ0VfS0VFUFNfJDAgfHwgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIgaWNvbiA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVN3QUFBRXNDQU1BQUFCT28zNUhBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQUZ6VWtkQ0FLN09IT2tBQUFEOFVFeFVSVWR3VEd4NXJwTE84WU9ZeDFPZzBseTI5WDVlelI0bVQwdGlqaTRlV0o5NTNLR24xSnhzN3FCOXh2ZkQvVXMwZ2R1dTh5ZWg0SE9xNzRkRDY0N1I5MTI1NmVTeitqODJjYnZnL2RTai9MdUw3OVdwNnpDZjI0S045eEFOR1JBTkY1OWQvMFcrL3RhYS84aU4vM0hMOXVPbi96NjM4QmlsN2wzRzg0VFArRkhCOG81QS8waTkvWmpVKzQ3Uyt2cTgvNFF5L1M2dzhPK3gvNVJwL3d5ZzdHMlQvcytUL3ZPMi8rcXQvMXFwL3FEVi9IeUQva2k0KzRSNy9xblkvdHloLzFHeC9wdFUvNzZFLzJiSjlMZDgvNHQwL3B4ZStYdk45aU9xN3JCMC8waTg4YVJrLzZwcy96KysvbmFML21hYi9tR2gvcFZNL3d1YjVtR2QrZkFFT2hFQUFBQWdkRkpPVXdCRXlXS0E0N0VLSmhuRmx1R0E2bDNINjdEdTZjcmROT1hzNXEvSTY1cmNRYmZCOUFBQUlBQkpSRUZVZU5yc25FOXI0em9YeGlkT0c5dE5RcUJ2U3JMS2VLR0Y3V0l6NEowV2dTQ3VEYzFzN3ZmL01xLytTMGQycDdaa2Q3aTBTc1pKaDN0aCtQR2NSNCtPcFA3NDhUMys0eU5PRG9mREtZMi9TWXhnZGJoY2ZsNHVsOU0zclk5WnBaZWZiRnd1NlRlTUQ4ZEp3UHA1U2I2bDllRklMNXpXNVREb1dyRWMzNXdFanRPRkRXUHhqRTJhSk1rcVdhM1c2L1dldnVpZ1B5VkordFduZ1RnK0hRNThQbVNEUWxxdnQ1RWF4K2pJQnYyVVk3dW15TDZ1MEppTUJLNkRwRVRwNEtxbUwvbmdYOWhud2NFSllsOFRHSVYxRXB6T0VhTlVDVUJxRlB3UGZSWDBXOEdmRlNQR2dYMjU1SkNjVHB3VUJ5VlkxV0FVL0ZId0x4UldWM1JkSVlHdHZoSXZLcW9WSTBXcml3b0dLMUNEdkxpOEpEb3VzZTVMOFlxVDA4TTJPcCt2VkZPWWw1NHdKKzVQa3Bwa0pVa0paWWxpcE45UlYxTmU2OVVYbUNPVDB6WTZYcSs0S2lwN0dFWUdtS1pWeU5GMWdoajl3aHgvL1pmbHRYUVlURS9iOHhuVFVlRnIxUjgyTG03dnd1UGg2Q2d6OWpyK1RWeDhNdCt6Y1RndDB3NklrMzEweElKVkpYeGRVYXFnc0l6SDF3NnRqbGVreHJWZHBYL0ZTbGI3elc2M2ErbHJ0M3Zhekc4SkZpcUhWYTJld09RTGxSNzBXMW9YNThYbGhTaXY3YWVyS3o0eFV2ZDdSc2U5cFdPMzJ4eG0vVmZFNlRvNjR5dDFLeUVzZ1V0OGNrVDk5R0RzSFVwTDZvcTlFYUtUNCtjV1k1d2VOcnZmYlp0bE53cUxma3BjTTBvOFh0Rk1oWmxSVVQ3WVlETEtFdG1oc3VyUUpOTzZSMHNFTDBicmszRlJXZTMreWRwTUR2Ymx6cER0bnZZei9TUGloSVlGekhSRllZRTZ4TWF6Qm5KV1lUeXJoc3JpNHVxRWZTRVNQWCtXZGNXbnphN05iamVtS3lZcFZvYi9NbDVadTl2UDBjbU1FMWFCeFpYRHVTcGRLV1NHbEswcXhVcXRlU3hVcGhBN2hMb09zZWRuV1ZlOFlpVjR5MzR6VFlrWDlhNGJoWGVqdGJnSnA4VlFjVm1KdURBNEd5cDdkMks4VEZuMW9HbkpXYkVqcU81eXduTEU1K2lLOG1HeUVuYkZsTVYwZFdPMUdFeUxtaFdkQTFrS3JkaVRHN3kyZHVQdnNzM1FXeDFxVkxWTFN4WmlKd1JXZE9RVHhKWHNkOXFyR0t2TUhzem5uNEpvY2JOaWM2QjVLV1c1d2xMTUJtYkRlc2pjT3pONEtaTGowdUtLRDd0V2NzbGNWSUpnaUxiaTFmYXNTWWszcDJXVUpUc09kc3FxSEdWQnc5STVxN0JRY1ZwMFhseFlYS2ROYTRUbHFrcDgvdU5OaTBVcnp1cHFhd3NMZDhjWXFxb1hTa0hPcXUwRUQ1U0YxQXNoUW8xK3RSeXRlTStGMVJoR2pYeTBvaXdaTFU5dHhXd2RLRWhwVEtJSWpXdjFwRFVRSEdwWFc2NnVVR2ZUV2k4V0lrNVBkNkFvNVZxTk5EQ0dxNzE3MFdJeDlJcUZxcTRpdVhOVVZ5V3I5NVJWRGVZc1NLcXdQRXZTa3JnUUxjWEZoSFcvU1R6OFQydXF6OURLZkh3clBWaXNNUC9HU1YwdFpka3h2cTZxZ2Y2Znp1KzFoUXNvQyttd1JRZC9QaTVrWE9ubXQrSmg1M2ZING1rRzIyMG0vZ09TaDBncHl1QlNWVmhodU54UnNiUmZoKzVzQ0gxTENxcGp2TmczOWtIWXJMaUljZkVxWkh3YWg1RHpNOHRiazJnbGJCYkVWZ0hLcVZBTk14VmlKenZBcFdGZDl3T1djbmc5RlNySFF0THBhVUpkZ0ZhOGV1cUhoZUV4emVXcHRSdXpNZ3F6Z3BhTzhiQ2xWVlh1aG9YU1ZUMGtMQ0V0d1VvK21HMmh4d1ZveGV0ZE5oWVcwOVlrWFVGUTNMSU1KMU9KR1BKeUZvaXFWVnJENks2VnBTZENwUzB4bHFqRWREOGExaFJhOGZZczhEaXVCVXJScFNXRjFlLytEYlN6ckNxMFlwYWFEanYybUo5V3V0bGw5dzh4TldLR3BMVDI0MmdsMGZuREVzUkR5bEtrcW9GMlZ1MjRGb3hZY3NHanlwRFFFYTNucFJWdlJsbFd3OE1YWFdHUHBKVkUwYlh2V0NhZDJzTENmYzl5WmtTb3FrSTNzdXlsam5RcnJpbU9pK1E1bXBsV3VobnA3ektxVW0ybG82d1FscUdxUXlnc3RlREJvQUZmdVdzZHAxT3F1dSs4MmRCWnlvS3VSZGhyM2txa3NNYlNvdjhkamE4anRaVnNveUZseWU2RHJTd3RMVnhieWRRQTA1aHFXMXFPWjFtclExR0VOR3l4eDd5MEtLemJPRmdOejZhalhUNXhvZ08rMmowSDRGbTJ0TnhlcVpYZ0I1U0YzSlFGQm5XdGVmUFcyREpzVkxSdlI5S0trNEdncFYxTFNRdjBIakRjd2g4Q3BUZkNRSFBHV0phbXBGMSt6cncxMnJQRWxEZ2hRWEJhMlBWM0xGYzlsckl3YkN0YnMyRXhCTXpPbzlaRXFDdFFVcExGbU9mSDU5bFcxZW1ZQU4rMnJiMXNuRURySFdtNTZRRTd1QVptUTFpSW5iM1FrYVRFZ3doZ2lJZ1BOQ2V0ZE54cXB6VW1uNGtleEZoYXVPZGJZRFZ0ZHdBcjl6emI4SmFoeXFTd0NqdGtTNHZ3d1gvSzgyZzdUMzhybnFnczlSZjMwUzUveFg5UWxoTzFhdk55bGRWemVLZWpiS3BRU29zSTQ2SmhpK1J6eGExMDlEb2FqRnMybnRZZnBOV2JFSHN0bXJvZnNtUVpGckQ1RGsyTENKTm5wa1dCb1hsTVBoNEpxNEVORzU2M3ZMVFZDMXFnRHV0K0Y3NS81QWlVSWZSMzZlcjZXeTRVUnJwNWJDc1pCYXZwYjJmY1J2YTMrdHFDTWI3Q1RnK3c2cDhxZmI4TWtlYmxtcGF3ZU9aYmxGbDVuS1BSSEh1VzRmaitGc2hiZUlnWFBQQlFnU05hOGl3cG5BanRJalR1VG9CcHlhVzBHdlBZRmxYV1BZVFdoRG5STkpjeDFyczh5ckMwWmZXT080Q0dBNWdMa1cxWnJKMnNrQWxCV1FQbDVDWGN0cGl5ZkdHMTJjaVZ6MGxXSWpaTGE2T3N5ajNYVnRmdkc1WW1WVmlHWmExMXBHVVJFVXBGZXBEU0lqUFlscWV5R3RYZm1wSzNzTlVBdEdqMVRtbkIzcCs3YVdpT04xalcza2xKNlRvRXdxS29hTnA2aVA4S3JFYTUvZGk4ZGJMblJOeHJsMVoyMUpMTFJKZ2QzTU16cnJ1cjdFNlFlUUJZcENSUk1rUE84aXREdGJjNHRtTnpCZ1p2dzNLYjhBTTdQRUpibWhYWU1FU2dqMFYweURJMW1ITnBsY2RnYWZrYlBLZkY5aFBIbkEwY1dQbUFyR1YxYWNDSnR0NStZUUg5eW5Zc2d2UzZFRGxsU0duUktCL3M4UUVHYjNZeHhzNkpnNVlGdHl5QXJBcG5iU2pQZFBjU0tRTEtVZ2J2ZUZZZTd2RkIwV0ZLZjZ1M2tZaEI5d0gybGpVckZVcnJvZTFDSTZxT0dHRVJoRkNmRS84SWxWYVlzcVowYk5US0IyT1ZJckJUaWZKeTRjQVIzSGNXT2hLWUcwZDdNK0ZjMHZKVGxsZC9DODZKSUdycEpRL29sYXFMVFhWdG9TcXNSR3BXT1RDNW0zREZLVEZRM0xWQ2M3eVhzdHArZjJ2VW5vL0pXMDQzWHNiU3VocTRrREowN2hadXJNSkFPbUJYaWxvWkppM2ZCTi9Db3lOc1B6R2RzUEt4WVptenk4S3ZzSzVGOVdVb2swTFhJcUNmYkNKRHJsamxZcFJoMGtyRHl0QmFKMDdSbHVOYThKajNVVjBpZjViM3B1MkRwSTZ5WU1BeWpRWXJNaEQ5Q3BWV0hCd2RWSC9yOXhSYUlNVGJUUm9CYXI5YUpXS3MrSDFYU3F4bjhKcFZKMmREaVFyQktFcUFzZ0tsRmJhUWhubHJkQ1Zld1RhK1ZoYS9YODkraVVNTS80OUVBQ3NLYy9JZHdmTU5CTFJJa1d0WXVmYjVJR2t4WmJFN0F0TVhoOW5BZWZudDZQMUVyTmZWOGlZUHhtZDJRZUtkUzN0eHNscFRYUEplVTFjZzVQUm5VSy8rQkI5TFZETklpKzBidHUyZjNHZzB2WkZuYkhRUG9tSzNVMFFncmE3bmoyNklzOXMveHlPbFV4UkRaOWQwS0xYamxlYWxQQ3NuUWRKSytDWnJtODB3MmltVktMcUIvSG9LVjlXN29vSzRva0oxc3hDTVdVUWxkMlFiRnZBcnVwYm1yWnBWZ0xMK3h5NkRaZmR3VXF6TE5TMXZpV1hPOVJwdGsxRTdlMXhkdEFhVmJTSFUyNm9Bd1QwM1ppV1psYlFPL1pzUEZOYnJMYnNOSDdxZDBnelU1N2ZTOFZtZVg5U2tGVGora0grU2JLTmFuR0NUSjdFNjN2Z2pDRVlzb3VaQlJZbTdPelA0a0w0V2hmWHI5WFliM0grZVBqZmVzbVlDTGQ2SnYwNjhiTVBFcFkvTzJDZG0xRTQwc3FyUXJVVE95OS9pR1N4RnF3bGdwYzl2TlU5aks1SGRBSjRrSzNXKyt2a0l0K3c3cXptSyt2MEdDMVFlbGg0NHJGLy8zdVRONkNiTXVXNmo4OWFQbEhkc3p0SDB5N3JzQXJHcXhNNXErQkYzQlczbEswV0xMUkQ5TFY3QW90cTZaekp2TmI3UndmUzNSczJKbEJhTm1sN1hScEx0OFVpb3JBcHd5a2pIaHR3T0M0WlVLVC9LUjk4NmxMQW9yWUVyZEY3cjYzYTB0dGJlZHdPcGNSSFNkWENYQXNZRzFmSWpEaS8yOEsxREJZdlRhbHZ2NE9EMHQwWnBLL2IvSlJ1TWxyTUpUZHc4Q3JPN3BhejhKUlNXMEZaSXg5VGE4aG1wclpCdUNhV1Z5LzFDR0xHc3VLNTRsY0xkcGJKeTd6bzBzTGh2WmQ3N1lnMDROSEpmbnRZMk1nMWxnbnJ0UHVEclNsb1MxK056R2dwTEpvaDdnTEltOTdkQ0d1TGJJNEU3OW82L1c3aElxVm1WdEF4OTY5Q0cxVStuUG5PaXpCQy9GNmUxaXRSMkRobFk1cGp1cU8xWlVsb3ZxM0JZZ2xicjVmT05YMzhycENXK2p1ejlIT1Qwc0d6TEtxVnhsZUx0YTFvUUZ2ZXRXM1p2NStsQmJCZitIUXZVdHVTQm9qL1ZvUEg0VXFBcWMrSm5XZzRzT1NlMlFjdEVmZEJtd3YxRVA5dUtPblVlQzJncUgvWXJTWW85L0pLV0M0dlR1czBnckFucE5MQVFZY0p5bHM5bGJtSkRLUTJlUGw3bWdSV1V0NXlZMml4Tkszays4Z1BKVHNDeWRTVlFLVXhTV1crUFhodjVmVmdpYjRWMkE2ZjF0L3lsZFJ3TURVNVRSdkF5MGFFczBjTk1zR2JwYjhsZm50RTB5OUpLb2lNNzZPNElLN2VET3pBc2h1cU5LZXNoblFtV1M2djF0cTN4OXhQOVhZdllzS3lPZThuZW1wWXNRRVhNeitGRjgyK1lWdHVHMnRadGNkK2l5WlJZVzZudktjdFFrdU1sbVV0WnByL1ZodnNXcGJWZGpsYTZQWlpjV1E0cUtDcmJzZGg0SzcweXZGYlc2OENjNk4reVVibTBiVGl0NWJRVnI2Sjh1TjBPRE10VzFodWZEbjB5UE52ZCtUV3NMZjlFcWhZKzdMTloyT1dUbDM3LzJPN0o2TGhnQVhzTGdjVnh2YzZZdDh6dlNXS0x4bVpKV3VuenNYUnhsZHphUzl1dGNoc1Zlejk0Syt2MTErdXdid1ZLcTJrRnJIWTVXalJxbFdZamg2akZvRnc4QTFCdkZxdkg1eUJsRFduTHQyVWo5cWNiUnF2aHltcitUOXZadFRhT1pHRzRtNTFPM00zQXNET0VnYUVEWGhqc3hyNkpjWHhoM0FLTEhRbkZEazY4L3YvL1phdk9WNTFUVmZLSHBKUmt4VWw2THViaE9XK2RLdGxPOVZHMGZHaEZyYWpzeGlpaGZxaThnclBMVXBwaHRiaFY5bGhINHdkTjRmakEzUHI4OFBjUHZjYWhYUVpkZ1JvVnNlclVhSEVaaWx1R0dkNVA3QkQwVHFleUZxMTh4bjhZcmRIdmY0Zm1YV0pkMW9OUmc3V2o4ejhQM1dBOXpjbXNsdHdxTzlKeWJRTWRPRDZvRXUvL2xYUlkwWDZNVElFRUNpNGRZYzBGMUR6ZlFkeTh2K1VKNGJuVTQvRkRhRUdubFpnbHBIN3NvZzZMYUhXR1Jiam11WmlIL2EzNkpxZkdKYkdLWURtM1B1SkRNU0hoQ2RSL2JSZjZROVhlenVUN3JwZFo4L1pLN0hESGd1dFBUb0wxN1FOb3VlVWh2eGc1dEEyemREbTRJMmE3Zm1YSWF1VjUzWFkvc1E1MWFNV3EzT0hkdXY4UVdET0pMSVhxaDQ3MDNVeWZ1eTZMUXpJTGVjM1QrVEI3UDdFK3F4YVFxbU9yaU5jSDBCbzl5RXZWZUI2Y21iVGF4Y0IySFZmU2JCWUF3MkpNN2JweWZ3dUxjSW1KdFJ3bmlRV1g2dHZRdEQ0L1NOZE9HNk42Y2FQN2RqbmMrUEo1Z014cTcwNnZ1Wis0WkxlWVZTU1dnelc0Vzg2c3pLNk1YVGRyV2p0NGRIazduWmcxbjgvVnRCaFhJK3h2amMvdWJ5M0pxbVdtYVNDeE1MYUdkb3RnaGJVZzM1VUlNczB3MXluZWQyaldmZWZNMHAzcHZHVVA0cUpad291Y0d1c0NKRnArZkJ2MGsvaEdEei8wWXREczhkbmVLcUNhREdLV1pOZFQ0dGJsanJUV2RiaE1wa0ptVlQzK09pUXRCMnVtN2puYnhZMHFRSjFZUGN5YWkxeTZpOGoyVy90MnFaWVJxWEVvdnpwWVZRM3VGcG8xaTdZWlF2MzU4NmNwUVc5V2w5Mi9YR2FaNkRLNWRiNC9MVG15SXJHcWNId0VMYzRzbStuY0pFU1Vob0wxRkJxdXJGcFA2dDBGN1F2Q2pGZHdGbHFzUVduNU1reFd6cnRNdHlDZ0p1NHloRm1tNDVvbmJwWG5iMUVzV3hvc2ExV0J0SWFhRXdGV3ZCWlVDNXVJRmRMcUR1c1lWYUVxUXVzWHZWNytUT2ZPaytCWU5lMitYWWk4OG1Pb2xJZUFUMi9naEVsd05yT29lcG5sV1Izbjg0eGhtUTZpOWZWYjNGMk4wNjRka1NtekNqOGVCM0pyOUNETmxlN1dkN3N3RDA1MlA5R25jQm1vRE1QTStEVFAzL05KdG13OG9uS1ptd2k1Rncya2lvcU9vaGlHbG9jRmJ1MVV0eERTUFZTZU9YcVU0VEZITEp2MTRGWU43eFZlMmkwc3RjaXhhYlhVTlZpd1dKVjNhNGhLRkxObWloZFR3aWZDS0R6cFVZWkhDMHphaHl3dGlLMTlWSURwUk1pTnU4MHJKWmFqOWZzQXRCaldUalVNTzkydWE3WHc3Qm53U09xWW1wVnUyK0E2TWJ6Ymx4djNmSWRseTdDQU1neGppQTRDWWFtSmI1Wk1mZ0dWWEwvODBzTXNWcXRsWm16dElKWnhneFVDcTlMclFjMEtjRzM4dVJtZ0VvMVp5cWJKMmFNN0xNYVZacGZzM2N5enRQQ3RGUm12S3U1SWJicUhDZ1JhZzFRaXdGSlRuMkdsbWFuSTZtK1crSFdNYUNWdUhabFczZGE1aTFUV3JGQ0RIdFZtc3htQWxvTWxRVFdUWFFXS3Awa1VWU0hnZitrZDhNZnNuSmoyWEVmY0NvVHcya3RvUmZ2dFVlTWVFcXNpcTF3WkFxMStmNnVLek9KZFBWMkNreFNTNTljUFZub2tYVmZjY2RXditIbVMvaVZZKzJYWXc0cTJSVFdxUW9lN3c3UVpoaGFZdFRQclpRM0pjdUpISDFoSC83RGhkY3hGbDR3Ny81ZEphOXBwMk9kV2c4czQyeXVOaXNYeW95Y3RiMWF5VXRaSkJYQW1oSXRwZFlTRmxFSXRKbEgveEl2cm9OY2ZkMy8rZGtldnZ2S3ZXRXYzUmRNYU5EMERtTVcwTnIxb2ViTnlMZFhFcm5DaTBSa1dEN2FMV0oxeDY0L2Z2bjc5ZklkLzdIWlppMWUxd2hSdDkxRllWUm16ZXJwRlpYaTJYNWpJVjhiV0RWWjlMQVdVa01vMUV0SjFBYXo3VC9mT3JWZXZWVDNXVnNVYjdySnlqa2l4V1FkMzlISUx6VEpOZWtCanJoT0ZxeGVzU0s0NHVwNFVMb0wxNmV0dmQvdFh2UGRzMDcycWtpb3NLcWExa2NaQnhQSzR1dE5DV0pOcy9jazFIb3Zlc0NEb2JYVGxObTNtSGhiOHg4NnQydDdJQ2JjbW9zQ3k2YjdoQTgwNjlLRkZac1ZhN1ZTcTZ5ZVR2bVZZR3J0RU1OdWk2bTFuTU12OTE1L3ZLS2RxdWxUU3Q1dHRHZGxwVUdGbHhEb2NEbzkzM1dpTkh0S0V1akFXUGMwcUxhdTVqcTlvd1JoZ2ViZDB1SHVwaW5RYldhOEhxWFVuWEFjZ0JheFdoNDV1eGJBbXFsZFFlT2lFUjY4eUxNc1NjU2xrOHpwZFd3c3loZ1dWaUZwVnl6VFprL1dnbEtBU0M2cnc0SEYxb3hWZ3RYUUpBNXRWbG9LcTFEbXZwOGZqWEcxeUNTeFBxd3B1S2JWVU14b2wxbWF6NFhUSHFSQmp5ejIrZEtFMWVqZ1BDWXl5aHpzN3dnSlNaVWxma3V5aXNyU0dCVmkrZzZqaUZXR1ZxRVcwZ2xncXNDQ3l3SzFPS2U5Z1JZMUNXbnhjZnd1QjF4a1djNEluY1RXYTNZZ2pOUkFLRnRHcWxybDkwY2lxV0N6TWR1QUVvMU51ZVZpWk9tT0ZCSnZGMVFYV0NNMkN6RUpteDFTeE9PYWZEQ3hQQ3pqVjBHQXBYb1haZEdlcENoMVg5R0JZcXc2NWhXWWxyR3dKbWt0dnN4QVhTRVd0UkdublJ0TjZHVmpnVnBYWmtwRVZZZFVhN29lTjlzckJXdDJjV3ptekp0cXN1Qmk3WjlZM2dDVTFTSlhJbHFYdFJBNFdwM3l5SG94UThSWldDQ3NLOWtETGZYY3JMUTlya1laNWtDZ04rSzVtTVN4R0ZxcVI3S3FqK0lKTEJBdHpxMXFtUFlQZHdySzlhSmdIb1FMSnJNT3R1UVZtSllqZ1hPZ2lOTjlNQm9DbEhIT1V5cml6NStnNnhyREFyYWdPdzNLd2tQV05GQ0V0Y2dRVmtzTHI2VFphWkZiN0taUjZaNWFETmZidi9pcjVVcW9xbEdxc2ZZdXE2akdCaGJSeU4xUE5QRmdZczZRQVYrSHd4RzdMTFFlcm5VLzRickhBaTc5TytwaFYrM09zMVFwVmlka1B2S2l2ZDVjVVZrUkxibnBWSWxaaDU4R0Rxa0dzUWpwWGI3ZjE4bFNHaHRXQ1NqQkFtcWpyb3J0Wlk0K3BSckVTd1VxRlM2bVZnV1ZwRllsYUc3VjhQdGk4SWtqMFpYWGpuQWhtTGZRNVlWRHFxWURxbDFrZTFqalFNcnk0RW8vWTUzUFk1OHlpRHNKc001Z0d5L2J1QjkxZkhZaFZHRGVrL09pN0FXTjFraHFrbjZGWVBjMUNZZ3hwckhEUlVzaTJxVmxZd2ExQ1o5YUdPeXluMVNGYU80Y0dTK042VzUxdWNHdjBmVEd4WGxuQkZndHRGei92Q3N2ZkxHVmE0TmhZY0NHeVk2MnYzckE4ck9CVzZMQTIwalVVZWkzSW0xaGhLZ3lrNFBwMjlhcmF3Ykpqb3A0M090MG44ck5GRDFqME1WQkF5ckhTdVB4M1pvS0VhbXlCeGJRS2ZUZEhsamdGcHhVdm5pMHFLY00zaDhxTjFaWDNxaFdzaVNxL0pzS21ZUHBmL2JzcnJKSSs2aGZ0R2t0ZGNvSkZSWGxzTll0cEZYYUpZelpHRDNieHZESmluVWdzcjlicHlrcU16R3FVUG5TTnFQa2ZUanJDMnFjZmtGeU9wU3hybmZpeU9mRnJHeXlrcGVmQlRhRVh6OUU4dUpKK1ZJbmxJNHZkdW9KV0JHdlNMSzRaQThFU1pQaTFER1ZaY3BOUnRwb0Z0RXpQWUJwUm5BTHRyb3dwUWM0c3hIWDZja1VsT2xnTituUUJrOWFyaDFsN09yTEFhbFdUWEpYdFpxRmJVUzlxYms0YzFFWXlMUWtGMXh0VklNWFcrK21LU2lTekNGZERsd3k1WmpDejhOUFlXcWpweU1jZTlnd3NjTXZjZGk0TXFEaXdiSVBsaWc5SnJRRFc2WExLczFsR0wvdTBTZEIxTjJ2dnhoZ2VsdFdlUU9Gbk8yRi9BVzdWNTh6Q2Zxc3c5N3owZ3JBdDNGRXNaUFVPUlhnNmdWc1hhT25NYW9TT01vMS8xYWgvMW5TSHhRY3o0eFBKN2VVem5zU3pzMlpSSlJaRjFMZFQ5VzNPb3VMR3dVMkdEdGE3dzNhSkZwblZoUEpyREo3Ry9nd2YvY3hpdTFneE9lR280YUFQZlBlZm5Id2VsbmVMMmxIZGltN09zcElxcEhIeTQvMzlJaTBkOEUyc1VmaEJOQXYwZ0lWQTlxS1h5TVdvOE04UXdNY2UrdU1TTE1vdHV4cTAyd3dacnp3cVlZVzBQS3dMdER3c0I2S2hTeE5VRW9LTnFWUDRUVmRZMlJGd3VWSFRROFpGV09CV1llN1FtM1Z6YnBIRG5UdE9oRy92UE5idnAzTzBSdCtiaGxHRmNtekVwc1k4NGNlZ3NPendSWWlWQ0k4cllIbTNIam5pRHh1N01hck1zbXFGeERvSnFiVzdubk9MWVpGWUdsbGpac2Ztdzh3NlA2NkFCYlNDVlhiL0tyQ0twc0ZRZ0dUV3liRmFyOC9SRWxndGdrWE5GM3pwRE92Vi9jKy93dGsya2wrOTFsZkE4cSt4ZVRRTlZuVFhLK01WOGpvUnJUY1F5N3QxV3JmVDhyQ203ckRFd2hGQ0t5UlpEMWl2Uk9zVlR6N0NVNDhIamozOTQydk1ndHg2REh0WXVSb00rd3pnRmRlZ0V3cmFCakRydFBabmUyNDVXRk9EYTVFeVcxaGluYzE2SlJwQkw0V0lrZmtUQm43emNoMnNUL2QvM2xWS0xMTXpHdEw5emV6TVlMeEx1SzlKcm5Xclc2UHYweW1nbXZxdkxRT0xrODlGSDFpdlRJVWhBUk90R1A4Uy8rWHJsYkErM1ZNbDR2YlZKb2NxNnE1d0luUzAza0xDcjVsVzlwMWNEaFp5aW11eGFUTEp6NXIxTVV0WG5zWWtITVV0UDE2dWhvVzBIS2VWZVFWSTNHQ3RRc0MvMjY1QnhQSXBuLzNrQ2pacmluS2RJN1lJMEhxWkpWd1VNRXRJZjNjdExLakV4NDFlNTZSM2NsQ3NsWGdsV2dHa2R6cldiWlVJc0lEVjlLSmJJZlM3d29wTnVqeGVyb2YxNlN2UVN0YlBxaDE5VzBXc3RGbHJNV3Zyamh3dGhCV0FZWDQxVFd0K05VMC9XRmNSZW4yaDgrVVdXT2lXYmJIUzJ4T3JSS3QzVVlwVGZ1dHdaV2dGV09RV3hEeE5rUGtrVzB5N3duclpueVVFcHg5TXl6LzU1d1pZUUN1OFNrWmUwaERGTyt6NXVhN2h6WGdsZ1lWamtxSGxZVDFQWTJEeXBTWDNoemJyaFZHRmc4UzZ5U3lpdFVuN2R0VzRVek5LdlpVbXBWazV1VkphRHRZelk5SzB6ckxxQ3VzbDhRaUJ2SVRuOGlNZWY5MEVpOTNLUkx0WjVtU0xrT05xNjF2VEhLM1I5MmVqMXRSWTFVaUc2VEh0QVl2Tm9aTXR3cnJqSWxUam45dk1JbHE1bGJQYWsxRzVya2dKTGpkbXArMDJwZVZoQWE3bkprbjZXTEplc080QkZ2SUpHVzRqS2dMMThvODdialRMRGFBVnJRZERXdEVzcUhDWnVOcWlYT3N0RHR0dkVheXA4YXQ1YmtJM2thdkhIbWE5aEhLVFFFOG9NU2wzM0E0cmRTdnBHVUpnU1h2bHppMkgxUmFLTVhXTHlqQ3V4UVNVVXF5eldWSnNKcGhTVE15cG8xbWY3a2RJSzREU2VhWGJxeld0Q1kxWkFzcVBuNXFXZy9YOGpMUUkyclQ1bnlSK25sZFhzMTVVUU9reU5KZzBLVDg2d0xLMDFCN3k2aTFlNWRpMmZjc1p2eVc5dHR2LzgzWitQWTNrV0JTSHBka2taQnRsSGpZdFFyOVVsYUNrbGlYVUtHdUlaQ2xSS1E4UWJRbFUrZjdmWmUxNy9lZGVsOU1UWE1sV01tbUdIcVRoMStjZUh4OVhCMEZwQVN4blc3WFYxOXV5YjE2MVR4VFpCdjlPRWtIcTJ2TEhGdjdKZWpzblE0dDJvazVaZThmS1ZET2ZldEV6amQrS2k4ckw2cGNSMXVyeE1kQ2EvRFNvR0MrdHJDNm82NDFSc21JYkFvdk8zbjhQaU1xajBzcktlaThHVDR0Vzd2dWVydllybGtZQmxNZTEydUVnQm0xNVpjRkxaNEIxYjV5VHcxVVA4aXlBbFJCV3dCTmU2TFhJZk9NS29QWHhZVzlZMi8vblk3K1BodERQbjk4UGtoRlU5bFhweTd2ODVDZm9hcm5VY3FxSnZLemZMOThJdDhCc0FLd2VLZnZxVENwb2F0dVlSNDVuTVczdDlkT2RPbitRTEpySzdadlZocnE3c2F5Tk1OckNCREg1MlNFcWEvUEU2T2wrMFVzTVgwOEVhK3VsNWZod1ZUWDZ1Y2grUzVUeFA2L2hGaG04RlFzc2EwK25jUFVaenlDYlE2MHRZWEJwWUtxNC9vZjUzeGdqTEZSV1I1VEZva1NjVS9OZ2JXT0hzb01YSnBDQmdzY0FXQ05EQzZLb3plNTdYN2Y3Sk9wWmJieXVnckxFQnFkUUNWR1llMnhHWm0rNHRMeWN0cFo4RkQyd042K3ZYRmhiTW4zYlNGUkpWRU9VaGRyNmNKRVU3cFFCVGg5aEN0bkZTQ25yV1JxVlZsWnIxc1R4ajUrMVFRVzRuTGFpV1h6anUreEJ5dG9HVWZFNDlaNGdCZGNRV0liV0I0bWpFTm8veUFqUy9UT0Nvcm9DZXpkaktJcTJiYS8vL2UzYno4N3BDclZGdlFzY2ZzbEJ3Y2REWVBVaVFrcFNJQ29BTmdqV2hadEVSMnRGOTRNc3RxK1l0eXNySzQxS0dHS0Z4blY5ZmYyWGh0V2h0R3FucmJBcThqMlFQOXNZTUlZOVViMGZHc0FUS0l2UjZqVU5uL0V5U01ZUWRXWHNTcjhhYmNIMVdIZUl5MHFycGh2cjVWc29JMnF5Q2NxSEZSQzlwNDNLVThLcldneDlnN0J2ZWsyMDQ3Zkh6U0F4ckUvcjdEd3lXRjJaMENCVUlkUXY3VnBGV3hRYVdXMEdzZXZxOUN4YWVYR3Z6NFMxNVZ1Wjl5Z2xiUGtBR2xURFlSbGFSbFFtdi9lUFUxMHJzK0VKU3hoWE43VEVwb0E1ZE5KcTJ6ZXFyYzV2clAwdnhNTHNKT2JDT2p4N3lDcFNWblVDWmVrRW9Xa1paZTAvVVZ1cno1NWZSYkp5am1XRVpVU2xnUmxWYVpFaHJTV1pSS2V0bEtnR0tpdXNmTzlwVDJjajJGVFZjRmlnTFh1bnpIN2ZXd1hqQXNzcUMwaHRRRnFnS0dHWUFTelUxcktqcTJMdGFIbU5MVU0xbUE4cjdWVjlYQld3YWs0Q3kyZ0xJdForNy9zcm5xNzRNaWlVM1JRS3E2eTJMZHpWSWkzQ3FyWlBqd3NGOXJZOGpiS1NzZ0pNMjBoV3AvQXNxNjFQY3dpeC80eld3WTJ2R3J5eWhOMC9ZMnd3Qmwrd3kyc3JUbHhkV0J4SmpsaldBMkF4YVRWK0RXeElEbldpQWx3bmdXVzBaZS9zNDl2Qk9MZTdyZ0cyaFBwaHJwMEExNElSTElUbzA2cHRvZ2RwOVRZL2c1V1ZTRlhjMXdPdXhXbmV5OTFNNGlxeEVyTGNEbnZuWUZkR1dJQk1HVllRVEF0TTgyM05KdEUzZ2gxZkdIRTlQQW1zSGlTTmFGdjUrVHVsc3F4dk9WUjdYdld0SWxsWlVnQkl1Q24wdzRqYXdyeTFyTGwxOFlyTGZtSWdyS2Ivb0ZiVkJGUW5nNFcrRlVoNVdhMkl0VnRaYlVCUk9pa1FRdTZESFg0NnNTWjZZRnhheTJHd0dwNFhtamd2ZUdXZEZoYlNZc3RnY1BjSTZGSmlBQUFTRTBsRVFWUlFOSUJaYVdJR2lqUDN5T0ozenVVSnJNNlZ6WFh3ZUV0dEFLd21tcjh0RDFhb3FTWU00dUtFUHdtRzBOcTRqTVdtVU9BaXVBRmRDY1FVeGhBLzJyWHBOYkdydlhlQmRYVnVITE5oTmR0RDgwZWlGVkdXbENlRVpYeUxuVHZUZ0FVcklMUlgySTNpSTlKVUFWdEVLeTNVVm5TaHBycndTejBFVmpLcnV4WFE2Y29QNFVtVkJkcGlMWExRbFlJTzJjY3JFMFZWYXdheGNONmxHRE5WSkdqVjRlaUg5RGI1c0pyZVpwbUppbkVDYVowVWx0ZldwaCt3YkNWajk0UFdzNHFJa0dpRGlmVjJQbVJ4N0l5c3JNQnlZVG12MnZaVVpYbjVMSG9lV0pnZ3JGV3R3cm16Y3Iwb3FxcFZyZkF6VnhSOWFqdUJuVTFicC9lSi9tQ3h5eDlEYis2OUZGcjVkRVZSeVpQRHNyVDRhV3JRRlpiSWtCc0VpaXRlQ3AyeUlLUVdwTjg2RkNLV3kyeFl5VzZoWWNIS2ZTQlBidkRCdDFqWi9tanJtTEFPcXA2dGsyVVJneWt3MVovNlhkTTFzYU41M2hsWVBxd21Ia05uVjAyd2RtbEZCUi9jWFo3OHg5QWlyZmhBRlZWbEhaMGFGcXlKN1k2amN3a2ZzcnpSRmR2K2tJNHJYMWwvUnVVRUZTWlJ5bXB4K3A5dzdHZ0JzY2ZReWVCMk1LMHNsMGE5c2l5dVZBZmhaUVh0YzZheUZnY21rR3dHdmJTa2U5eWRIdGJJMGxJclVybWJHVlQrWkNJTnJHV0RDS1BvKzYxKzVITE9sUVZydXFqNnNpS0pvVUZoeVdCWUFHdDZjbGhXV3l0K2tBTkhYZ0o5WGJYVXJMeWlSRzhRZDNycEpOcEtLbXdBck1RRWVsUWtaVW1VbDRGMWhoOWliN1FGdGg0T0NLRVlSYyt5V2FGVlRGSENLNHBvUzdUSzU2MXVtUjdHSEZpajc0c2txb3J0Y0dTUWxRRW01ZDNOR1dCZFhGeHFXdVNHQmhoQ0pVUlI5TU9vb0ZHTHdDcHNNNmhoL2E1VHNBWW9hM1QxcjJqTFRMYk5UVURsRTVhOVp1Tnp3THJ3MmpMaEFScStYODZ3cURmeHJOVXpNbkN1b25EOUZqaDZGODFqRnF6TEJlSGtIY3VMU3BJQk5KcXl0TXJaNWVoc3RBRFc0d1pFRlE0SHYzSXBseURJbXVpUCtGRmRXYkIrek1MV3BncDdHLzJBa1NOUkZKRlpYUE9yODhCQzM0SmJpb0FURnNpMHdISkJWSmlRSmVLa2hUb1Q5b3VpZm11b3NpNEFWdC9WVVZtTmRKeDhhTERYbVV6TDB3S2JoKzhiVGlqY3JLVlZKckNEVU5HcXlQc3RycXc4V09PYmxMSFRua0hhNUVBY1M4cjFtVXdMYVlHcXJMZWJVZXd6T3BSUWhiY3RWRmJjMkhqSHo0S0ZFYjZpNVVLdmtlRVRLTTg2aDRHV3U1bEI0YkdYbFk3b2MxSUpYbTU5RExUNDNxZk9oMVZ4dy9MYm0vUU1scklzenhOTEtTMTdXSThuTjJuOUdNY1NFVElWQmhHK09KeFZXMlNXV0JhczBYUkJXNzRxTHZ1Y2ErRVFWbzdXR2VmUStaYUFBVFRESkJJeFFkamFQU0V4NWZlSnFxRG5pUjNORDNuS3VyemJWdEdwb0krZnZwSUpVMWppbzZ6bTMwZG5wYVZzaFNBU1hWK1VUNm5BcU1VWHp1eHMzaUp4cTh0VDF1V0MxWHhFWUJWdHNJaGZsUkxtOFA1ODBnSmFRclYyWjZpSy9qWXdsQTV0NnQ5Y0E0Rng5cmZiK1hoOTVTbExad2ZhV2pXVmJMeXNuTGhvSG5YS2t0WDVMTjdSYW4yUHdEQ0ZJb3Q4TnFqTEhaYlpTV1Q5bGgvRFBHWHA3Q0NkUjVIa3dIVkZVRmxhOHN6U3NpNFAzN0xkOFlpQ0hVZi9JVDhVZU1Cdng5aW4wODZaVnBjOWhwUHBYUlh2bm9Pa1lBTDlRbGphcFJDZTVWbWxCYlIrcVZhbjBoMWZEbmxvSjVtK0pUVWdmdElCTTBZZnRZRjV5aHBkTFhwNm9uME16ZTBXRjhCYXk3dlpPYVVGKzBUalc1amdSVEpPYVk4U0NYSWljSEw3eElMM1c1bGpxQjIrQ21jNFRjVExTVXdHd3lwUldtdFpubk5CZExUZ2hpSVJPMVBVdjhNMnNXREJ3WCtOemhnQy80YkJHMG1sbWJBdWZ0eWtNcnNreXlCUFdHQlphN2t1eTd0emRRK0VsakwzcWhYK2tFdUlZN1krOXI0a1A1SUdGNzkvS3hjV21KWXZaV1E0d21INXlwS3lub1VLTzdQSE8xcHdzN3ZwaW5ITHAwWHk5NGNYQ1hpK2d4Z3dobUJhdERxV2RQdE1BbFlwMGF5a3hFRXN5L1Y2UGowL0xmTnRLdlZvSm9sMm92RStjUmNYaEl3VjNsSDVPL2hXTHF6TFdXeFU5SkNRMGlxOXNOQzVqRzFOemt0cmdyN2xUcmlDSFNsQ1NkQktYdkd6VjhHMFplOE56SVpsa2hidDJ5VVZWa3dLSjNGdG51WGFET0xzYW5UeGYvRXRrRWJSTXZPbWRiUDR3M0YxM0c5MStiRE1DWStNaFNYalVxYU0xMEtZUXprZlFHczBHbjNGNVRGZHVqckIxNlJoWlZRcHoxZE1XZjRlbTF4WWJBNWxoQXVBbGZ4aFJMV0cxNGNodEVhWDA4c2phWVc4aFNJcjR2MVB3dUVWS3lsWXZ6VkFXYVB4VGNSS1ZnZDBGZUk3c0NvMXJUS1gxdVRxZG42YzVRRXRQSWFBYjNmM3g5T0s1RytMcUEzTWhnVnpTSm8rQ3dwUlZTRXlCRnBJU3NzTFh2Tm9qYWUzdDArM3Q4ZlMrcVVLNTF2b1VqYTc3OUtwUVNTYVU4aGVlSjQ0QUpZTzhiS0orL2FvUmk1dFlDRENrbXZnWldoOUgzOVp6ZmUzVC9vNm50YWovallkclNNYmVVRktWYmVsQm5WcGJXWEQwdXZoWGNPUEo2U2tyRXB1V1dZcFJIV3RnZFo2UHB0KzdRYzRqaTQxcTVlbnA1ZVgyK01tMFNRSUUwYWhhRmJwTGd2VkpaenN6Ry82L3lEdXQrcDhXS01ySGVKbFF4SkRmL2NjUkdXVlZlSVVtcXQ4bU45ZmZTRndqYi9QYjE4MEs4UHJlRzM1eEtRT25ZbWxUMXpkRVByTFpQbDhXQmMvWmpKcTI2WFhWaG1DdTkvbnJPMkt1TVlMYlA1b2NlblZkMzc3K3ZvRTE4dnI4YlIyMkcvdEZIZWtIYXNmMUNGN3h6SUNucHJXQUZpNFAvVFppdXFxbEwwdG9adEJNQ3lBOWZDZzQrbjk5eU53alVianFaV1YxaFg4OHZRRmwyOWRoRWplRG4rd0RQU29YSzNmWHVmRDBuL1lNajRmckRnck5vbHJxaXN6aGxwYjJybG1mNGRyTkJsUGpheGVZQUx4K2ZUeWhVbUVObENJZzg2K2EvSGdKL3hGRE9IdmZSQys1akp2emZKdHdOdDQzTnc1czVMOVpaQnBTdHBsa1BQUzZqSkdyNGR4TWpvc3FxdjcrZTB6eU9uMStjbGRMMS94cmZadzVkRDdHd1NocStmN2IrTjZRMkNaNmtHeTRDNTd3ZDBxYXgxQ1ZnUkxQelV1UFkzajNqNUc3MnpHbDA1VXowL1AxdDJmM0NBZVRjdjBVaVNSMjhyNWJ5WnlKNEljYllnWUF1dGljbk1YV25ldUxSbTFEVFNVTWxSdzNSbGUwKytYNC9Ga01qTFhaRElaajYrbTl6T042dm41NWZuRlhkNnp2a2dMZDlNNzVUcFJ5S25oNkhCM2pJdTFnMkJwYWNuK3pUSlMwc0FRTWtPSVdMZ1lQb1RudzhQcmVqNmZHV1Q2bXBxWDJiM21kS3ZuNzVuQ2VxSW0vM0treTAvaWZtc254SUdCM1AwcHNLcEJzTFJycmRsSkRzdFlzcy9LMDNwQVhFUmNtdGZENjZ2T0JITzg3bTcvMTk3VjlDYU9CTkd3QkdFbUNrSklPRUtjTUhLMFFwYlErR0Qzd1ZMZmtmai9mMmU3K3JPcXVzMEFOdEZxRXE4MnlhejJzUHZ5NnZXclY5VkcxT3JQdGNHcXRsQTl4cTNlZkN0aTFTVlJubjZMY0ZnWmdqRU5uRHJ3OHFOb0JjVXFVc3dDcEVvUWZLRi9CcEQwRjhDS1ZLRVZMZjFEZlR1M3J1ZGJVWHRZUlhjeEJqTkxxVlp4T0hDbDhrMGh5eHUwZDBkMWlMQ3kzREx3Q0EwVC9LRnRNVnduODNjZzFsM2NZdmxXVmJHQ08vdVVTeCtIUHF6cC9OMnhnY3hTMU1wVHZpRjRkOWNUMGlyVVNBV3NaQ2tNVnNKOGhRSjAzMFdvUW91VkY2MzJQcFZuK1JidWY3cmVLSDVNWnVrRE1aVmdGVGh5d05UQ0NpOHRWRTZ5TkVDR1g3NEVxY0MzdmdJOXYrN1FMWlJ2N2F2ZUN1enpZb09acGFpMU9qUjhXY1lOYzV6SmdrQlpVa3RxcVdYeDBsaFo1UUkyYVZKNXlCeTFUcjRLMnhPcXhkdlJ3dmxXbUUyZmsxSnZERDNaeFJuTXJKYzVkSWltdjRGcUxJakFHK2NPS1pZc1VsakpjQktXWlcycDViRUtBbys1Ulk3RE85SDZWT3JlbDIrbHI5aGh5bDBHZy9YeThVczJoNEtPQ2FQRDBIYzd4R1ZKeEN3Tm1BaDQxZUZBYkpGc0JZK0ZFYnZIYi9GOGkzR3E2MTNqR2w2R0VJdHZpME5Uc0FtMG14SzYzRjJ5WG9jQjVjQUtTQWw3S0NhWWRXcXh3dC9ydCt5UWl3Y1FmQTBDcndnNkNJZURCYzYwY1lZaDJJVVFZN2ttT25DclJKSkZrY0p3K2FjbHR0U1RDakdydlQyeCtjVDVWbnJOcGtmcXgyQVdSRFVXTGRvUk5yZ2xiSkxkRHZaWWxGbVdYYlZ4RGduTmFpbGNqK1ZiektLZkE2dlE2azNnMkFoZ3ZTemVWU0ZhZ015aUxVbG1jUFJleEw1QjRtNG53SVVmNUxTUXVqK2s4bkcrZGI0aTltYzh1UjZGV1ZDSUJXNmc0ZnZCVFZZYkh6ZHd6WkpNdEl3akxTbXpySDhQNWdFejYxRzBYTDdWNGJ2VDFSOXMxa2pNZ2tJc0Rpd1p0VVZJbVJWcEZyV2syRHRZNnlBOFdpeDNpQXpFNC9sV3hVdXlTMXJWa1pnMVZ5ZGlPQWxsZzZZNXdWL2h4TUVwbGtNTWthb014NkVYZVNaYXFLTm1hTDNkM0NjYXYvVnA3aUNldmZQcTJGVXh2QkZSZGFPQUJhUGlMWnBRU0xjRVFqeERpUDFLS1ZPK29jZVV1azQ2eERSTzNlTlN2R05DZHRINzh0SCtGdEV3c2h6UlZTT0JOUWZaS2hCZVpQWkZBdVVTNXpPbzE2RkZhTXRRSkpsMWFvUFRhaDlBeStWYm5YLzluNEdyU3ZzSE4zc2NpMWxhdGtqZ3dFSy9va2ZjMFZtSVRzT2ErQ3gySEJJYlQ1ODdzbE9VTDhmNTF2bkNPRmFOeVN6akgyQjMyekhMalNoNDZPZlI0azEwS1lpOFk4QjBxaFh4cWswWWlNZnpyYTdxM1paM3VqVWVXREJ6RFdaVWF4YXFRNG5TR2R3VUJvVVgxR2ZoM3RBVVlVM0w4SlFvd2tINUZyMitFdTFNamxtR0dxMjhDZGtNN2dtNXlYSXBLWkg0a2pZN3RCUlJ0T3pyTU1rc2pWWjJvMjUxYUx2dmZHV1N1QitkV2VxM3Rjc0xuTXp3c1U3QmlwRDdkMUtJZGJJM0pNUksyWWZiMFlMT3B3cUp6WVYyaDFxdmlOOGFPR1JON0U5dG5WNDFYTnVqcnBDR015VS9DeU9oSjNGcEd3eEVvaEpYdCs5djBYeXJaNC9TQlBLcURLZWp2bHNPMERKV3EwbGk1YVlVL2lpVVVhdGpvYXByRmp4UVQ0cnowcmdTODNzMmtuQysxWEduRmU3NWpBMldRY3RjYVlLL0dobDVVcTlXVnhUTHdjVmtpNHd0eUZnczV0WnRsOCt5Sy9sV2REUldZNE9sMGRLR2xKNkVFdHQzcEZnc280bThROEpuT1dhUnlYUWJOejQzL1cveGZPdmFOalA0ck1uTHFNOThzdHRhd1VvNVVqb0NJNzFPRDdGU0h2N1B6RnJkdUNRWDUxdm4zcmNES3JER3ZrZXpBTFNra1huY1FJYytHaXY4TldheDdyREZWb3ZNcGFNdWNYbjd6VE9TYi9rYkt1SGxCZWo5TEYyMUdmM1MwZnpqMTFZU1ZrV3REbWRXMUJjR1dtSE5RdmxmMjlzZEFsYTdPMjdweGZ0YkZkZXR5akZyZkxCQXQzSnJTTU5lSk5Pc01OeWgxS0o0bVdGK0d6c3RObWx0cVY3dDd0cUNEdmtXOWFNOG43K01hZUFqbFpjUzJYZ2k4YktrWGJSSGlsbDR3Ukt0T0hsSWxPRHkzaHQ2MmRUZlQ2enN4L0xBenhjU0N5cjIvUjViM3gxYWI3a3hXcVYxRVFWTHNpUTE3d252UUp2RDFJRVlwaGEySUZ1emFucDNyU2kwck4rQ3p6R2k0MFIvR1ZaaHQzN1NQY21QOXh4RXZwVFI4Z3hheTVMSm1XSGlMQXpNWWtFTnBwVlpFMWxOSDdqTGFLYXY1aDc1SitTbWxWdVV0RG1YTnZsUHFVSTdlbDJaN3JERUsxbmNPa2htU3Z0OFZpSlpwaTdMYlprK2VBSGJ2UFVIQUR0M3grNm90QnpzUk5pRzF4SDA1bWtYY09lTGlUa1VyYllYa2t3cUpHMTE2bFJ2R0tqVitqS2tJay9qNVJiazZ0RnJXNkR5blh0M01MMi9hZDRmY3B3OTlXVW5IMis1a0VWQkFtVzI3OGZOUThsTlZwL0FlM2x2VVVpYXZ6Lyt1OWQrcXpPdnNLRXB2TjNqbXEyZmVyTjduazFYVzFXR0RxMlNSTXBzTjZ1a0R0NXpxN2NNd3c2ZytiYk1kNFBlZ2FEekxmUHBNdTRkYmRVK3ZQUG9NbnZ5R3hiQXplY05HWUtWdmROVjZ1QjlDWXEwd0xQRk5oMDBaSU0vRWZDb0RkZGxiMS9DNWQ2VnBQN0IrWG5xamdlS0sxQXV2Vm5MaDJEU3JkNWE4eEF4NjlydzhHUkZ5OUpxdVJ1dUtJdnA1dmlwaHoxZGR6enF0LzhZQVZOMmRQYWF2VHovV1V6ZVZ0dXlBUmZoRm1lU0FVM1p3NnhveEJOeW1sTnRMcW0wSWw4TnBaWDliOTNNOXIvdHJPZTgxNStHQ0hWWnpkYlRyOERLd0pXTDBvdFdnZFJkOWdhbHhHaUpWQUo0RWdZcEVQYTN5Vmp6dk5mWldjdFdlUGEvai8rOFp2T1hMM29XSVBTbHVUVFhvMW9SczVLVFE4b3REVlhkS21FZjhkZWVUZGY2cnJDV0x2MzFjN2I1S2xxWlg5ajg0MzIxRFBmQVBLZDZOYXRHVHFzdkFUeWRoRkRXYXB3S3hFZjRadmJ2MGI1SmR6YmJyTCtRVmtpNmNqcTV2K2F6Qks1QU1ySUlraVhxOGFFeWNFMWUxeHY5ckYrbmt5K0h5cHcxQ2k0VS9QSFdzRXhyVmp6RGQzQ0paZjRFcUV3bExMSnNrbVdKVzMxZlZveUdYVEpLMzBXc1dYVXFLaVhNV2o0TnF2L0xBOW9WdEY1N0w1czNoSEVZbVJ0cXVQUWxIcnZ3b0trbGFsVi9TdGIvWnFqTXlhaXZwdGFsYktSYkNIR3BneUR4bjJoeENScmtORkxDa0dyeHQwTmxxdkZqcXZHU09wWng4UXhDeTIrVittdGlVSTNLcWdPQ0xTQTF5YjREVWdTdnJiWVNOYnBzV0NZeWVDQ1U4bE9hVzhDcHQrazNRc3JocFc5QUEyQ1dYTFdndVhKdEw3SUtXNE1BMUU1eGF2SGRvUEtHUmhGc3BSQURXa2tNViswV1ErRDhnNXZBNmw5N24zNVhvSkNqbWI3clMvWTVZTVlhUkdDVHZwWS96YjQ1VUtRbWdXUTdoUmw1ZGo4d1hhUFpRci9QUWVHVExmUUxIbjVBK1hsK25wL241M25DOHgvdEFNbGpXa2VCbkFBQUFBQkpSVTVFcmtKZ2dnPT1gO1xuXG5jb25zdCByZXNvbHZlV2FsbGV0VXJsID0gKG5ldHdvcmssIHdhbGxldFVybCkgPT4ge1xuICBpZiAod2FsbGV0VXJsKSB7XG4gICAgcmV0dXJuIHdhbGxldFVybDtcbiAgfVxuICBzd2l0Y2ggKG5ldHdvcmsubmV0d29ya0lkKSB7XG4gICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgIHJldHVybiBcImh0dHBzOi8vYXBwLm15bmVhcndhbGxldC5jb21cIjtcbiAgICBjYXNlIFwidGVzdG5ldFwiOlxuICAgICAgcmV0dXJuIFwiaHR0cHM6Ly90ZXN0bmV0Lm15bmVhcndhbGxldC5jb21cIjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3YWxsZXQgdXJsXCIpO1xuICB9XG59O1xuY29uc3Qgc2V0dXBXYWxsZXRTdGF0ZSA9IChwYXJhbXMsIG5ldHdvcmspID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBrZXlTdG9yZSA9IG5ldyBuZWFyQVBJLmtleVN0b3Jlcy5Ccm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmUoKTtcbiAgY29uc3QgbmVhciA9IHlpZWxkIG5lYXJBUEkuY29ubmVjdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe1xuICAgIGtleVN0b3JlLFxuICAgIHdhbGxldFVybDogcGFyYW1zLndhbGxldFVybFxuICB9LCBuZXR3b3JrKSwge1xuICAgIGhlYWRlcnM6IHt9XG4gIH0pKTtcbiAgY29uc3Qgd2FsbGV0ID0gbmV3IG5lYXJBUEkuV2FsbGV0Q29ubmVjdGlvbihuZWFyLCBcIm5lYXJfYXBwXCIpO1xuICByZXR1cm4ge1xuICAgIHdhbGxldCxcbiAgICBrZXlTdG9yZVxuICB9O1xufSk7XG5jb25zdCBNeU5lYXJXYWxsZXQgPSAoe1xuICBtZXRhZGF0YSxcbiAgb3B0aW9ucyxcbiAgc3RvcmUsXG4gIHBhcmFtcyxcbiAgbG9nZ2VyLFxuICBpZFxufSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IF9zdGF0ZSA9IHlpZWxkIHNldHVwV2FsbGV0U3RhdGUocGFyYW1zLCBvcHRpb25zLm5ldHdvcmspO1xuICBjb25zdCBnZXRBY2NvdW50cyA9ICgpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFjY291bnRJZCA9IF9zdGF0ZS53YWxsZXQuZ2V0QWNjb3VudElkKCk7XG4gICAgY29uc3QgYWNjb3VudCA9IF9zdGF0ZS53YWxsZXQuYWNjb3VudCgpO1xuICAgIGlmICghYWNjb3VudElkIHx8ICFhY2NvdW50KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHlpZWxkIGFjY291bnQuY29ubmVjdGlvbi5zaWduZXIuZ2V0UHVibGljS2V5KGFjY291bnQuYWNjb3VudElkLCBvcHRpb25zLm5ldHdvcmsubmV0d29ya0lkKTtcbiAgICByZXR1cm4gW3tcbiAgICAgIGFjY291bnRJZCxcbiAgICAgIHB1YmxpY0tleTogcHVibGljS2V5ID8gcHVibGljS2V5LnRvU3RyaW5nKCkgOiBcIlwiXG4gICAgfV07XG4gIH0pO1xuICBjb25zdCB0cmFuc2Zvcm1UcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWNjb3VudCA9IF9zdGF0ZS53YWxsZXQuYWNjb3VudCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ldHdvcmtJZCxcbiAgICAgIHNpZ25lcixcbiAgICAgIHByb3ZpZGVyXG4gICAgfSA9IGFjY291bnQuY29ubmVjdGlvbjtcbiAgICBjb25zdCBsb2NhbEtleSA9IHlpZWxkIHNpZ25lci5nZXRQdWJsaWNLZXkoYWNjb3VudC5hY2NvdW50SWQsIG5ldHdvcmtJZCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBhY3Rpb25zID0gdHJhbnNhY3Rpb24uYWN0aW9ucy5tYXAoYWN0aW9uID0+IGNyZWF0ZUFjdGlvbihhY3Rpb24pKTtcbiAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IHlpZWxkIGFjY291bnQuYWNjZXNzS2V5Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24ucmVjZWl2ZXJJZCwgYWN0aW9ucywgbG9jYWxLZXkpO1xuICAgICAgaWYgKCFhY2Nlc3NLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBtYXRjaGluZyBrZXkgZm9yIHRyYW5zYWN0aW9uIHNlbnQgdG8gJHt0cmFuc2FjdGlvbi5yZWNlaXZlcklkfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCBwcm92aWRlci5ibG9jayh7XG4gICAgICAgIGZpbmFsaXR5OiBcImZpbmFsXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5lYXJBUEkudHJhbnNhY3Rpb25zLmNyZWF0ZVRyYW5zYWN0aW9uKGFjY291bnQuYWNjb3VudElkLCBuZWFyQVBJLnV0aWxzLlB1YmxpY0tleS5mcm9tKGFjY2Vzc0tleS5wdWJsaWNfa2V5KSwgdHJhbnNhY3Rpb24ucmVjZWl2ZXJJZCwgYWNjZXNzS2V5LmFjY2Vzc19rZXkubm9uY2UgKyBpbmRleCArIDEsIGFjdGlvbnMsIG5lYXJBUEkudXRpbHMuc2VyaWFsaXplLmJhc2VfZGVjb2RlKGJsb2NrLmhlYWRlci5oYXNoKSk7XG4gICAgfSkpKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2lnbkluKHtcbiAgICAgIGNvbnRyYWN0SWQsXG4gICAgICBtZXRob2ROYW1lcyxcbiAgICAgIHN1Y2Nlc3NVcmwsXG4gICAgICBmYWlsdXJlVXJsXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBY2NvdW50cyA9IHlpZWxkIGdldEFjY291bnRzKCk7XG4gICAgICAgIGlmIChleGlzdGluZ0FjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ0FjY291bnRzO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9zdGF0ZS53YWxsZXQucmVxdWVzdFNpZ25Jbih7XG4gICAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgICBtZXRob2ROYW1lcyxcbiAgICAgICAgICBzdWNjZXNzVXJsLFxuICAgICAgICAgIGZhaWx1cmVVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50cygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaWduT3V0KCkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKF9zdGF0ZS53YWxsZXQuaXNTaWduZWRJbigpKSB7XG4gICAgICAgICAgX3N0YXRlLndhbGxldC5zaWduT3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0QWNjb3VudHMoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gZ2V0QWNjb3VudHMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdmVyaWZ5T3duZXIoKSB7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCBub3Qgc3VwcG9ydGVkIGJ5ICR7bWV0YWRhdGEubmFtZX1gKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbk1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5vbmNlLFxuICAgICAgcmVjaXBpZW50LFxuICAgICAgY2FsbGJhY2tVcmwsXG4gICAgICBzdGF0ZVxuICAgIH0pIHtcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJzaWduIG1lc3NhZ2VcIiwge1xuICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZCAhPT0gXCJteS1uZWFyLXdhbGxldFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSBzaWduTWVzc2FnZSBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSAke21ldGFkYXRhLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYXRpb25VcmwgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiBcIlwiO1xuICAgICAgICBjb25zdCB1cmwgPSBjYWxsYmFja1VybCB8fCBsb2NhdGlvblVybDtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjYWxsYmFja1VybCBpcyBtaXNzaW5nIGZvciAke21ldGFkYXRhLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaHJlZiA9IG5ldyBVUkwocGFyYW1zLndhbGxldFVybCk7XG4gICAgICAgIGhyZWYucGF0aG5hbWUgPSBcInNpZ24tbWVzc2FnZVwiO1xuICAgICAgICBocmVmLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgICAgICBocmVmLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub25jZVwiLCBub25jZS50b1N0cmluZygpKTtcbiAgICAgICAgaHJlZi5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicmVjaXBpZW50XCIsIHJlY2lwaWVudCk7XG4gICAgICAgIGhyZWYuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNhbGxiYWNrVXJsXCIsIHVybCk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIGhyZWYuc2VhcmNoUGFyYW1zLmFwcGVuZChcInN0YXRlXCIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgc2lnbmVySWQsXG4gICAgICByZWNlaXZlcklkLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGNhbGxiYWNrVXJsXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICAgIHNpZ25lcklkLFxuICAgICAgICAgIHJlY2VpdmVySWQsXG4gICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICBjYWxsYmFja1VybFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRyYWN0XG4gICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIV9zdGF0ZS53YWxsZXQuaXNTaWduZWRJbigpIHx8ICFjb250cmFjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3Qgc2lnbmVkIGluXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfc3RhdGUud2FsbGV0LmFjY291bnQoKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRbXCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uXCJdKHtcbiAgICAgICAgICByZWNlaXZlcklkOiByZWNlaXZlcklkIHx8IGNvbnRyYWN0LmNvbnRyYWN0SWQsXG4gICAgICAgICAgYWN0aW9uczogYWN0aW9ucy5tYXAoYWN0aW9uID0+IGNyZWF0ZUFjdGlvbihhY3Rpb24pKSxcbiAgICAgICAgICB3YWxsZXRDYWxsYmFja1VybDogY2FsbGJhY2tVcmxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zKHtcbiAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgIGNhbGxiYWNrVXJsXG4gICAgfSkge1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgY2FsbGJhY2tVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghX3N0YXRlLndhbGxldC5pc1NpZ25lZEluKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IHNpZ25lZCBpblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N0YXRlLndhbGxldC5yZXF1ZXN0U2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgdHJhbnNhY3Rpb25zOiB5aWVsZCB0cmFuc2Zvcm1UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSxcbiAgICAgICAgICBjYWxsYmFja1VybFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYnVpbGRJbXBvcnRBY2NvdW50c1VybCgpIHtcbiAgICAgIHJldHVybiBgJHtwYXJhbXMud2FsbGV0VXJsfS9iYXRjaC1pbXBvcnRgO1xuICAgIH1cbiAgfTtcbn0pO1xuZnVuY3Rpb24gc2V0dXBNeU5lYXJXYWxsZXQoe1xuICB3YWxsZXRVcmwsXG4gIGljb25VcmwgPSBpY29uLFxuICBkZXByZWNhdGVkID0gZmFsc2UsXG4gIHN1Y2Nlc3NVcmwgPSBcIlwiLFxuICBmYWlsdXJlVXJsID0gXCJcIlxufSA9IHt9KSB7XG4gIHJldHVybiBtb2R1bGVPcHRpb25zID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFwibXktbmVhci13YWxsZXRcIixcbiAgICAgIHR5cGU6IFwiYnJvd3NlclwiLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgbmFtZTogXCJNeU5lYXJXYWxsZXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTkVBUiB3YWxsZXQgdG8gc3RvcmUsIGJ1eSwgc2VuZCBhbmQgc3Rha2UgYXNzZXRzIGZvciBEZUZpLlwiLFxuICAgICAgICBpY29uVXJsLFxuICAgICAgICBkZXByZWNhdGVkLFxuICAgICAgICBhdmFpbGFibGU6IHRydWUsXG4gICAgICAgIHN1Y2Nlc3NVcmwsXG4gICAgICAgIGZhaWx1cmVVcmwsXG4gICAgICAgIHdhbGxldFVybDogcmVzb2x2ZVdhbGxldFVybChtb2R1bGVPcHRpb25zLm9wdGlvbnMubmV0d29yaywgd2FsbGV0VXJsKVxuICAgICAgfSxcbiAgICAgIGluaXQ6IG9wdGlvbnMgPT4ge1xuICAgICAgICByZXR1cm4gTXlOZWFyV2FsbGV0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHdhbGxldFVybDogcmVzb2x2ZVdhbGxldFVybChvcHRpb25zLm9wdGlvbnMubmV0d29yaywgd2FsbGV0VXJsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBzZXR1cE15TmVhcldhbGxldCB9O1xuIl0sIm5hbWVzIjpbIm5lYXJBUEkiLCJjcmVhdGVBY3Rpb24iLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiY2hlY2siLCJpdCIsIk1hdGgiLCJnbG9iYWwkbyIsIkZ1bmN0aW9uIiwib2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZmFpbHMkayIsImV4ZWMiLCJlcnJvciIsImZhaWxzJGoiLCJkZXNjcmlwdG9ycyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZmFpbHMkaSIsImZ1bmN0aW9uQmluZE5hdGl2ZSIsInRlc3QiLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJOQVRJVkVfQklORCQzIiwiY2FsbCRrIiwicHJvdG90eXBlIiwiY2FsbCIsImZ1bmN0aW9uQ2FsbCIsImFwcGx5IiwiYXJndW1lbnRzIiwib2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciQzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiTkFTSE9STl9CVUciLCJmIiwiViIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDUiLCJiaXRtYXAiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiTkFUSVZFX0JJTkQkMiIsIkZ1bmN0aW9uUHJvdG90eXBlJDIiLCJiaW5kJDgiLCJjYWxsJGoiLCJ1bmN1cnJ5VGhpcyRtIiwiZnVuY3Rpb25VbmN1cnJ5VGhpcyIsImZuIiwidW5jdXJyeVRoaXMkbCIsInRvU3RyaW5nJDYiLCJ0b1N0cmluZyIsInN0cmluZ1NsaWNlJDYiLCJzbGljZSIsImNsYXNzb2ZSYXckMSIsInVuY3VycnlUaGlzJGsiLCJmYWlscyRoIiwiY2xhc3NvZiQ3IiwiJE9iamVjdCQ0Iiwic3BsaXQkMyIsInNwbGl0IiwiaW5kZXhlZE9iamVjdCIsIiRUeXBlRXJyb3IkYyIsIlR5cGVFcnJvciIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkNCIsInVuZGVmaW5lZCIsIkluZGV4ZWRPYmplY3QkMSIsInJlcXVpcmVPYmplY3RDb2VyY2libGUkMyIsInRvSW5kZXhlZE9iamVjdCQ1IiwiaXNDYWxsYWJsZSRuIiwiYXJndW1lbnQiLCJpc0NhbGxhYmxlJG0iLCJpc09iamVjdCQ4IiwiZ2xvYmFsJG4iLCJpc0NhbGxhYmxlJGwiLCJhRnVuY3Rpb24iLCJnZXRCdWlsdEluJDgiLCJuYW1lc3BhY2UiLCJtZXRob2QiLCJsZW5ndGgiLCJ1bmN1cnJ5VGhpcyRqIiwib2JqZWN0SXNQcm90b3R5cGVPZiIsImlzUHJvdG90eXBlT2YiLCJnZXRCdWlsdEluJDciLCJlbmdpbmVVc2VyQWdlbnQiLCJnbG9iYWwkbSIsInVzZXJBZ2VudCQzIiwicHJvY2VzcyQzIiwicHJvY2VzcyIsIkRlbm8kMSIsIkRlbm8iLCJ2ZXJzaW9ucyIsInZlcnNpb24iLCJ2OCIsIm1hdGNoIiwiZW5naW5lVjhWZXJzaW9uIiwiVjhfVkVSU0lPTiQxIiwiZmFpbHMkZyIsIm5hdGl2ZVN5bWJvbCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbCIsIlN5bWJvbCIsIlN0cmluZyIsInNoYW0iLCJOQVRJVkVfU1lNQk9MJDEiLCJ1c2VTeW1ib2xBc1VpZCIsIml0ZXJhdG9yIiwiZ2V0QnVpbHRJbiQ2IiwiaXNDYWxsYWJsZSRrIiwiaXNQcm90b3R5cGVPZiQzIiwiVVNFX1NZTUJPTF9BU19VSUQkMSIsIiRPYmplY3QkMyIsImlzU3ltYm9sJDIiLCIkU3ltYm9sIiwiJFN0cmluZyQzIiwidHJ5VG9TdHJpbmckNCIsImlzQ2FsbGFibGUkaiIsInRyeVRvU3RyaW5nJDMiLCIkVHlwZUVycm9yJGIiLCJhQ2FsbGFibGUkNyIsImFDYWxsYWJsZSQ2IiwiZ2V0TWV0aG9kJDQiLCJQIiwiZnVuYyIsImNhbGwkaSIsImlzQ2FsbGFibGUkaSIsImlzT2JqZWN0JDciLCIkVHlwZUVycm9yJGEiLCJvcmRpbmFyeVRvUHJpbWl0aXZlJDEiLCJpbnB1dCIsInByZWYiLCJ2YWwiLCJ2YWx1ZU9mIiwic2hhcmVkJDQiLCJleHBvcnRzIiwiaXNQdXJlIiwiZ2xvYmFsJGwiLCJkZWZpbmVQcm9wZXJ0eSQ2IiwiZGVmaW5lR2xvYmFsUHJvcGVydHkkMyIsImtleSIsImdsb2JhbCRrIiwiZGVmaW5lR2xvYmFsUHJvcGVydHkkMiIsIlNIQVJFRCIsInN0b3JlJDMiLCJzaGFyZWRTdG9yZSIsInN0b3JlJDIiLCJwdXNoIiwibW9kZSIsImNvcHlyaWdodCIsImxpY2Vuc2UiLCJzb3VyY2UiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIiLCIkT2JqZWN0JDIiLCJ0b09iamVjdCQ1IiwidW5jdXJyeVRoaXMkaSIsInRvT2JqZWN0JDQiLCJoYXNPd25Qcm9wZXJ0eV8xIiwiaGFzT3duIiwidW5jdXJyeVRoaXMkaCIsImlkIiwicG9zdGZpeCIsInJhbmRvbSIsInRvU3RyaW5nJDUiLCJ1aWQkMiIsImdsb2JhbCRqIiwic2hhcmVkJDMiLCJoYXNPd24kYyIsInVpZCQxIiwiTkFUSVZFX1NZTUJPTCIsIlVTRV9TWU1CT0xfQVNfVUlEIiwiV2VsbEtub3duU3ltYm9sc1N0b3JlIiwiU3ltYm9sJDEiLCJzeW1ib2xGb3IiLCJjcmVhdGVXZWxsS25vd25TeW1ib2wiLCJ3aXRob3V0U2V0dGVyIiwid2VsbEtub3duU3ltYm9sJGkiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJjYWxsJGgiLCJpc09iamVjdCQ2IiwiaXNTeW1ib2wkMSIsImdldE1ldGhvZCQzIiwib3JkaW5hcnlUb1ByaW1pdGl2ZSIsIndlbGxLbm93blN5bWJvbCRoIiwiJFR5cGVFcnJvciQ5IiwiVE9fUFJJTUlUSVZFIiwidG9QcmltaXRpdmUkMSIsImV4b3RpY1RvUHJpbSIsInJlc3VsdCIsInRvUHJpbWl0aXZlIiwiaXNTeW1ib2wiLCJ0b1Byb3BlcnR5S2V5JDMiLCJnbG9iYWwkaSIsImlzT2JqZWN0JDUiLCJkb2N1bWVudCQzIiwiZG9jdW1lbnQiLCJFWElTVFMkMSIsImNyZWF0ZUVsZW1lbnQiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQkMiIsIkRFU0NSSVBUT1JTJGMiLCJmYWlscyRmIiwiY3JlYXRlRWxlbWVudCQxIiwiaWU4RG9tRGVmaW5lIiwiYSIsIkRFU0NSSVBUT1JTJGIiLCJjYWxsJGciLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQiLCJ0b0luZGV4ZWRPYmplY3QkNCIsInRvUHJvcGVydHlLZXkkMiIsImhhc093biRiIiwiSUU4X0RPTV9ERUZJTkUkMSIsIiRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSIsIk8iLCJvYmplY3REZWZpbmVQcm9wZXJ0eSIsIkRFU0NSSVBUT1JTJGEiLCJmYWlscyRlIiwidjhQcm90b3R5cGVEZWZpbmVCdWciLCJpc09iamVjdCQ0IiwiJFN0cmluZyQyIiwiJFR5cGVFcnJvciQ4IiwiYW5PYmplY3QkZyIsIkRFU0NSSVBUT1JTJDkiLCJJRThfRE9NX0RFRklORSIsIlY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEiLCJhbk9iamVjdCRmIiwidG9Qcm9wZXJ0eUtleSQxIiwiJFR5cGVFcnJvciQ3IiwiJGRlZmluZVByb3BlcnR5IiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIkVOVU1FUkFCTEUiLCJDT05GSUdVUkFCTEUkMSIsIldSSVRBQkxFIiwiQXR0cmlidXRlcyIsImN1cnJlbnQiLCJERVNDUklQVE9SUyQ4IiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkNSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUiLCJvYmplY3QiLCJtYWtlQnVpbHRJbiQzIiwiREVTQ1JJUFRPUlMkNyIsImhhc093biRhIiwiRnVuY3Rpb25Qcm90b3R5cGUkMSIsImdldERlc2NyaXB0b3IiLCJFWElTVFMiLCJQUk9QRVIiLCJzb21ldGhpbmciLCJDT05GSUdVUkFCTEUiLCJmdW5jdGlvbk5hbWUiLCJ1bmN1cnJ5VGhpcyRnIiwiaXNDYWxsYWJsZSRoIiwic3RvcmUkMSIsImZ1bmN0aW9uVG9TdHJpbmciLCJpbnNwZWN0U291cmNlIiwiaW5zcGVjdFNvdXJjZSQ0IiwiZ2xvYmFsJGgiLCJpc0NhbGxhYmxlJGciLCJpbnNwZWN0U291cmNlJDMiLCJXZWFrTWFwJDEiLCJXZWFrTWFwIiwibmF0aXZlV2Vha01hcCIsInNoYXJlZCQyIiwidWlkIiwia2V5cyIsInNoYXJlZEtleSQzIiwiaGlkZGVuS2V5cyQ0IiwiTkFUSVZFX1dFQUtfTUFQIiwiZ2xvYmFsJGciLCJ1bmN1cnJ5VGhpcyRmIiwiaXNPYmplY3QkMyIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0IiwiaGFzT3duJDkiLCJzaGFyZWQkMSIsInNoYXJlZEtleSQyIiwiaGlkZGVuS2V5cyQzIiwiT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQiLCJUeXBlRXJyb3IkNCIsInNldCQxIiwiaGFzIiwiZW5mb3JjZSIsImdldHRlckZvciIsIlRZUEUiLCJzdGF0ZSIsInR5cGUiLCJzdG9yZSIsIndtZ2V0Iiwid21oYXMiLCJ3bXNldCIsInNldCIsIm1ldGFkYXRhIiwiZmFjYWRlIiwiU1RBVEUiLCJpbnRlcm5hbFN0YXRlIiwiZmFpbHMkZCIsImlzQ2FsbGFibGUkZiIsImhhc093biQ4IiwiREVTQ1JJUFRPUlMkNiIsIkNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEiLCJpbnNwZWN0U291cmNlJDIiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsImdldEludGVybmFsU3RhdGUkMyIsImRlZmluZVByb3BlcnR5JDUiLCJDT05GSUdVUkFCTEVfTEVOR1RIIiwiVEVNUExBVEUiLCJtYWtlQnVpbHRJbiQyIiwib3B0aW9ucyIsInJlcGxhY2UiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJhcml0eSIsImNvbnN0cnVjdG9yIiwiam9pbiIsImlzQ2FsbGFibGUkZSIsImRlZmluZVByb3BlcnR5TW9kdWxlJDQiLCJtYWtlQnVpbHRJbiQxIiwiZGVmaW5lR2xvYmFsUHJvcGVydHkkMSIsImRlZmluZUJ1aWx0SW4kYSIsInNpbXBsZSIsInVuc2FmZSIsIm5vbkNvbmZpZ3VyYWJsZSIsIm5vbldyaXRhYmxlIiwib2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyIsImNlaWwiLCJmbG9vciQ0IiwiZmxvb3IiLCJtYXRoVHJ1bmMiLCJ0cnVuYyIsIngiLCJuIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQ0IiwibnVtYmVyIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQzIiwibWF4JDIiLCJtYXgiLCJtaW4kMiIsIm1pbiIsInRvQWJzb2x1dGVJbmRleCQyIiwiaW5kZXgiLCJpbnRlZ2VyIiwidG9JbnRlZ2VyT3JJbmZpbml0eSQyIiwibWluJDEiLCJ0b0xlbmd0aCQyIiwidG9MZW5ndGgkMSIsImxlbmd0aE9mQXJyYXlMaWtlJDQiLCJvYmoiLCJ0b0luZGV4ZWRPYmplY3QkMyIsInRvQWJzb2x1dGVJbmRleCQxIiwibGVuZ3RoT2ZBcnJheUxpa2UkMyIsImNyZWF0ZU1ldGhvZCQxIiwiSVNfSU5DTFVERVMiLCIkdGhpcyIsImVsIiwiZnJvbUluZGV4IiwiYXJyYXlJbmNsdWRlcyIsImluY2x1ZGVzIiwiaW5kZXhPZiIsInVuY3VycnlUaGlzJGUiLCJoYXNPd24kNyIsInRvSW5kZXhlZE9iamVjdCQyIiwiaW5kZXhPZiQxIiwiaGlkZGVuS2V5cyQyIiwicHVzaCQ0Iiwib2JqZWN0S2V5c0ludGVybmFsIiwibmFtZXMiLCJpIiwiZW51bUJ1Z0tleXMkMyIsImludGVybmFsT2JqZWN0S2V5cyQxIiwiZW51bUJ1Z0tleXMkMiIsImhpZGRlbktleXMkMSIsImNvbmNhdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRCdWlsdEluJDUiLCJ1bmN1cnJ5VGhpcyRkIiwiZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSIsImdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxIiwiYW5PYmplY3QkZSIsImNvbmNhdCQyIiwib3duS2V5cyQxIiwib3duS2V5cyIsImhhc093biQ2IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkMyIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSIsInRhcmdldCIsImV4Y2VwdGlvbnMiLCJmYWlscyRjIiwiaXNDYWxsYWJsZSRkIiwicmVwbGFjZW1lbnQiLCJpc0ZvcmNlZCQyIiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInN0cmluZyIsInRvTG93ZXJDYXNlIiwiaXNGb3JjZWRfMSIsImdsb2JhbCRmIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyIsImRlZmluZUJ1aWx0SW4kOSIsImRlZmluZUdsb2JhbFByb3BlcnR5IiwiY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyIsImlzRm9yY2VkJDEiLCJfZXhwb3J0IiwiVEFSR0VUIiwiR0xPQkFMIiwiU1RBVElDIiwic3RhdCIsIkZPUkNFRCIsInRhcmdldFByb3BlcnR5Iiwic291cmNlUHJvcGVydHkiLCJkb250Q2FsbEdldFNldCIsImZvcmNlZCIsImludGVybmFsT2JqZWN0S2V5cyIsImVudW1CdWdLZXlzJDEiLCJvYmplY3RLZXlzJDIiLCJERVNDUklQVE9SUyQ1IiwidW5jdXJyeVRoaXMkYyIsImNhbGwkZiIsImZhaWxzJGIiLCJvYmplY3RLZXlzJDEiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsInRvT2JqZWN0JDMiLCJJbmRleGVkT2JqZWN0IiwiJGFzc2lnbiIsImFzc2lnbiIsImRlZmluZVByb3BlcnR5JDQiLCJjb25jYXQkMSIsIm9iamVjdEFzc2lnbiIsImIiLCJBIiwiQiIsImFscGhhYmV0IiwiZm9yRWFjaCIsImNociIsIlQiLCJhcmd1bWVudHNMZW5ndGgiLCJTIiwiaiIsIiQkYSIsImFzc2lnbiQxIiwid2VsbEtub3duU3ltYm9sJGciLCJUT19TVFJJTkdfVEFHJDMiLCJ0b1N0cmluZ1RhZ1N1cHBvcnQiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJpc0NhbGxhYmxlJGMiLCJjbGFzc29mUmF3Iiwid2VsbEtub3duU3ltYm9sJGYiLCJUT19TVFJJTkdfVEFHJDIiLCIkT2JqZWN0JDEiLCJDT1JSRUNUX0FSR1VNRU5UUyIsInRyeUdldCIsImNsYXNzb2YkNiIsInRhZyIsImNhbGxlZSIsImNsYXNzb2YkNSIsIiRTdHJpbmckMSIsInRvU3RyaW5nJDQiLCJhbk9iamVjdCRkIiwicmVnZXhwRmxhZ3MkMSIsInRoYXQiLCJoYXNJbmRpY2VzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImRvdEFsbCIsInVuaWNvZGUiLCJ1bmljb2RlU2V0cyIsInN0aWNreSIsImNhbGwkZSIsImhhc093biQ1IiwiaXNQcm90b3R5cGVPZiQyIiwicmVnRXhwRmxhZ3MiLCJSZWdFeHBQcm90b3R5cGUkMiIsIlJlZ0V4cCIsInJlZ2V4cEdldEZsYWdzIiwiUiIsImZsYWdzIiwiUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSIsImRlZmluZUJ1aWx0SW4kOCIsImFuT2JqZWN0JGMiLCIkdG9TdHJpbmckMiIsImZhaWxzJGEiLCJnZXRSZWdFeHBGbGFncyIsIlRPX1NUUklORyIsIlJlZ0V4cFByb3RvdHlwZSQxIiwibiRUb1N0cmluZyIsIk5PVF9HRU5FUklDIiwiSU5DT1JSRUNUX05BTUUiLCJwYXR0ZXJuIiwib2JqZWN0RGVmaW5lUHJvcGVydGllcyIsIkRFU0NSSVBUT1JTJDQiLCJWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyIsImRlZmluZVByb3BlcnR5TW9kdWxlJDIiLCJhbk9iamVjdCRiIiwidG9JbmRleGVkT2JqZWN0JDEiLCJvYmplY3RLZXlzIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJwcm9wcyIsImdldEJ1aWx0SW4kNCIsImh0bWwkMiIsImFuT2JqZWN0JGEiLCJkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlIiwiZW51bUJ1Z0tleXMiLCJoaWRkZW5LZXlzIiwiaHRtbCQxIiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50JDEiLCJzaGFyZWRLZXkkMSIsIkdUIiwiTFQiLCJQUk9UT1RZUEUiLCJTQ1JJUFQiLCJJRV9QUk9UTyQxIiwiRW1wdHlDb25zdHJ1Y3RvciIsInNjcmlwdFRhZyIsImNvbnRlbnQiLCJOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYIiwiYWN0aXZlWERvY3VtZW50Iiwid3JpdGUiLCJjbG9zZSIsInRlbXAiLCJwYXJlbnRXaW5kb3ciLCJOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUiLCJpZnJhbWUiLCJKUyIsImlmcmFtZURvY3VtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJzcmMiLCJjb250ZW50V2luZG93Iiwib3BlbiIsIkYiLCJOdWxsUHJvdG9PYmplY3QiLCJBY3RpdmVYT2JqZWN0IiwiZG9tYWluIiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwid2VsbEtub3duU3ltYm9sJGUiLCJjcmVhdGUkMyIsImRlZmluZVByb3BlcnR5JDMiLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG90eXBlJDEiLCJBcnJheSIsImFkZFRvVW5zY29wYWJsZXMkMSIsIml0ZXJhdG9ycyIsImZhaWxzJDkiLCJjb3JyZWN0UHJvdG90eXBlR2V0dGVyIiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNPd24kNCIsImlzQ2FsbGFibGUkYiIsInRvT2JqZWN0JDIiLCJzaGFyZWRLZXkiLCJDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIiLCJJRV9QUk9UTyIsIiRPYmplY3QiLCJPYmplY3RQcm90b3R5cGUiLCJvYmplY3RHZXRQcm90b3R5cGVPZiIsImZhaWxzJDgiLCJpc0NhbGxhYmxlJGEiLCJnZXRQcm90b3R5cGVPZiQxIiwiZGVmaW5lQnVpbHRJbiQ3Iiwid2VsbEtub3duU3ltYm9sJGQiLCJJVEVSQVRPUiQ3IiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxIiwiSXRlcmF0b3JQcm90b3R5cGUkMiIsIlByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3IiLCJORVdfSVRFUkFUT1JfUFJPVE9UWVBFIiwiaXRlcmF0b3JzQ29yZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyIsImRlZmluZVByb3BlcnR5JDIiLCJoYXNPd24kMyIsIndlbGxLbm93blN5bWJvbCRjIiwiVE9fU1RSSU5HX1RBRyQxIiwic2V0VG9TdHJpbmdUYWckNSIsIlRBRyIsIkl0ZXJhdG9yUHJvdG90eXBlJDEiLCJjcmVhdGUkMiIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyIiwic2V0VG9TdHJpbmdUYWckNCIsIkl0ZXJhdG9ycyQ0IiwicmV0dXJuVGhpcyQxIiwiY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQyIiwiSXRlcmF0b3JDb25zdHJ1Y3RvciIsIk5BTUUiLCJuZXh0IiwiRU5VTUVSQUJMRV9ORVhUIiwiVE9fU1RSSU5HX1RBRyIsImlzQ2FsbGFibGUkOSIsIiRTdHJpbmciLCIkVHlwZUVycm9yJDYiLCJhUG9zc2libGVQcm90b3R5cGUkMSIsInVuY3VycnlUaGlzJGIiLCJhbk9iamVjdCQ5IiwiYVBvc3NpYmxlUHJvdG90eXBlIiwib2JqZWN0U2V0UHJvdG90eXBlT2YiLCJzZXRQcm90b3R5cGVPZiIsIkNPUlJFQ1RfU0VUVEVSIiwicHJvdG8iLCJfX3Byb3RvX18iLCIkJDkiLCJjYWxsJGQiLCJGdW5jdGlvbk5hbWUiLCJpc0NhbGxhYmxlJDgiLCJjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDEiLCJzZXRQcm90b3R5cGVPZiQxIiwic2V0VG9TdHJpbmdUYWckMyIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyIiwiZGVmaW5lQnVpbHRJbiQ2Iiwid2VsbEtub3duU3ltYm9sJGIiLCJJdGVyYXRvcnMkMyIsIkl0ZXJhdG9yc0NvcmUiLCJQUk9QRVJfRlVOQ1RJT05fTkFNRSIsIkNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FIiwiSVRFUkFUT1IkNiIsIktFWVMiLCJWQUxVRVMiLCJFTlRSSUVTIiwicmV0dXJuVGhpcyIsImRlZmluZUl0ZXJhdG9yJDIiLCJJdGVyYWJsZSIsIkRFRkFVTFQiLCJJU19TRVQiLCJnZXRJdGVyYXRpb25NZXRob2QiLCJLSU5EIiwiZGVmYXVsdEl0ZXJhdG9yIiwiSXRlcmFibGVQcm90b3R5cGUiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiSU5DT1JSRUNUX1ZBTFVFU19OQU1FIiwibmF0aXZlSXRlcmF0b3IiLCJhbnlOYXRpdmVJdGVyYXRvciIsIkN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSIsIm1ldGhvZHMiLCJLRVkiLCJ0b0luZGV4ZWRPYmplY3QiLCJhZGRUb1Vuc2NvcGFibGVzIiwiSXRlcmF0b3JzJDIiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDQiLCJkZWZpbmVQcm9wZXJ0eSQxIiwiZGVmaW5lSXRlcmF0b3IkMSIsIkRFU0NSSVBUT1JTJDMiLCJBUlJBWV9JVEVSQVRPUiIsInNldEludGVybmFsU3RhdGUkNCIsImdldEludGVybmFsU3RhdGUkMiIsImVzX2FycmF5X2l0ZXJhdG9yIiwiaXRlcmF0ZWQiLCJraW5kIiwiZG9uZSIsIkFyZ3VtZW50cyIsImNsYXNzb2YkNCIsImdsb2JhbCRlIiwiZW5naW5lSXNOb2RlIiwiZ2V0QnVpbHRJbiQzIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkMSIsIndlbGxLbm93blN5bWJvbCRhIiwiREVTQ1JJUFRPUlMkMiIsIlNQRUNJRVMkMyIsInNldFNwZWNpZXMkMSIsIkNPTlNUUlVDVE9SX05BTUUiLCJDb25zdHJ1Y3RvciIsImlzUHJvdG90eXBlT2YkMSIsIiRUeXBlRXJyb3IkNSIsImFuSW5zdGFuY2UkMyIsIlByb3RvdHlwZSIsInVuY3VycnlUaGlzJGEiLCJmYWlscyQ3IiwiaXNDYWxsYWJsZSQ3IiwiY2xhc3NvZiQzIiwiZ2V0QnVpbHRJbiQyIiwiaW5zcGVjdFNvdXJjZSQxIiwibm9vcCIsImVtcHR5IiwiY29uc3RydWN0IiwiY29uc3RydWN0b3JSZWdFeHAiLCJleGVjJDMiLCJJTkNPUlJFQ1RfVE9fU1RSSU5HIiwiaXNDb25zdHJ1Y3Rvck1vZGVybiIsImlzQ29uc3RydWN0b3IiLCJpc0NvbnN0cnVjdG9yTGVnYWN5IiwiaXNDb25zdHJ1Y3RvciQyIiwiY2FsbGVkIiwiaXNDb25zdHJ1Y3RvciQxIiwidHJ5VG9TdHJpbmckMiIsIiRUeXBlRXJyb3IkNCIsImFDb25zdHJ1Y3RvciQxIiwiYW5PYmplY3QkOCIsImFDb25zdHJ1Y3RvciIsIndlbGxLbm93blN5bWJvbCQ5IiwiU1BFQ0lFUyQyIiwic3BlY2llc0NvbnN0cnVjdG9yJDEiLCJkZWZhdWx0Q29uc3RydWN0b3IiLCJDIiwiTkFUSVZFX0JJTkQkMSIsIkZ1bmN0aW9uUHJvdG90eXBlIiwiYXBwbHkkMiIsImNhbGwkYyIsImZ1bmN0aW9uQXBwbHkiLCJSZWZsZWN0IiwidW5jdXJyeVRoaXMkOSIsImFDYWxsYWJsZSQ1IiwiTkFUSVZFX0JJTkQiLCJiaW5kJDciLCJmdW5jdGlvbkJpbmRDb250ZXh0IiwidW5jdXJyeVRoaXMkOCIsImFycmF5U2xpY2UkMyIsIiRUeXBlRXJyb3IkMyIsInZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDMiLCJwYXNzZWQiLCJyZXF1aXJlZCIsInVzZXJBZ2VudCQyIiwiZW5naW5lSXNJb3MiLCJnbG9iYWwkZCIsImFwcGx5JDEiLCJiaW5kJDYiLCJpc0NhbGxhYmxlJDYiLCJoYXNPd24kMiIsImZhaWxzJDYiLCJodG1sIiwiYXJyYXlTbGljZSQyIiwidmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMiIsIklTX0lPUyQxIiwiSVNfTk9ERSQyIiwic2V0SW1tZWRpYXRlIiwiY2xlYXIiLCJjbGVhckltbWVkaWF0ZSIsInByb2Nlc3MkMiIsIkRpc3BhdGNoIiwiRnVuY3Rpb24kMSIsIk1lc3NhZ2VDaGFubmVsIiwiU3RyaW5nJDEiLCJjb3VudGVyIiwicXVldWUkMSIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImxvY2F0aW9uIiwiZGVmZXIiLCJjaGFubmVsIiwicG9ydCIsInJ1biIsInJ1bm5lciIsImxpc3RlbmVyIiwiZXZlbnQiLCJwb3N0IiwicG9zdE1lc3NhZ2UiLCJwcm90b2NvbCIsImhvc3QiLCJoYW5kbGVyIiwiYXJncyIsIm5leHRUaWNrIiwibm93IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbXBvcnRTY3JpcHRzIiwicmVtb3ZlQ2hpbGQiLCJzZXRUaW1lb3V0IiwidGFzayQxIiwidXNlckFnZW50JDEiLCJnbG9iYWwkYyIsImVuZ2luZUlzSW9zUGViYmxlIiwiUGViYmxlIiwidXNlckFnZW50IiwiZW5naW5lSXNXZWJvc1dlYmtpdCIsImdsb2JhbCRiIiwiYmluZCQ1IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJtYWNyb3Rhc2siLCJJU19JT1MiLCJJU19JT1NfUEVCQkxFIiwiSVNfV0VCT1NfV0VCS0lUIiwiSVNfTk9ERSQxIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJkb2N1bWVudCQyIiwicHJvY2VzcyQxIiwiUHJvbWlzZSQxIiwiUHJvbWlzZSIsInF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciIsInF1ZXVlTWljcm90YXNrIiwiZmx1c2giLCJoZWFkIiwibGFzdCIsIm5vdGlmeSQxIiwidG9nZ2xlIiwibm9kZSIsInByb21pc2UiLCJ0aGVuIiwicGFyZW50IiwiZXhpdCIsImVudGVyIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInJlc29sdmUiLCJtaWNyb3Rhc2skMSIsInRhc2siLCJnbG9iYWwkYSIsImhvc3RSZXBvcnRFcnJvcnMkMSIsImNvbnNvbGUiLCJwZXJmb3JtJDMiLCJRdWV1ZSQxIiwidGFpbCIsImFkZCIsIml0ZW0iLCJlbnRyeSIsInF1ZXVlIiwiZ2xvYmFsJDkiLCJwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IiLCJlbmdpbmVJc0Jyb3dzZXIiLCJnbG9iYWwkOCIsIk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzIiwiaXNDYWxsYWJsZSQ1IiwiaXNGb3JjZWQiLCJ3ZWxsS25vd25TeW1ib2wkOCIsIklTX0JST1dTRVIiLCJWOF9WRVJTSU9OIiwiU1BFQ0lFUyQxIiwiU1VCQ0xBU1NJTkciLCJOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDUiLCJQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSIsIkdMT0JBTF9DT1JFX0pTX1BST01JU0UiLCJGYWtlUHJvbWlzZSIsInByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiIsIkNPTlNUUlVDVE9SIiwiUkVKRUNUSU9OX0VWRU5UIiwibmV3UHJvbWlzZUNhcGFiaWxpdHkkMiIsImFDYWxsYWJsZSQ0IiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJyZWplY3QiLCIkJHJlc29sdmUiLCIkJHJlamVjdCIsIiQkOCIsIklTX05PREUiLCJnbG9iYWwkNyIsImNhbGwkYiIsImRlZmluZUJ1aWx0SW4kNSIsInNldFRvU3RyaW5nVGFnJDIiLCJzZXRTcGVjaWVzIiwiYUNhbGxhYmxlJDMiLCJpc0NhbGxhYmxlJDQiLCJpc09iamVjdCQyIiwiYW5JbnN0YW5jZSQyIiwic3BlY2llc0NvbnN0cnVjdG9yIiwibWljcm90YXNrIiwiaG9zdFJlcG9ydEVycm9ycyIsInBlcmZvcm0kMiIsIlF1ZXVlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSQzIiwiTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIiLCJQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24iLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzIiwiUFJPTUlTRSIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQiLCJOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQiLCJOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyIsImdldEludGVybmFsUHJvbWlzZVN0YXRlIiwic2V0SW50ZXJuYWxTdGF0ZSQzIiwiTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxIiwiUHJvbWlzZUNvbnN0cnVjdG9yIiwiUHJvbWlzZVByb3RvdHlwZSIsIlR5cGVFcnJvciQzIiwiZG9jdW1lbnQkMSIsIm5ld1Byb21pc2VDYXBhYmlsaXR5JDEiLCJuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkiLCJESVNQQVRDSF9FVkVOVCIsImNyZWF0ZUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIlVOSEFORExFRF9SRUpFQ1RJT04iLCJSRUpFQ1RJT05fSEFORExFRCIsIlBFTkRJTkciLCJGVUxGSUxMRUQiLCJSRUpFQ1RFRCIsIkhBTkRMRUQiLCJVTkhBTkRMRUQiLCJJbnRlcm5hbCIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiUHJvbWlzZVdyYXBwZXIiLCJuYXRpdmVUaGVuIiwiaXNUaGVuYWJsZSIsImNhbGxSZWFjdGlvbiIsInJlYWN0aW9uIiwib2siLCJmYWlsIiwiZXhpdGVkIiwicmVqZWN0aW9uIiwib25IYW5kbGVVbmhhbmRsZWQiLCJub3RpZnkiLCJpc1JlamVjdCIsIm5vdGlmaWVkIiwicmVhY3Rpb25zIiwib25VbmhhbmRsZWQiLCJyZWFzb24iLCJpbml0RXZlbnQiLCJJU19VTkhBTkRMRUQiLCJpc1VuaGFuZGxlZCIsImVtaXQiLCJiaW5kJDQiLCJ1bndyYXAiLCJpbnRlcm5hbFJlamVjdCIsImludGVybmFsUmVzb2x2ZSIsIndyYXBwZXIiLCJleGVjdXRvciIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsIndyYXAiLCJ3ZWxsS25vd25TeW1ib2wkNyIsIkl0ZXJhdG9ycyQxIiwiSVRFUkFUT1IkNSIsIkFycmF5UHJvdG90eXBlIiwiaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDIiLCJjbGFzc29mJDIiLCJnZXRNZXRob2QkMiIsIkl0ZXJhdG9ycyIsIndlbGxLbm93blN5bWJvbCQ2IiwiSVRFUkFUT1IkNCIsImdldEl0ZXJhdG9yTWV0aG9kJDQiLCJjYWxsJGEiLCJhQ2FsbGFibGUkMiIsImFuT2JqZWN0JDciLCJ0cnlUb1N0cmluZyQxIiwiZ2V0SXRlcmF0b3JNZXRob2QkMyIsIiRUeXBlRXJyb3IkMiIsImdldEl0ZXJhdG9yJDMiLCJ1c2luZ0l0ZXJhdG9yIiwiaXRlcmF0b3JNZXRob2QiLCJjYWxsJDkiLCJhbk9iamVjdCQ2IiwiZ2V0TWV0aG9kJDEiLCJpdGVyYXRvckNsb3NlJDIiLCJpbm5lclJlc3VsdCIsImlubmVyRXJyb3IiLCJiaW5kJDMiLCJjYWxsJDgiLCJhbk9iamVjdCQ1IiwidHJ5VG9TdHJpbmciLCJpc0FycmF5SXRlcmF0b3JNZXRob2QkMSIsImxlbmd0aE9mQXJyYXlMaWtlJDIiLCJnZXRJdGVyYXRvciQyIiwiZ2V0SXRlcmF0b3JNZXRob2QkMiIsIml0ZXJhdG9yQ2xvc2UkMSIsIiRUeXBlRXJyb3IkMSIsIlJlc3VsdCIsInN0b3BwZWQiLCJSZXN1bHRQcm90b3R5cGUiLCJpdGVyYXRlJDIiLCJpdGVyYWJsZSIsInVuYm91bmRGdW5jdGlvbiIsIkFTX0VOVFJJRVMiLCJJU19JVEVSQVRPUiIsIklOVEVSUlVQVEVEIiwiaXRlckZuIiwic3RlcCIsInN0b3AiLCJjb25kaXRpb24iLCJjYWxsRm4iLCJ3ZWxsS25vd25TeW1ib2wkNSIsIklURVJBVE9SJDMiLCJTQUZFX0NMT1NJTkciLCJpdGVyYXRvcldpdGhSZXR1cm4iLCJmcm9tIiwiY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEiLCJTS0lQX0NMT1NJTkciLCJJVEVSQVRJT05fU1VQUE9SVCIsIk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxIiwiY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uIiwiRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyIsInByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uIiwiYWxsIiwiJCQ3IiwiY2FsbCQ3IiwiYUNhbGxhYmxlJDEiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyIiwicGVyZm9ybSQxIiwiaXRlcmF0ZSQxIiwiUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04kMSIsImNhcGFiaWxpdHkiLCIkcHJvbWlzZVJlc29sdmUiLCJyZW1haW5pbmciLCJhbHJlYWR5Q2FsbGVkIiwiJCQ2IiwiRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiIsIk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciIsImdldEJ1aWx0SW4kMSIsImlzQ2FsbGFibGUkMyIsImRlZmluZUJ1aWx0SW4kNCIsIk5hdGl2ZVByb21pc2VQcm90b3R5cGUiLCJyZWFsIiwiJCQ1IiwiY2FsbCQ2IiwiYUNhbGxhYmxlIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMSIsInBlcmZvcm0iLCJpdGVyYXRlIiwiUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04iLCJyYWNlIiwiJCQ0IiwiY2FsbCQ1IiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQxIiwiciIsImFuT2JqZWN0JDQiLCJpc09iamVjdCQxIiwibmV3UHJvbWlzZUNhcGFiaWxpdHkiLCJwcm9taXNlUmVzb2x2ZSQxIiwicHJvbWlzZUNhcGFiaWxpdHkiLCIkJDMiLCJnZXRCdWlsdEluIiwiRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IiLCJwcm9taXNlUmVzb2x2ZSIsImRvbUl0ZXJhYmxlcyIsIkNTU1J1bGVMaXN0IiwiQ1NTU3R5bGVEZWNsYXJhdGlvbiIsIkNTU1ZhbHVlTGlzdCIsIkNsaWVudFJlY3RMaXN0IiwiRE9NUmVjdExpc3QiLCJET01TdHJpbmdMaXN0IiwiRE9NVG9rZW5MaXN0IiwiRGF0YVRyYW5zZmVySXRlbUxpc3QiLCJGaWxlTGlzdCIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIk1lZGlhTGlzdCIsIk1pbWVUeXBlQXJyYXkiLCJOYW1lZE5vZGVNYXAiLCJOb2RlTGlzdCIsIlBhaW50UmVxdWVzdExpc3QiLCJQbHVnaW4iLCJQbHVnaW5BcnJheSIsIlNWR0xlbmd0aExpc3QiLCJTVkdOdW1iZXJMaXN0IiwiU1ZHUGF0aFNlZ0xpc3QiLCJTVkdQb2ludExpc3QiLCJTVkdTdHJpbmdMaXN0IiwiU1ZHVHJhbnNmb3JtTGlzdCIsIlNvdXJjZUJ1ZmZlckxpc3QiLCJTdHlsZVNoZWV0TGlzdCIsIlRleHRUcmFja0N1ZUxpc3QiLCJUZXh0VHJhY2tMaXN0IiwiVG91Y2hMaXN0IiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEiLCJkb21Ub2tlbkxpc3RQcm90b3R5cGUiLCJnbG9iYWwkNiIsIkRPTUl0ZXJhYmxlcyIsIkRPTVRva2VuTGlzdFByb3RvdHlwZSIsIkFycmF5SXRlcmF0b3JNZXRob2RzIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEiLCJ3ZWxsS25vd25TeW1ib2wkNCIsIklURVJBVE9SJDIiLCJBcnJheVZhbHVlcyIsImhhbmRsZVByb3RvdHlwZSIsIkNvbGxlY3Rpb25Qcm90b3R5cGUiLCJDT0xMRUNUSU9OX05BTUUiLCJNRVRIT0RfTkFNRSIsInVuY3VycnlUaGlzJDciLCJ0b0ludGVnZXJPckluZmluaXR5JDEiLCJ0b1N0cmluZyQzIiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSQxIiwiY2hhckF0JDYiLCJjaGFyQXQiLCJjaGFyQ29kZUF0JDEiLCJjaGFyQ29kZUF0Iiwic3RyaW5nU2xpY2UkNSIsImNyZWF0ZU1ldGhvZCIsIkNPTlZFUlRfVE9fU1RSSU5HIiwicG9zIiwicG9zaXRpb24iLCJzaXplIiwiZmlyc3QiLCJzZWNvbmQiLCJzdHJpbmdNdWx0aWJ5dGUiLCJjb2RlQXQiLCJjaGFyQXQkNSIsInRvU3RyaW5nJDIiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDIiLCJkZWZpbmVJdGVyYXRvciIsIlNUUklOR19JVEVSQVRPUiIsInNldEludGVybmFsU3RhdGUkMiIsImdldEludGVybmFsU3RhdGUkMSIsInBvaW50IiwiZmFpbHMkNSIsIndlbGxLbm93blN5bWJvbCQzIiwiSVNfUFVSRSIsIklURVJBVE9SJDEiLCJuYXRpdmVVcmwiLCJ1cmwiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsInRvSlNPTiIsInNvcnQiLCJocmVmIiwiVVJMU2VhcmNoUGFyYW1zIiwidXNlcm5hbWUiLCJoYXNoIiwibWFrZUJ1aWx0SW4iLCJkZWZpbmVCdWlsdEluQWNjZXNzb3IkMSIsImFuT2JqZWN0JDMiLCJpdGVyYXRvckNsb3NlIiwiY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyQxIiwidG9Qcm9wZXJ0eUtleSIsImRlZmluZVByb3BlcnR5TW9kdWxlIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJjcmVhdGVQcm9wZXJ0eSQyIiwicHJvcGVydHlLZXkiLCJiaW5kJDIiLCJjYWxsJDQiLCJ0b09iamVjdCQxIiwiY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyIsImlzQXJyYXlJdGVyYXRvck1ldGhvZCIsImxlbmd0aE9mQXJyYXlMaWtlJDEiLCJjcmVhdGVQcm9wZXJ0eSQxIiwiZ2V0SXRlcmF0b3IkMSIsImdldEl0ZXJhdG9yTWV0aG9kJDEiLCIkQXJyYXkkMSIsImFycmF5RnJvbSQxIiwiYXJyYXlMaWtlIiwiSVNfQ09OU1RSVUNUT1IiLCJtYXBmbiIsIm1hcHBpbmciLCJ0b0Fic29sdXRlSW5kZXgiLCJsZW5ndGhPZkFycmF5TGlrZSIsImNyZWF0ZVByb3BlcnR5IiwiJEFycmF5IiwibWF4JDEiLCJhcnJheVNsaWNlU2ltcGxlIiwic3RhcnQiLCJlbmQiLCJrIiwiZmluIiwidW5jdXJyeVRoaXMkNiIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJPVkVSRkxPV19FUlJPUiIsImJhc2VNaW51c1RNaW4iLCIkUmFuZ2VFcnJvciIsIlJhbmdlRXJyb3IiLCJleGVjJDIiLCJmbG9vciQzIiwiZnJvbUNoYXJDb2RlIiwiam9pbiQyIiwicHVzaCQzIiwicmVwbGFjZSQ0Iiwic3BsaXQkMiIsInRvTG93ZXJDYXNlJDEiLCJ1Y3MyZGVjb2RlIiwib3V0cHV0IiwiZXh0cmEiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJlbmNvZGUiLCJpbnB1dExlbmd0aCIsImJpYXMiLCJjdXJyZW50VmFsdWUiLCJiYXNpY0xlbmd0aCIsImhhbmRsZWRDUENvdW50IiwibSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInEiLCJ0IiwicU1pbnVzVCIsImJhc2VNaW51c1QiLCJzdHJpbmdQdW55Y29kZVRvQXNjaWkiLCJlbmNvZGVkIiwibGFiZWxzIiwibGFiZWwiLCJkZWZpbmVCdWlsdEluJDMiLCJkZWZpbmVCdWlsdElucyQxIiwiYXJyYXlTbGljZSQxIiwiZmxvb3IkMiIsIm1lcmdlU29ydCIsImFycmF5IiwiY29tcGFyZWZuIiwibWlkZGxlIiwiaW5zZXJ0aW9uU29ydCIsIm1lcmdlIiwiZWxlbWVudCIsImxlZnQiLCJyaWdodCIsImxsZW5ndGgiLCJybGVuZ3RoIiwibGluZGV4IiwicmluZGV4IiwiYXJyYXlTb3J0JDEiLCIkJDIiLCJnbG9iYWwkNSIsImNhbGwkMyIsInVuY3VycnlUaGlzJDUiLCJERVNDUklQVE9SUyQxIiwiVVNFX05BVElWRV9VUkwkMSIsImRlZmluZUJ1aWx0SW4kMiIsImRlZmluZUJ1aWx0SW5zIiwic2V0VG9TdHJpbmdUYWckMSIsImNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDEiLCJhbkluc3RhbmNlJDEiLCJpc0NhbGxhYmxlJDIiLCJoYXNPd24kMSIsImJpbmQkMSIsImNsYXNzb2YkMSIsImFuT2JqZWN0JDIiLCJpc09iamVjdCIsIiR0b1N0cmluZyQxIiwiY3JlYXRlJDEiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRJdGVyYXRvciIsImdldEl0ZXJhdG9yTWV0aG9kIiwidmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMSIsIndlbGxLbm93blN5bWJvbCQyIiwiYXJyYXlTb3J0IiwiSVRFUkFUT1IiLCJVUkxfU0VBUkNIX1BBUkFNUyIsIlVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SIiwic2V0SW50ZXJuYWxTdGF0ZSQxIiwiZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSIsImdldEludGVybmFsSXRlcmF0b3JTdGF0ZSIsInNhZmVHZXRCdWlsdEluIiwibmF0aXZlRmV0Y2giLCJOYXRpdmVSZXF1ZXN0IiwiSGVhZGVycyIsIlJlcXVlc3RQcm90b3R5cGUiLCJIZWFkZXJzUHJvdG90eXBlIiwiUmVnRXhwJDEiLCJUeXBlRXJyb3IkMiIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSUNvbXBvbmVudCQxIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY2hhckF0JDQiLCJqb2luJDEiLCJwdXNoJDIiLCJyZXBsYWNlJDMiLCJzaGlmdCQxIiwic2hpZnQiLCJzcGxpY2UiLCJzcGxpdCQxIiwic3RyaW5nU2xpY2UkNCIsInBsdXMiLCJzZXF1ZW5jZXMiLCJwZXJjZW50U2VxdWVuY2UiLCJieXRlcyIsInBlcmNlbnREZWNvZGUiLCJzZXF1ZW5jZSIsImRlc2VyaWFsaXplIiwiZmluZCIsInJlcGxhY2VtZW50cyIsInJlcGxhY2VyIiwic2VyaWFsaXplIiwiVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IiLCJJdGVyYXRvciIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtc1N0YXRlIiwiaW5pdCIsInBhcnNlT2JqZWN0IiwicGFyc2VRdWVyeSIsImJpbmRVUkwiLCJ1cGRhdGUiLCJlbnRyeUl0ZXJhdG9yIiwiZW50cnlOZXh0IiwicXVlcnkiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlIiwidXBkYXRlVVJMIiwiVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IiLCJVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUiLCJhcHBlbmQiLCJnZXRBbGwiLCJmb3VuZCIsImNhbGxiYWNrIiwiYm91bmRGdW5jdGlvbiIsImhlYWRlcnNIYXMiLCJoZWFkZXJzU2V0Iiwid3JhcFJlcXVlc3RPcHRpb25zIiwiYm9keSIsImhlYWRlcnMiLCJmZXRjaCIsIlJlcXVlc3RDb25zdHJ1Y3RvciIsIlJlcXVlc3QiLCJ3ZWJfdXJsU2VhcmNoUGFyYW1zX2NvbnN0cnVjdG9yIiwiZ2V0U3RhdGUiLCIkJDEiLCJERVNDUklQVE9SUyIsIlVTRV9OQVRJVkVfVVJMIiwiZ2xvYmFsJDQiLCJ1bmN1cnJ5VGhpcyQ0IiwiZGVmaW5lQnVpbHRJbiQxIiwiZGVmaW5lQnVpbHRJbkFjY2Vzc29yIiwiYW5JbnN0YW5jZSIsImFycmF5RnJvbSIsImFycmF5U2xpY2UiLCJ0b0FTQ0lJIiwiJHRvU3RyaW5nIiwic2V0VG9TdHJpbmdUYWciLCJ2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCIsIlVSTFNlYXJjaFBhcmFtc01vZHVsZSIsIkludGVybmFsU3RhdGVNb2R1bGUiLCJzZXRJbnRlcm5hbFN0YXRlIiwiZ2V0SW50ZXJuYWxVUkxTdGF0ZSIsIlVSTFNlYXJjaFBhcmFtcyQxIiwiZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZSIsIk5hdGl2ZVVSTCIsIlR5cGVFcnJvciQxIiwicGFyc2VJbnQiLCJmbG9vciQxIiwicG93IiwiY2hhckF0JDMiLCJleGVjJDEiLCJudW1iZXJUb1N0cmluZyIsInBvcCIsInB1c2gkMSIsInJlcGxhY2UkMiIsInN0cmluZ1NsaWNlJDMiLCJ1bnNoaWZ0IiwiSU5WQUxJRF9BVVRIT1JJVFkiLCJJTlZBTElEX1NDSEVNRSIsIklOVkFMSURfSE9TVCIsIklOVkFMSURfUE9SVCIsIkFMUEhBIiwiQUxQSEFOVU1FUklDIiwiRElHSVQiLCJIRVhfU1RBUlQiLCJPQ1QiLCJERUMiLCJIRVgiLCJGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UIiwiRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVF9FWENMVURJTkdfUEVSQ0VOVCIsIkxFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UiLCJUQUJfQU5EX05FV19MSU5FIiwiRU9GIiwicGFyc2VJUHY0IiwicGFydHMiLCJwYXJ0c0xlbmd0aCIsIm51bWJlcnMiLCJwYXJ0IiwicmFkaXgiLCJpcHY0IiwicGFyc2VJUHY2IiwiYWRkcmVzcyIsInBpZWNlSW5kZXgiLCJjb21wcmVzcyIsInBvaW50ZXIiLCJudW1iZXJzU2VlbiIsImlwdjRQaWVjZSIsInN3YXBzIiwic3dhcCIsImZpbmRMb25nZXN0WmVyb1NlcXVlbmNlIiwiaXB2NiIsIm1heEluZGV4IiwibWF4TGVuZ3RoIiwiY3VyclN0YXJ0IiwiY3Vyckxlbmd0aCIsInNlcmlhbGl6ZUhvc3QiLCJpZ25vcmUwIiwiQzBDb250cm9sUGVyY2VudEVuY29kZVNldCIsImZyYWdtZW50UGVyY2VudEVuY29kZVNldCIsInBhdGhQZXJjZW50RW5jb2RlU2V0IiwidXNlcmluZm9QZXJjZW50RW5jb2RlU2V0IiwicGVyY2VudEVuY29kZSIsImNvZGUiLCJzcGVjaWFsU2NoZW1lcyIsImZ0cCIsImZpbGUiLCJodHRwIiwiaHR0cHMiLCJ3cyIsIndzcyIsImlzV2luZG93c0RyaXZlTGV0dGVyIiwibm9ybWFsaXplZCIsInN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIiLCJ0aGlyZCIsImlzU2luZ2xlRG90Iiwic2VnbWVudCIsImlzRG91YmxlRG90IiwiU0NIRU1FX1NUQVJUIiwiU0NIRU1FIiwiTk9fU0NIRU1FIiwiU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFkiLCJQQVRIX09SX0FVVEhPUklUWSIsIlJFTEFUSVZFIiwiUkVMQVRJVkVfU0xBU0giLCJTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTIiwiU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVMiLCJBVVRIT1JJVFkiLCJIT1NUIiwiSE9TVE5BTUUiLCJQT1JUIiwiRklMRSIsIkZJTEVfU0xBU0giLCJGSUxFX0hPU1QiLCJQQVRIX1NUQVJUIiwiUEFUSCIsIkNBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEgiLCJRVUVSWSIsIkZSQUdNRU5UIiwiVVJMU3RhdGUiLCJpc0Jhc2UiLCJ1cmxTdHJpbmciLCJiYXNlU3RhdGUiLCJmYWlsdXJlIiwicGFyc2UiLCJzdGF0ZU92ZXJyaWRlIiwiYnVmZmVyIiwic2VlbkF0Iiwic2VlbkJyYWNrZXQiLCJzZWVuUGFzc3dvcmRUb2tlbiIsImNvZGVQb2ludHMiLCJidWZmZXJDb2RlUG9pbnRzIiwic2NoZW1lIiwicGFzc3dvcmQiLCJwYXRoIiwiZnJhZ21lbnQiLCJjYW5ub3RCZUFCYXNlVVJMIiwiaXNTcGVjaWFsIiwiaW5jbHVkZXNDcmVkZW50aWFscyIsImNvZGVQb2ludCIsImVuY29kZWRDb2RlUG9pbnRzIiwicGFyc2VIb3N0Iiwic2hvcnRlblBhdGgiLCJjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQiLCJwYXRoU2l6ZSIsInNldEhyZWYiLCJnZXRPcmlnaW4iLCJVUkxDb25zdHJ1Y3RvciIsIm9yaWdpbiIsImdldFByb3RvY29sIiwic2V0UHJvdG9jb2wiLCJnZXRVc2VybmFtZSIsInNldFVzZXJuYW1lIiwiZ2V0UGFzc3dvcmQiLCJzZXRQYXNzd29yZCIsImdldEhvc3QiLCJzZXRIb3N0IiwiZ2V0SG9zdG5hbWUiLCJzZXRIb3N0bmFtZSIsImhvc3RuYW1lIiwiZ2V0UG9ydCIsInNldFBvcnQiLCJnZXRQYXRobmFtZSIsInNldFBhdGhuYW1lIiwiZ2V0U2VhcmNoIiwic2V0U2VhcmNoIiwic2VhcmNoIiwiZ2V0U2VhcmNoUGFyYW1zIiwiZ2V0SGFzaCIsInNldEhhc2giLCJVUkxQcm90b3R5cGUiLCJhY2Nlc3NvckRlc2NyaXB0b3IiLCJuYXRpdmVDcmVhdGVPYmplY3RVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJuYXRpdmVSZXZva2VPYmplY3RVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJmYWlscyQ0IiwiZ2xvYmFsJDMiLCIkUmVnRXhwJDIiLCJVTlNVUFBPUlRFRF9ZJDEiLCJyZSIsImxhc3RJbmRleCIsIk1JU1NFRF9TVElDS1kiLCJCUk9LRU5fQ0FSRVQiLCJyZWdleHBTdGlja3lIZWxwZXJzIiwiVU5TVVBQT1JURURfWSIsImZhaWxzJDMiLCJnbG9iYWwkMiIsIiRSZWdFeHAkMSIsInJlZ2V4cFVuc3VwcG9ydGVkRG90QWxsIiwiZmFpbHMkMiIsImdsb2JhbCQxIiwiJFJlZ0V4cCIsInJlZ2V4cFVuc3VwcG9ydGVkTmNnIiwiZ3JvdXBzIiwiY2FsbCQyIiwidW5jdXJyeVRoaXMkMyIsInRvU3RyaW5nJDEiLCJyZWdleHBGbGFncyIsInN0aWNreUhlbHBlcnMiLCJzaGFyZWQiLCJnZXRJbnRlcm5hbFN0YXRlIiwiVU5TVVBQT1JURURfRE9UX0FMTCIsIlVOU1VQUE9SVEVEX05DRyIsIm5hdGl2ZVJlcGxhY2UiLCJuYXRpdmVFeGVjIiwicGF0Y2hlZEV4ZWMiLCJjaGFyQXQkMiIsInJlcGxhY2UkMSIsInN0cmluZ1NsaWNlJDIiLCJVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkciLCJyZTEiLCJyZTIiLCJOUENHX0lOQ0xVREVEIiwiUEFUQ0giLCJzdHIiLCJyYXciLCJyZUNvcHkiLCJncm91cCIsImNoYXJzQWRkZWQiLCJzdHJDb3B5IiwicmVnZXhwRXhlYyQyIiwiJCIsInVuY3VycnlUaGlzJDIiLCJkZWZpbmVCdWlsdEluIiwicmVnZXhwRXhlYyQxIiwiZmFpbHMkMSIsIndlbGxLbm93blN5bWJvbCQxIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5IiwiU1BFQ0lFUyIsIlJlZ0V4cFByb3RvdHlwZSIsImZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljIiwiU0hBTSIsIlNZTUJPTCIsIkRFTEVHQVRFU19UT19TWU1CT0wiLCJERUxFR0FURVNfVE9fRVhFQyIsImV4ZWNDYWxsZWQiLCJ1bmN1cnJpZWROYXRpdmVSZWdFeHBNZXRob2QiLCJuYXRpdmVNZXRob2QiLCJyZWdleHAiLCJhcmcyIiwiZm9yY2VTdHJpbmdNZXRob2QiLCJ1bmN1cnJpZWROYXRpdmVNZXRob2QiLCIkZXhlYyIsImNoYXJBdCQxIiwiYWR2YW5jZVN0cmluZ0luZGV4JDEiLCJ1bmN1cnJ5VGhpcyQxIiwidG9PYmplY3QiLCJzdHJpbmdTbGljZSQxIiwiU1VCU1RJVFVUSU9OX1NZTUJPTFMiLCJTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCIsImdldFN1YnN0aXR1dGlvbiQxIiwibWF0Y2hlZCIsImNhcHR1cmVzIiwibmFtZWRDYXB0dXJlcyIsInRhaWxQb3MiLCJzeW1ib2xzIiwiY2giLCJjYXB0dXJlIiwiY2FsbCQxIiwiYW5PYmplY3QkMSIsImlzQ2FsbGFibGUkMSIsImNsYXNzb2YiLCJyZWdleHBFeGVjIiwiJFR5cGVFcnJvciIsInJlZ2V4cEV4ZWNBYnN0cmFjdCIsInVuY3VycnlUaGlzIiwiZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMiLCJmYWlscyIsImFuT2JqZWN0IiwiaXNDYWxsYWJsZSIsInRvSW50ZWdlck9ySW5maW5pdHkiLCJ0b0xlbmd0aCIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCJhZHZhbmNlU3RyaW5nSW5kZXgiLCJnZXRNZXRob2QiLCJnZXRTdWJzdGl0dXRpb24iLCJyZWdFeHBFeGVjIiwid2VsbEtub3duU3ltYm9sIiwiUkVQTEFDRSIsInN0cmluZ0luZGV4T2YiLCJzdHJpbmdTbGljZSIsIm1heWJlVG9TdHJpbmciLCJSRVBMQUNFX0tFRVBTXyQwIiwiUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUiLCJSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyIsIl8iLCJtYXliZUNhbGxOYXRpdmUiLCJVTlNBRkVfU1VCU1RJVFVURSIsInNlYXJjaFZhbHVlIiwicmVwbGFjZVZhbHVlIiwicngiLCJyZXMiLCJmdW5jdGlvbmFsUmVwbGFjZSIsImZ1bGxVbmljb2RlIiwicmVzdWx0cyIsIm1hdGNoU3RyIiwiYWNjdW11bGF0ZWRSZXN1bHQiLCJuZXh0U291cmNlUG9zaXRpb24iLCJyZXBsYWNlckFyZ3MiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsImFkb3B0IiwiZnVsZmlsbGVkIiwiZSIsInJlamVjdGVkIiwiU3VwcHJlc3NlZEVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJFcnJvciIsImljb24iLCJyZXNvbHZlV2FsbGV0VXJsIiwibmV0d29yayIsIndhbGxldFVybCIsIm5ldHdvcmtJZCIsInNldHVwV2FsbGV0U3RhdGUiLCJrZXlTdG9yZSIsImtleVN0b3JlcyIsIkJyb3dzZXJMb2NhbFN0b3JhZ2VLZXlTdG9yZSIsIm5lYXIiLCJjb25uZWN0Iiwid2FsbGV0IiwiV2FsbGV0Q29ubmVjdGlvbiIsIk15TmVhcldhbGxldCIsImxvZ2dlciIsIl9zdGF0ZSIsImdldEFjY291bnRzIiwiYWNjb3VudElkIiwiZ2V0QWNjb3VudElkIiwiYWNjb3VudCIsInB1YmxpY0tleSIsImNvbm5lY3Rpb24iLCJzaWduZXIiLCJnZXRQdWJsaWNLZXkiLCJ0cmFuc2Zvcm1UcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJwcm92aWRlciIsImxvY2FsS2V5IiwibWFwIiwidHJhbnNhY3Rpb24iLCJhY3Rpb25zIiwiYWN0aW9uIiwiYWNjZXNzS2V5IiwiYWNjZXNzS2V5Rm9yVHJhbnNhY3Rpb24iLCJyZWNlaXZlcklkIiwiYmxvY2siLCJmaW5hbGl0eSIsImNyZWF0ZVRyYW5zYWN0aW9uIiwidXRpbHMiLCJQdWJsaWNLZXkiLCJwdWJsaWNfa2V5IiwiYWNjZXNzX2tleSIsIm5vbmNlIiwiYmFzZV9kZWNvZGUiLCJoZWFkZXIiLCJzaWduSW4iLCJjb250cmFjdElkIiwibWV0aG9kTmFtZXMiLCJzdWNjZXNzVXJsIiwiZmFpbHVyZVVybCIsImV4aXN0aW5nQWNjb3VudHMiLCJyZXF1ZXN0U2lnbkluIiwic2lnbk91dCIsImlzU2lnbmVkSW4iLCJ2ZXJpZnlPd25lciIsInNpZ25NZXNzYWdlIiwicmVjaXBpZW50IiwiY2FsbGJhY2tVcmwiLCJsb2ciLCJsb2NhdGlvblVybCIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iLCJzaWduZXJJZCIsImNvbnRyYWN0Iiwid2FsbGV0Q2FsbGJhY2tVcmwiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9ucyIsInJlcXVlc3RTaWduVHJhbnNhY3Rpb25zIiwiYnVpbGRJbXBvcnRBY2NvdW50c1VybCIsInNldHVwTXlOZWFyV2FsbGV0IiwiaWNvblVybCIsImRlcHJlY2F0ZWQiLCJtb2R1bGVPcHRpb25zIiwiYXZhaWxhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/my-near-wallet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@near-wallet-selector/wallet-utils/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var near_api_js__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   signTransactions: () => (/* binding */ signTransactions)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/near-api-js/lib/index.js\");\n\n\nconst { transactions, utils } = /*#__PURE__*/ (near_api_js__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (near_api_js__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(near_api_js__WEBPACK_IMPORTED_MODULE_1__, 2)));\nconst getAccessKey = (permission)=>{\n    if (permission === \"FullAccess\") {\n        return transactions.fullAccessKey();\n    }\n    const { receiverId, methodNames = [] } = permission;\n    const allowance = permission.allowance ? new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(permission.allowance) : undefined;\n    return transactions.functionCallAccessKey(receiverId, methodNames, allowance);\n};\nconst createAction = (action)=>{\n    switch(action.type){\n        case \"CreateAccount\":\n            return transactions.createAccount();\n        case \"DeployContract\":\n            {\n                const { code } = action.params;\n                return transactions.deployContract(code);\n            }\n        case \"FunctionCall\":\n            {\n                const { methodName, args, gas, deposit } = action.params;\n                return transactions.functionCall(methodName, args, new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(gas), new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(deposit));\n            }\n        case \"Transfer\":\n            {\n                const { deposit } = action.params;\n                return transactions.transfer(new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(deposit));\n            }\n        case \"Stake\":\n            {\n                const { stake, publicKey } = action.params;\n                return transactions.stake(new bn_js__WEBPACK_IMPORTED_MODULE_0__.BN(stake), utils.PublicKey.from(publicKey));\n            }\n        case \"AddKey\":\n            {\n                const { publicKey, accessKey } = action.params;\n                return transactions.addKey(utils.PublicKey.from(publicKey), // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?\n                getAccessKey(accessKey.permission));\n            }\n        case \"DeleteKey\":\n            {\n                const { publicKey } = action.params;\n                return transactions.deleteKey(utils.PublicKey.from(publicKey));\n            }\n        case \"DeleteAccount\":\n            {\n                const { beneficiaryId } = action.params;\n                return transactions.deleteAccount(beneficiaryId);\n            }\n        default:\n            throw new Error(\"Invalid action type\");\n    }\n};\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar fails$d = function(exec) {\n    try {\n        return !!exec();\n    } catch (error) {\n        return true;\n    }\n};\nvar fails$c = fails$d;\nvar functionBindNative = !fails$c(function() {\n    // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n    var test = (function() {}).bind();\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return typeof test != \"function\" || test.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$3 = functionBindNative;\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$5 = FunctionPrototype$2.bind;\nvar call$e = FunctionPrototype$2.call;\nvar uncurryThis$d = NATIVE_BIND$3 && bind$5.bind(call$e, call$e);\nvar functionUncurryThis = NATIVE_BIND$3 ? function(fn) {\n    return fn && uncurryThis$d(fn);\n} : function(fn) {\n    return fn && function() {\n        return call$e.apply(fn, arguments);\n    };\n};\nvar uncurryThis$c = functionUncurryThis;\nvar toString$2 = uncurryThis$c({}.toString);\nvar stringSlice = uncurryThis$c(\"\".slice);\nvar classofRaw$1 = function(it) {\n    return stringSlice(toString$2(it), 8, -1);\n};\nvar uncurryThis$b = functionUncurryThis;\nvar fails$b = fails$d;\nvar classof$5 = classofRaw$1;\nvar $Object$4 = Object;\nvar split = uncurryThis$b(\"\".split);\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$b(function() {\n    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n    // eslint-disable-next-line no-prototype-builtins -- safe\n    return !$Object$4(\"z\").propertyIsEnumerable(0);\n}) ? function(it) {\n    return classof$5(it) == \"String\" ? split(it, \"\") : $Object$4(it);\n} : $Object$4;\nvar $TypeError$b = TypeError;\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$2 = function(it) {\n    if (it == undefined) throw $TypeError$b(\"Can't call method on \" + it);\n    return it;\n};\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = indexedObject;\nvar requireObjectCoercible$1 = requireObjectCoercible$2;\nvar toIndexedObject$5 = function(it) {\n    return IndexedObject(requireObjectCoercible$1(it));\n};\nvar check = function(it) {\n    return it && it.Math == Math && it;\n};\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$j = // eslint-disable-next-line es-x/no-global-this -- safe\ncheck(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\ncheck(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback\nfunction() {\n    return this;\n}() || Function(\"return this\")();\nvar shared$3 = {\n    exports: {}\n};\nvar global$i = global$j;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$4 = Object.defineProperty;\nvar defineGlobalProperty$3 = function(key, value) {\n    try {\n        defineProperty$4(global$i, key, {\n            value: value,\n            configurable: true,\n            writable: true\n        });\n    } catch (error) {\n        global$i[key] = value;\n    }\n    return value;\n};\nvar global$h = global$j;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\nvar SHARED = \"__core-js_shared__\";\nvar store$3 = global$h[SHARED] || defineGlobalProperty$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$3.exports = function(key, value) {\n    return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})(\"versions\", []).push({\n    version: \"3.23.3\",\n    mode: \"global\",\n    copyright: \"\\xa9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n});\nvar requireObjectCoercible = requireObjectCoercible$2;\nvar $Object$3 = Object;\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$2 = function(argument) {\n    return $Object$3(requireObjectCoercible(argument));\n};\nvar uncurryThis$a = functionUncurryThis;\nvar toObject$1 = toObject$2;\nvar hasOwnProperty = uncurryThis$a({}.hasOwnProperty);\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n    return hasOwnProperty(toObject$1(it), key);\n};\nvar uncurryThis$9 = functionUncurryThis;\nvar id = 0;\nvar postfix = Math.random();\nvar toString$1 = uncurryThis$9(1.0.toString);\nvar uid$2 = function(key) {\n    return \"Symbol(\" + (key === undefined ? \"\" : key) + \")_\" + toString$1(++id + postfix, 36);\n};\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$k = function(argument) {\n    return typeof argument == \"function\";\n};\nvar global$g = global$j;\nvar isCallable$j = isCallable$k;\nvar aFunction = function(argument) {\n    return isCallable$j(argument) ? argument : undefined;\n};\nvar getBuiltIn$8 = function(namespace, method) {\n    return arguments.length < 2 ? aFunction(global$g[namespace]) : global$g[namespace] && global$g[namespace][method];\n};\nvar getBuiltIn$7 = getBuiltIn$8;\nvar engineUserAgent = getBuiltIn$7(\"navigator\", \"userAgent\") || \"\";\nvar global$f = global$j;\nvar userAgent$3 = engineUserAgent;\nvar process$3 = global$f.process;\nvar Deno$1 = global$f.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n    match = v8.split(\".\");\n    // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n    // but their correct versions are not interesting for us\n    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$3) {\n    match = userAgent$3.match(/Edge\\/(\\d+)/);\n    if (!match || match[1] >= 74) {\n        match = userAgent$3.match(/Chrome\\/(\\d+)/);\n        if (match) version = +match[1];\n    }\n}\nvar engineV8Version = version;\n/* eslint-disable es-x/no-symbol -- required for testing */ var V8_VERSION$1 = engineV8Version;\nvar fails$a = fails$d;\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$a(function() {\n    var symbol = Symbol();\n    // Chrome 38 Symbol has incorrect toString conversion\n    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n/* eslint-disable es-x/no-symbol -- required for testing */ var NATIVE_SYMBOL$1 = nativeSymbol;\nvar useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar global$e = global$j;\nvar shared$2 = shared$3.exports;\nvar hasOwn$a = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$2(\"wks\");\nvar Symbol$1 = global$e.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1[\"for\"];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\nvar wellKnownSymbol$e = function(name) {\n    if (!hasOwn$a(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n        var description = \"Symbol.\" + name;\n        if (NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)) {\n            WellKnownSymbolsStore[name] = Symbol$1[name];\n        } else if (USE_SYMBOL_AS_UID$1 && symbolFor) {\n            WellKnownSymbolsStore[name] = symbolFor(description);\n        } else {\n            WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n        }\n    }\n    return WellKnownSymbolsStore[name];\n};\nvar isCallable$i = isCallable$k;\nvar isObject$7 = function(it) {\n    return typeof it == \"object\" ? it !== null : isCallable$i(it);\n};\nvar isObject$6 = isObject$7;\nvar $String$3 = String;\nvar $TypeError$a = TypeError;\n// `Assert: Type(argument) is Object`\nvar anObject$c = function(argument) {\n    if (isObject$6(argument)) return argument;\n    throw $TypeError$a($String$3(argument) + \" is not an object\");\n};\nvar objectDefineProperties = {};\nvar fails$9 = fails$d;\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$9(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty({}, 1, {\n        get: function() {\n            return 7;\n        }\n    })[1] != 7;\n});\nvar DESCRIPTORS$9 = descriptors;\nvar fails$8 = fails$d;\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$9 && fails$8(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(function() {}, \"prototype\", {\n        value: 42,\n        writable: false\n    }).prototype != 42;\n});\nvar objectDefineProperty = {};\nvar global$d = global$j;\nvar isObject$5 = isObject$7;\nvar document$3 = global$d.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);\nvar documentCreateElement$2 = function(it) {\n    return EXISTS$1 ? document$3.createElement(it) : {};\n};\nvar DESCRIPTORS$8 = descriptors;\nvar fails$7 = fails$d;\nvar createElement$1 = documentCreateElement$2;\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$8 && !fails$7(function() {\n    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n    return Object.defineProperty(createElement$1(\"div\"), \"a\", {\n        get: function() {\n            return 7;\n        }\n    }).a != 7;\n});\nvar NATIVE_BIND$2 = functionBindNative;\nvar call$d = Function.prototype.call;\nvar functionCall = NATIVE_BIND$2 ? call$d.bind(call$d) : function() {\n    return call$d.apply(call$d, arguments);\n};\nvar uncurryThis$8 = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$h = isCallable$k;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar $Object$2 = Object;\nvar isSymbol$2 = USE_SYMBOL_AS_UID ? function(it) {\n    return typeof it == \"symbol\";\n} : function(it) {\n    var $Symbol = getBuiltIn$6(\"Symbol\");\n    return isCallable$h($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$2(it));\n};\nvar $String$2 = String;\nvar tryToString$4 = function(argument) {\n    try {\n        return $String$2(argument);\n    } catch (error) {\n        return \"Object\";\n    }\n};\nvar isCallable$g = isCallable$k;\nvar tryToString$3 = tryToString$4;\nvar $TypeError$9 = TypeError;\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function(argument) {\n    if (isCallable$g(argument)) return argument;\n    throw $TypeError$9(tryToString$3(argument) + \" is not a function\");\n};\nvar aCallable$6 = aCallable$7;\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function(V, P) {\n    var func = V[P];\n    return func == null ? undefined : aCallable$6(func);\n};\nvar call$c = functionCall;\nvar isCallable$f = isCallable$k;\nvar isObject$4 = isObject$7;\nvar $TypeError$8 = TypeError;\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function(input, pref) {\n    var fn, val;\n    if (pref === \"string\" && isCallable$f(fn = input.toString) && !isObject$4(val = call$c(fn, input))) return val;\n    if (isCallable$f(fn = input.valueOf) && !isObject$4(val = call$c(fn, input))) return val;\n    if (pref !== \"string\" && isCallable$f(fn = input.toString) && !isObject$4(val = call$c(fn, input))) return val;\n    throw $TypeError$8(\"Can't convert object to primitive value\");\n};\nvar call$b = functionCall;\nvar isObject$3 = isObject$7;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$d = wellKnownSymbol$e;\nvar $TypeError$7 = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$d(\"toPrimitive\");\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$1 = function(input, pref) {\n    if (!isObject$3(input) || isSymbol$1(input)) return input;\n    var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n    var result;\n    if (exoticToPrim) {\n        if (pref === undefined) pref = \"default\";\n        result = call$b(exoticToPrim, input, pref);\n        if (!isObject$3(result) || isSymbol$1(result)) return result;\n        throw $TypeError$7(\"Can't convert object to primitive value\");\n    }\n    if (pref === undefined) pref = \"number\";\n    return ordinaryToPrimitive(input, pref);\n};\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$2 = function(argument) {\n    var key = toPrimitive(argument, \"string\");\n    return isSymbol(key) ? key : key + \"\";\n};\nvar DESCRIPTORS$7 = descriptors;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$b = anObject$c;\nvar toPropertyKey$1 = toPropertyKey$2;\nvar $TypeError$6 = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = \"enumerable\";\nvar CONFIGURABLE$1 = \"configurable\";\nvar WRITABLE = \"writable\";\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$7 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n    anObject$b(O);\n    P = toPropertyKey$1(P);\n    anObject$b(Attributes);\n    if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n        var current = $getOwnPropertyDescriptor$1(O, P);\n        if (current && current[WRITABLE]) {\n            O[P] = Attributes.value;\n            Attributes = {\n                configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n                writable: false\n            };\n        }\n    }\n    return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n    anObject$b(O);\n    P = toPropertyKey$1(P);\n    anObject$b(Attributes);\n    if (IE8_DOM_DEFINE$1) try {\n        return $defineProperty(O, P, Attributes);\n    } catch (error) {}\n    if (\"get\" in Attributes || \"set\" in Attributes) throw $TypeError$6(\"Accessors not supported\");\n    if (\"value\" in Attributes) O[P] = Attributes.value;\n    return O;\n};\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n    var n = +x;\n    return (n > 0 ? floor : ceil)(n);\n};\nvar trunc = mathTrunc;\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$2 = function(argument) {\n    var number = +argument;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number !== number || number === 0 ? 0 : trunc(number);\n};\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$2;\nvar max = Math.max;\nvar min$1 = Math.min;\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$1 = function(index, length) {\n    var integer = toIntegerOrInfinity$1(index);\n    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\nvar toIntegerOrInfinity = toIntegerOrInfinity$2;\nvar min = Math.min;\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function(argument) {\n    return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\nvar toLength = toLength$1;\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$2 = function(obj) {\n    return toLength(obj.length);\n};\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toAbsoluteIndex = toAbsoluteIndex$1;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$2;\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function(IS_INCLUDES) {\n    return function($this, el, fromIndex) {\n        var O = toIndexedObject$4($this);\n        var length = lengthOfArrayLike$1(O);\n        var index = toAbsoluteIndex(fromIndex, length);\n        var value;\n        // Array#includes uses SameValueZero equality algorithm\n        // eslint-disable-next-line no-self-compare -- NaN check\n        if (IS_INCLUDES && el != el) while(length > index){\n            value = O[index++];\n            // eslint-disable-next-line no-self-compare -- NaN check\n            if (value != value) return true;\n        // Array#indexOf ignores holes, Array#includes - not\n        }\n        else for(; length > index; index++){\n            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n        }\n        return !IS_INCLUDES && -1;\n    };\n};\nvar arrayIncludes = {\n    // `Array.prototype.includes` method\n    // https://tc39.es/ecma262/#sec-array.prototype.includes\n    includes: createMethod(true),\n    // `Array.prototype.indexOf` method\n    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n    indexOf: createMethod(false)\n};\nvar hiddenKeys$4 = {};\nvar uncurryThis$7 = functionUncurryThis;\nvar hasOwn$9 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$5;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$3 = hiddenKeys$4;\nvar push = uncurryThis$7([].push);\nvar objectKeysInternal = function(object, names) {\n    var O = toIndexedObject$3(object);\n    var i = 0;\n    var result = [];\n    var key;\n    for(key in O)!hasOwn$9(hiddenKeys$3, key) && hasOwn$9(O, key) && push(result, key);\n    // Don't enum bug & hidden keys\n    while(names.length > i)if (hasOwn$9(O, key = names[i++])) {\n        ~indexOf(result, key) || push(result, key);\n    }\n    return result;\n};\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n    \"constructor\",\n    \"hasOwnProperty\",\n    \"isPrototypeOf\",\n    \"propertyIsEnumerable\",\n    \"toLocaleString\",\n    \"toString\",\n    \"valueOf\"\n];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$1 = Object.keys || function keys(O) {\n    return internalObjectKeys$1(O, enumBugKeys$2);\n};\nvar DESCRIPTORS$6 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$4 = objectDefineProperty;\nvar anObject$a = anObject$c;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar objectKeys = objectKeys$1;\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$6 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n    anObject$a(O);\n    var props = toIndexedObject$2(Properties);\n    var keys = objectKeys(Properties);\n    var length = keys.length;\n    var index = 0;\n    var key;\n    while(length > index)definePropertyModule$4.f(O, key = keys[index++], props[key]);\n    return O;\n};\nvar getBuiltIn$5 = getBuiltIn$8;\nvar html$2 = getBuiltIn$5(\"document\", \"documentElement\");\nvar shared$1 = shared$3.exports;\nvar uid = uid$2;\nvar keys = shared$1(\"keys\");\nvar sharedKey$3 = function(key) {\n    return keys[key] || (keys[key] = uid(key));\n};\n/* global ActiveXObject -- old IE, WSH */ var anObject$9 = anObject$c;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar html$1 = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$2 = sharedKey$3;\nvar GT = \">\";\nvar LT = \"<\";\nvar PROTOTYPE = \"prototype\";\nvar SCRIPT = \"script\";\nvar IE_PROTO$1 = sharedKey$2(\"IE_PROTO\");\nvar EmptyConstructor = function() {};\nvar scriptTag = function(content) {\n    return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n};\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function(activeXDocument) {\n    activeXDocument.write(scriptTag(\"\"));\n    activeXDocument.close();\n    var temp = activeXDocument.parentWindow.Object;\n    activeXDocument = null; // avoid memory leak\n    return temp;\n};\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function() {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = documentCreateElement$1(\"iframe\");\n    var JS = \"java\" + SCRIPT + \":\";\n    var iframeDocument;\n    iframe.style.display = \"none\";\n    html$1.appendChild(iframe);\n    // https://github.com/zloirock/core-js/issues/475\n    iframe.src = String(JS);\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(scriptTag(\"document.F=Object\"));\n    iframeDocument.close();\n    return iframeDocument.F;\n};\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function() {\n    try {\n        activeXDocument = new ActiveXObject(\"htmlfile\");\n    } catch (error) {}\n    NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n     : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH\n    var length = enumBugKeys$1.length;\n    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];\n    return NullProtoObject();\n};\nhiddenKeys$2[IE_PROTO$1] = true;\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n    var result;\n    if (O !== null) {\n        EmptyConstructor[PROTOTYPE] = anObject$9(O);\n        result = new EmptyConstructor();\n        EmptyConstructor[PROTOTYPE] = null;\n        // add \"__proto__\" for Object.getPrototypeOf polyfill\n        result[IE_PROTO$1] = O;\n    } else result = NullProtoObject();\n    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\nvar wellKnownSymbol$c = wellKnownSymbol$e;\nvar create$1 = objectCreate;\nvar defineProperty$3 = objectDefineProperty.f;\nvar UNSCOPABLES = wellKnownSymbol$c(\"unscopables\");\nvar ArrayPrototype$1 = Array.prototype;\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n    defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {\n        configurable: true,\n        value: create$1(null)\n    });\n}\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$1 = function(key) {\n    ArrayPrototype$1[UNSCOPABLES][key] = true;\n};\nvar iterators = {};\nvar uncurryThis$6 = functionUncurryThis;\nvar isCallable$e = isCallable$k;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$6(Function.toString);\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$e(store$1.inspectSource)) {\n    store$1.inspectSource = function(it) {\n        return functionToString(it);\n    };\n}\nvar inspectSource$4 = store$1.inspectSource;\nvar global$c = global$j;\nvar isCallable$d = isCallable$k;\nvar inspectSource$3 = inspectSource$4;\nvar WeakMap$1 = global$c.WeakMap;\nvar nativeWeakMap = isCallable$d(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\nvar createPropertyDescriptor$3 = function(bitmap, value) {\n    return {\n        enumerable: !(bitmap & 1),\n        configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        value: value\n    };\n};\nvar DESCRIPTORS$5 = descriptors;\nvar definePropertyModule$3 = objectDefineProperty;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$3;\nvar createNonEnumerableProperty$4 = DESCRIPTORS$5 ? function(object, key, value) {\n    return definePropertyModule$3.f(object, key, createPropertyDescriptor$2(1, value));\n} : function(object, key, value) {\n    object[key] = value;\n    return object;\n};\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$b = global$j;\nvar uncurryThis$5 = functionUncurryThis;\nvar isObject$2 = isObject$7;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$4;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared = sharedStore;\nvar sharedKey$1 = sharedKey$3;\nvar hiddenKeys$1 = hiddenKeys$4;\nvar OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\nvar TypeError$2 = global$b.TypeError;\nvar WeakMap = global$b.WeakMap;\nvar set$1, get, has;\nvar enforce = function(it) {\n    return has(it) ? get(it) : set$1(it, {});\n};\nvar getterFor = function(TYPE) {\n    return function(it) {\n        var state;\n        if (!isObject$2(it) || (state = get(it)).type !== TYPE) {\n            throw TypeError$2(\"Incompatible receiver, \" + TYPE + \" required\");\n        }\n        return state;\n    };\n};\nif (NATIVE_WEAK_MAP || shared.state) {\n    var store = shared.state || (shared.state = new WeakMap());\n    var wmget = uncurryThis$5(store.get);\n    var wmhas = uncurryThis$5(store.has);\n    var wmset = uncurryThis$5(store.set);\n    set$1 = function(it, metadata) {\n        if (wmhas(store, it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        wmset(store, it, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return wmget(store, it) || {};\n    };\n    has = function(it) {\n        return wmhas(store, it);\n    };\n} else {\n    var STATE = sharedKey$1(\"state\");\n    hiddenKeys$1[STATE] = true;\n    set$1 = function(it, metadata) {\n        if (hasOwn$8(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        createNonEnumerableProperty$3(it, STATE, metadata);\n        return metadata;\n    };\n    get = function(it) {\n        return hasOwn$8(it, STATE) ? it[STATE] : {};\n    };\n    has = function(it) {\n        return hasOwn$8(it, STATE);\n    };\n}\nvar internalState = {\n    set: set$1,\n    get: get,\n    has: has,\n    enforce: enforce,\n    getterFor: getterFor\n};\nvar objectGetOwnPropertyDescriptor = {};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({\n    1: 2\n}, 1);\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n    var descriptor = getOwnPropertyDescriptor$2(this, V);\n    return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar DESCRIPTORS$4 = descriptors;\nvar call$a = functionCall;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$3;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar toPropertyKey = toPropertyKey$2;\nvar hasOwn$7 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE = ie8DomDefine;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$4 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n    O = toIndexedObject$1(O);\n    P = toPropertyKey(P);\n    if (IE8_DOM_DEFINE) try {\n        return $getOwnPropertyDescriptor(O, P);\n    } catch (error) {}\n    if (hasOwn$7(O, P)) return createPropertyDescriptor$1(!call$a(propertyIsEnumerableModule.f, O, P), O[P]);\n};\nvar makeBuiltIn$2 = {\n    exports: {}\n};\nvar DESCRIPTORS$3 = descriptors;\nvar hasOwn$6 = hasOwnProperty_1;\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$6(FunctionPrototype$1, \"name\");\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() {}).name === \"something\";\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, \"name\").configurable);\nvar functionName = {\n    EXISTS: EXISTS,\n    PROPER: PROPER,\n    CONFIGURABLE: CONFIGURABLE\n};\nvar fails$6 = fails$d;\nvar isCallable$c = isCallable$k;\nvar hasOwn$5 = hasOwnProperty_1;\nvar DESCRIPTORS$2 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$2 = internalState;\nvar enforceInternalState = InternalStateModule$2.enforce;\nvar getInternalState$1 = InternalStateModule$2.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$2 = Object.defineProperty;\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$2 && !fails$6(function() {\n    return defineProperty$2(function() {}, \"length\", {\n        value: 8\n    }).length !== 8;\n});\nvar TEMPLATE = String(String).split(\"String\");\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {\n    if (String(name).slice(0, 7) === \"Symbol(\") {\n        name = \"[\" + String(name).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n    }\n    if (options && options.getter) name = \"get \" + name;\n    if (options && options.setter) name = \"set \" + name;\n    if (!hasOwn$5(value, \"name\") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {\n        if (DESCRIPTORS$2) defineProperty$2(value, \"name\", {\n            value: name,\n            configurable: true\n        });\n        else value.name = name;\n    }\n    if (CONFIGURABLE_LENGTH && options && hasOwn$5(options, \"arity\") && value.length !== options.arity) {\n        defineProperty$2(value, \"length\", {\n            value: options.arity\n        });\n    }\n    try {\n        if (options && hasOwn$5(options, \"constructor\") && options.constructor) {\n            if (DESCRIPTORS$2) defineProperty$2(value, \"prototype\", {\n                writable: false\n            });\n        // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n        } else if (value.prototype) value.prototype = undefined;\n    } catch (error) {}\n    var state = enforceInternalState(value);\n    if (!hasOwn$5(state, \"source\")) {\n        state.source = TEMPLATE.join(typeof name == \"string\" ? name : \"\");\n    }\n    return value;\n};\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n    return isCallable$c(this) && getInternalState$1(this).source || inspectSource$2(this);\n}, \"toString\");\nvar isCallable$b = isCallable$k;\nvar definePropertyModule$2 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\nvar defineBuiltIn$6 = function(O, key, value, options) {\n    if (!options) options = {};\n    var simple = options.enumerable;\n    var name = options.name !== undefined ? options.name : key;\n    if (isCallable$b(value)) makeBuiltIn(value, name, options);\n    if (options.global) {\n        if (simple) O[key] = value;\n        else defineGlobalProperty$1(key, value);\n    } else {\n        try {\n            if (!options.unsafe) delete O[key];\n            else if (O[key]) simple = true;\n        } catch (error) {}\n        if (simple) O[key] = value;\n        else definePropertyModule$2.f(O, key, {\n            value: value,\n            enumerable: false,\n            configurable: !options.nonConfigurable,\n            writable: !options.nonWritable\n        });\n    }\n    return O;\n};\nvar objectGetOwnPropertyNames = {};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return internalObjectKeys(O, hiddenKeys);\n};\nvar objectGetOwnPropertySymbols = {};\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn$4 = getBuiltIn$8;\nvar uncurryThis$4 = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$8 = anObject$c;\nvar concat = uncurryThis$4([].concat);\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$4(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n    var keys = getOwnPropertyNamesModule.f(anObject$8(it));\n    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n    return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\nvar hasOwn$4 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$1 = objectDefineProperty;\nvar copyConstructorProperties$1 = function(target, source, exceptions) {\n    var keys = ownKeys(source);\n    var defineProperty = definePropertyModule$1.f;\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        if (!hasOwn$4(target, key) && !(exceptions && hasOwn$4(exceptions, key))) {\n            defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n        }\n    }\n};\nvar fails$5 = fails$d;\nvar isCallable$a = isCallable$k;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$2 = function(feature, detection) {\n    var value = data[normalize(feature)];\n    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$a(detection) ? fails$5(detection) : !!detection;\n};\nvar normalize = isForced$2.normalize = function(string) {\n    return String(string).replace(replacement, \".\").toLowerCase();\n};\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = \"N\";\nvar POLYFILL = isForced$2.POLYFILL = \"P\";\nvar isForced_1 = isForced$2;\nvar global$a = global$j;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$4;\nvar defineBuiltIn$5 = defineBuiltIn$6;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/ var _export = function(options, source) {\n    var TARGET = options.target;\n    var GLOBAL = options.global;\n    var STATIC = options.stat;\n    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n    if (GLOBAL) {\n        target = global$a;\n    } else if (STATIC) {\n        target = global$a[TARGET] || defineGlobalProperty(TARGET, {});\n    } else {\n        target = (global$a[TARGET] || {}).prototype;\n    }\n    if (target) for(key in source){\n        sourceProperty = source[key];\n        if (options.dontCallGetSet) {\n            descriptor = getOwnPropertyDescriptor$1(target, key);\n            targetProperty = descriptor && descriptor.value;\n        } else targetProperty = target[key];\n        FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n        // contained in target\n        if (!FORCED && targetProperty !== undefined) {\n            if (typeof sourceProperty == typeof targetProperty) continue;\n            copyConstructorProperties(sourceProperty, targetProperty);\n        }\n        // add a flag to not completely full polyfills\n        if (options.sham || targetProperty && targetProperty.sham) {\n            createNonEnumerableProperty$2(sourceProperty, \"sham\", true);\n        }\n        defineBuiltIn$5(target, key, sourceProperty, options);\n    }\n};\nvar fails$4 = fails$d;\nvar correctPrototypeGetter = !fails$4(function() {\n    function F() {}\n    F.prototype.constructor = null;\n    // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n    return Object.getPrototypeOf(new F()) !== F.prototype;\n});\nvar hasOwn$3 = hasOwnProperty_1;\nvar isCallable$9 = isCallable$k;\nvar toObject = toObject$2;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\nvar IE_PROTO = sharedKey(\"IE_PROTO\");\nvar $Object$1 = Object;\nvar ObjectPrototype = $Object$1.prototype;\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function(O) {\n    var object = toObject(O);\n    if (hasOwn$3(object, IE_PROTO)) return object[IE_PROTO];\n    var constructor = object.constructor;\n    if (isCallable$9(constructor) && object instanceof constructor) {\n        return constructor.prototype;\n    }\n    return object instanceof $Object$1 ? ObjectPrototype : null;\n};\nvar fails$3 = fails$d;\nvar isCallable$8 = isCallable$k;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$6;\nvar wellKnownSymbol$b = wellKnownSymbol$e;\nvar ITERATOR$5 = wellKnownSymbol$b(\"iterator\");\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n/* eslint-disable es-x/no-array-prototype-keys -- safe */ if ([].keys) {\n    arrayIterator = [].keys();\n    // Safari 8 has buggy iterators w/o `next`\n    if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n    else {\n        PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n    }\n}\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$3(function() {\n    var test = {};\n    // FF44- legacy iterators case\n    return IteratorPrototype$2[ITERATOR$5].call(test) !== test;\n});\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$8(IteratorPrototype$2[ITERATOR$5])) {\n    defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function() {\n        return this;\n    });\n}\nvar iteratorsCore = {\n    IteratorPrototype: IteratorPrototype$2,\n    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\nvar defineProperty$1 = objectDefineProperty.f;\nvar hasOwn$2 = hasOwnProperty_1;\nvar wellKnownSymbol$a = wellKnownSymbol$e;\nvar TO_STRING_TAG$3 = wellKnownSymbol$a(\"toStringTag\");\nvar setToStringTag$3 = function(target, TAG, STATIC) {\n    if (target && !STATIC) target = target.prototype;\n    if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {\n        defineProperty$1(target, TO_STRING_TAG$3, {\n            configurable: true,\n            value: TAG\n        });\n    }\n};\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create = objectCreate;\nvar createPropertyDescriptor = createPropertyDescriptor$3;\nvar setToStringTag$2 = setToStringTag$3;\nvar Iterators$4 = iterators;\nvar returnThis$1 = function() {\n    return this;\n};\nvar createIteratorConstructor$1 = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    IteratorConstructor.prototype = create(IteratorPrototype$1, {\n        next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next)\n    });\n    setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n    Iterators$4[TO_STRING_TAG] = returnThis$1;\n    return IteratorConstructor;\n};\nvar isCallable$7 = isCallable$k;\nvar $String$1 = String;\nvar $TypeError$5 = TypeError;\nvar aPossiblePrototype$1 = function(argument) {\n    if (typeof argument == \"object\" || isCallable$7(argument)) return argument;\n    throw $TypeError$5(\"Can't set \" + $String$1(argument) + \" as a prototype\");\n};\n/* eslint-disable no-proto -- safe */ var uncurryThis$3 = functionUncurryThis;\nvar anObject$7 = anObject$c;\nvar aPossiblePrototype = aPossiblePrototype$1;\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n    var CORRECT_SETTER = false;\n    var test = {};\n    var setter;\n    try {\n        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n        setter = uncurryThis$3(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set);\n        setter(test, []);\n        CORRECT_SETTER = test instanceof Array;\n    } catch (error) {}\n    return function setPrototypeOf(O, proto) {\n        anObject$7(O);\n        aPossiblePrototype(proto);\n        if (CORRECT_SETTER) setter(O, proto);\n        else O.__proto__ = proto;\n        return O;\n    };\n}() : undefined);\nvar $$6 = _export;\nvar call$9 = functionCall;\nvar FunctionName = functionName;\nvar isCallable$6 = isCallable$k;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$3;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$4;\nvar defineBuiltIn$3 = defineBuiltIn$6;\nvar wellKnownSymbol$9 = wellKnownSymbol$e;\nvar Iterators$3 = iterators;\nvar IteratorsCore = iteratorsCore;\nvar PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$4 = wellKnownSymbol$9(\"iterator\");\nvar KEYS = \"keys\";\nvar VALUES = \"values\";\nvar ENTRIES = \"entries\";\nvar returnThis = function() {\n    return this;\n};\nvar defineIterator$1 = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n    createIteratorConstructor(IteratorConstructor, NAME, next);\n    var getIterationMethod = function(KIND) {\n        if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n        switch(KIND){\n            case KEYS:\n                return function keys() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case VALUES:\n                return function values() {\n                    return new IteratorConstructor(this, KIND);\n                };\n            case ENTRIES:\n                return function entries() {\n                    return new IteratorConstructor(this, KIND);\n                };\n        }\n        return function() {\n            return new IteratorConstructor(this);\n        };\n    };\n    var TO_STRING_TAG = NAME + \" Iterator\";\n    var INCORRECT_VALUES_NAME = false;\n    var IterablePrototype = Iterable.prototype;\n    var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n    var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n    var CurrentIteratorPrototype, methods, KEY;\n    // fix native\n    if (anyNativeIterator) {\n        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n            if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n                if (setPrototypeOf$1) {\n                    setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);\n                } else if (!isCallable$6(CurrentIteratorPrototype[ITERATOR$4])) {\n                    defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);\n                }\n            }\n            // Set @@toStringTag to native iterators\n            setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n        }\n    }\n    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n    if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n        if (CONFIGURABLE_FUNCTION_NAME) {\n            createNonEnumerableProperty$1(IterablePrototype, \"name\", VALUES);\n        } else {\n            INCORRECT_VALUES_NAME = true;\n            defaultIterator = function values() {\n                return call$9(nativeIterator, this);\n            };\n        }\n    }\n    // export additional methods\n    if (DEFAULT) {\n        methods = {\n            values: getIterationMethod(VALUES),\n            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n            entries: getIterationMethod(ENTRIES)\n        };\n        if (FORCED) for(KEY in methods){\n            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n                defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n            }\n        }\n        else $$6({\n            target: NAME,\n            proto: true,\n            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n        }, methods);\n    }\n    // define iterator\n    if (IterablePrototype[ITERATOR$4] !== defaultIterator) {\n        defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, {\n            name: DEFAULT\n        });\n    }\n    Iterators$3[NAME] = defaultIterator;\n    return methods;\n};\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables = addToUnscopables$1;\nvar Iterators$2 = iterators;\nvar InternalStateModule$1 = internalState;\nvar defineProperty = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$1 = descriptors;\nvar ARRAY_ITERATOR = \"Array Iterator\";\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalState = InternalStateModule$1.getterFor(ARRAY_ITERATOR);\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, \"Array\", function(iterated, kind) {\n    setInternalState$1(this, {\n        type: ARRAY_ITERATOR,\n        target: toIndexedObject(iterated),\n        index: 0,\n        kind: kind // kind\n    });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function() {\n    var state = getInternalState(this);\n    var target = state.target;\n    var kind = state.kind;\n    var index = state.index++;\n    if (!target || index >= target.length) {\n        state.target = undefined;\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    if (kind == \"keys\") return {\n        value: index,\n        done: false\n    };\n    if (kind == \"values\") return {\n        value: target[index],\n        done: false\n    };\n    return {\n        value: [\n            index,\n            target[index]\n        ],\n        done: false\n    };\n}, \"values\");\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators$2.Arguments = Iterators$2.Array;\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(\"keys\");\naddToUnscopables(\"values\");\naddToUnscopables(\"entries\");\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$1 && values.name !== \"values\") try {\n    defineProperty(values, \"name\", {\n        value: \"values\"\n    });\n} catch (error) {}\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n};\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\nvar classList = documentCreateElement(\"span\").classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\nvar global$9 = global$j;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty = createNonEnumerableProperty$4;\nvar wellKnownSymbol$8 = wellKnownSymbol$e;\nvar ITERATOR$3 = wellKnownSymbol$8(\"iterator\");\nvar TO_STRING_TAG$2 = wellKnownSymbol$8(\"toStringTag\");\nvar ArrayValues = ArrayIteratorMethods.values;\nvar handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {\n    if (CollectionPrototype) {\n        // some Chrome versions have non-configurable methods on DOMTokenList\n        if (CollectionPrototype[ITERATOR$3] !== ArrayValues) try {\n            createNonEnumerableProperty(CollectionPrototype, ITERATOR$3, ArrayValues);\n        } catch (error) {\n            CollectionPrototype[ITERATOR$3] = ArrayValues;\n        }\n        if (!CollectionPrototype[TO_STRING_TAG$2]) {\n            createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);\n        }\n        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){\n            // some Chrome versions have non-configurable methods on DOMTokenList\n            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n            } catch (error) {\n                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n            }\n        }\n    }\n};\nfor(var COLLECTION_NAME in DOMIterables){\n    handlePrototype(global$9[COLLECTION_NAME] && global$9[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\nhandlePrototype(DOMTokenListPrototype, \"DOMTokenList\");\nvar classof$4 = classofRaw$1;\nvar global$8 = global$j;\nvar engineIsNode = classof$4(global$8.process) == \"process\";\nvar getBuiltIn$3 = getBuiltIn$8;\nvar definePropertyModule = objectDefineProperty;\nvar wellKnownSymbol$7 = wellKnownSymbol$e;\nvar DESCRIPTORS = descriptors;\nvar SPECIES$2 = wellKnownSymbol$7(\"species\");\nvar setSpecies$1 = function(CONSTRUCTOR_NAME) {\n    var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n    var defineProperty = definePropertyModule.f;\n    if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {\n        defineProperty(Constructor, SPECIES$2, {\n            configurable: true,\n            get: function() {\n                return this;\n            }\n        });\n    }\n};\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar $TypeError$4 = TypeError;\nvar anInstance$1 = function(it, Prototype) {\n    if (isPrototypeOf$2(Prototype, it)) return it;\n    throw $TypeError$4(\"Incorrect invocation\");\n};\nvar wellKnownSymbol$6 = wellKnownSymbol$e;\nvar TO_STRING_TAG$1 = wellKnownSymbol$6(\"toStringTag\");\nvar test = {};\ntest[TO_STRING_TAG$1] = \"z\";\nvar toStringTagSupport = String(test) === \"[object z]\";\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$5 = isCallable$k;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$5 = wellKnownSymbol$e;\nvar TO_STRING_TAG = wellKnownSymbol$5(\"toStringTag\");\nvar $Object = Object;\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function() {\n    return arguments;\n}()) == \"Arguments\";\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key) {\n    try {\n        return it[key];\n    } catch (error) {}\n};\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$3 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n    var O, tag, result;\n    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && isCallable$5(O.callee) ? \"Arguments\" : result;\n};\nvar uncurryThis$2 = functionUncurryThis;\nvar fails$2 = fails$d;\nvar isCallable$4 = isCallable$k;\nvar classof$2 = classof$3;\nvar getBuiltIn$2 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\nvar noop = function() {};\nvar empty = [];\nvar construct = getBuiltIn$2(\"Reflect\", \"construct\");\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis$2(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\nvar isConstructorModern = function isConstructor(argument) {\n    if (!isCallable$4(argument)) return false;\n    try {\n        construct(noop, empty, argument);\n        return true;\n    } catch (error) {\n        return false;\n    }\n};\nvar isConstructorLegacy = function isConstructor(argument) {\n    if (!isCallable$4(argument)) return false;\n    switch(classof$2(argument)){\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n            return false;\n    }\n    try {\n        // we can't check .prototype since constructors produced by .bind haven't it\n        // `Function#toString` throws on some built-it function in some legacy engines\n        // (for example, `DOMQuad` and similar in FF41-)\n        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));\n    } catch (error) {\n        return true;\n    }\n};\nisConstructorLegacy.sham = true;\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$1 = !construct || fails$2(function() {\n    var called;\n    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {\n        called = true;\n    }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar isConstructor = isConstructor$1;\nvar tryToString$2 = tryToString$4;\nvar $TypeError$3 = TypeError;\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function(argument) {\n    if (isConstructor(argument)) return argument;\n    throw $TypeError$3(tryToString$2(argument) + \" is not a constructor\");\n};\nvar anObject$6 = anObject$c;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$e;\nvar SPECIES$1 = wellKnownSymbol$4(\"species\");\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$1 = function(O, defaultConstructor) {\n    var C = anObject$6(O).constructor;\n    var S;\n    return C === undefined || (S = anObject$6(C)[SPECIES$1]) == undefined ? defaultConstructor : aConstructor(S);\n};\nvar NATIVE_BIND$1 = functionBindNative;\nvar FunctionPrototype = Function.prototype;\nvar apply$1 = FunctionPrototype.apply;\nvar call$8 = FunctionPrototype.call;\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND$1 ? call$8.bind(apply$1) : function() {\n    return call$8.apply(apply$1, arguments);\n});\nvar uncurryThis$1 = functionUncurryThis;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND = functionBindNative;\nvar bind$4 = uncurryThis$1(uncurryThis$1.bind);\n// optional / simple context binding\nvar functionBindContext = function(fn, that) {\n    aCallable$5(fn);\n    return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function() {\n        return fn.apply(that, arguments);\n    };\n};\nvar uncurryThis = functionUncurryThis;\nvar arraySlice$1 = uncurryThis([].slice);\nvar $TypeError$2 = TypeError;\nvar validateArgumentsLength$1 = function(passed, required) {\n    if (passed < required) throw $TypeError$2(\"Not enough arguments\");\n    return passed;\n};\nvar userAgent$2 = engineUserAgent;\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\nvar global$7 = global$j;\nvar apply = functionApply;\nvar bind$3 = functionBindContext;\nvar isCallable$3 = isCallable$k;\nvar hasOwn$1 = hasOwnProperty_1;\nvar fails$1 = fails$d;\nvar html = html$2;\nvar arraySlice = arraySlice$1;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$2 = engineIsNode;\nvar set = global$7.setImmediate;\nvar clear = global$7.clearImmediate;\nvar process$2 = global$7.process;\nvar Dispatch = global$7.Dispatch;\nvar Function$1 = global$7.Function;\nvar MessageChannel = global$7.MessageChannel;\nvar String$1 = global$7.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = \"onreadystatechange\";\nvar location, defer, channel, port;\ntry {\n    // Deno throws a ReferenceError on `location` access without `--location` flag\n    location = global$7.location;\n} catch (error) {}\nvar run = function(id) {\n    if (hasOwn$1(queue$1, id)) {\n        var fn = queue$1[id];\n        delete queue$1[id];\n        fn();\n    }\n};\nvar runner = function(id) {\n    return function() {\n        run(id);\n    };\n};\nvar listener = function(event) {\n    run(event.data);\n};\nvar post = function(id) {\n    // old engines have not location.origin\n    global$7.postMessage(String$1(id), location.protocol + \"//\" + location.host);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set || !clear) {\n    set = function setImmediate(handler) {\n        validateArgumentsLength(arguments.length, 1);\n        var fn = isCallable$3(handler) ? handler : Function$1(handler);\n        var args = arraySlice(arguments, 1);\n        queue$1[++counter] = function() {\n            apply(fn, undefined, args);\n        };\n        defer(counter);\n        return counter;\n    };\n    clear = function clearImmediate(id) {\n        delete queue$1[id];\n    };\n    // Node.js 0.8-\n    if (IS_NODE$2) {\n        defer = function(id) {\n            process$2.nextTick(runner(id));\n        };\n    // Sphere (JS game engine) Dispatch API\n    } else if (Dispatch && Dispatch.now) {\n        defer = function(id) {\n            Dispatch.now(runner(id));\n        };\n    // Browsers with MessageChannel, includes WebWorkers\n    // except iOS - https://github.com/zloirock/core-js/issues/624\n    } else if (MessageChannel && !IS_IOS$1) {\n        channel = new MessageChannel();\n        port = channel.port2;\n        channel.port1.onmessage = listener;\n        defer = bind$3(port.postMessage, port);\n    // Browsers with postMessage, skip WebWorkers\n    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n    } else if (global$7.addEventListener && isCallable$3(global$7.postMessage) && !global$7.importScripts && location && location.protocol !== \"file:\" && !fails$1(post)) {\n        defer = post;\n        global$7.addEventListener(\"message\", listener, false);\n    // IE8-\n    } else if (ONREADYSTATECHANGE in createElement(\"script\")) {\n        defer = function(id) {\n            html.appendChild(createElement(\"script\"))[ONREADYSTATECHANGE] = function() {\n                html.removeChild(this);\n                run(id);\n            };\n        };\n    // Rest old browsers\n    } else {\n        defer = function(id) {\n            setTimeout(runner(id), 0);\n        };\n    }\n}\nvar task$1 = {\n    set: set,\n    clear: clear\n};\nvar userAgent$1 = engineUserAgent;\nvar global$6 = global$j;\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$6.Pebble !== undefined;\nvar userAgent = engineUserAgent;\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\nvar global$5 = global$j;\nvar bind$2 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$1 = engineIsNode;\nvar MutationObserver = global$5.MutationObserver || global$5.WebKitMutationObserver;\nvar document$2 = global$5.document;\nvar process$1 = global$5.process;\nvar Promise$1 = global$5.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$5, \"queueMicrotask\");\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\nvar flush, head, last, notify$1, toggle, node, promise, then;\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n    flush = function() {\n        var parent, fn;\n        if (IS_NODE$1 && (parent = process$1.domain)) parent.exit();\n        while(head){\n            fn = head.fn;\n            head = head.next;\n            try {\n                fn();\n            } catch (error) {\n                if (head) notify$1();\n                else last = undefined;\n                throw error;\n            }\n        }\n        last = undefined;\n        if (parent) parent.enter();\n    };\n    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n    if (!IS_IOS && !IS_NODE$1 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n        toggle = true;\n        node = document$2.createTextNode(\"\");\n        new MutationObserver(flush).observe(node, {\n            characterData: true\n        });\n        notify$1 = function() {\n            node.data = toggle = !toggle;\n        };\n    // environments with maybe non-completely correct, but existent Promise\n    } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n        // Promise.resolve without an argument throws an error in LG WebOS 2\n        promise = Promise$1.resolve(undefined);\n        // workaround of WebKit ~ iOS Safari 10.1 bug\n        promise.constructor = Promise$1;\n        then = bind$2(promise.then, promise);\n        notify$1 = function() {\n            then(flush);\n        };\n    // Node.js without promises\n    } else if (IS_NODE$1) {\n        notify$1 = function() {\n            process$1.nextTick(flush);\n        };\n    // for other environments - macrotask based on:\n    // - setImmediate\n    // - MessageChannel\n    // - window.postMessage\n    // - onreadystatechange\n    // - setTimeout\n    } else {\n        // strange IE + webpack dev server bug - use .bind(global)\n        macrotask = bind$2(macrotask, global$5);\n        notify$1 = function() {\n            macrotask(flush);\n        };\n    }\n}\nvar microtask$1 = queueMicrotask || function(fn) {\n    var task = {\n        fn: fn,\n        next: undefined\n    };\n    if (last) last.next = task;\n    if (!head) {\n        head = task;\n        notify$1();\n    }\n    last = task;\n};\nvar global$4 = global$j;\nvar hostReportErrors$1 = function(a, b) {\n    var console = global$4.console;\n    if (console && console.error) {\n        arguments.length == 1 ? console.error(a) : console.error(a, b);\n    }\n};\nvar perform$3 = function(exec) {\n    try {\n        return {\n            error: false,\n            value: exec()\n        };\n    } catch (error) {\n        return {\n            error: true,\n            value: error\n        };\n    }\n};\nvar Queue$1 = function() {\n    this.head = null;\n    this.tail = null;\n};\nQueue$1.prototype = {\n    add: function(item) {\n        var entry = {\n            item: item,\n            next: null\n        };\n        if (this.head) this.tail.next = entry;\n        else this.head = entry;\n        this.tail = entry;\n    },\n    get: function() {\n        var entry = this.head;\n        if (entry) {\n            this.head = entry.next;\n            if (this.tail === entry) this.tail = null;\n            return entry.item;\n        }\n    }\n};\nvar queue = Queue$1;\nvar global$3 = global$j;\nvar promiseNativeConstructor = global$3.Promise;\nvar engineIsBrowser =  false && 0;\nvar global$2 = global$j;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$2 = isCallable$k;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$3 = wellKnownSymbol$e;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES = wellKnownSymbol$3(\"species\");\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(global$2.PromiseRejectionEvent);\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced(\"Promise\", function() {\n    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n    // We can't detect it synchronously, so just check versions\n    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n    // We can't use @@species feature detection in V8 since it causes\n    // deoptimization and performance degradation\n    // https://github.com/zloirock/core-js/issues/679\n    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n    // Detect correctness of subclassing with @@species support\n    var promise = new NativePromiseConstructor$3(function(resolve) {\n        resolve(1);\n    });\n    var FakePromise = function(exec) {\n        exec(function() {}, function() {});\n    };\n    var constructor = promise.constructor = {};\n    constructor[SPECIES] = FakePromise;\n    SUBCLASSING = promise.then(function() {}) instanceof FakePromise;\n    if (!SUBCLASSING) return true;\n    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\nvar promiseConstructorDetection = {\n    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n    SUBCLASSING: SUBCLASSING\n};\nvar newPromiseCapability$2 = {};\nvar aCallable$4 = aCallable$7;\nvar PromiseCapability = function(C) {\n    var resolve, reject;\n    this.promise = new C(function($$resolve, $$reject) {\n        if (resolve !== undefined || reject !== undefined) throw TypeError(\"Bad Promise constructor\");\n        resolve = $$resolve;\n        reject = $$reject;\n    });\n    this.resolve = aCallable$4(resolve);\n    this.reject = aCallable$4(reject);\n};\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function(C) {\n    return new PromiseCapability(C);\n};\nvar $$5 = _export;\nvar IS_NODE = engineIsNode;\nvar global$1 = global$j;\nvar call$7 = functionCall;\nvar defineBuiltIn$2 = defineBuiltIn$6;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag = setToStringTag$3;\nvar setSpecies = setSpecies$1;\nvar aCallable$3 = aCallable$7;\nvar isCallable$1 = isCallable$k;\nvar isObject$1 = isObject$7;\nvar anInstance = anInstance$1;\nvar speciesConstructor = speciesConstructor$1;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\nvar PROMISE = \"Promise\";\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar setInternalState = InternalStateModule.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$1 = global$1.TypeError;\nvar document$1 = global$1.document;\nvar process = global$1.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);\nvar UNHANDLED_REJECTION = \"unhandledrejection\";\nvar REJECTION_HANDLED = \"rejectionhandled\";\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n// helpers\nvar isThenable = function(it) {\n    var then;\n    return isObject$1(it) && isCallable$1(then = it.then) ? then : false;\n};\nvar callReaction = function(reaction, state) {\n    var value = state.value;\n    var ok = state.state == FULFILLED;\n    var handler = ok ? reaction.ok : reaction.fail;\n    var resolve = reaction.resolve;\n    var reject = reaction.reject;\n    var domain = reaction.domain;\n    var result, then, exited;\n    try {\n        if (handler) {\n            if (!ok) {\n                if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n                state.rejection = HANDLED;\n            }\n            if (handler === true) result = value;\n            else {\n                if (domain) domain.enter();\n                result = handler(value); // can throw\n                if (domain) {\n                    domain.exit();\n                    exited = true;\n                }\n            }\n            if (result === reaction.promise) {\n                reject(TypeError$1(\"Promise-chain cycle\"));\n            } else if (then = isThenable(result)) {\n                call$7(then, result, resolve, reject);\n            } else resolve(result);\n        } else reject(value);\n    } catch (error) {\n        if (domain && !exited) domain.exit();\n        reject(error);\n    }\n};\nvar notify = function(state, isReject) {\n    if (state.notified) return;\n    state.notified = true;\n    microtask(function() {\n        var reactions = state.reactions;\n        var reaction;\n        while(reaction = reactions.get()){\n            callReaction(reaction, state);\n        }\n        state.notified = false;\n        if (isReject && !state.rejection) onUnhandled(state);\n    });\n};\nvar dispatchEvent = function(name, promise, reason) {\n    var event, handler;\n    if (DISPATCH_EVENT) {\n        event = document$1.createEvent(\"Event\");\n        event.promise = promise;\n        event.reason = reason;\n        event.initEvent(name, false, true);\n        global$1.dispatchEvent(event);\n    } else event = {\n        promise: promise,\n        reason: reason\n    };\n    if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$1[\"on\" + name])) handler(event);\n    else if (name === UNHANDLED_REJECTION) hostReportErrors(\"Unhandled promise rejection\", reason);\n};\nvar onUnhandled = function(state) {\n    call$7(task, global$1, function() {\n        var promise = state.facade;\n        var value = state.value;\n        var IS_UNHANDLED = isUnhandled(state);\n        var result;\n        if (IS_UNHANDLED) {\n            result = perform$2(function() {\n                if (IS_NODE) {\n                    process.emit(\"unhandledRejection\", value, promise);\n                } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n            });\n            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n            if (result.error) throw result.value;\n        }\n    });\n};\nvar isUnhandled = function(state) {\n    return state.rejection !== HANDLED && !state.parent;\n};\nvar onHandleUnhandled = function(state) {\n    call$7(task, global$1, function() {\n        var promise = state.facade;\n        if (IS_NODE) {\n            process.emit(\"rejectionHandled\", promise);\n        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n    });\n};\nvar bind$1 = function(fn, state, unwrap) {\n    return function(value) {\n        fn(state, value, unwrap);\n    };\n};\nvar internalReject = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    state.value = value;\n    state.state = REJECTED;\n    notify(state, true);\n};\nvar internalResolve = function(state, value, unwrap) {\n    if (state.done) return;\n    state.done = true;\n    if (unwrap) state = unwrap;\n    try {\n        if (state.facade === value) throw TypeError$1(\"Promise can't be resolved itself\");\n        var then = isThenable(value);\n        if (then) {\n            microtask(function() {\n                var wrapper = {\n                    done: false\n                };\n                try {\n                    call$7(then, value, bind$1(internalResolve, wrapper, state), bind$1(internalReject, wrapper, state));\n                } catch (error) {\n                    internalReject(wrapper, error, state);\n                }\n            });\n        } else {\n            state.value = value;\n            state.state = FULFILLED;\n            notify(state, false);\n        }\n    } catch (error) {\n        internalReject({\n            done: false\n        }, error, state);\n    }\n};\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n    // 25.4.3.1 Promise(executor)\n    PromiseConstructor = function Promise1(executor) {\n        anInstance(this, PromisePrototype);\n        aCallable$3(executor);\n        call$7(Internal, this);\n        var state = getInternalPromiseState(this);\n        try {\n            executor(bind$1(internalResolve, state), bind$1(internalReject, state));\n        } catch (error) {\n            internalReject(state, error);\n        }\n    };\n    PromisePrototype = PromiseConstructor.prototype;\n    // eslint-disable-next-line no-unused-vars -- required for `.length`\n    Internal = function Promise1(executor) {\n        setInternalState(this, {\n            type: PROMISE,\n            done: false,\n            notified: false,\n            parent: false,\n            reactions: new Queue(),\n            rejection: false,\n            state: PENDING,\n            value: undefined\n        });\n    };\n    // `Promise.prototype.then` method\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\n    Internal.prototype = defineBuiltIn$2(PromisePrototype, \"then\", function then(onFulfilled, onRejected) {\n        var state = getInternalPromiseState(this);\n        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n        state.parent = true;\n        reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;\n        reaction.fail = isCallable$1(onRejected) && onRejected;\n        reaction.domain = IS_NODE ? process.domain : undefined;\n        if (state.state == PENDING) state.reactions.add(reaction);\n        else microtask(function() {\n            callReaction(reaction, state);\n        });\n        return reaction.promise;\n    });\n    OwnPromiseCapability = function() {\n        var promise = new Internal();\n        var state = getInternalPromiseState(promise);\n        this.promise = promise;\n        this.resolve = bind$1(internalResolve, state);\n        this.reject = bind$1(internalReject, state);\n    };\n    newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function(C) {\n        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n    };\n    if (isCallable$1(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n        nativeThen = NativePromisePrototype$1.then;\n        if (!NATIVE_PROMISE_SUBCLASSING) {\n            // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n            defineBuiltIn$2(NativePromisePrototype$1, \"then\", function then(onFulfilled, onRejected) {\n                var that = this;\n                return new PromiseConstructor(function(resolve, reject) {\n                    call$7(nativeThen, that, resolve, reject);\n                }).then(onFulfilled, onRejected);\n            // https://github.com/zloirock/core-js/issues/640\n            }, {\n                unsafe: true\n            });\n        }\n        // make `.constructor === Promise` work for native promise-based APIs\n        try {\n            delete NativePromisePrototype$1.constructor;\n        } catch (error) {}\n        // make `instanceof Promise` work for native promise-based APIs\n        if (setPrototypeOf) {\n            setPrototypeOf(NativePromisePrototype$1, PromisePrototype);\n        }\n    }\n}\n$$5({\n    global: true,\n    constructor: true,\n    wrap: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$4\n}, {\n    Promise: PromiseConstructor\n});\nsetToStringTag(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\nvar wellKnownSymbol$2 = wellKnownSymbol$e;\nvar Iterators$1 = iterators;\nvar ITERATOR$2 = wellKnownSymbol$2(\"iterator\");\nvar ArrayPrototype = Array.prototype;\n// check on default Array iterator\nvar isArrayIteratorMethod$1 = function(it) {\n    return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);\n};\nvar classof$1 = classof$3;\nvar getMethod$1 = getMethod$3;\nvar Iterators = iterators;\nvar wellKnownSymbol$1 = wellKnownSymbol$e;\nvar ITERATOR$1 = wellKnownSymbol$1(\"iterator\");\nvar getIteratorMethod$2 = function(it) {\n    if (it != undefined) return getMethod$1(it, ITERATOR$1) || getMethod$1(it, \"@@iterator\") || Iterators[classof$1(it)];\n};\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$5 = anObject$c;\nvar tryToString$1 = tryToString$4;\nvar getIteratorMethod$1 = getIteratorMethod$2;\nvar $TypeError$1 = TypeError;\nvar getIterator$1 = function(argument, usingIterator) {\n    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;\n    if (aCallable$2(iteratorMethod)) return anObject$5(call$6(iteratorMethod, argument));\n    throw $TypeError$1(tryToString$1(argument) + \" is not iterable\");\n};\nvar call$5 = functionCall;\nvar anObject$4 = anObject$c;\nvar getMethod = getMethod$3;\nvar iteratorClose$1 = function(iterator, kind, value) {\n    var innerResult, innerError;\n    anObject$4(iterator);\n    try {\n        innerResult = getMethod(iterator, \"return\");\n        if (!innerResult) {\n            if (kind === \"throw\") throw value;\n            return value;\n        }\n        innerResult = call$5(innerResult, iterator);\n    } catch (error) {\n        innerError = true;\n        innerResult = error;\n    }\n    if (kind === \"throw\") throw value;\n    if (innerError) throw innerResult;\n    anObject$4(innerResult);\n    return value;\n};\nvar bind = functionBindContext;\nvar call$4 = functionCall;\nvar anObject$3 = anObject$c;\nvar tryToString = tryToString$4;\nvar isArrayIteratorMethod = isArrayIteratorMethod$1;\nvar lengthOfArrayLike = lengthOfArrayLike$2;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getIterator = getIterator$1;\nvar getIteratorMethod = getIteratorMethod$2;\nvar iteratorClose = iteratorClose$1;\nvar $TypeError = TypeError;\nvar Result = function(stopped, result) {\n    this.stopped = stopped;\n    this.result = result;\n};\nvar ResultPrototype = Result.prototype;\nvar iterate$2 = function(iterable, unboundFunction, options) {\n    var that = options && options.that;\n    var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n    var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n    var INTERRUPTED = !!(options && options.INTERRUPTED);\n    var fn = bind(unboundFunction, that);\n    var iterator, iterFn, index, length, result, next, step;\n    var stop = function(condition) {\n        if (iterator) iteratorClose(iterator, \"normal\", condition);\n        return new Result(true, condition);\n    };\n    var callFn = function(value) {\n        if (AS_ENTRIES) {\n            anObject$3(value);\n            return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n        }\n        return INTERRUPTED ? fn(value, stop) : fn(value);\n    };\n    if (IS_ITERATOR) {\n        iterator = iterable;\n    } else {\n        iterFn = getIteratorMethod(iterable);\n        if (!iterFn) throw $TypeError(tryToString(iterable) + \" is not iterable\");\n        // optimisation for array iterators\n        if (isArrayIteratorMethod(iterFn)) {\n            for(index = 0, length = lengthOfArrayLike(iterable); length > index; index++){\n                result = callFn(iterable[index]);\n                if (result && isPrototypeOf$1(ResultPrototype, result)) return result;\n            }\n            return new Result(false);\n        }\n        iterator = getIterator(iterable, iterFn);\n    }\n    next = iterator.next;\n    while(!(step = call$4(next, iterator)).done){\n        try {\n            result = callFn(step.value);\n        } catch (error) {\n            iteratorClose(iterator, \"throw\", error);\n        }\n        if (typeof result == \"object\" && result && isPrototypeOf$1(ResultPrototype, result)) return result;\n    }\n    return new Result(false);\n};\nvar wellKnownSymbol = wellKnownSymbol$e;\nvar ITERATOR = wellKnownSymbol(\"iterator\");\nvar SAFE_CLOSING = false;\ntry {\n    var called = 0;\n    var iteratorWithReturn = {\n        next: function() {\n            return {\n                done: !!called++\n            };\n        },\n        \"return\": function() {\n            SAFE_CLOSING = true;\n        }\n    };\n    iteratorWithReturn[ITERATOR] = function() {\n        return this;\n    };\n    // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n    Array.from(iteratorWithReturn, function() {\n        throw 2;\n    });\n} catch (error) {}\nvar checkCorrectnessOfIteration$1 = function(exec, SKIP_CLOSING) {\n    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n    var ITERATION_SUPPORT = false;\n    try {\n        var object = {};\n        object[ITERATOR] = function() {\n            return {\n                next: function() {\n                    return {\n                        done: ITERATION_SUPPORT = true\n                    };\n                }\n            };\n        };\n        exec(object);\n    } catch (error) {}\n    return ITERATION_SUPPORT;\n};\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function(iterable) {\n    NativePromiseConstructor$1.all(iterable).then(undefined, function() {});\n});\nvar $$4 = _export;\nvar call$3 = functionCall;\nvar aCallable$1 = aCallable$7;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$4({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION$1\n}, {\n    all: function all(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$2.f(C);\n        var resolve = capability.resolve;\n        var reject = capability.reject;\n        var result = perform$1(function() {\n            var $promiseResolve = aCallable$1(C.resolve);\n            var values = [];\n            var counter = 0;\n            var remaining = 1;\n            iterate$1(iterable, function(promise) {\n                var index = counter++;\n                var alreadyCalled = false;\n                remaining++;\n                call$3($promiseResolve, C, promise).then(function(value) {\n                    if (alreadyCalled) return;\n                    alreadyCalled = true;\n                    values[index] = value;\n                    --remaining || resolve(values);\n                }, reject);\n            });\n            --remaining || resolve(values);\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$3 = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable = isCallable$k;\nvar defineBuiltIn$1 = defineBuiltIn$6;\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$3({\n    target: \"Promise\",\n    proto: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$2,\n    real: true\n}, {\n    \"catch\": function(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n});\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable(NativePromiseConstructor)) {\n    var method = getBuiltIn$1(\"Promise\").prototype[\"catch\"];\n    if (NativePromisePrototype[\"catch\"] !== method) {\n        defineBuiltIn$1(NativePromisePrototype, \"catch\", method, {\n            unsafe: true\n        });\n    }\n}\nvar $$2 = _export;\nvar call$2 = functionCall;\nvar aCallable = aCallable$7;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$2({\n    target: \"Promise\",\n    stat: true,\n    forced: PROMISE_STATICS_INCORRECT_ITERATION\n}, {\n    race: function race(iterable) {\n        var C = this;\n        var capability = newPromiseCapabilityModule$1.f(C);\n        var reject = capability.reject;\n        var result = perform(function() {\n            var $promiseResolve = aCallable(C.resolve);\n            iterate(iterable, function(promise) {\n                call$2($promiseResolve, C, promise).then(capability.resolve, reject);\n            });\n        });\n        if (result.error) reject(result.value);\n        return capability.promise;\n    }\n});\nvar $$1 = _export;\nvar call$1 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$1({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR$1\n}, {\n    reject: function reject(r) {\n        var capability = newPromiseCapabilityModule.f(this);\n        call$1(capability.reject, undefined, r);\n        return capability.promise;\n    }\n});\nvar anObject$2 = anObject$c;\nvar isObject = isObject$7;\nvar newPromiseCapability = newPromiseCapability$2;\nvar promiseResolve$1 = function(C, x) {\n    anObject$2(C);\n    if (isObject(x) && x.constructor === C) return x;\n    var promiseCapability = newPromiseCapability.f(C);\n    var resolve = promiseCapability.resolve;\n    resolve(x);\n    return promiseCapability.promise;\n};\nvar $ = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\ngetBuiltIn(\"Promise\");\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$({\n    target: \"Promise\",\n    stat: true,\n    forced: FORCED_PROMISE_CONSTRUCTOR\n}, {\n    resolve: function resolve(x) {\n        return promiseResolve(this, x);\n    }\n});\nvar classof = classof$3;\nvar $String = String;\nvar toString = function(argument) {\n    if (classof(argument) === \"Symbol\") throw TypeError(\"Cannot convert a Symbol value to a string\");\n    return $String(argument);\n};\nvar anObject$1 = anObject$c;\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags = function() {\n    var that = anObject$1(this);\n    var result = \"\";\n    if (that.hasIndices) result += \"d\";\n    if (that.global) result += \"g\";\n    if (that.ignoreCase) result += \"i\";\n    if (that.multiline) result += \"m\";\n    if (that.dotAll) result += \"s\";\n    if (that.unicode) result += \"u\";\n    if (that.unicodeSets) result += \"v\";\n    if (that.sticky) result += \"y\";\n    return result;\n};\nvar call = functionCall;\nvar hasOwn = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar regExpFlags = regexpFlags;\nvar RegExpPrototype$1 = RegExp.prototype;\nvar regexpGetFlags = function(R) {\n    var flags = R.flags;\n    return flags === undefined && !(\"flags\" in RegExpPrototype$1) && !hasOwn(R, \"flags\") && isPrototypeOf(RegExpPrototype$1, R) ? call(regExpFlags, R) : flags;\n};\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar defineBuiltIn = defineBuiltIn$6;\nvar anObject = anObject$c;\nvar $toString = toString;\nvar fails = fails$d;\nvar getRegExpFlags = regexpGetFlags;\nvar TO_STRING = \"toString\";\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\nvar NOT_GENERIC = fails(function() {\n    return n$ToString.call({\n        source: \"a\",\n        flags: \"b\"\n    }) != \"/a/b\";\n});\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n    defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {\n        var R = anObject(this);\n        var pattern = $toString(R.source);\n        var flags = $toString(getRegExpFlags(R));\n        return \"/\" + pattern + \"/\" + flags;\n    }, {\n        unsafe: true\n    });\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst signTransactions = (transactions, signer, network)=>__awaiter(void 0, void 0, void 0, function*() {\n        const provider = new near_api_js__WEBPACK_IMPORTED_MODULE_1__.providers.JsonRpcProvider({\n            url: network.nodeUrl\n        });\n        const signedTransactions = [];\n        for(let i = 0; i < transactions.length; i++){\n            const publicKey = yield signer.getPublicKey(transactions[i].signerId, network.networkId);\n            const [block, accessKey] = yield Promise.all([\n                provider.block({\n                    finality: \"final\"\n                }),\n                provider.query({\n                    request_type: \"view_access_key\",\n                    finality: \"final\",\n                    account_id: transactions[i].signerId,\n                    public_key: publicKey.toString()\n                })\n            ]);\n            const actions = transactions[i].actions.map((action)=>createAction(action));\n            const transaction = near_api_js__WEBPACK_IMPORTED_MODULE_1__.transactions.createTransaction(transactions[i].signerId, near_api_js__WEBPACK_IMPORTED_MODULE_1__.utils.PublicKey.from(publicKey.toString()), transactions[i].receiverId, accessKey.nonce + i + 1, actions, near_api_js__WEBPACK_IMPORTED_MODULE_1__.utils.serialize.base_decode(block.header.hash));\n            const response = yield near_api_js__WEBPACK_IMPORTED_MODULE_1__.transactions.signTransaction(transaction, signer, transactions[i].signerId, network.networkId);\n            signedTransactions.push(response[1]);\n        }\n        return signedTransactions;\n    });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL3dhbGxldC11dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyQjtBQUNZO0FBRXZDLE1BQU0sRUFDSkUsWUFBWSxFQUNaQyxLQUFLLEVBQ04sR0FBR0YsMk1BQU9BO0FBQ1gsTUFBTUcsZUFBZUMsQ0FBQUE7SUFDbkIsSUFBSUEsZUFBZSxjQUFjO1FBQy9CLE9BQU9ILGFBQWFJLGFBQWE7SUFDbkM7SUFDQSxNQUFNLEVBQ0pDLFVBQVUsRUFDVkMsY0FBYyxFQUFFLEVBQ2pCLEdBQUdIO0lBQ0osTUFBTUksWUFBWUosV0FBV0ksU0FBUyxHQUFHLElBQUlULHFDQUFFQSxDQUFDSyxXQUFXSSxTQUFTLElBQUlDO0lBQ3hFLE9BQU9SLGFBQWFTLHFCQUFxQixDQUFDSixZQUFZQyxhQUFhQztBQUNyRTtBQUNBLE1BQU1HLGVBQWVDLENBQUFBO0lBQ25CLE9BQVFBLE9BQU9DLElBQUk7UUFDakIsS0FBSztZQUNILE9BQU9aLGFBQWFhLGFBQWE7UUFDbkMsS0FBSztZQUNIO2dCQUNFLE1BQU0sRUFDSkMsSUFBSSxFQUNMLEdBQUdILE9BQU9JLE1BQU07Z0JBQ2pCLE9BQU9mLGFBQWFnQixjQUFjLENBQUNGO1lBQ3JDO1FBQ0YsS0FBSztZQUNIO2dCQUNFLE1BQU0sRUFDSkcsVUFBVSxFQUNWQyxJQUFJLEVBQ0pDLEdBQUcsRUFDSEMsT0FBTyxFQUNSLEdBQUdULE9BQU9JLE1BQU07Z0JBQ2pCLE9BQU9mLGFBQWFxQixZQUFZLENBQUNKLFlBQVlDLE1BQU0sSUFBSXBCLHFDQUFFQSxDQUFDcUIsTUFBTSxJQUFJckIscUNBQUVBLENBQUNzQjtZQUN6RTtRQUNGLEtBQUs7WUFDSDtnQkFDRSxNQUFNLEVBQ0pBLE9BQU8sRUFDUixHQUFHVCxPQUFPSSxNQUFNO2dCQUNqQixPQUFPZixhQUFhc0IsUUFBUSxDQUFDLElBQUl4QixxQ0FBRUEsQ0FBQ3NCO1lBQ3RDO1FBQ0YsS0FBSztZ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QUFNemtDLHFEQUFvQixDQUFDMGtDLGVBQWUsQ0FBQ1IsYUFBYW5CLFFBQVE5aUMsWUFBWSxDQUFDbVMsRUFBRSxDQUFDb3hCLFFBQVEsRUFBRVIsUUFBUVMsU0FBUztZQUM1SEgsbUJBQW1CbjlCLElBQUksQ0FBQ3MrQixRQUFRLENBQUMsRUFBRTtRQUNyQztRQUNBLE9BQU9uQjtJQUNUO0FBRTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaS1hbS1uZWFyYnkvLi9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL3dhbGxldC11dGlscy9pbmRleC5qcz80NjczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJOIH0gZnJvbSAnYm4uanMnO1xuaW1wb3J0ICogYXMgbmVhckFQSSBmcm9tICduZWFyLWFwaS1qcyc7XG5cbmNvbnN0IHtcbiAgdHJhbnNhY3Rpb25zLFxuICB1dGlsc1xufSA9IG5lYXJBUEk7XG5jb25zdCBnZXRBY2Nlc3NLZXkgPSBwZXJtaXNzaW9uID0+IHtcbiAgaWYgKHBlcm1pc3Npb24gPT09IFwiRnVsbEFjY2Vzc1wiKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5mdWxsQWNjZXNzS2V5KCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHJlY2VpdmVySWQsXG4gICAgbWV0aG9kTmFtZXMgPSBbXVxuICB9ID0gcGVybWlzc2lvbjtcbiAgY29uc3QgYWxsb3dhbmNlID0gcGVybWlzc2lvbi5hbGxvd2FuY2UgPyBuZXcgQk4ocGVybWlzc2lvbi5hbGxvd2FuY2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gdHJhbnNhY3Rpb25zLmZ1bmN0aW9uQ2FsbEFjY2Vzc0tleShyZWNlaXZlcklkLCBtZXRob2ROYW1lcywgYWxsb3dhbmNlKTtcbn07XG5jb25zdCBjcmVhdGVBY3Rpb24gPSBhY3Rpb24gPT4ge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcIkNyZWF0ZUFjY291bnRcIjpcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuY3JlYXRlQWNjb3VudCgpO1xuICAgIGNhc2UgXCJEZXBsb3lDb250cmFjdFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29kZVxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5kZXBsb3lDb250cmFjdChjb2RlKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiRnVuY3Rpb25DYWxsXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgZ2FzLFxuICAgICAgICAgIGRlcG9zaXRcbiAgICAgICAgfSA9IGFjdGlvbi5wYXJhbXM7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuZnVuY3Rpb25DYWxsKG1ldGhvZE5hbWUsIGFyZ3MsIG5ldyBCTihnYXMpLCBuZXcgQk4oZGVwb3NpdCkpO1xuICAgICAgfVxuICAgIGNhc2UgXCJUcmFuc2ZlclwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGVwb3NpdFxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy50cmFuc2ZlcihuZXcgQk4oZGVwb3NpdCkpO1xuICAgICAgfVxuICAgIGNhc2UgXCJTdGFrZVwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3Rha2UsXG4gICAgICAgICAgcHVibGljS2V5XG4gICAgICAgIH0gPSBhY3Rpb24ucGFyYW1zO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLnN0YWtlKG5ldyBCTihzdGFrZSksIHV0aWxzLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSkpO1xuICAgICAgfVxuICAgIGNhc2UgXCJBZGRLZXlcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICBhY2Nlc3NLZXlcbiAgICAgICAgfSA9IGFjdGlvbi5wYXJhbXM7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnMuYWRkS2V5KHV0aWxzLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSksXG4gICAgICAgIC8vIFRPRE86IFVzZSBhY2Nlc3NLZXkubm9uY2U/IG5lYXItYXBpLWpzIHNlZW1zIHRvIHRoaW5rIDAgaXMgZmluZT9cbiAgICAgICAgZ2V0QWNjZXNzS2V5KGFjY2Vzc0tleS5wZXJtaXNzaW9uKSk7XG4gICAgICB9XG4gICAgY2FzZSBcIkRlbGV0ZUtleVwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHVibGljS2V5XG4gICAgICAgIH0gPSBhY3Rpb24ucGFyYW1zO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLmRlbGV0ZUtleSh1dGlscy5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpKTtcbiAgICAgIH1cbiAgICBjYXNlIFwiRGVsZXRlQWNjb3VudFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYmVuZWZpY2lhcnlJZFxuICAgICAgICB9ID0gYWN0aW9uLnBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5kZWxldGVBY2NvdW50KGJlbmVmaWNpYXJ5SWQpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFjdGlvbiB0eXBlXCIpO1xuICB9XG59O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGZhaWxzJGQgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGZhaWxzJGMgPSBmYWlscyRkO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJGMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQkNSA9IEZ1bmN0aW9uUHJvdG90eXBlJDIuYmluZDtcbnZhciBjYWxsJGUgPSBGdW5jdGlvblByb3RvdHlwZSQyLmNhbGw7XG52YXIgdW5jdXJyeVRoaXMkZCA9IE5BVElWRV9CSU5EJDMgJiYgYmluZCQ1LmJpbmQoY2FsbCRlLCBjYWxsJGUpO1xuXG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpcyA9IE5BVElWRV9CSU5EJDMgPyBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzJGQoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGUuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyQyID0gdW5jdXJyeVRoaXMkYyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyRjKCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmckMihpdCksIDgsIC0xKTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyRiID0gZmFpbHMkZDtcbnZhciBjbGFzc29mJDUgPSBjbGFzc29mUmF3JDE7XG5cbnZhciAkT2JqZWN0JDQgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcyRiKCcnLnNwbGl0KTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCQ0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZiQ1KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDQoaXQpO1xufSA6ICRPYmplY3QkNDtcblxudmFyICRUeXBlRXJyb3IkYiA9IFR5cGVFcnJvcjtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IkYihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBpbmRleGVkT2JqZWN0O1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkMjtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUkMShpdCkpO1xufTtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCRqID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBzaGFyZWQkMyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkaSA9IGdsb2JhbCRqO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ0KGdsb2JhbCRpLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRpW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJGggPSBnbG9iYWwkajtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkaFtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkMy5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSQyO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxudmFyIHRvT2JqZWN0JDIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QkMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkYSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkMSA9IHRvT2JqZWN0JDI7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJGEoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG52YXIgaGFzT3duUHJvcGVydHlfMSA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0JDEoaXQpLCBrZXkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJDEgPSB1bmN1cnJ5VGhpcyQ5KDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkMiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyQxKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbnZhciBpc0NhbGxhYmxlJGsgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGdsb2JhbCRnID0gZ2xvYmFsJGo7XG52YXIgaXNDYWxsYWJsZSRqID0gaXNDYWxsYWJsZSRrO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGooYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ4ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWwkZ1tuYW1lc3BhY2VdKSA6IGdsb2JhbCRnW25hbWVzcGFjZV0gJiYgZ2xvYmFsJGdbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kODtcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kNygnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJGYgPSBnbG9iYWwkajtcbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHByb2Nlc3MkMyA9IGdsb2JhbCRmLnByb2Nlc3M7XG52YXIgRGVubyQxID0gZ2xvYmFsJGYuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MkMyAmJiBwcm9jZXNzJDMudmVyc2lvbnMgfHwgRGVubyQxICYmIERlbm8kMS52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkMykge1xuICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQzLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkYSA9IGZhaWxzJGQ7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJGEoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMSAmJiBWOF9WRVJTSU9OJDEgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gbmF0aXZlU3ltYm9sO1xuXG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDFcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnbG9iYWwkZSA9IGdsb2JhbCRqO1xudmFyIHNoYXJlZCQyID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciBoYXNPd24kYSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDEgPSB1aWQkMjtcbnZhciBOQVRJVkVfU1lNQk9MID0gbmF0aXZlU3ltYm9sO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQyKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRlLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQkMSA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQkMTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24kYShXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzT3duJGEoU3ltYm9sJDEsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEJDEgJiYgc3ltYm9sRm9yKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBzeW1ib2xGb3IoZGVzY3JpcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxudmFyIGlzQ2FsbGFibGUkaSA9IGlzQ2FsbGFibGUkaztcblxudmFyIGlzT2JqZWN0JDcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZSRpKGl0KTtcbn07XG5cbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkNztcblxudmFyICRTdHJpbmckMyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJGEgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCRjID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQ2KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGEoJFN0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSB7fTtcblxudmFyIGZhaWxzJDkgPSBmYWlscyRkO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxudmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkOSA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJDggPSBmYWlscyRkO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbnZhciB2OFByb3RvdHlwZURlZmluZUJ1ZyA9IERFU0NSSVBUT1JTJDkgJiYgZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ3Byb3RvdHlwZScsIHtcbiAgICB2YWx1ZTogNDIsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLnByb3RvdHlwZSAhPSA0Mjtcbn0pO1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIGdsb2JhbCRkID0gZ2xvYmFsJGo7XG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JDc7XG5cbnZhciBkb2N1bWVudCQzID0gZ2xvYmFsJGQuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JDUoZG9jdW1lbnQkMykgJiYgaXNPYmplY3QkNShkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJDggPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyQ3ID0gZmFpbHMkZDtcbnZhciBjcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJDggJiYgIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50JDEoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgY2FsbCRkID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQyID8gY2FsbCRkLmJpbmQoY2FsbCRkKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZC5hcHBseShjYWxsJGQsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkOCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkOCh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kNiA9IGdldEJ1aWx0SW4kODtcbnZhciBpc0NhbGxhYmxlJGggPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNQcm90b3R5cGVPZiQzID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgJE9iamVjdCQyID0gT2JqZWN0O1xuXG52YXIgaXNTeW1ib2wkMiA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiQ2KCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkaCgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJDMoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkMihpdCkpO1xufTtcblxudmFyICRTdHJpbmckMiA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQyKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJGs7XG52YXIgdHJ5VG9TdHJpbmckMyA9IHRyeVRvU3RyaW5nJDQ7XG5cbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkZyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ5KHRyeVRvU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxudmFyIGFDYWxsYWJsZSQ2ID0gYUNhbGxhYmxlJDc7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcbnZhciBnZXRNZXRob2QkMyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZSQ2KGZ1bmMpO1xufTtcblxudmFyIGNhbGwkYyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JDc7XG5cbnZhciAkVHlwZUVycm9yJDggPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUkMSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZihmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlJGYoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QkNCh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlJGYoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0JDQodmFsID0gY2FsbCRjKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyAkVHlwZUVycm9yJDgoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgY2FsbCRiID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCQ3O1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQyO1xudmFyIGdldE1ldGhvZCQyID0gZ2V0TWV0aG9kJDM7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkZCA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRkKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDEgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCQzKGlucHV0KSB8fCBpc1N5bWJvbCQxKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDIoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkYihleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JDMocmVzdWx0KSB8fCBpc1N5bWJvbCQxKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQ3KFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcbnZhciBpc1N5bWJvbCA9IGlzU3ltYm9sJDI7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkMiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgSUU4X0RPTV9ERUZJTkUkMSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkYiA9IGFuT2JqZWN0JGM7XG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQyO1xuXG52YXIgJFR5cGVFcnJvciQ2ID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyQ3ID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYihPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMShQKTtcbiAgYW5PYmplY3QkYihBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG59IDogJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdCRiKE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleSQxKFApO1xuICBhbk9iamVjdCRiKEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUkMSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IkNignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxudmFyIG1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDEgPSB0b0ludGVnZXJPckluZmluaXR5JDI7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG52YXIgdG9BYnNvbHV0ZUluZGV4JDEgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkkMShpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQxKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkMjtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxudmFyIHRvTGVuZ3RoJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQxO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNCA9IHRvSW5kZXhlZE9iamVjdCQ1O1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHRvQWJzb2x1dGVJbmRleCQxO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQyO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkNCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJbmNsdWRlcyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxudmFyIGhpZGRlbktleXMkNCA9IHt9O1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDQ7XG5cbnZhciBwdXNoID0gdW5jdXJyeVRoaXMkNyhbXS5wdXNoKTtcblxudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDMob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24kOShoaWRkZW5LZXlzJDMsIGtleSkgJiYgaGFzT3duJDkoTywga2V5KSAmJiBwdXNoKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ5KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBlbnVtQnVnS2V5cyQzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDIgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMSA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzJDEoTywgZW51bUJ1Z0tleXMkMik7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNCA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGFuT2JqZWN0JGEgPSBhbk9iamVjdCRjO1xudmFyIHRvSW5kZXhlZE9iamVjdCQyID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDYgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkYShPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDIoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xuXG52YXIgaHRtbCQyID0gZ2V0QnVpbHRJbiQ1KCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxudmFyIHNoYXJlZCQxID0gc2hhcmVkJDMuZXhwb3J0cztcbnZhciB1aWQgPSB1aWQkMjtcblxudmFyIGtleXMgPSBzaGFyZWQkMSgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkYztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzJDIgPSBoaWRkZW5LZXlzJDQ7XG52YXIgaHRtbCQxID0gaHRtbCQyO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgc2hhcmVkS2V5JDIgPSBzaGFyZWRLZXkkMztcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkkMignSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbCQxLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzJDEubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5cyQxW2xlbmd0aF1dO1xuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuXG5oaWRkZW5LZXlzJDJbSUVfUFJPVE8kMV0gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdCQ5KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkZTtcbnZhciBjcmVhdGUkMSA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sJGMoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGUkMVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5JDMoQXJyYXlQcm90b3R5cGUkMSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZSQxKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgYWRkVG9VbnNjb3BhYmxlcyQxID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZSQxW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkZSA9IGlzQ2FsbGFibGUkaztcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkNihGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRlKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQ0ID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkajtcbnZhciBpc0NhbGxhYmxlJGQgPSBpc0NhbGxhYmxlJGs7XG52YXIgaW5zcGVjdFNvdXJjZSQzID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJGMuV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJGQoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQzKFdlYWtNYXAkMSkpO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMztcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gREVTQ1JJUFRPUlMkNSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDMuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gbmF0aXZlV2Vha01hcDtcbnZhciBnbG9iYWwkYiA9IGdsb2JhbCRqO1xudmFyIHVuY3VycnlUaGlzJDUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCQ3O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgaGFzT3duJDggPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQxID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQxID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQyID0gZ2xvYmFsJGIuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkYi5XZWFrTWFwO1xudmFyIHNldCQxLCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0JDEoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkMihpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDIoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyQ1KHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJDUoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkNShzdG9yZS5zZXQpO1xuICBzZXQkMSA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQyKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSQxKCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzJDFbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0JDEgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093biQ4KGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkMihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDgoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duJDgoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxudmFyIGludGVybmFsU3RhdGUgPSB7XG4gIHNldDogc2V0JDEsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge307XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgREVTQ1JJUFRPUlMkNCA9IGRlc2NyaXB0b3JzO1xudmFyIGNhbGwkYSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQxID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDM7XG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkNTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQyO1xudmFyIGhhc093biQ3ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxub2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYgPSBERVNDUklQVE9SUyQ0ID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QkMShPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJDcoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSghY2FsbCRhKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBtYWtlQnVpbHRJbiQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQxID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhc093biQ2KEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTJDMgfHwgKERFU0NSSVBUT1JTJDMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG52YXIgZnVuY3Rpb25OYW1lID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG52YXIgZmFpbHMkNiA9IGZhaWxzJGQ7XG52YXIgaXNDYWxsYWJsZSRjID0gaXNDYWxsYWJsZSRrO1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBERVNDUklQVE9SUyQyID0gZGVzY3JpcHRvcnM7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSQyID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMi5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gREVTQ1JJUFRPUlMkMiAmJiAhZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eSQyKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG5cbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxudmFyIG1ha2VCdWlsdEluJDEgPSBtYWtlQnVpbHRJbiQyLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093biQ1KHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQxICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTJDIpIGRlZmluZVByb3BlcnR5JDIodmFsdWUsICduYW1lJywgeyB2YWx1ZTogbmFtZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGVsc2UgdmFsdWUubmFtZSA9IG5hbWU7XG4gIH1cbiAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd24kNShvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQyKHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093biQ1KG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChERVNDUklQVE9SUyQyKSBkZWZpbmVQcm9wZXJ0eSQyKHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093biQ1KHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQxKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRjKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUkMSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQyKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJGIgPSBpc0NhbGxhYmxlJGs7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMiA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQ2ID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJGIodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIGdldEJ1aWx0SW4kNCA9IGdldEJ1aWx0SW4kODtcbnZhciB1bmN1cnJ5VGhpcyQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGM7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQ0KFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDQoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkOChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQoa2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxudmFyIGhhc093biQ0ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBvd25LZXlzID0gb3duS2V5cyQxO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093biQ0KHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duJDQoZXhjZXB0aW9ucywga2V5KSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWlscyQ1ID0gZmFpbHMkZDtcbnZhciBpc0NhbGxhYmxlJGEgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCQyID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlJGEoZGV0ZWN0aW9uKSA/IGZhaWxzJDUoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQkMi5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkJDIuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkJDIuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQkMi5QT0xZRklMTCA9ICdQJztcblxudmFyIGlzRm9yY2VkXzEgPSBpc0ZvcmNlZCQyO1xuXG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkajtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgZGVmaW5lQnVpbHRJbiQ1ID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyQxO1xudmFyIGlzRm9yY2VkJDEgPSBpc0ZvcmNlZF8xO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgICAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xudmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGE7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsJGFbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsJGFbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZCQxKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMihzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbiQ1KHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBmYWlscyQ0ID0gZmFpbHMkZDtcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMkNChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxudmFyIGhhc093biQzID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc0NhbGxhYmxlJDkgPSBpc0NhbGxhYmxlJGs7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQyO1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQzO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0JDEgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdCQxLnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcbnZhciBvYmplY3RHZXRQcm90b3R5cGVPZiA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QkMS5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChPKTtcbiAgaWYgKGhhc093biQzKG9iamVjdCwgSUVfUFJPVE8pKSByZXR1cm4gb2JqZWN0W0lFX1BST1RPXTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNDYWxsYWJsZSQ5KGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QkMSA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG52YXIgZmFpbHMkMyA9IGZhaWxzJGQ7XG52YXIgaXNDYWxsYWJsZSQ4ID0gaXNDYWxsYWJsZSRrO1xudmFyIGdldFByb3RvdHlwZU9mJDEgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBkZWZpbmVCdWlsdEluJDQgPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkZTtcblxudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2wkYignaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSBmYWxzZTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQxKGdldFByb3RvdHlwZU9mJDEoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSQyID09IHVuZGVmaW5lZCB8fCBmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZSQyW0lURVJBVE9SJDVdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlJDgoSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQ1XSkpIHtcbiAgZGVmaW5lQnVpbHRJbiQ0KEl0ZXJhdG9yUHJvdG90eXBlJDIsIElURVJBVE9SJDUsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG59XG5cbnZhciBpdGVyYXRvcnNDb3JlID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUkMixcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2wkYSgndG9TdHJpbmdUYWcnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBmdW5jdGlvbiAodGFyZ2V0LCBUQUcsIFNUQVRJQykge1xuICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQgJiYgIWhhc093biQyKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQzKSkge1xuICAgIGRlZmluZVByb3BlcnR5JDEodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDMsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQzO1xudmFyIHNldFRvU3RyaW5nVGFnJDIgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0LCBFTlVNRVJBQkxFX05FWFQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlJDEsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWckMihJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSk7XG4gIEl0ZXJhdG9ycyQ0W1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciBpc0NhbGxhYmxlJDcgPSBpc0NhbGxhYmxlJGs7XG5cbnZhciAkU3RyaW5nJDEgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciQ1ID0gVHlwZUVycm9yO1xuXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlJDcoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNShcIkNhbid0IHNldCBcIiArICRTdHJpbmckMShhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG5cbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkYztcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBhUG9zc2libGVQcm90b3R5cGUkMTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMkMyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QkNyhPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgJCQ2ID0gX2V4cG9ydDtcbnZhciBjYWxsJDkgPSBmdW5jdGlvbkNhbGw7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkaztcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxO1xudmFyIGdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDEgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDQ7XG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJGU7XG52YXIgSXRlcmF0b3JzJDMgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQxID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCQ5KCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ0XVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mJDEpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZiQxKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlJDYoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SJDRdKSkge1xuICAgICAgICAgIGRlZmluZUJ1aWx0SW4kMyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDQsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyQxKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUkMSAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBpZiAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJDkobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCQ2KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNF0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkNCwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JDU7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IGFkZFRvVW5zY29wYWJsZXMkMTtcbnZhciBJdGVyYXRvcnMkMiA9IGl0ZXJhdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xudmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBkZWZpbmVJdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yJDE7XG52YXIgREVTQ1JJUFRPUlMkMSA9IGRlc2NyaXB0b3JzO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3RcbnZhciB2YWx1ZXMgPSBJdGVyYXRvcnMkMi5Bcmd1bWVudHMgPSBJdGVyYXRvcnMkMi5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDQ1LSBidWdcbmlmIChERVNDUklQVE9SUyQxICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcbiAgZGVmaW5lUHJvcGVydHkodmFsdWVzLCAnbmFtZScsIHsgdmFsdWU6ICd2YWx1ZXMnIH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbnZhciBkb21JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG4vLyBpbiBvbGQgV2ViS2l0IHZlcnNpb25zLCBgZWxlbWVudC5jbGFzc0xpc3RgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBnbG9iYWwgYERPTVRva2VuTGlzdGBcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxudmFyIGNsYXNzTGlzdCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc3BhbicpLmNsYXNzTGlzdDtcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUkMSA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxudmFyIGRvbVRva2VuTGlzdFByb3RvdHlwZSA9IERPTVRva2VuTGlzdFByb3RvdHlwZSQxID09PSBPYmplY3QucHJvdG90eXBlID8gdW5kZWZpbmVkIDogRE9NVG9rZW5MaXN0UHJvdG90eXBlJDE7XG5cbnZhciBnbG9iYWwkOSA9IGdsb2JhbCRqO1xudmFyIERPTUl0ZXJhYmxlcyA9IGRvbUl0ZXJhYmxlcztcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUgPSBkb21Ub2tlbkxpc3RQcm90b3R5cGU7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSBlc19hcnJheV9pdGVyYXRvcjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkOCA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCQ4KCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUckMiA9IHdlbGxLbm93blN5bWJvbCQ4KCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG52YXIgaGFuZGxlUHJvdG90eXBlID0gZnVuY3Rpb24gKENvbGxlY3Rpb25Qcm90b3R5cGUsIENPTExFQ1RJT05fTkFNRSkge1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SJDNdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiQzLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1IkM10gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUckMl0pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDIsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsJDlbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWwkOVtDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKTtcbn1cblxuaGFuZGxlUHJvdG90eXBlKERPTVRva2VuTGlzdFByb3RvdHlwZSwgJ0RPTVRva2VuTGlzdCcpO1xuXG52YXIgY2xhc3NvZiQ0ID0gY2xhc3NvZlJhdyQxO1xudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJGo7XG5cbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mJDQoZ2xvYmFsJDgucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgZ2V0QnVpbHRJbiQzID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgd2VsbEtub3duU3ltYm9sJDcgPSB3ZWxsS25vd25TeW1ib2wkZTtcbnZhciBERVNDUklQVE9SUyA9IGRlc2NyaXB0b3JzO1xuXG52YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sJDcoJ3NwZWNpZXMnKTtcblxudmFyIHNldFNwZWNpZXMkMSA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4kMyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVMkMl0pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUyQyLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGlzUHJvdG90eXBlT2YkMiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG5cbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbnZhciBhbkluc3RhbmNlJDEgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuICBpZiAoaXNQcm90b3R5cGVPZiQyKFByb3RvdHlwZSwgaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNCgnSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJDYoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUckMV0gPSAneic7XG5cbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBpc0NhbGxhYmxlJDUgPSBpc0NhbGxhYmxlJGs7XG52YXIgY2xhc3NvZlJhdyA9IGNsYXNzb2ZSYXckMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbCRlO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCQ1KCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG52YXIgY2xhc3NvZiQzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJDUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkMiA9IGZhaWxzJGQ7XG52YXIgaXNDYWxsYWJsZSQ0ID0gaXNDYWxsYWJsZSRrO1xudmFyIGNsYXNzb2YkMiA9IGNsYXNzb2YkMztcbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzJDIoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoY2xhc3NvZiQyKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZSQxKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxudmFyIGlzQ29uc3RydWN0b3IkMSA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbnZhciBpc0NvbnN0cnVjdG9yID0gaXNDb25zdHJ1Y3RvciQxO1xudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ0O1xuXG52YXIgJFR5cGVFcnJvciQzID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJDModHJ5VG9TdHJpbmckMihhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgYW5PYmplY3QkNiA9IGFuT2JqZWN0JGM7XG52YXIgYUNvbnN0cnVjdG9yID0gYUNvbnN0cnVjdG9yJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJDQgPSB3ZWxsS25vd25TeW1ib2wkZTtcblxudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQ0KCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdCQ2KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0JDYoQylbU1BFQ0lFUyQxXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUNvbnN0cnVjdG9yKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQxID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCQ4ID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJDguYmluZChhcHBseSQxKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkOC5hcHBseShhcHBseSQxLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ3O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ0ID0gdW5jdXJyeVRoaXMkMSh1bmN1cnJ5VGhpcyQxLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ1KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDQoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDEgPSB1bmN1cnJ5VGhpcyhbXS5zbGljZSk7XG5cbnZhciAkVHlwZUVycm9yJDIgPSBUeXBlRXJyb3I7XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxID0gZnVuY3Rpb24gKHBhc3NlZCwgcmVxdWlyZWQpIHtcbiAgaWYgKHBhc3NlZCA8IHJlcXVpcmVkKSB0aHJvdyAkVHlwZUVycm9yJDIoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIHJldHVybiBwYXNzZWQ7XG59O1xuXG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc0lvcyA9IC8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCQyKTtcblxudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJGo7XG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgaXNDYWxsYWJsZSQzID0gaXNDYWxsYWJsZSRrO1xudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBmYWlscyQxID0gZmFpbHMkZDtcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlJDE7XG52YXIgY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMTtcbnZhciBJU19JT1MkMSA9IGVuZ2luZUlzSW9zO1xudmFyIElTX05PREUkMiA9IGVuZ2luZUlzTm9kZTtcblxudmFyIHNldCA9IGdsb2JhbCQ3LnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbCQ3LmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MkMiA9IGdsb2JhbCQ3LnByb2Nlc3M7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwkNy5EaXNwYXRjaDtcbnZhciBGdW5jdGlvbiQxID0gZ2xvYmFsJDcuRnVuY3Rpb247XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwkNy5NZXNzYWdlQ2hhbm5lbDtcbnZhciBTdHJpbmckMSA9IGdsb2JhbCQ3LlN0cmluZztcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSQxID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgbG9jYXRpb24sIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG50cnkge1xuICAvLyBEZW5vIHRocm93cyBhIFJlZmVyZW5jZUVycm9yIG9uIGBsb2NhdGlvbmAgYWNjZXNzIHdpdGhvdXQgYC0tbG9jYXRpb25gIGZsYWdcbiAgbG9jYXRpb24gPSBnbG9iYWwkNy5sb2NhdGlvbjtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaGFzT3duJDEocXVldWUkMSwgaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWUkMVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlJDFbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBydW5uZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBydW4oaWQpO1xuICB9O1xufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwkNy5wb3N0TWVzc2FnZShTdHJpbmckMShpZCksIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQgfHwgIWNsZWFyKSB7XG4gIHNldCA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShoYW5kbGVyKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQzKGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcXVldWUkMVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHkoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFJDIpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MkMSkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZCQzKHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwkNy5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZSQzKGdsb2JhbCQ3LnBvc3RNZXNzYWdlKSAmJlxuICAgICFnbG9iYWwkNy5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMkMShwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsJDcuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciB0YXNrJDEgPSB7XG4gIHNldDogc2V0LFxuICBjbGVhcjogY2xlYXJcbn07XG5cbnZhciB1c2VyQWdlbnQkMSA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRqO1xuXG52YXIgZW5naW5lSXNJb3NQZWJibGUgPSAvaXBhZHxpcGhvbmV8aXBvZC9pLnRlc3QodXNlckFnZW50JDEpICYmIGdsb2JhbCQ2LlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgdXNlckFnZW50ID0gZW5naW5lVXNlckFnZW50O1xuXG52YXIgZW5naW5lSXNXZWJvc1dlYmtpdCA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50KTtcblxudmFyIGdsb2JhbCQ1ID0gZ2xvYmFsJGo7XG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBtYWNyb3Rhc2sgPSB0YXNrJDEuc2V0O1xudmFyIElTX0lPUyA9IGVuZ2luZUlzSW9zO1xudmFyIElTX0lPU19QRUJCTEUgPSBlbmdpbmVJc0lvc1BlYmJsZTtcbnZhciBJU19XRUJPU19XRUJLSVQgPSBlbmdpbmVJc1dlYm9zV2Via2l0O1xudmFyIElTX05PREUkMSA9IGVuZ2luZUlzTm9kZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwkNS5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbCQ1LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQkMiA9IGdsb2JhbCQ1LmRvY3VtZW50O1xudmFyIHByb2Nlc3MkMSA9IGdsb2JhbCQ1LnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gZ2xvYmFsJDUuUHJvbWlzZTtcbi8vIE5vZGUuanMgMTEgc2hvd3MgRXhwZXJpbWVudGFsV2FybmluZyBvbiBnZXR0aW5nIGBxdWV1ZU1pY3JvdGFza2BcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsJDUsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnkkMSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSQxICYmIChwYXJlbnQgPSBwcm9jZXNzJDEuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5JDEoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICAvLyBhbHNvIGV4Y2VwdCBXZWJPUyBXZWJraXQgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg5OFxuICBpZiAoIUlTX0lPUyAmJiAhSVNfTk9ERSQxICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCQyKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQkMi5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKCFJU19JT1NfUEVCQkxFICYmIFByb21pc2UkMSAmJiBQcm9taXNlJDEucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgLy8gd29ya2Fyb3VuZCBvZiBXZWJLaXQgfiBpT1MgU2FmYXJpIDEwLjEgYnVnXG4gICAgcHJvbWlzZS5jb25zdHJ1Y3RvciA9IFByb21pc2UkMTtcbiAgICB0aGVuID0gYmluZCQyKHByb21pc2UudGhlbiwgcHJvbWlzZSk7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBOb2RlLmpzIHdpdGhvdXQgcHJvbWlzZXNcbiAgfSBlbHNlIGlmIChJU19OT0RFJDEpIHtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnZVxuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuYmluZChnbG9iYWwpXG4gICAgbWFjcm90YXNrID0gYmluZCQyKG1hY3JvdGFzaywgZ2xvYmFsJDUpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFjcm90YXNrKGZsdXNoKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtaWNyb3Rhc2skMSA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSQxKCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59O1xuXG52YXIgZ2xvYmFsJDQgPSBnbG9iYWwkajtcblxudmFyIGhvc3RSZXBvcnRFcnJvcnMkMSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsJDQuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMSA/IGNvbnNvbGUuZXJyb3IoYSkgOiBjb25zb2xlLmVycm9yKGEsIGIpO1xuICB9XG59O1xuXG52YXIgcGVyZm9ybSQzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cbnZhciBRdWV1ZSQxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuUXVldWUkMS5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgZW50cnkgPSB7IGl0ZW06IGl0ZW0sIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGVhZDtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5leHQ7XG4gICAgICBpZiAodGhpcy50YWlsID09PSBlbnRyeSkgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHJldHVybiBlbnRyeS5pdGVtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHF1ZXVlID0gUXVldWUkMTtcblxudmFyIGdsb2JhbCQzID0gZ2xvYmFsJGo7XG5cbnZhciBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkMy5Qcm9taXNlO1xuXG52YXIgZW5naW5lSXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgRGVubyAhPSAnb2JqZWN0JztcblxudmFyIGdsb2JhbCQyID0gZ2xvYmFsJGo7XG52YXIgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRrO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBpbnNwZWN0U291cmNlID0gaW5zcGVjdFNvdXJjZSQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGU7XG52YXIgSVNfQlJPV1NFUiA9IGVuZ2luZUlzQnJvd3NlcjtcbnZhciBWOF9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xuXG5OYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMy5wcm90b3R5cGU7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCQzKCdzcGVjaWVzJyk7XG52YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSA9IGlzQ2FsbGFibGUkMihnbG9iYWwkMi5Qcm9taXNlUmVqZWN0aW9uRXZlbnQpO1xuXG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IG5ldyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyhmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IEZha2VQcm9taXNlO1xuICBTVUJDTEFTU0lORyA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIGlmICghU1VCQ0xBU1NJTkcpIHJldHVybiB0cnVlO1xuICAvLyBVbmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMTtcbn0pO1xuXG52YXIgcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uID0ge1xuICBDT05TVFJVQ1RPUjogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSxcbiAgUkVKRUNUSU9OX0VWRU5UOiBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSxcbiAgU1VCQ0xBU1NJTkc6IFNVQkNMQVNTSU5HXG59O1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMiA9IHt9O1xuXG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkNztcblxudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFDYWxsYWJsZSQ0KHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFDYWxsYWJsZSQ0KHJlamVjdCk7XG59O1xuXG4vLyBgTmV3UHJvbWlzZUNhcGFiaWxpdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1uZXdwcm9taXNlY2FwYWJpbGl0eVxubmV3UHJvbWlzZUNhcGFiaWxpdHkkMi5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbnZhciAkJDUgPSBfZXhwb3J0O1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG52YXIgZ2xvYmFsJDEgPSBnbG9iYWwkajtcbnZhciBjYWxsJDcgPSBmdW5jdGlvbkNhbGw7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiQ2O1xudmFyIHNldFByb3RvdHlwZU9mID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQzO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDE7XG52YXIgYUNhbGxhYmxlJDMgPSBhQ2FsbGFibGUkNztcbnZhciBpc0NhbGxhYmxlJDEgPSBpc0NhbGxhYmxlJGs7XG52YXIgaXNPYmplY3QkMSA9IGlzT2JqZWN0JDc7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBzcGVjaWVzQ29uc3RydWN0b3IkMTtcbnZhciB0YXNrID0gdGFzayQxLnNldDtcbnZhciBtaWNyb3Rhc2sgPSBtaWNyb3Rhc2skMTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gaG9zdFJlcG9ydEVycm9ycyQxO1xudmFyIHBlcmZvcm0kMiA9IHBlcmZvcm0kMztcbnZhciBRdWV1ZSA9IHF1ZXVlO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQzID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uUkVKRUNUSU9OX0VWRU5UO1xudmFyIE5BVElWRV9QUk9NSVNFX1NVQkNMQVNTSU5HID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlNVQkNMQVNTSU5HO1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSA9IE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyLnByb3RvdHlwZTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMjtcbnZhciBQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZSQxO1xudmFyIFR5cGVFcnJvciQxID0gZ2xvYmFsJDEuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkMS5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsJDEucHJvY2VzcztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDE7XG5cbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50JDEgJiYgZG9jdW1lbnQkMS5jcmVhdGVFdmVudCAmJiBnbG9iYWwkMS5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcblxudmFyIEludGVybmFsLCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgUHJvbWlzZVdyYXBwZXIsIG5hdGl2ZVRoZW47XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QkMShpdCkgJiYgaXNDYWxsYWJsZSQxKHRoZW4gPSBpdC50aGVuKSA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBjYWxsUmVhY3Rpb24gPSBmdW5jdGlvbiAocmVhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQxKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNhbGwkNyh0aGVuLCByZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICB9XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHN0YXRlLCBpc1JlamVjdCkge1xuICBpZiAoc3RhdGUubm90aWZpZWQpIHJldHVybjtcbiAgc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFjdGlvbnMgPSBzdGF0ZS5yZWFjdGlvbnM7XG4gICAgdmFyIHJlYWN0aW9uO1xuICAgIHdoaWxlIChyZWFjdGlvbiA9IHJlYWN0aW9ucy5nZXQoKSkge1xuICAgICAgY2FsbFJlYWN0aW9uKHJlYWN0aW9uLCBzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50JDEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICAgIGV2ZW50LmluaXRFdmVudChuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsJDEuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcbiAgaWYgKCFOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQgJiYgKGhhbmRsZXIgPSBnbG9iYWwkMVsnb24nICsgbmFtZV0pKSBoYW5kbGVyKGV2ZW50KTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjYWxsJDcodGFzaywgZ2xvYmFsJDEsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHN0YXRlLmZhY2FkZTtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybSQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKElTX05PREUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGNhbGwkNyh0YXNrLCBnbG9iYWwkMSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlO1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuICB9KTtcbn07XG5cbnZhciBiaW5kJDEgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUuZmFjYWRlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDEoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICAgIGlmICh0aGVuKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsJDcodGhlbiwgdmFsdWUsXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZXNvbHZlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHdyYXBwZXIsIHN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZWplY3Qod3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICAgIG5vdGlmeShzdGF0ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpbnRlcm5hbFJlamVjdCh7IGRvbmU6IGZhbHNlIH0sIGVycm9yLCBzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkMyhleGVjdXRvcik7XG4gICAgY2FsbCQ3KEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDEoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogbmV3IFF1ZXVlKCksXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYFByb21pc2UucHJvdG90eXBlLnRoZW5gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgSW50ZXJuYWwucHJvdG90eXBlID0gZGVmaW5lQnVpbHRJbiQyKFByb21pc2VQcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICAgcmVhY3Rpb24ub2sgPSBpc0NhbGxhYmxlJDEob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgIHJlYWN0aW9uLmZhaWwgPSBpc0NhbGxhYmxlJDEob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDtcbiAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZCQxKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZCQxKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlJDEoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4kMihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjYWxsJDcobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIHNldFByb3RvdHlwZU9mKE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSwgUHJvbWlzZVByb3RvdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbiQkNSh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQyID0gd2VsbEtub3duU3ltYm9sJGU7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDIoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDEuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SJDJdID09PSBpdCk7XG59O1xuXG52YXIgY2xhc3NvZiQxID0gY2xhc3NvZiQzO1xudmFyIGdldE1ldGhvZCQxID0gZ2V0TWV0aG9kJDM7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBJVEVSQVRPUiQxID0gd2VsbEtub3duU3ltYm9sJDEoJ2l0ZXJhdG9yJyk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBnZXRNZXRob2QkMShpdCwgSVRFUkFUT1IkMSlcbiAgICB8fCBnZXRNZXRob2QkMShpdCwgJ0BAaXRlcmF0b3InKVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mJDEoaXQpXTtcbn07XG5cbnZhciBjYWxsJDYgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkNztcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkYztcbnZhciB0cnlUb1N0cmluZyQxID0gdHJ5VG9TdHJpbmckNDtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQxID0gZ2V0SXRlcmF0b3JNZXRob2QkMjtcblxudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDEgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQxKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkMihpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ1KGNhbGwkNihpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nJDEoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNCA9IGFuT2JqZWN0JGM7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDM7XG5cbnZhciBpdGVyYXRvckNsb3NlJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgYW5PYmplY3QkNChpdGVyYXRvcik7XG4gIHRyeSB7XG4gICAgaW5uZXJSZXN1bHQgPSBnZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gY2FsbCQ1KGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QkNChpbm5lclJlc3VsdCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBiaW5kID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDQgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JGM7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ0O1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkMjtcbnZhciBpc1Byb3RvdHlwZU9mJDEgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IkMTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgaXRlcmF0b3JDbG9zZSA9IGl0ZXJhdG9yQ2xvc2UkMTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDIgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ25vcm1hbCcsIGNvbmRpdGlvbik7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiAgfTtcblxuICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgICAgIGFuT2JqZWN0JDModmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoaXRlcmFibGUpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQxKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBjYWxsJDQobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxGbihzdGVwLnZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ3Rocm93JywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQxKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gd2VsbEtub3duU3ltYm9sJGU7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG5cbnZhciBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbiA9IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDEuYWxsKGl0ZXJhYmxlKS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG52YXIgJCQ0ID0gX2V4cG9ydDtcbnZhciBjYWxsJDMgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkNztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtJDEgPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQyO1xudmFyIFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UuYWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxcbiQkNCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IFBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEgfSwge1xuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDIuZihDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0kMShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDEoQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZSQxKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBjYWxsJDMoJHByb21pc2VSZXNvbHZlLCBDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG52YXIgJCQzID0gX2V4cG9ydDtcbnZhciBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQyID0gcHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLkNPTlNUUlVDVE9SO1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSA9IGlzQ2FsbGFibGUkaztcbnZhciBkZWZpbmVCdWlsdEluJDEgPSBkZWZpbmVCdWlsdEluJDY7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kJDMoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiwgcmVhbDogdHJ1ZSB9LCB7XG4gICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG59KTtcblxuLy8gbWFrZXMgc3VyZSB0aGF0IG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXMgYFByb21pc2UjY2F0Y2hgIHByb3Blcmx5IHdvcmtzIHdpdGggcGF0Y2hlZCBgUHJvbWlzZSN0aGVuYFxuaWYgKGlzQ2FsbGFibGUoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yKSkge1xuICB2YXIgbWV0aG9kID0gZ2V0QnVpbHRJbiQxKCdQcm9taXNlJykucHJvdG90eXBlWydjYXRjaCddO1xuICBpZiAoTmF0aXZlUHJvbWlzZVByb3RvdHlwZVsnY2F0Y2gnXSAhPT0gbWV0aG9kKSB7XG4gICAgZGVmaW5lQnVpbHRJbiQxKE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICdjYXRjaCcsIG1ldGhvZCwgeyB1bnNhZmU6IHRydWUgfSk7XG4gIH1cbn1cblxudmFyICQkMiA9IF9leHBvcnQ7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSA9IGFDYWxsYWJsZSQ3O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDEgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyO1xudmFyIHBlcmZvcm0gPSBwZXJmb3JtJDM7XG52YXIgaXRlcmF0ZSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiA9IHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uO1xuXG4vLyBgUHJvbWlzZS5yYWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4kJDIoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxLmYoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkMigkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJDEgPSBfZXhwb3J0O1xudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkMSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkMShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDIgPSBhbk9iamVjdCRjO1xudmFyIGlzT2JqZWN0ID0gaXNPYmplY3QkNztcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBwcm9taXNlUmVzb2x2ZSQxID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QkMihDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiB9LCB7XG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZSh0aGlzLCB4KTtcbiAgfVxufSk7XG5cbnZhciBjbGFzc29mID0gY2xhc3NvZiQzO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxudmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRjO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG52YXIgcmVnZXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkMSh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNhbGwgPSBmdW5jdGlvbkNhbGw7XG52YXIgaGFzT3duID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciByZWdFeHBGbGFncyA9IHJlZ2V4cEZsYWdzO1xuXG52YXIgUmVnRXhwUHJvdG90eXBlJDEgPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgcmVnZXhwR2V0RmxhZ3MgPSBmdW5jdGlvbiAoUikge1xuICB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuICByZXR1cm4gZmxhZ3MgPT09IHVuZGVmaW5lZCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlJDEpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUkMSwgUilcbiAgICA/IGNhbGwocmVnRXhwRmxhZ3MsIFIpIDogZmxhZ3M7XG59O1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDY7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRjO1xudmFyICR0b1N0cmluZyA9IHRvU3RyaW5nO1xudmFyIGZhaWxzID0gZmFpbHMkZDtcbnZhciBnZXRSZWdFeHBGbGFncyA9IHJlZ2V4cEdldEZsYWdzO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG4kVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbiRUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBuJFRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICBkZWZpbmVCdWlsdEluKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICB2YXIgcGF0dGVybiA9ICR0b1N0cmluZyhSLnNvdXJjZSk7XG4gICAgdmFyIGZsYWdzID0gJHRvU3RyaW5nKGdldFJlZ0V4cEZsYWdzKFIpKTtcbiAgICByZXR1cm4gJy8nICsgcGF0dGVybiArICcvJyArIGZsYWdzO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuY29uc3Qgc2lnblRyYW5zYWN0aW9ucyA9ICh0cmFuc2FjdGlvbnMsIHNpZ25lciwgbmV0d29yaykgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IG5lYXJBUEkucHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcih7XG4gICAgdXJsOiBuZXR3b3JrLm5vZGVVcmxcbiAgfSk7XG4gIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IHlpZWxkIHNpZ25lci5nZXRQdWJsaWNLZXkodHJhbnNhY3Rpb25zW2ldLnNpZ25lcklkLCBuZXR3b3JrLm5ldHdvcmtJZCk7XG4gICAgY29uc3QgW2Jsb2NrLCBhY2Nlc3NLZXldID0geWllbGQgUHJvbWlzZS5hbGwoW3Byb3ZpZGVyLmJsb2NrKHtcbiAgICAgIGZpbmFsaXR5OiBcImZpbmFsXCJcbiAgICB9KSwgcHJvdmlkZXIucXVlcnkoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInZpZXdfYWNjZXNzX2tleVwiLFxuICAgICAgZmluYWxpdHk6IFwiZmluYWxcIixcbiAgICAgIGFjY291bnRfaWQ6IHRyYW5zYWN0aW9uc1tpXS5zaWduZXJJZCxcbiAgICAgIHB1YmxpY19rZXk6IHB1YmxpY0tleS50b1N0cmluZygpXG4gICAgfSldKTtcbiAgICBjb25zdCBhY3Rpb25zID0gdHJhbnNhY3Rpb25zW2ldLmFjdGlvbnMubWFwKGFjdGlvbiA9PiBjcmVhdGVBY3Rpb24oYWN0aW9uKSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZWFyQVBJLnRyYW5zYWN0aW9ucy5jcmVhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbnNbaV0uc2lnbmVySWQsIG5lYXJBUEkudXRpbHMuUHVibGljS2V5LmZyb20ocHVibGljS2V5LnRvU3RyaW5nKCkpLCB0cmFuc2FjdGlvbnNbaV0ucmVjZWl2ZXJJZCwgYWNjZXNzS2V5Lm5vbmNlICsgaSArIDEsIGFjdGlvbnMsIG5lYXJBUEkudXRpbHMuc2VyaWFsaXplLmJhc2VfZGVjb2RlKGJsb2NrLmhlYWRlci5oYXNoKSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBuZWFyQVBJLnRyYW5zYWN0aW9ucy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25lciwgdHJhbnNhY3Rpb25zW2ldLnNpZ25lcklkLCBuZXR3b3JrLm5ldHdvcmtJZCk7XG4gICAgc2lnbmVkVHJhbnNhY3Rpb25zLnB1c2gocmVzcG9uc2VbMV0pO1xuICB9XG4gIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG59KTtcblxuZXhwb3J0IHsgY3JlYXRlQWN0aW9uLCBzaWduVHJhbnNhY3Rpb25zIH07XG4iXSwibmFtZXMiOlsiQk4iLCJuZWFyQVBJIiwidHJhbnNhY3Rpb25zIiwidXRpbHMiLCJnZXRBY2Nlc3NLZXkiLCJwZXJtaXNzaW9uIiwiZnVsbEFjY2Vzc0tleSIsInJlY2VpdmVySWQiLCJtZXRob2ROYW1lcyIsImFsbG93YW5jZSIsInVuZGVmaW5lZCIsImZ1bmN0aW9uQ2FsbEFjY2Vzc0tleSIsImNyZWF0ZUFjdGlvbiIsImFjdGlvbiIsInR5cGUiLCJjcmVhdGVBY2NvdW50IiwiY29kZSIsInBhcmFtcyIsImRlcGxveUNvbnRyYWN0IiwibWV0aG9kTmFtZSIsImFyZ3MiLCJnYXMiLCJkZXBvc2l0IiwiZnVuY3Rpb25DYWxsIiwidHJhbnNmZXIiLCJzdGFrZSIsInB1YmxpY0tleSIsIlB1YmxpY0tleSIsImZyb20iLCJhY2Nlc3NLZXkiLCJhZGRLZXkiLCJkZWxldGVLZXkiLCJiZW5lZmljaWFyeUlkIiwiZGVsZXRlQWNjb3VudCIsIkVycm9yIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImZhaWxzJGQiLCJleGVjIiwiZXJyb3IiLCJmYWlscyRjIiwiZnVuY3Rpb25CaW5kTmF0aXZlIiwidGVzdCIsImJpbmQiLCJoYXNPd25Qcm9wZXJ0eSIsIk5BVElWRV9CSU5EJDMiLCJGdW5jdGlvblByb3RvdHlwZSQyIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJiaW5kJDUiLCJjYWxsJGUiLCJjYWxsIiwidW5jdXJyeVRoaXMkZCIsImZ1bmN0aW9uVW5jdXJyeVRoaXMiLCJmbiIsImFwcGx5IiwiYXJndW1lbnRzIiwidW5jdXJyeVRoaXMkYyIsInRvU3RyaW5nJDIiLCJ0b1N0cmluZyIsInN0cmluZ1NsaWNlIiwic2xpY2UiLCJjbGFzc29mUmF3JDEiLCJpdCIsInVuY3VycnlUaGlzJGIiLCJmYWlscyRiIiwiY2xhc3NvZiQ1IiwiJE9iamVjdCQ0IiwiT2JqZWN0Iiwic3BsaXQiLCJpbmRleGVkT2JqZWN0IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCIkVHlwZUVycm9yJGIiLCJUeXBlRXJyb3IiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIiLCJJbmRleGVkT2JqZWN0IiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSQxIiwidG9JbmRleGVkT2JqZWN0JDUiLCJjaGVjayIsIk1hdGgiLCJnbG9iYWwkaiIsInNoYXJlZCQzIiwiZXhwb3J0cyIsImdsb2JhbCRpIiwiZGVmaW5lUHJvcGVydHkkNCIsImRlZmluZVByb3BlcnR5IiwiZGVmaW5lR2xvYmFsUHJvcGVydHkkMyIsImtleSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJnbG9iYWwkaCIsImRlZmluZUdsb2JhbFByb3BlcnR5JDIiLCJTSEFSRUQiLCJzdG9yZSQzIiwic2hhcmVkU3RvcmUiLCJzdG9yZSQyIiwicHVzaCIsInZlcnNpb24iLCJtb2RlIiwiY29weXJpZ2h0IiwibGljZW5zZSIsInNvdXJjZSIsInJlcXVpcmVPYmplY3RDb2VyY2libGUiLCIkT2JqZWN0JDMiLCJ0b09iamVjdCQyIiwiYXJndW1lbnQiLCJ1bmN1cnJ5VGhpcyRhIiwidG9PYmplY3QkMSIsImhhc093blByb3BlcnR5XzEiLCJoYXNPd24iLCJ1bmN1cnJ5VGhpcyQ5IiwiaWQiLCJwb3N0Zml4IiwicmFuZG9tIiwidG9TdHJpbmckMSIsInVpZCQyIiwiaXNDYWxsYWJsZSRrIiwiZ2xvYmFsJGciLCJpc0NhbGxhYmxlJGoiLCJhRnVuY3Rpb24iLCJnZXRCdWlsdEluJDgiLCJuYW1lc3BhY2UiLCJtZXRob2QiLCJsZW5ndGgiLCJnZXRCdWlsdEluJDciLCJlbmdpbmVVc2VyQWdlbnQiLCJnbG9iYWwkZiIsInVzZXJBZ2VudCQzIiwicHJvY2VzcyQzIiwicHJvY2VzcyIsIkRlbm8kMSIsIkRlbm8iLCJ2ZXJzaW9ucyIsInY4IiwibWF0Y2giLCJlbmdpbmVWOFZlcnNpb24iLCJWOF9WRVJTSU9OJDEiLCJmYWlscyRhIiwibmF0aXZlU3ltYm9sIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9sIiwiU3ltYm9sIiwiU3RyaW5nIiwic2hhbSIsIk5BVElWRV9TWU1CT0wkMSIsInVzZVN5bWJvbEFzVWlkIiwiaXRlcmF0b3IiLCJnbG9iYWwkZSIsInNoYXJlZCQyIiwiaGFzT3duJGEiLCJ1aWQkMSIsIk5BVElWRV9TWU1CT0wiLCJVU0VfU1lNQk9MX0FTX1VJRCQxIiwiV2VsbEtub3duU3ltYm9sc1N0b3JlIiwiU3ltYm9sJDEiLCJzeW1ib2xGb3IiLCJjcmVhdGVXZWxsS25vd25TeW1ib2wiLCJ3aXRob3V0U2V0dGVyIiwid2VsbEtub3duU3ltYm9sJGUiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJpc0NhbGxhYmxlJGkiLCJpc09iamVjdCQ3IiwiaXNPYmplY3QkNiIsIiRTdHJpbmckMyIsIiRUeXBlRXJyb3IkYSIsImFuT2JqZWN0JGMiLCJvYmplY3REZWZpbmVQcm9wZXJ0aWVzIiwiZmFpbHMkOSIsImRlc2NyaXB0b3JzIiwiZ2V0IiwiREVTQ1JJUFRPUlMkOSIsImZhaWxzJDgiLCJ2OFByb3RvdHlwZURlZmluZUJ1ZyIsIm9iamVjdERlZmluZVByb3BlcnR5IiwiZ2xvYmFsJGQiLCJpc09iamVjdCQ1IiwiZG9jdW1lbnQkMyIsImRvY3VtZW50IiwiRVhJU1RTJDEiLCJjcmVhdGVFbGVtZW50IiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIiLCJERVNDUklQVE9SUyQ4IiwiZmFpbHMkNyIsImNyZWF0ZUVsZW1lbnQkMSIsImllOERvbURlZmluZSIsImEiLCJOQVRJVkVfQklORCQyIiwiY2FsbCRkIiwidW5jdXJyeVRoaXMkOCIsIm9iamVjdElzUHJvdG90eXBlT2YiLCJpc1Byb3RvdHlwZU9mIiwiZ2V0QnVpbHRJbiQ2IiwiaXNDYWxsYWJsZSRoIiwiaXNQcm90b3R5cGVPZiQzIiwiVVNFX1NZTUJPTF9BU19VSUQiLCIkT2JqZWN0JDIiLCJpc1N5bWJvbCQyIiwiJFN5bWJvbCIsIiRTdHJpbmckMiIsInRyeVRvU3RyaW5nJDQiLCJpc0NhbGxhYmxlJGciLCJ0cnlUb1N0cmluZyQzIiwiJFR5cGVFcnJvciQ5IiwiYUNhbGxhYmxlJDciLCJhQ2FsbGFibGUkNiIsImdldE1ldGhvZCQzIiwiViIsIlAiLCJmdW5jIiwiY2FsbCRjIiwiaXNDYWxsYWJsZSRmIiwiaXNPYmplY3QkNCIsIiRUeXBlRXJyb3IkOCIsIm9yZGluYXJ5VG9QcmltaXRpdmUkMSIsImlucHV0IiwicHJlZiIsInZhbCIsInZhbHVlT2YiLCJjYWxsJGIiLCJpc09iamVjdCQzIiwiaXNTeW1ib2wkMSIsImdldE1ldGhvZCQyIiwib3JkaW5hcnlUb1ByaW1pdGl2ZSIsIndlbGxLbm93blN5bWJvbCRkIiwiJFR5cGVFcnJvciQ3IiwiVE9fUFJJTUlUSVZFIiwidG9QcmltaXRpdmUkMSIsImV4b3RpY1RvUHJpbSIsInJlc3VsdCIsInRvUHJpbWl0aXZlIiwiaXNTeW1ib2wiLCJ0b1Byb3BlcnR5S2V5JDIiLCJERVNDUklQVE9SUyQ3IiwiSUU4X0RPTV9ERUZJTkUkMSIsIlY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEiLCJhbk9iamVjdCRiIiwidG9Qcm9wZXJ0eUtleSQxIiwiJFR5cGVFcnJvciQ2IiwiJGRlZmluZVByb3BlcnR5IiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRU5VTUVSQUJMRSIsIkNPTkZJR1VSQUJMRSQxIiwiV1JJVEFCTEUiLCJmIiwiTyIsIkF0dHJpYnV0ZXMiLCJjdXJyZW50IiwiZW51bWVyYWJsZSIsImNlaWwiLCJmbG9vciIsIm1hdGhUcnVuYyIsInRydW5jIiwieCIsIm4iLCJ0b0ludGVnZXJPckluZmluaXR5JDIiLCJudW1iZXIiLCJ0b0ludGVnZXJPckluZmluaXR5JDEiLCJtYXgiLCJtaW4kMSIsIm1pbiIsInRvQWJzb2x1dGVJbmRleCQxIiwiaW5kZXgiLCJpbnRlZ2VyIiwidG9JbnRlZ2VyT3JJbmZpbml0eSIsInRvTGVuZ3RoJDEiLCJ0b0xlbmd0aCIsImxlbmd0aE9mQXJyYXlMaWtlJDIiLCJvYmoiLCJ0b0luZGV4ZWRPYmplY3QkNCIsInRvQWJzb2x1dGVJbmRleCIsImxlbmd0aE9mQXJyYXlMaWtlJDEiLCJjcmVhdGVNZXRob2QiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZWwiLCJmcm9tSW5kZXgiLCJhcnJheUluY2x1ZGVzIiwiaW5jbHVkZXMiLCJpbmRleE9mIiwiaGlkZGVuS2V5cyQ0IiwidW5jdXJyeVRoaXMkNyIsImhhc093biQ5IiwidG9JbmRleGVkT2JqZWN0JDMiLCJoaWRkZW5LZXlzJDMiLCJvYmplY3RLZXlzSW50ZXJuYWwiLCJvYmplY3QiLCJuYW1lcyIsImkiLCJlbnVtQnVnS2V5cyQzIiwiaW50ZXJuYWxPYmplY3RLZXlzJDEiLCJlbnVtQnVnS2V5cyQyIiwib2JqZWN0S2V5cyQxIiwia2V5cyIsIkRFU0NSSVBUT1JTJDYiLCJWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyIsImRlZmluZVByb3BlcnR5TW9kdWxlJDQiLCJhbk9iamVjdCRhIiwidG9JbmRleGVkT2JqZWN0JDIiLCJvYmplY3RLZXlzIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJwcm9wcyIsImdldEJ1aWx0SW4kNSIsImh0bWwkMiIsInNoYXJlZCQxIiwidWlkIiwic2hhcmVkS2V5JDMiLCJhbk9iamVjdCQ5IiwiZGVmaW5lUHJvcGVydGllc01vZHVsZSIsImVudW1CdWdLZXlzJDEiLCJoaWRkZW5LZXlzJDIiLCJodG1sJDEiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSIsInNoYXJlZEtleSQyIiwiR1QiLCJMVCIsIlBST1RPVFlQRSIsIlNDUklQVCIsIklFX1BST1RPJDEiLCJFbXB0eUNvbnN0cnVjdG9yIiwic2NyaXB0VGFnIiwiY29udGVudCIsIk51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgiLCJhY3RpdmVYRG9jdW1lbnQiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwiRiIsIk51bGxQcm90b09iamVjdCIsIkFjdGl2ZVhPYmplY3QiLCJkb21haW4iLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJ3ZWxsS25vd25TeW1ib2wkYyIsImNyZWF0ZSQxIiwiZGVmaW5lUHJvcGVydHkkMyIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90b3R5cGUkMSIsIkFycmF5IiwiYWRkVG9VbnNjb3BhYmxlcyQxIiwiaXRlcmF0b3JzIiwidW5jdXJyeVRoaXMkNiIsImlzQ2FsbGFibGUkZSIsInN0b3JlJDEiLCJmdW5jdGlvblRvU3RyaW5nIiwiaW5zcGVjdFNvdXJjZSIsImluc3BlY3RTb3VyY2UkNCIsImdsb2JhbCRjIiwiaXNDYWxsYWJsZSRkIiwiaW5zcGVjdFNvdXJjZSQzIiwiV2Vha01hcCQxIiwiV2Vha01hcCIsIm5hdGl2ZVdlYWtNYXAiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyIsImJpdG1hcCIsIkRFU0NSSVBUT1JTJDUiLCJkZWZpbmVQcm9wZXJ0eU1vZHVsZSQzIiwiY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDIiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNCIsIk5BVElWRV9XRUFLX01BUCIsImdsb2JhbCRiIiwidW5jdXJyeVRoaXMkNSIsImlzT2JqZWN0JDIiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyIsImhhc093biQ4Iiwic2hhcmVkIiwic2hhcmVkS2V5JDEiLCJoaWRkZW5LZXlzJDEiLCJPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCIsIlR5cGVFcnJvciQyIiwic2V0JDEiLCJoYXMiLCJlbmZvcmNlIiwiZ2V0dGVyRm9yIiwiVFlQRSIsInN0YXRlIiwic3RvcmUiLCJ3bWdldCIsIndtaGFzIiwid21zZXQiLCJzZXQiLCJtZXRhZGF0YSIsImZhY2FkZSIsIlNUQVRFIiwiaW50ZXJuYWxTdGF0ZSIsIm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlIiwiJHByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIiLCJOQVNIT1JOX0JVRyIsImRlc2NyaXB0b3IiLCJERVNDUklQVE9SUyQ0IiwiY2FsbCRhIiwicHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSIsInRvSW5kZXhlZE9iamVjdCQxIiwidG9Qcm9wZXJ0eUtleSIsImhhc093biQ3IiwiSUU4X0RPTV9ERUZJTkUiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwibWFrZUJ1aWx0SW4kMiIsIkRFU0NSSVBUT1JTJDMiLCJoYXNPd24kNiIsIkZ1bmN0aW9uUHJvdG90eXBlJDEiLCJnZXREZXNjcmlwdG9yIiwiRVhJU1RTIiwiUFJPUEVSIiwic29tZXRoaW5nIiwiQ09ORklHVVJBQkxFIiwiZnVuY3Rpb25OYW1lIiwiZmFpbHMkNiIsImlzQ2FsbGFibGUkYyIsImhhc093biQ1IiwiREVTQ1JJUFRPUlMkMiIsIkNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEiLCJpbnNwZWN0U291cmNlJDIiLCJJbnRlcm5hbFN0YXRlTW9kdWxlJDIiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsImdldEludGVybmFsU3RhdGUkMSIsImRlZmluZVByb3BlcnR5JDIiLCJDT05GSUdVUkFCTEVfTEVOR1RIIiwiVEVNUExBVEUiLCJtYWtlQnVpbHRJbiQxIiwib3B0aW9ucyIsInJlcGxhY2UiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJhcml0eSIsImNvbnN0cnVjdG9yIiwiam9pbiIsImlzQ2FsbGFibGUkYiIsImRlZmluZVByb3BlcnR5TW9kdWxlJDIiLCJtYWtlQnVpbHRJbiIsImRlZmluZUdsb2JhbFByb3BlcnR5JDEiLCJkZWZpbmVCdWlsdEluJDYiLCJzaW1wbGUiLCJ1bnNhZmUiLCJub25Db25maWd1cmFibGUiLCJub25Xcml0YWJsZSIsIm9iamVjdEdldE93blByb3BlcnR5TmFtZXMiLCJpbnRlcm5hbE9iamVjdEtleXMiLCJlbnVtQnVnS2V5cyIsImhpZGRlbktleXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0QnVpbHRJbiQ0IiwidW5jdXJyeVRoaXMkNCIsImdldE93blByb3BlcnR5TmFtZXNNb2R1bGUiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJhbk9iamVjdCQ4Iiwib3duS2V5cyQxIiwib3duS2V5cyIsImhhc093biQ0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUkMSIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMkMSIsInRhcmdldCIsImV4Y2VwdGlvbnMiLCJmYWlscyQ1IiwiaXNDYWxsYWJsZSRhIiwicmVwbGFjZW1lbnQiLCJpc0ZvcmNlZCQyIiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsInN0cmluZyIsInRvTG93ZXJDYXNlIiwiaXNGb3JjZWRfMSIsImdsb2JhbCRhIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiIsImRlZmluZUJ1aWx0SW4kNSIsImRlZmluZUdsb2JhbFByb3BlcnR5IiwiY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyIsImlzRm9yY2VkJDEiLCJfZXhwb3J0IiwiVEFSR0VUIiwiR0xPQkFMIiwiU1RBVElDIiwic3RhdCIsIkZPUkNFRCIsInRhcmdldFByb3BlcnR5Iiwic291cmNlUHJvcGVydHkiLCJkb250Q2FsbEdldFNldCIsImZvcmNlZCIsImZhaWxzJDQiLCJjb3JyZWN0UHJvdG90eXBlR2V0dGVyIiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNPd24kMyIsImlzQ2FsbGFibGUkOSIsInRvT2JqZWN0Iiwic2hhcmVkS2V5IiwiQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSIiwiSUVfUFJPVE8iLCIkT2JqZWN0JDEiLCJPYmplY3RQcm90b3R5cGUiLCJvYmplY3RHZXRQcm90b3R5cGVPZiIsImZhaWxzJDMiLCJpc0NhbGxhYmxlJDgiLCJnZXRQcm90b3R5cGVPZiQxIiwiZGVmaW5lQnVpbHRJbiQ0Iiwid2VsbEtub3duU3ltYm9sJGIiLCJJVEVSQVRPUiQ1IiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxIiwiSXRlcmF0b3JQcm90b3R5cGUkMiIsIlByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3IiLCJORVdfSVRFUkFUT1JfUFJPVE9UWVBFIiwiaXRlcmF0b3JzQ29yZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyIsImRlZmluZVByb3BlcnR5JDEiLCJoYXNPd24kMiIsIndlbGxLbm93blN5bWJvbCRhIiwiVE9fU1RSSU5HX1RBRyQzIiwic2V0VG9TdHJpbmdUYWckMyIsIlRBRyIsIkl0ZXJhdG9yUHJvdG90eXBlJDEiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJzZXRUb1N0cmluZ1RhZyQyIiwiSXRlcmF0b3JzJDQiLCJyZXR1cm5UaGlzJDEiLCJjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yJDEiLCJJdGVyYXRvckNvbnN0cnVjdG9yIiwiTkFNRSIsIm5leHQiLCJFTlVNRVJBQkxFX05FWFQiLCJUT19TVFJJTkdfVEFHIiwiaXNDYWxsYWJsZSQ3IiwiJFN0cmluZyQxIiwiJFR5cGVFcnJvciQ1IiwiYVBvc3NpYmxlUHJvdG90eXBlJDEiLCJ1bmN1cnJ5VGhpcyQzIiwiYW5PYmplY3QkNyIsImFQb3NzaWJsZVByb3RvdHlwZSIsIm9iamVjdFNldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJDT1JSRUNUX1NFVFRFUiIsInByb3RvIiwiX19wcm90b19fIiwiJCQ2IiwiY2FsbCQ5IiwiRnVuY3Rpb25OYW1lIiwiaXNDYWxsYWJsZSQ2IiwiY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciIsInNldFByb3RvdHlwZU9mJDEiLCJzZXRUb1N0cmluZ1RhZyQxIiwiY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEiLCJkZWZpbmVCdWlsdEluJDMiLCJ3ZWxsS25vd25TeW1ib2wkOSIsIkl0ZXJhdG9ycyQzIiwiSXRlcmF0b3JzQ29yZSIsIlBST1BFUl9GVU5DVElPTl9OQU1FJDEiLCJDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSIsIklURVJBVE9SJDQiLCJLRVlTIiwiVkFMVUVTIiwiRU5UUklFUyIsInJldHVyblRoaXMiLCJkZWZpbmVJdGVyYXRvciQxIiwiSXRlcmFibGUiLCJERUZBVUxUIiwiSVNfU0VUIiwiZ2V0SXRlcmF0aW9uTWV0aG9kIiwiS0lORCIsImRlZmF1bHRJdGVyYXRvciIsIkl0ZXJhYmxlUHJvdG90eXBlIiwidmFsdWVzIiwiZW50cmllcyIsIklOQ09SUkVDVF9WQUxVRVNfTkFNRSIsIm5hdGl2ZUl0ZXJhdG9yIiwiYW55TmF0aXZlSXRlcmF0b3IiLCJDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUiLCJtZXRob2RzIiwiS0VZIiwidG9JbmRleGVkT2JqZWN0IiwiYWRkVG9VbnNjb3BhYmxlcyIsIkl0ZXJhdG9ycyQyIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSQxIiwiZGVmaW5lSXRlcmF0b3IiLCJERVNDUklQVE9SUyQxIiwiQVJSQVlfSVRFUkFUT1IiLCJzZXRJbnRlcm5hbFN0YXRlJDEiLCJnZXRJbnRlcm5hbFN0YXRlIiwiZXNfYXJyYXlfaXRlcmF0b3IiLCJpdGVyYXRlZCIsImtpbmQiLCJkb25lIiwiQXJndW1lbnRzIiwiZG9tSXRlcmFibGVzIiwiQ1NTUnVsZUxpc3QiLCJDU1NTdHlsZURlY2xhcmF0aW9uIiwiQ1NTVmFsdWVMaXN0IiwiQ2xpZW50UmVjdExpc3QiLCJET01SZWN0TGlzdCIsIkRPTVN0cmluZ0xpc3QiLCJET01Ub2tlbkxpc3QiLCJEYXRhVHJhbnNmZXJJdGVtTGlzdCIsIkZpbGVMaXN0IiwiSFRNTEFsbENvbGxlY3Rpb24iLCJIVE1MQ29sbGVjdGlvbiIsIkhUTUxGb3JtRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiTWVkaWFMaXN0IiwiTWltZVR5cGVBcnJheSIsIk5hbWVkTm9kZU1hcCIsIk5vZGVMaXN0IiwiUGFpbnRSZXF1ZXN0TGlzdCIsIlBsdWdpbiIsIlBsdWdpbkFycmF5IiwiU1ZHTGVuZ3RoTGlzdCIsIlNWR051bWJlckxpc3QiLCJTVkdQYXRoU2VnTGlzdCIsIlNWR1BvaW50TGlzdCIsIlNWR1N0cmluZ0xpc3QiLCJTVkdUcmFuc2Zvcm1MaXN0IiwiU291cmNlQnVmZmVyTGlzdCIsIlN0eWxlU2hlZXRMaXN0IiwiVGV4dFRyYWNrQ3VlTGlzdCIsIlRleHRUcmFja0xpc3QiLCJUb3VjaExpc3QiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJET01Ub2tlbkxpc3RQcm90b3R5cGUkMSIsImRvbVRva2VuTGlzdFByb3RvdHlwZSIsImdsb2JhbCQ5IiwiRE9NSXRlcmFibGVzIiwiRE9NVG9rZW5MaXN0UHJvdG90eXBlIiwiQXJyYXlJdGVyYXRvck1ldGhvZHMiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkiLCJ3ZWxsS25vd25TeW1ib2wkOCIsIklURVJBVE9SJDMiLCJUT19TVFJJTkdfVEFHJDIiLCJBcnJheVZhbHVlcyIsImhhbmRsZVByb3RvdHlwZSIsIkNvbGxlY3Rpb25Qcm90b3R5cGUiLCJDT0xMRUNUSU9OX05BTUUiLCJNRVRIT0RfTkFNRSIsImNsYXNzb2YkNCIsImdsb2JhbCQ4IiwiZW5naW5lSXNOb2RlIiwiZ2V0QnVpbHRJbiQzIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUiLCJ3ZWxsS25vd25TeW1ib2wkNyIsIkRFU0NSSVBUT1JTIiwiU1BFQ0lFUyQyIiwic2V0U3BlY2llcyQxIiwiQ09OU1RSVUNUT1JfTkFNRSIsIkNvbnN0cnVjdG9yIiwiaXNQcm90b3R5cGVPZiQyIiwiJFR5cGVFcnJvciQ0IiwiYW5JbnN0YW5jZSQxIiwiUHJvdG90eXBlIiwid2VsbEtub3duU3ltYm9sJDYiLCJUT19TVFJJTkdfVEFHJDEiLCJ0b1N0cmluZ1RhZ1N1cHBvcnQiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJpc0NhbGxhYmxlJDUiLCJjbGFzc29mUmF3Iiwid2VsbEtub3duU3ltYm9sJDUiLCIkT2JqZWN0IiwiQ09SUkVDVF9BUkdVTUVOVFMiLCJ0cnlHZXQiLCJjbGFzc29mJDMiLCJ0YWciLCJjYWxsZWUiLCJ1bmN1cnJ5VGhpcyQyIiwiZmFpbHMkMiIsImlzQ2FsbGFibGUkNCIsImNsYXNzb2YkMiIsImdldEJ1aWx0SW4kMiIsImluc3BlY3RTb3VyY2UkMSIsIm5vb3AiLCJlbXB0eSIsImNvbnN0cnVjdCIsImNvbnN0cnVjdG9yUmVnRXhwIiwiSU5DT1JSRUNUX1RPX1NUUklORyIsImlzQ29uc3RydWN0b3JNb2Rlcm4iLCJpc0NvbnN0cnVjdG9yIiwiaXNDb25zdHJ1Y3RvckxlZ2FjeSIsImlzQ29uc3RydWN0b3IkMSIsImNhbGxlZCIsInRyeVRvU3RyaW5nJDIiLCIkVHlwZUVycm9yJDMiLCJhQ29uc3RydWN0b3IkMSIsImFuT2JqZWN0JDYiLCJhQ29uc3RydWN0b3IiLCJ3ZWxsS25vd25TeW1ib2wkNCIsIlNQRUNJRVMkMSIsInNwZWNpZXNDb25zdHJ1Y3RvciQxIiwiZGVmYXVsdENvbnN0cnVjdG9yIiwiQyIsIlMiLCJOQVRJVkVfQklORCQxIiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJhcHBseSQxIiwiY2FsbCQ4IiwiZnVuY3Rpb25BcHBseSIsIlJlZmxlY3QiLCJ1bmN1cnJ5VGhpcyQxIiwiYUNhbGxhYmxlJDUiLCJOQVRJVkVfQklORCIsImJpbmQkNCIsImZ1bmN0aW9uQmluZENvbnRleHQiLCJ0aGF0IiwidW5jdXJyeVRoaXMiLCJhcnJheVNsaWNlJDEiLCIkVHlwZUVycm9yJDIiLCJ2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxIiwicGFzc2VkIiwicmVxdWlyZWQiLCJ1c2VyQWdlbnQkMiIsImVuZ2luZUlzSW9zIiwiZ2xvYmFsJDciLCJiaW5kJDMiLCJpc0NhbGxhYmxlJDMiLCJoYXNPd24kMSIsImZhaWxzJDEiLCJodG1sIiwiYXJyYXlTbGljZSIsInZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoIiwiSVNfSU9TJDEiLCJJU19OT0RFJDIiLCJzZXRJbW1lZGlhdGUiLCJjbGVhciIsImNsZWFySW1tZWRpYXRlIiwicHJvY2VzcyQyIiwiRGlzcGF0Y2giLCJGdW5jdGlvbiQxIiwiTWVzc2FnZUNoYW5uZWwiLCJTdHJpbmckMSIsImNvdW50ZXIiLCJxdWV1ZSQxIiwiT05SRUFEWVNUQVRFQ0hBTkdFIiwibG9jYXRpb24iLCJkZWZlciIsImNoYW5uZWwiLCJwb3J0IiwicnVuIiwicnVubmVyIiwibGlzdGVuZXIiLCJldmVudCIsInBvc3QiLCJwb3N0TWVzc2FnZSIsInByb3RvY29sIiwiaG9zdCIsImhhbmRsZXIiLCJuZXh0VGljayIsIm5vdyIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsInRhc2skMSIsInVzZXJBZ2VudCQxIiwiZ2xvYmFsJDYiLCJlbmdpbmVJc0lvc1BlYmJsZSIsIlBlYmJsZSIsInVzZXJBZ2VudCIsImVuZ2luZUlzV2Vib3NXZWJraXQiLCJnbG9iYWwkNSIsImJpbmQkMiIsIm1hY3JvdGFzayIsIklTX0lPUyIsIklTX0lPU19QRUJCTEUiLCJJU19XRUJPU19XRUJLSVQiLCJJU19OT0RFJDEiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImRvY3VtZW50JDIiLCJwcm9jZXNzJDEiLCJQcm9taXNlJDEiLCJQcm9taXNlIiwicXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yIiwicXVldWVNaWNyb3Rhc2siLCJmbHVzaCIsImhlYWQiLCJsYXN0Iiwibm90aWZ5JDEiLCJ0b2dnbGUiLCJub2RlIiwicHJvbWlzZSIsInRoZW4iLCJwYXJlbnQiLCJleGl0IiwiZW50ZXIiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwicmVzb2x2ZSIsIm1pY3JvdGFzayQxIiwidGFzayIsImdsb2JhbCQ0IiwiaG9zdFJlcG9ydEVycm9ycyQxIiwiYiIsImNvbnNvbGUiLCJwZXJmb3JtJDMiLCJRdWV1ZSQxIiwidGFpbCIsImFkZCIsIml0ZW0iLCJlbnRyeSIsInF1ZXVlIiwiZ2xvYmFsJDMiLCJwcm9taXNlTmF0aXZlQ29uc3RydWN0b3IiLCJlbmdpbmVJc0Jyb3dzZXIiLCJnbG9iYWwkMiIsIk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzIiwiaXNDYWxsYWJsZSQyIiwiaXNGb3JjZWQiLCJ3ZWxsS25vd25TeW1ib2wkMyIsIklTX0JST1dTRVIiLCJWOF9WRVJTSU9OIiwiU1BFQ0lFUyIsIlNVQkNMQVNTSU5HIiwiTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UJDEiLCJQcm9taXNlUmVqZWN0aW9uRXZlbnQiLCJGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1IiwiUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UiLCJHTE9CQUxfQ09SRV9KU19QUk9NSVNFIiwiRmFrZVByb21pc2UiLCJwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24iLCJDT05TVFJVQ1RPUiIsIlJFSkVDVElPTl9FVkVOVCIsIm5ld1Byb21pc2VDYXBhYmlsaXR5JDIiLCJhQ2FsbGFibGUkNCIsIlByb21pc2VDYXBhYmlsaXR5IiwicmVqZWN0IiwiJCRyZXNvbHZlIiwiJCRyZWplY3QiLCIkJDUiLCJJU19OT0RFIiwiZ2xvYmFsJDEiLCJjYWxsJDciLCJkZWZpbmVCdWlsdEluJDIiLCJzZXRUb1N0cmluZ1RhZyIsInNldFNwZWNpZXMiLCJhQ2FsbGFibGUkMyIsImlzQ2FsbGFibGUkMSIsImlzT2JqZWN0JDEiLCJhbkluc3RhbmNlIiwic3BlY2llc0NvbnN0cnVjdG9yIiwibWljcm90YXNrIiwiaG9zdFJlcG9ydEVycm9ycyIsInBlcmZvcm0kMiIsIlF1ZXVlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSIsIk5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQyIiwiUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMyIsIlBST01JU0UiLCJGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ0IiwiTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UIiwiTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkciLCJnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSIsInNldEludGVybmFsU3RhdGUiLCJOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEiLCJQcm9taXNlQ29uc3RydWN0b3IiLCJQcm9taXNlUHJvdG90eXBlIiwiVHlwZUVycm9yJDEiLCJkb2N1bWVudCQxIiwibmV3UHJvbWlzZUNhcGFiaWxpdHkkMSIsIm5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSIsIkRJU1BBVENIX0VWRU5UIiwiY3JlYXRlRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiVU5IQU5ETEVEX1JFSkVDVElPTiIsIlJFSkVDVElPTl9IQU5ETEVEIiwiUEVORElORyIsIkZVTEZJTExFRCIsIlJFSkVDVEVEIiwiSEFORExFRCIsIlVOSEFORExFRCIsIkludGVybmFsIiwiT3duUHJvbWlzZUNhcGFiaWxpdHkiLCJQcm9taXNlV3JhcHBlciIsIm5hdGl2ZVRoZW4iLCJpc1RoZW5hYmxlIiwiY2FsbFJlYWN0aW9uIiwicmVhY3Rpb24iLCJvayIsImZhaWwiLCJleGl0ZWQiLCJyZWplY3Rpb24iLCJvbkhhbmRsZVVuaGFuZGxlZCIsIm5vdGlmeSIsImlzUmVqZWN0Iiwibm90aWZpZWQiLCJyZWFjdGlvbnMiLCJvblVuaGFuZGxlZCIsInJlYXNvbiIsImluaXRFdmVudCIsIklTX1VOSEFORExFRCIsImlzVW5oYW5kbGVkIiwiZW1pdCIsImJpbmQkMSIsInVud3JhcCIsImludGVybmFsUmVqZWN0IiwiaW50ZXJuYWxSZXNvbHZlIiwid3JhcHBlciIsImV4ZWN1dG9yIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwid3JhcCIsIndlbGxLbm93blN5bWJvbCQyIiwiSXRlcmF0b3JzJDEiLCJJVEVSQVRPUiQyIiwiQXJyYXlQcm90b3R5cGUiLCJpc0FycmF5SXRlcmF0b3JNZXRob2QkMSIsImNsYXNzb2YkMSIsImdldE1ldGhvZCQxIiwiSXRlcmF0b3JzIiwid2VsbEtub3duU3ltYm9sJDEiLCJJVEVSQVRPUiQxIiwiZ2V0SXRlcmF0b3JNZXRob2QkMiIsImNhbGwkNiIsImFDYWxsYWJsZSQyIiwiYW5PYmplY3QkNSIsInRyeVRvU3RyaW5nJDEiLCJnZXRJdGVyYXRvck1ldGhvZCQxIiwiJFR5cGVFcnJvciQxIiwiZ2V0SXRlcmF0b3IkMSIsInVzaW5nSXRlcmF0b3IiLCJpdGVyYXRvck1ldGhvZCIsImNhbGwkNSIsImFuT2JqZWN0JDQiLCJnZXRNZXRob2QiLCJpdGVyYXRvckNsb3NlJDEiLCJpbm5lclJlc3VsdCIsImlubmVyRXJyb3IiLCJjYWxsJDQiLCJhbk9iamVjdCQzIiwidHJ5VG9TdHJpbmciLCJpc0FycmF5SXRlcmF0b3JNZXRob2QiLCJsZW5ndGhPZkFycmF5TGlrZSIsImlzUHJvdG90eXBlT2YkMSIsImdldEl0ZXJhdG9yIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJpdGVyYXRvckNsb3NlIiwiJFR5cGVFcnJvciIsIlJlc3VsdCIsInN0b3BwZWQiLCJSZXN1bHRQcm90b3R5cGUiLCJpdGVyYXRlJDIiLCJpdGVyYWJsZSIsInVuYm91bmRGdW5jdGlvbiIsIkFTX0VOVFJJRVMiLCJJU19JVEVSQVRPUiIsIklOVEVSUlVQVEVEIiwiaXRlckZuIiwic3RlcCIsInN0b3AiLCJjb25kaXRpb24iLCJjYWxsRm4iLCJ3ZWxsS25vd25TeW1ib2wiLCJJVEVSQVRPUiIsIlNBRkVfQ0xPU0lORyIsIml0ZXJhdG9yV2l0aFJldHVybiIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxIiwiU0tJUF9DTE9TSU5HIiwiSVRFUkFUSU9OX1NVUFBPUlQiLCJOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMSIsImNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDMiLCJwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbiIsImFsbCIsIiQkNCIsImNhbGwkMyIsImFDYWxsYWJsZSQxIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMiIsInBlcmZvcm0kMSIsIml0ZXJhdGUkMSIsIlBST01JU0VfU1RBVElDU19JTkNPUlJFQ1RfSVRFUkFUSU9OJDEiLCJjYXBhYmlsaXR5IiwiJHByb21pc2VSZXNvbHZlIiwicmVtYWluaW5nIiwiYWxyZWFkeUNhbGxlZCIsIiQkMyIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDIiLCJOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IiLCJnZXRCdWlsdEluJDEiLCJpc0NhbGxhYmxlIiwiZGVmaW5lQnVpbHRJbiQxIiwiTmF0aXZlUHJvbWlzZVByb3RvdHlwZSIsInJlYWwiLCIkJDIiLCJjYWxsJDIiLCJhQ2FsbGFibGUiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxIiwicGVyZm9ybSIsIml0ZXJhdGUiLCJQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiIsInJhY2UiLCIkJDEiLCJjYWxsJDEiLCJuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEiLCJyIiwiYW5PYmplY3QkMiIsImlzT2JqZWN0IiwibmV3UHJvbWlzZUNhcGFiaWxpdHkiLCJwcm9taXNlUmVzb2x2ZSQxIiwicHJvbWlzZUNhcGFiaWxpdHkiLCIkIiwiZ2V0QnVpbHRJbiIsIkZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIiwicHJvbWlzZVJlc29sdmUiLCJjbGFzc29mIiwiJFN0cmluZyIsImFuT2JqZWN0JDEiLCJyZWdleHBGbGFncyIsImhhc0luZGljZXMiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwiZG90QWxsIiwidW5pY29kZSIsInVuaWNvZGVTZXRzIiwic3RpY2t5IiwicmVnRXhwRmxhZ3MiLCJSZWdFeHBQcm90b3R5cGUkMSIsIlJlZ0V4cCIsInJlZ2V4cEdldEZsYWdzIiwiUiIsImZsYWdzIiwiUFJPUEVSX0ZVTkNUSU9OX05BTUUiLCJkZWZpbmVCdWlsdEluIiwiYW5PYmplY3QiLCIkdG9TdHJpbmciLCJmYWlscyIsImdldFJlZ0V4cEZsYWdzIiwiVE9fU1RSSU5HIiwiUmVnRXhwUHJvdG90eXBlIiwibiRUb1N0cmluZyIsIk5PVF9HRU5FUklDIiwiSU5DT1JSRUNUX05BTUUiLCJwYXR0ZXJuIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJnZW5lcmF0b3IiLCJhZG9wdCIsImZ1bGZpbGxlZCIsImUiLCJyZWplY3RlZCIsIlN1cHByZXNzZWRFcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwic2lnblRyYW5zYWN0aW9ucyIsInNpZ25lciIsIm5ldHdvcmsiLCJwcm92aWRlciIsInByb3ZpZGVycyIsIkpzb25ScGNQcm92aWRlciIsInVybCIsIm5vZGVVcmwiLCJzaWduZWRUcmFuc2FjdGlvbnMiLCJnZXRQdWJsaWNLZXkiLCJzaWduZXJJZCIsIm5ldHdvcmtJZCIsImJsb2NrIiwiZmluYWxpdHkiLCJxdWVyeSIsInJlcXVlc3RfdHlwZSIsImFjY291bnRfaWQiLCJwdWJsaWNfa2V5IiwiYWN0aW9ucyIsIm1hcCIsInRyYW5zYWN0aW9uIiwiY3JlYXRlVHJhbnNhY3Rpb24iLCJub25jZSIsInNlcmlhbGl6ZSIsImJhc2VfZGVjb2RlIiwiaGVhZGVyIiwiaGFzaCIsInJlc3BvbnNlIiwic2lnblRyYW5zYWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@near-wallet-selector/wallet-utils/index.js\n");

/***/ })

};
;